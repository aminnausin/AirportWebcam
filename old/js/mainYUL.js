define('jquery', [], function () {
  // jQuery should be already present on the page
  return jQuery;
});
define('settings', [
  'jquery'
], function ($) {

  // Can not use setting to get lang (required inception)
  var lang = $("html").attr("lang") || "fr";

  var Settings = {
    webServicePath: {
      autocomplete: {
        arrival: "/" + lang + "/admtldata/api/autocomplete?type=arrival",
        departure: "/" + lang + "/admtldata/api/autocomplete?type=departure"
      },
      flight: "/" + lang + "/admtldata/api/flight",
      waitingtime: "/" + lang + "/admtldata/api/waitingtime",
      flightTrackerMock: "/sites/all/themes/custom/angani/stub-webservice/flighttracker.json",
      flightTracker: "/" + lang + "/admtldata/api/flighttracker",
      interactivemapMock: "/sites/all/themes/custom/angani/stub-webservice/interactivemap.json",
      interactivemap: "/" + lang + "/admtldata/api/poi",
      parkingOccupancy: "/" + lang + "/admtldata/api/parkingoccupancy",
      taxiWaitingTime: "/" + lang + "/admtldata/api/taxiwaitingtime",
    },
    platform: "mobile",
    events: {
      scroll: ""
    },
    breakpoints: {
      home: {

      },
      byDefault: { //match css values in responsive.less
        tablet: 'screen and (max-width: 768px)',
        mobile: 'screen and (max-width: 460px), screen and (max-device-width: 460px), screen and (max-width: 640px) and (orientation:landscape), screen and (max-device-width: 640px) and (orientation:landscape)'
      }
    },
    sharethis: {
      apikey: '3bc1c4fc-1679-4c7a-9029-73770970ad12'
    },
    compatibility: {
      test: {
        // Classes applied on the html tag by Modernizr Tests.
        classes: ['fontface', 'hashchange'],
        // Test on window / ex: 'matchMedia' will test if window.matchMedia is available.
        window: []
      },
      modal: {
        settings: {
          type: 'inline',
          items: {
            src: '#CompatibilityModal'
          }
        }
      }
    },
    map: {
      apikey: "AIzaSyDByzOlwHXwhgFw7bxzNidXkukulmzg2nI",
      airportLatLng: { lat: 45.4576400, lng: -73.7496970 },
      zones: {}, //deprecated
      parkings: {

        'parking_cellparc': [{ lat: 45.45091896282539, lng: -73.75044822692871 }], //Valet Parc
        'parking_valetparc': [{ lat: 45.45730483060549, lng: -73.74890327453613 }], //Stationnement Aerogare
        'parking_hotelparc': [{ lat: 45.456202313448664, lng: -73.75195026397705 }], //Hotel parc
        'parking_multilevel': [{ lat: 45.45644690102668, lng: -73.75034093856812 }],
        'parking_shortterm': [{ lat: 45.45722957414717, lng: -73.75034093856812 }],
        'parking_econoparc_p5': [{ lat: 45.45443748855845, lng: -73.74904811382294 }],
        'parking_econoparc_p6': [{ lat: 45.45345533394208, lng: -73.74594748020172 }],
        'parking_econoparc_p7': [{ lat: 45.453176865536214, lng: -73.74413430690765 }],
        'parking_econoparc_p8': [{ lat: 45.45159257992858, lng: -73.74382317066193 }],
        'parking_econoparc_p9': [{ lat: 45.45198395153369, lng: -73.74787330627441 }],
        'parking_aeroparc': [{ lat: 45.45514869329252, lng: -73.73997688293457 }],
        'parking_aeroparc2': [{ lat: 45.45352306929236, lng: -73.7385606765747 }]
        //'parking_expressparc': [{lat: 45.456819424683985, lng: -73.74873161315918}],
        //'parking_econoparc_p10': [{lat: 45.45496807071767, lng: -73.73933851718903}],
        //'parking_econoparc_p11': [{lat: 45.45380906209658, lng: -73.73834073543549}]


      },
      sprite: (/localhost|127.0.0.1/.test(window.location.hostname)) ? '/images/interactivemap/map_sprite.png' : '/sites/all/themes/custom/angani/images/interactivemap/map_sprite.png'
    },
    interactivemap: {
      mockData: false,
      defaultOpts: {
        maptype: "MapTypeId.ROADMAP",
        zoom: 15,
        maxZoom: 18,
        minZoom: 10,
        disableDefaultUI: true,
        zoomControl: false,
        scaleControl: true,
        center: { lat: 45.4576400, lng: -73.7496970 }
      }
    }
  };

  return Settings;
});
/*!
* EventEmitter v4.2.3 - git.io/ee
* Oliver Caldwell
* MIT license
* @preserve
*/

(function () {
  'use strict';

  /**
   * Class for managing events.
   * Can be extended to provide event functionality in other classes.
   *
   * @class EventEmitter Manages event registering and emitting.
   */
  function EventEmitter() { }

  // Shortcuts to improve speed and size

  // Easy access to the prototype
  var proto = EventEmitter.prototype;

  /**
   * Finds the index of the listener for the event in it's storage array.
   *
   * @param {Function[]} listeners Array of listeners to search through.
   * @param {Function} listener Method to look for.
   * @return {Number} Index of the specified listener, -1 if not found
   * @api private
   */
  function indexOfListener(listeners, listener) {
    var i = listeners.length;
    while (i--) {
      if (listeners[i].listener === listener) {
        return i;
      }
    }

    return -1;
  }

  /**
   * Alias a method while keeping the context correct, to allow for overwriting of target method.
   *
   * @param {String} name The name of the target method.
   * @return {Function} The aliased method
   * @api private
   */
  function alias(name) {
    return function aliasClosure() {
      return this[name].apply(this, arguments);
    };
  }

  /**
   * Returns the listener array for the specified event.
   * Will initialise the event object and listener arrays if required.
   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
   * Each property in the object response is an array of listener functions.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Function[]|Object} All listener functions for the event.
   */
  proto.getListeners = function getListeners(evt) {
    var events = this._getEvents();
    var response;
    var key;

    // Return a concatenated array of all matching events if
    // the selector is a regular expression.
    if (typeof evt === 'object') {
      response = {};
      for (key in events) {
        if (events.hasOwnProperty(key) && evt.test(key)) {
          response[key] = events[key];
        }
      }
    }
    else {
      response = events[evt] || (events[evt] = []);
    }

    return response;
  };

  /**
   * Takes a list of listener objects and flattens it into a list of listener functions.
   *
   * @param {Object[]} listeners Raw listener objects.
   * @return {Function[]} Just the listener functions.
   */
  proto.flattenListeners = function flattenListeners(listeners) {
    var flatListeners = [];
    var i;

    for (i = 0; i < listeners.length; i += 1) {
      flatListeners.push(listeners[i].listener);
    }

    return flatListeners;
  };

  /**
   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Object} All listener functions for an event in an object.
   */
  proto.getListenersAsObject = function getListenersAsObject(evt) {
    var listeners = this.getListeners(evt);
    var response;

    if (listeners instanceof Array) {
      response = {};
      response[evt] = listeners;
    }

    return response || listeners;
  };

  /**
   * Adds a listener function to the specified event.
   * The listener will not be added if it is a duplicate.
   * If the listener returns true then it will be removed after it is called.
   * If you pass a regular expression as the event name then the listener will be added to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to attach the listener to.
   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.addListener = function addListener(evt, listener) {
    var listeners = this.getListenersAsObject(evt);
    var listenerIsWrapped = typeof listener === 'object';
    var key;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
        listeners[key].push(listenerIsWrapped ? listener : {
          listener: listener,
          once: false
        });
      }
    }

    return this;
  };

  /**
   * Alias of addListener
   */
  proto.on = alias('addListener');

  /**
   * Semi-alias of addListener. It will add a listener that will be
   * automatically removed after it's first execution.
   *
   * @param {String|RegExp} evt Name of the event to attach the listener to.
   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.addOnceListener = function addOnceListener(evt, listener) {
    return this.addListener(evt, {
      listener: listener,
      once: true
    });
  };

  /**
   * Alias of addOnceListener.
   */
  proto.once = alias('addOnceListener');

  /**
   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
   * You need to tell it what event names should be matched by a regex.
   *
   * @param {String} evt Name of the event to create.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.defineEvent = function defineEvent(evt) {
    this.getListeners(evt);
    return this;
  };

  /**
   * Uses defineEvent to define multiple events.
   *
   * @param {String[]} evts An array of event names to define.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.defineEvents = function defineEvents(evts) {
    for (var i = 0; i < evts.length; i += 1) {
      this.defineEvent(evts[i]);
    }
    return this;
  };

  /**
   * Removes a listener function from the specified event.
   * When passed a regular expression as the event name, it will remove the listener from all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to remove the listener from.
   * @param {Function} listener Method to remove from the event.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.removeListener = function removeListener(evt, listener) {
    var listeners = this.getListenersAsObject(evt);
    var index;
    var key;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key)) {
        index = indexOfListener(listeners[key], listener);

        if (index !== -1) {
          listeners[key].splice(index, 1);
        }
      }
    }

    return this;
  };

  /**
   * Alias of removeListener
   */
  proto.off = alias('removeListener');

  /**
   * Adds listeners in bulk using the manipulateListeners method.
   * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
   * You can also pass it a regular expression to add the array of listeners to all events that match it.
   * Yeah, this function does quite a bit. That's probably a bad thing.
   *
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to add.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.addListeners = function addListeners(evt, listeners) {
    // Pass through to manipulateListeners
    return this.manipulateListeners(false, evt, listeners);
  };

  /**
   * Removes listeners in bulk using the manipulateListeners method.
   * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
   * You can also pass it an event name and an array of listeners to be removed.
   * You can also pass it a regular expression to remove the listeners from all events that match it.
   *
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to remove.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.removeListeners = function removeListeners(evt, listeners) {
    // Pass through to manipulateListeners
    return this.manipulateListeners(true, evt, listeners);
  };

  /**
   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
   * The first argument will determine if the listeners are removed (true) or added (false).
   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
   * You can also pass it an event name and an array of listeners to be added/removed.
   * You can also pass it a regular expression to manipulate the listeners of all events that match it.
   *
   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
    var i;
    var value;
    var single = remove ? this.removeListener : this.addListener;
    var multiple = remove ? this.removeListeners : this.addListeners;

    // If evt is an object then pass each of it's properties to this method
    if (typeof evt === 'object' && !(evt instanceof RegExp)) {
      for (i in evt) {
        if (evt.hasOwnProperty(i) && (value = evt[i])) {
          // Pass the single listener straight through to the singular method
          if (typeof value === 'function') {
            single.call(this, i, value);
          }
          else {
            // Otherwise pass back to the multiple function
            multiple.call(this, i, value);
          }
        }
      }
    }
    else {
      // So evt must be a string
      // And listeners must be an array of listeners
      // Loop over it and pass each one to the multiple method
      i = listeners.length;
      while (i--) {
        single.call(this, evt, listeners[i]);
      }
    }

    return this;
  };

  /**
   * Removes all listeners from a specified event.
   * If you do not specify an event then all listeners will be removed.
   * That means every event will be emptied.
   * You can also pass a regex to remove all events that match it.
   *
   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.removeEvent = function removeEvent(evt) {
    var type = typeof evt;
    var events = this._getEvents();
    var key;

    // Remove different things depending on the state of evt
    if (type === 'string') {
      // Remove all listeners for the specified event
      delete events[evt];
    }
    else if (type === 'object') {
      // Remove all events matching the regex.
      for (key in events) {
        if (events.hasOwnProperty(key) && evt.test(key)) {
          delete events[key];
        }
      }
    }
    else {
      // Remove all listeners in all events
      delete this._events;
    }

    return this;
  };

  /**
   * Emits an event of your choice.
   * When emitted, every listener attached to that event will be executed.
   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
   * So they will not arrive within the array on the other side, they will be separate.
   * You can also pass a regular expression to emit to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
   * @param {Array} [args] Optional array of arguments to be passed to each listener.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.emitEvent = function emitEvent(evt, args) {
    var listeners = this.getListenersAsObject(evt);
    var listener;
    var i;
    var key;
    var response;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key)) {
        i = listeners[key].length;

        while (i--) {
          // If the listener returns true then it shall be removed from the event
          // The function is executed either with a basic call or an apply if there is an args array
          listener = listeners[key][i];

          if (listener.once === true) {
            this.removeListener(evt, listener.listener);
          }

          response = listener.listener.apply(this, args || []);

          if (response === this._getOnceReturnValue()) {
            this.removeListener(evt, listener.listener);
          }
        }
      }
    }

    return this;
  };

  /**
   * Alias of emitEvent
   */
  proto.trigger = alias('emitEvent');

  /**
   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
   * @param {...*} Optional additional arguments to be passed to each listener.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.emit = function emit(evt) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.emitEvent(evt, args);
  };

  /**
   * Sets the current value to check against when executing listeners. If a
   * listeners return value matches the one set here then it will be removed
   * after execution. This value defaults to true.
   *
   * @param {*} value The new value to check for when executing listeners.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.setOnceReturnValue = function setOnceReturnValue(value) {
    this._onceReturnValue = value;
    return this;
  };

  /**
   * Fetches the current value to check against when executing listeners. If
   * the listeners return value matches this one then it should be removed
   * automatically. It will return true by default.
   *
   * @return {*|Boolean} The current value to check for or the default, true.
   * @api private
   */
  proto._getOnceReturnValue = function _getOnceReturnValue() {
    if (this.hasOwnProperty('_onceReturnValue')) {
      return this._onceReturnValue;
    }
    else {
      return true;
    }
  };

  /**
   * Fetches the events object and creates one if required.
   *
   * @return {Object} The events storage object.
   * @api private
   */
  proto._getEvents = function _getEvents() {
    return this._events || (this._events = {});
  };

  // Expose the class either via AMD, CommonJS or the global object
  if (typeof define === 'function' && define.amd) {
    define('eventEmitter', [], function () {
      return EventEmitter;
    });
  }
  else if (typeof module === 'object' && module.exports) {
    module.exports = EventEmitter;
  }
  else {
    this.EventEmitter = EventEmitter;
  }
}.call(this));

/*!
* enquire.js v2.1.0 - Awesome Media Queries in JavaScript
* Copyright (c) 2013 Nick Williams - http://wicky.nillia.ms/enquire.js
* License: MIT (http://www.opensource.org/licenses/mit-license.php)
*/

; (function (name, context, factory) {
  var matchMedia = context.matchMedia;

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = factory(matchMedia);
  }
  else if (typeof define === 'function' && define.amd) {
    define('enquire', [], function () {
      return (context[name] = factory(matchMedia));
    });
  }
  else {
    context[name] = factory(matchMedia);
  }
}('enquire', this, function (matchMedia) {

  'use strict';

  /*jshint unused:false */
  /**
   * Helper function for iterating over a collection
   *
   * @param collection
   * @param fn
   */
  function each(collection, fn) {
    var i = 0,
      length = collection.length,
      cont;

    for (i; i < length; i++) {
      cont = fn(collection[i], i);
      if (cont === false) {
        break; //allow early exit
      }
    }
  }

  /**
   * Helper function for determining whether target object is an array
   *
   * @param target the object under test
   * @return {Boolean} true if array, false otherwise
   */
  function isArray(target) {
    return Object.prototype.toString.apply(target) === '[object Array]';
  }

  /**
   * Helper function for determining whether target object is a function
   *
   * @param target the object under test
   * @return {Boolean} true if function, false otherwise
   */
  function isFunction(target) {
    return typeof target === 'function';
  }

  /**
   * Delegate to handle a media query being matched and unmatched.
   *
   * @param {object} options
   * @param {function} options.match callback for when the media query is matched
   * @param {function} [options.unmatch] callback for when the media query is unmatched
   * @param {function} [options.setup] one-time callback triggered the first time a query is matched
   * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
   * @constructor
   */
  function QueryHandler(options) {
    this.options = options;
    !options.deferSetup && this.setup();
  }
  QueryHandler.prototype = {

    /**
     * coordinates setup of the handler
     *
     * @function
     */
    setup: function () {
      if (this.options.setup) {
        this.options.setup();
      }
      this.initialised = true;
    },

    /**
     * coordinates setup and triggering of the handler
     *
     * @function
     */
    on: function () {
      !this.initialised && this.setup();
      this.options.match && this.options.match();
    },

    /**
     * coordinates the unmatch event for the handler
     *
     * @function
     */
    off: function () {
      this.options.unmatch && this.options.unmatch();
    },

    /**
     * called when a handler is to be destroyed.
     * delegates to the destroy or unmatch callbacks, depending on availability.
     *
     * @function
     */
    destroy: function () {
      this.options.destroy ? this.options.destroy() : this.off();
    },

    /**
     * determines equality by reference.
     * if object is supplied compare options, if function, compare match callback
     *
     * @function
     * @param {object || function} [target] the target for comparison
     */
    equals: function (target) {
      return this.options === target || this.options.match === target;
    }

  };
  /**
   * Represents a single media query, manages it's state and registered handlers for this query
   *
   * @constructor
   * @param {string} query the media query string
   * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
   */
  function MediaQuery(query, isUnconditional) {
    this.query = query;
    this.isUnconditional = isUnconditional;
    this.handlers = [];
    this.mql = matchMedia(query);

    var self = this;
    this.listener = function (mql) {
      self.mql = mql;
      self.assess();
    };
    this.mql.addListener(this.listener);
  }
  MediaQuery.prototype = {

    /**
     * add a handler for this query, triggering if already active
     *
     * @param {object} handler
     * @param {function} handler.match callback for when query is activated
     * @param {function} [handler.unmatch] callback for when query is deactivated
     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
     */
    addHandler: function (handler) {
      var qh = new QueryHandler(handler);
      this.handlers.push(qh);

      this.matches() && qh.on();
    },

    /**
     * removes the given handler from the collection, and calls it's destroy methods
     * 
     * @param {object || function} handler the handler to remove
     */
    removeHandler: function (handler) {
      var handlers = this.handlers;
      each(handlers, function (h, i) {
        if (h.equals(handler)) {
          h.destroy();
          return !handlers.splice(i, 1); //remove from array and exit each early
        }
      });
    },

    /**
     * Determine whether the media query should be considered a match
     * 
     * @return {Boolean} true if media query can be considered a match, false otherwise
     */
    matches: function () {
      return this.mql.matches || this.isUnconditional;
    },

    /**
     * Clears all handlers and unbinds events
     */
    clear: function () {
      each(this.handlers, function (handler) {
        handler.destroy();
      });
      this.mql.removeListener(this.listener);
      this.handlers.length = 0; //clear array
    },

    /*
     * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
     */
    assess: function () {
      var action = this.matches() ? 'on' : 'off';

      each(this.handlers, function (handler) {
        handler[action]();
      });
    }
  };
  /**
   * Allows for registration of query handlers.
   * Manages the query handler's state and is responsible for wiring up browser events
   *
   * @constructor
   */
  function MediaQueryDispatch() {


    if (!matchMedia) {
      //throw new Error('matchMedia not present, legacy browsers require a polyfill');
    }

    this.queries = {};
    if (matchMedia) {
      this.browserIsIncapable = !matchMedia('only all').matches;
    }

  }

  MediaQueryDispatch.prototype = {

    /**
     * Registers a handler for the given media query
     *
     * @param {string} q the media query
     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
     * @param {function} options.match fired when query matched
     * @param {function} [options.unmatch] fired when a query is no longer matched
     * @param {function} [options.setup] fired when handler first triggered
     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
     */
    register: function (q, options, shouldDegrade) {
      if (matchMedia) {

        var queries = this.queries,
          isUnconditional = shouldDegrade && this.browserIsIncapable;

        if (!queries[q]) {
          queries[q] = new MediaQuery(q, isUnconditional);
        }

        //normalise to object in an array
        if (isFunction(options)) {
          options = { match: options };
        }
        if (!isArray(options)) {
          options = [options];
        }
        each(options, function (handler) {
          queries[q].addHandler(handler);
        });
      }
      return this;
    },

    /**
     * unregisters a query and all it's handlers, or a specific handler for a query
     *
     * @param {string} q the media query to target
     * @param {object || function} [handler] specific handler to unregister
     */
    unregister: function (q, handler) {
      if (matchMedia) {
        var query = this.queries[q];

        if (query) {
          if (handler) {
            query.removeHandler(handler);
          }
          else {
            query.clear();
            delete this.queries[q];
          }
        }
      }
      return this;
    }
  };

  return new MediaQueryDispatch();

}));
/* 
* Copyright (c) <year>, <copyright holder>
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the <organization> nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY <copyright holder> ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* TODO:
* - Support for ISO GUID stanard
*/

function Guid(options) {
  this.options = options || {};
  this.chars = this.options.chars || Guid.constants.alphanumerics;
  this.epoch = this.options.epoch || Guid.constants.epoch1970;
  this.counterSequenceLength = this.options.counterSequenceLength || 1;
  this.randomSequenceLength = this.options.randomSequenceLength || 2;
}

Guid.prototype.generate = function () {
  var now = (new Date()).getTime() - this.epoch;
  var guid = this.baseN(now);

  this.counterSeq = (now == this.lastTimestampUsed ? this.counterSeq + 1 : 1);
  guid += this.counterSeq;

  for (var i = 0; i < this.randomSequenceLength; i++) {
    guid += this.chars.charAt(Math.floor(Math.random() * this.chars.length));
  }

  this.lastTimestampUsed = now;

  return guid;
};

Guid.prototype.baseN = function (val) {
  if (val == 0) return "";
  var rightMost = val % this.chars.length;
  var rightMostChar = this.chars.charAt(rightMost);
  var remaining = Math.floor(val / this.chars.length);
  return this.baseN(remaining) + rightMostChar;
};

Guid.constants = {};
Guid.constants.numbers = "0123456789";
Guid.constants.alphas = "abcdefghijklmnopqrstuvwxyz";
Guid.constants.lowerAlphanumerics = "0123456789abcdefghijklmnopqrstuvwxyz";
Guid.constants.alphanumerics = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
// http://tools.ietf.org/html/rfc1924
Guid.constants.base85 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&()*+-;<=>?@^_`{|}~";

Guid.constants.epoch1970 = (new Date(0));
Guid.constants.epoch = function (year) { return (new Date("Jan 1 " + year)).getTime(); }

// function log() { if (console) console.log.apply(console, arguments); };
define("guid0", function () { });

define('UTILS', [
  'jquery',
  'settings',
  'guid0'
], function ($, Settings, GUID) {

  var Utils;
  var normalizeCharacter = (function () {
    var a = ['À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'ß', 'à', 'á', 'â', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'ÿ', 'Ā', 'ā', 'Ă', 'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Ċ', 'ċ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 'Ĕ', 'ĕ', 'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ġ', 'ġ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ħ', 'ħ', 'Ĩ', 'ĩ', 'Ī', 'ī', 'Ĭ', 'ĭ', 'Į', 'į', 'İ', 'ı', 'Ĳ', 'ĳ', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'ŉ', 'Ō', 'ō', 'Ŏ', 'ŏ', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 'Ŗ', 'ŗ', 'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ŧ', 'ŧ', 'Ũ', 'ũ', 'Ū', 'ū', 'Ŭ', 'ŭ', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 'ź', 'Ż', 'ż', 'Ž', 'ž', 'ſ', 'ƒ', 'Ơ', 'ơ', 'Ư', 'ư', 'Ǎ', 'ǎ', 'Ǐ', 'ǐ', 'Ǒ', 'ǒ', 'Ǔ', 'ǔ', 'Ǖ', 'ǖ', 'Ǘ', 'ǘ', 'Ǚ', 'ǚ', 'Ǜ', 'ǜ', 'Ǻ', 'ǻ', 'Ǽ', 'ǽ', 'Ǿ', 'ǿ'];
    var b = ['A', 'A', 'A', 'A', 'A', 'A', 'AE', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'O', 'U', 'U', 'U', 'U', 'Y', 's', 'a', 'a', 'a', 'a', 'a', 'a', 'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'n', 'o', 'o', 'o', 'o', 'o', 'o', 'u', 'u', 'u', 'u', 'y', 'y', 'A', 'a', 'A', 'a', 'A', 'a', 'C', 'c', 'C', 'c', 'C', 'c', 'C', 'c', 'D', 'd', 'D', 'd', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'G', 'g', 'G', 'g', 'G', 'g', 'G', 'g', 'H', 'h', 'H', 'h', 'I', 'i', 'I', 'i', 'I', 'i', 'I', 'i', 'I', 'i', 'IJ', 'ij', 'J', 'j', 'K', 'k', 'L', 'l', 'L', 'l', 'L', 'l', 'L', 'l', 'l', 'l', 'N', 'n', 'N', 'n', 'N', 'n', 'n', 'O', 'o', 'O', 'o', 'O', 'o', 'OE', 'oe', 'R', 'r', 'R', 'r', 'R', 'r', 'S', 's', 'S', 's', 'S', 's', 'S', 's', 'T', 't', 'T', 't', 'T', 't', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'W', 'w', 'Y', 'y', 'Y', 'Z', 'z', 'Z', 'z', 'Z', 'z', 's', 'f', 'O', 'o', 'U', 'u', 'A', 'a', 'I', 'i', 'O', 'o', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'A', 'a', 'AE', 'ae', 'O', 'o'];

    return function (str) {
      var i = a.length;
      while (i--) str = str.replace(a[i], b[i]);
      return str;
    };
  }());


  Utils = {
    matrixToArray: function (str) {
      console.log("matrixToArray", str);
      return str.split('(')[1].split(')')[0].split(',');
    },
    // TODO :: Refactoring method "getViewportState"
    setPlatform: function (platform) {
      //console.log("setting to ", platform);
      Settings.platform = platform;
      $(".flightWidget").attr('data-platform', platform); //TODO : Ceci n'as pas affaire ici, to be remove
    },
    // TODO :: Refactoring method "getViewportState"
    getPlatform: function () {
      if (!$("html").hasClass("ie8") || !$("html").hasClass("ie7")) {
        return Settings.platform;
        $(".flightWidget").attr('data-platform', platform); //TODO : Ceci n'as pas affaire ici, to be remove
      } else {
        return "full";
        $(".flightWidget").attr('data-platform', "full"); //TODO : Ceci n'as pas affaire ici, to be remove
      }

    },
    getLang: function () {
      return $("html").attr("lang") || "fr";
    },
    random: function (min, max, float) {
      if (float) {
        return (min + Math.random() * (max - min));
      } else {
        return Math.floor(Math.random() * (1 + max - min)) + min;
      }
    },
    getTimestamp: function (date) {
      return Math.round(date.getTime() / 1000);
    },
    getUniqueId: function () {
      var guid = new Guid();
      return guid.generate();
    },
    removeHighlightedCodeFromContext: function (context) {
      // Remove Highlighted Code from the context when we are in integration static environnement
      if ($("body").attr("data-integration-mode") === "true") {
        var $filteredContext = $(context).filter(function () {

          var add = 1;
          $(this).parents().each(function () {
            if ($(this).is(".code-clean")) {
              add = 0;
            }
          });


          return add;
        });
        return $filteredContext;
      } else {
        return context;
      }
    },
    compatibilityTest: function () {
      var $testClasses = $(Settings.compatibility.test.classes);
      var $testWindow = $(Settings.compatibility.test.window);
      var $html = $('html');
      var flag = true;

      // Test classes on the html tag
      $testClasses.each(function (i, item) {
        flag = $html.hasClass(item);
        if (!flag) return false;
      });

      // Test if window object is available
      $testWindow.each(function (i, item) {
        flag = window[item];
        if (!flag) return false;
      });

      return flag;
    },
    isIE8OrLower: function () {

      return $('html').hasClass('oldie');
    },
    normalizeCharacter: function (str) {
      return normalizeCharacter(str);
    },
    isMobile: {
      Android: function () {
        return /Android/i.test(navigator.userAgent);
      },
      BlackBerry: function () {
        return /BlackBerry/i.test(navigator.userAgent);
      },
      iOS: function () {
        return /iPhone|iPad|iPod/i.test(navigator.userAgent);
      },
      Windows: function () {
        return /IEMobile/i.test(navigator.userAgent);
      },
      any: function () {
        return (this.Android() || this.BlackBerry() || this.iOS() || this.Windows());
      }
    }
  };


  return Utils;
});
define('mediaQueries/mediaQueries', [
  'jquery',
  'enquire',
  'UTILS'
], function ($, enquire, Utils) {
  var MediaQueries = {
    init: function () {
      var eventEmitter = ADM.eventEmitter;

      if (!Utils.isIE8OrLower()) {
        enquire.register("screen and (min-width: 1291px)", {
          match: function () {
            // console.log("enquire full");
            Utils.setPlatform("full");
            eventEmitter.emitEvent('plaformChanged', ["full"]);
          }
        });

        enquire.register("screen and (min-width: 1081px) and (max-width: 1290px)", {
          match: function () {
            // console.log("enquire large");
            Utils.setPlatform("large");
            eventEmitter.emitEvent('plaformChanged', ["large"]);
          }
        });

        enquire.register("screen and (min-width: 761px) and (max-width: 1080px)", {
          match: function () {
            // console.log("enquire medium");
            Utils.setPlatform("medium");
            eventEmitter.emitEvent('plaformChanged', ["medium"]);
          }
        });

        enquire.register("screen and (min-width: 641px) and (max-width: 760px)", {
          match: function () {
            //  console.log("enquire small");
            Utils.setPlatform("small");
            eventEmitter.emitEvent('plaformChanged', ["small"]);
          }
        });

        enquire.register("screen and (max-width: 640px)", {
          match: function () {
            // console.log("enquire mobile");
            Utils.setPlatform("mobile");
            eventEmitter.emitEvent('plaformChanged', ["mobile"]);
          }
        });
      } else {
        Utils.setPlatform("large");
        eventEmitter.emitEvent('plaformChanged', ["large"]);
      }

    }
  };

  return MediaQueries;
});
/*!
* tabbable 5.2.1
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('tabbable', ['exports'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (function () {
        var current = global.tabbable;
        var exports = global.tabbable = {};
        factory(exports);
        exports.noConflict = function () { global.tabbable = current; return exports; };
      }()));
}(this, (function (exports) {
  'use strict';

  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
  var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
  var matches = typeof Element === 'undefined' ? function () { } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  var getCandidates = function getCandidates(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));

    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }

    candidates = candidates.filter(filter);
    return candidates;
  };

  var isContentEditable = function isContentEditable(node) {
    return node.contentEditable === 'true';
  };

  var getTabindex = function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);

    if (!isNaN(tabindexAttr)) {
      return tabindexAttr;
    } // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.


    if (isContentEditable(node)) {
      return 0;
    } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    //  yet they are still part of the regular tab order; in FF, they get a default
    //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    //  order, consider their tab index to be 0.


    if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
      return 0;
    }

    return node.tabIndex;
  };

  var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  };

  var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
  };

  var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
  };

  var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
      return child.tagName === 'SUMMARY';
    });
    return r;
  };

  var getCheckedRadio = function getCheckedRadio(nodes, form) {
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].checked && nodes[i].form === form) {
        return nodes[i];
      }
    }
  };

  var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) {
      return true;
    }

    var radioScope = node.form || node.ownerDocument;

    var queryRadios = function queryRadios(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };

    var radioSet;

    if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
        return false;
      }
    }

    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };

  var isRadio = function isRadio(node) {
    return isInput(node) && node.type === 'radio';
  };

  var isNonTabbableRadio = function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };

  var isHidden = function isHidden(node, displayCheck) {
    if (getComputedStyle(node).visibility === 'hidden') {
      return true;
    }

    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
      return true;
    }

    if (!displayCheck || displayCheck === 'full') {
      while (node) {
        if (getComputedStyle(node).display === 'none') {
          return true;
        }

        node = node.parentElement;
      }
    } else if (displayCheck === 'non-zero-area') {
      var _node$getBoundingClie = node.getBoundingClientRect(),
        width = _node$getBoundingClie.width,
        height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    }

    return false;
  }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
  //  unless they are in the _first_ <legend> element of the top-most disabled
  //  fieldset


  var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
    if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {
      var parentNode = node.parentElement;

      while (parentNode) {
        if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
          // look for the first <legend> as an immediate child of the disabled
          //  <fieldset>: if the node is in that legend, it'll be enabled even
          //  though the fieldset is disabled; otherwise, the node is in a
          //  secondary/subsequent legend, or somewhere else within the fieldset
          //  (however deep nested) and it'll be disabled
          for (var i = 0; i < parentNode.children.length; i++) {
            var child = parentNode.children.item(i);

            if (child.tagName === 'LEGEND') {
              if (child.contains(node)) {
                return false;
              } // the node isn't in the first legend (in doc order), so no matter
              //  where it is now, it'll be disabled


              return true;
            }
          } // the node isn't in a legend, so no matter where it is now, it'll be disabled


          return true;
        }

        parentNode = parentNode.parentElement;
      }
    } // else, node's tabbable/focusable state should not be affected by a fieldset's
    //  enabled/disabled state


    return false;
  };

  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }

    return true;
  };

  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
    if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
      return false;
    }

    return true;
  };

  var tabbable = function tabbable(el, options) {
    options = options || {};
    var regularTabbables = [];
    var orderedTabbables = [];
    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    candidates.forEach(function (candidate, i) {
      var candidateTabindex = getTabindex(candidate);

      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    });
    var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {
      return a.node;
    }).concat(regularTabbables);
    return tabbableNodes;
  };

  var focusable = function focusable(el, options) {
    options = options || {};
    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    return candidates;
  };

  var isTabbable = function isTabbable(node, options) {
    options = options || {};

    if (!node) {
      throw new Error('No node provided');
    }

    if (matches.call(node, candidateSelector) === false) {
      return false;
    }

    return isNodeMatchingSelectorTabbable(options, node);
  };

  var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

  var isFocusable = function isFocusable(node, options) {
    options = options || {};

    if (!node) {
      throw new Error('No node provided');
    }

    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }

    return isNodeMatchingSelectorFocusable(options, node);
  };

  exports.focusable = focusable;
  exports.isFocusable = isFocusable;
  exports.isTabbable = isTabbable;
  exports.tabbable = tabbable;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map;
/*!
* focus-trap 7.0.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tabbable')) :
    typeof define === 'function' && define.amd ? define('focusTrap', ['exports', 'tabbable'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (function () {
        var current = global.focusTrap;
        var exports = global.focusTrap = {};
        factory(exports, global.tabbable);
        exports.noConflict = function () { global.focusTrap = current; return exports; };
      })());
})(this, (function (exports, tabbable) {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var activeFocusTraps = function () {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];

          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }

        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          // move this existing trap to the front of the queue
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }

        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();

  var isSelectableInput = function isSelectableInput(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
  };

  var isEscapeEvent = function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  };

  var isTabEvent = function isTabEvent(e) {
    return e.key === 'Tab' || e.keyCode === 9;
  };

  var delay = function delay(fn) {
    return setTimeout(fn, 0);
  }; // Array.find/findIndex() are not supported on IE; this replicates enough
  //  of Array.findIndex() for our needs


  var findIndex = function findIndex(arr, fn) {
    var idx = -1;
    arr.every(function (value, i) {
      if (fn(value)) {
        idx = i;
        return false; // break
      }

      return true; // next
    });
    return idx;
  };
  /**
   * Get an option's value when it could be a plain value, or a handler that provides
   *  the value.
   * @param {*} value Option's value to check.
   * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
   * @returns {*} The `value`, or the handler's returned value.
   */


  var valueOrHandler = function valueOrHandler(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }

    return typeof value === 'function' ? value.apply(void 0, params) : value;
  };

  var getActualTarget = function getActualTarget(event) {
    // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
    //  shadow host. However, event.target.composedPath() will be an array of
    //  nodes "clicked" from inner-most (the actual element inside the shadow) to
    //  outer-most (the host HTML document). If we have access to composedPath(),
    //  then use its first element; otherwise, fall back to event.target (and
    //  this only works for an _open_ shadow DOM; otherwise,
    //  composedPath()[0] === event.target always).
    return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
  };

  var createFocusTrap = function createFocusTrap(elements, userOptions) {
    // SSR: a live trap shouldn't be created in this type of environment so this
    //  should be safe code to execute if the `document` option isn't specified
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;

    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);

    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: undefined
    };
    var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

    /**
     * Gets a configuration option value.
     * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
     *  value will be taken from this object. Otherwise, value will be taken from base configuration.
     * @param {string} optionName Name of the option whose value is sought.
     * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
     *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
     */

    var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    /**
     * Finds the index of the container that contains the element.
     * @param {HTMLElement} element
     * @returns {number} Index of the container in either `state.containers` or
     *  `state.containerGroups` (the order/length of these lists are the same); -1
     *  if the element isn't found.
     */


    var findContainerIndex = function findContainerIndex(element) {
      // NOTE: search `containerGroups` because it's possible a group contains no tabbable
      //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
      //  and we still need to find the element in there
      return state.containerGroups.findIndex(function (_ref) {
        var container = _ref.container,
          tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          tabbableNodes.find(function (node) {
            return node === element;
          });
      });
    };
    /**
     * Gets the node for the given option, which is expected to be an option that
     *  can be either a DOM node, a string that is a selector to get a node, `false`
     *  (if a node is explicitly NOT given), or a function that returns any of these
     *  values.
     * @param {string} optionName
     * @returns {undefined | false | HTMLElement | SVGElement} Returns
     *  `undefined` if the option is not specified; `false` if the option
     *  resolved to `false` (node explicitly not given); otherwise, the resolved
     *  DOM node.
     * @throws {Error} If the option is set, not `false`, and is not, or does not
     *  resolve to a node.
     */


    var getNodeForOption = function getNodeForOption(optionName) {
      var optionValue = config[optionName];

      if (typeof optionValue === 'function') {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }

        optionValue = optionValue.apply(void 0, params);
      }

      if (optionValue === true) {
        optionValue = undefined; // use default value
      }

      if (!optionValue) {
        if (optionValue === undefined || optionValue === false) {
          return optionValue;
        } // else, empty string (invalid), null (invalid), 0 (invalid)


        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }

      var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point

      if (typeof optionValue === 'string') {
        node = doc.querySelector(optionValue); // resolve to node, or null if fails

        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }

      return node;
    };

    var getInitialFocusNode = function getInitialFocusNode() {
      var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all

      if (node === false) {
        return false;
      }

      if (node === undefined) {
        // option not specified: use fallback options
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)

          node = firstTabbableNode || getNodeForOption('fallbackFocus');
        }
      }

      if (!node) {
        throw new Error('Your focus-trap needs to have at least one focusable element');
      }

      return node;
    };

    var updateTabbableNodes = function updateTabbableNodes() {
      state.containerGroups = state.containers.map(function (container) {
        var tabbableNodes = tabbable.tabbable(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
        //  are a superset of tabbable nodes

        var focusableNodes = tabbable.focusable(container, config.tabbableOptions);
        return {
          container: container,
          tabbableNodes: tabbableNodes,
          focusableNodes: focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,

          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            // NOTE: If tabindex is positive (in order to manipulate the tab order separate
            //  from the DOM order), this __will not work__ because the list of focusableNodes,
            //  while it contains tabbable nodes, does not sort its nodes in any order other
            //  than DOM order, because it can't: Where would you place focusable (but not
            //  tabbable) nodes in that order? They have no order, because they aren't tabbale...
            // Support for positive tabindex is already broken and hard to manage (possibly
            //  not supportable, TBD), so this isn't going to make things worse than they
            //  already are, and at least makes things better for the majority of cases where
            //  tabindex is either 0/unset or negative.
            // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375
            var nodeIdx = focusableNodes.findIndex(function (n) {
              return n === node;
            });

            if (nodeIdx < 0) {
              return undefined;
            }

            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function (n) {
                return tabbable.isTabbable(n, config.tabbableOptions);
              });
            }

            return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {
              return tabbable.isTabbable(n, config.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function (group) {
        return group.tabbableNodes.length > 0;
      }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either

      if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
      ) {
        throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
      }
    };

    var tryFocus = function tryFocus(node) {
      if (node === false) {
        return;
      }

      if (node === doc.activeElement) {
        return;
      }

      if (!node || !node.focus) {
        tryFocus(getInitialFocusNode());
        return;
      }

      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;

      if (isSelectableInput(node)) {
        node.select();
      }
    };

    var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
      var node = getNodeForOption('setReturnFocus', previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    }; // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.


    var checkPointerDown = function checkPointerDown(e) {
      var target = getActualTarget(e);

      if (findContainerIndex(target) >= 0) {
        // allow the click since it ocurred inside the trap
        return;
      }

      if (valueOrHandler(config.clickOutsideDeactivates, e)) {
        // immediately deactivate the trap
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config.returnFocusOnDeactivate && !tabbable.isFocusable(target, config.tabbableOptions)
        });
        return;
      } // This is needed for mobile devices.
      // (If we'll only let `click` events through,
      // then on mobile they will be blocked anyways if `touchstart` is blocked.)


      if (valueOrHandler(config.allowOutsideClick, e)) {
        // allow the click outside the trap to take place
        return;
      } // otherwise, prevent the click


      e.preventDefault();
    }; // In case focus escapes the trap for some strange reason, pull it back in.


    var checkFocusIn = function checkFocusIn(e) {
      var target = getActualTarget(e);
      var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.

      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        // escaped! pull it back in to where it just left
        e.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }; // Hijack Tab events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.


    var checkTab = function checkTab(e) {
      var target = getActualTarget(e);
      updateTabbableNodes();
      var destinationNode = null;

      if (state.tabbableGroups.length > 0) {
        // make sure the target is actually contained in a group
        // NOTE: the target may also be the container itself if it's focusable
        //  with tabIndex='-1' and was given initial focus
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;

        if (containerIndex < 0) {
          // target not found in any group: quite possible focus has escaped the trap,
          //  so bring it back in to...
          if (e.shiftKey) {
            // ...the last node in the last group
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            // ...the first node in the first group
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e.shiftKey) {
          // REVERSE
          // is the target the first tabbable node in a group?
          var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });

          if (startOfGroupIndex < 0 && (containerGroup.container === target || tabbable.isFocusable(target, config.tabbableOptions) && !tabbable.isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            // an exception case where the target is either the container itself, or
            //  a non-tabbable node that was given focus (i.e. tabindex is negative
            //  and user clicked on it or node was programmatically given focus)
            //  and is not followed by any other tabbable node, in which
            //  case, we should handle shift+tab as if focus were on the container's
            //  first tabbable node, and go to the last tabbable node of the LAST group
            startOfGroupIndex = containerIndex;
          }

          if (startOfGroupIndex >= 0) {
            // YES: then shift+tab should go to the last tabbable node in the
            //  previous group (and wrap around to the last tabbable node of
            //  the LAST group if it's the first tabbable node of the FIRST group)
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          // FORWARD
          // is the target the last tabbable node in a group?
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });

          if (lastOfGroupIndex < 0 && (containerGroup.container === target || tabbable.isFocusable(target, config.tabbableOptions) && !tabbable.isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            // an exception case where the target is the container itself, or
            //  a non-tabbable node that was given focus (i.e. tabindex is negative
            //  and user clicked on it or node was programmatically given focus)
            //  and is not followed by any other tabbable node, in which
            //  case, we should handle tab as if focus were on the container's
            //  last tabbable node, and go to the first tabbable node of the FIRST group
            lastOfGroupIndex = containerIndex;
          }

          if (lastOfGroupIndex >= 0) {
            // YES: then tab should go to the first tabbable node in the next
            //  group (and wrap around to the first tabbable node of the FIRST
            //  group if it's the last tabbable node of the LAST group)
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;

            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        // NOTE: the fallbackFocus option does not support returning false to opt-out
        destinationNode = getNodeForOption('fallbackFocus');
      }

      if (destinationNode) {
        e.preventDefault();
        tryFocus(destinationNode);
      } // else, let the browser take care of [shift+]tab and move the focus

    };

    var checkKey = function checkKey(e) {
      if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {
        e.preventDefault();
        trap.deactivate();
        return;
      }

      if (isTabEvent(e)) {
        checkTab(e);
        return;
      }
    };

    var checkClick = function checkClick(e) {
      var target = getActualTarget(e);

      if (findContainerIndex(target) >= 0) {
        return;
      }

      if (valueOrHandler(config.clickOutsideDeactivates, e)) {
        return;
      }

      if (valueOrHandler(config.allowOutsideClick, e)) {
        return;
      }

      e.preventDefault();
      e.stopImmediatePropagation();
    }; //
    // EVENT LISTENERS
    //


    var addListeners = function addListeners() {
      if (!state.active) {
        return;
      } // There can be only one listening focus trap at a time


      activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event
      // that caused the focus trap activation.

      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener('focusin', checkFocusIn, true);
      doc.addEventListener('mousedown', checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener('touchstart', checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener('click', checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener('keydown', checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };

    var removeListeners = function removeListeners() {
      if (!state.active) {
        return;
      }

      doc.removeEventListener('focusin', checkFocusIn, true);
      doc.removeEventListener('mousedown', checkPointerDown, true);
      doc.removeEventListener('touchstart', checkPointerDown, true);
      doc.removeEventListener('click', checkClick, true);
      doc.removeEventListener('keydown', checkKey, true);
      return trap;
    }; //
    // TRAP DEFINITION
    //


    trap = {
      get active() {
        return state.active;
      },

      get paused() {
        return state.paused;
      },

      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }

        var onActivate = getOption(activateOptions, 'onActivate');
        var onPostActivate = getOption(activateOptions, 'onPostActivate');
        var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');

        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }

        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;

        if (onActivate) {
          onActivate();
        }

        var finishActivation = function finishActivation() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }

          addListeners();

          if (onPostActivate) {
            onPostActivate();
          }
        };

        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }

        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }

        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);

        clearTimeout(state.delayInitialFocusTimer); // noop if undefined

        state.delayInitialFocusTimer = undefined;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, 'onDeactivate');
        var onPostDeactivate = getOption(options, 'onPostDeactivate');
        var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
        var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');

        if (onDeactivate) {
          onDeactivate();
        }

        var finishDeactivation = function finishDeactivation() {
          delay(function () {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }

            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };

        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }

        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }

        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }

        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function (element) {
          return typeof element === 'string' ? doc.querySelector(element) : element;
        });

        if (state.active) {
          updateTabbableNodes();
        }

        return this;
      }
    }; // initialize container elements

    trap.updateContainerElements(elements);
    return trap;
  };

  exports.createFocusTrap = createFocusTrap;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=focus-trap.umd.js.map;
define('nav/nav', [
  'jquery',
  'focusTrap'
], function ($, focusTrap) {
  var closingTimeout;
  var closingIndex;
  var triggerHovering;
  var triggerTimeout;
  var pannelClosingTimeout;
  var mobileAnimationTimeout = null;
  var menuFocusTrap;
  var Nav = {
    init: function () {
      Nav.initPlusSubnav();
      Nav.initResizeEvents();
      Nav.initMobileEvents();
      Nav.updatePlusSubnav();
      Nav.initSubnavEvents();
    },
    initResizeEvents: function () {
      $(window).bind('resize', function () {
        Nav.updatePlusSubnav();
      });
    },
    initMobileEvents: function () {
      var $defaultSubnav = $('.header-rebrand-mobile .first-level.active');
      var $mobileSubnavTriggers = $('.header-rebrand-mobile .first-level > span > a');
      var $mobileToggle = $('.mobile-toggle');
      var $subnavList = $defaultSubnav.find('> ul');
      var animationDuration = 500;

      $defaultSubnav.addClass('subnav-visible');
      showSubnav($subnavList);

      menuFocusTrap = focusTrap.createFocusTrap($('.header-rebrand').parent()[0], {
        returnFocus: true,
        checkCanReturnFocus: $mobileToggle[0],
        initialFocus: $('.header-rebrand-mobile .form-item-search-block-form input').first()[0]
      });

      // Mobile subnavs
      $mobileSubnavTriggers.on('click', function (evt) {
        evt.preventDefault();
        var $subnavWrapper = $(this).parents('.first-level');
        var $subnav = $subnavWrapper.find('> ul');

        if ($subnavWrapper.hasClass('subnav-visible')) {
          reset();
        } else {
          reset();
          $subnavWrapper.addClass('subnav-visible');
          showSubnav($subnav);
        }
      });

      // Mobile nav trigger
      $mobileToggle.on('click', function (evt) {
        evt.preventDefault();
        if ($('html').hasClass('mobile-nav-opened')) {
          Nav.closeMobile();
        } else {
          Nav.openMobile();
        }
      });

      function showSubnav($subnav) {
        $subnav.slideDown(animationDuration)
      }

      function reset() {
        var $subnavCollapseCtaList = $('.header-rebrand-mobile .first-level');
        $subnavCollapseCtaList.removeClass('subnav-visible');
        $subnavCollapseCtaList.find('> ul').slideUp(animationDuration)
      }
    },
    initSubnavEvents: function () {
      var $subnavWrapper = $('.header-rebrand .first-level.active');
      var $subnavTriggers = $('.header-rebrand .first-level.active > ul > li > a, .header-rebrand .first-level.active .subnav a, .header-rebrand .plus-button button, .header-rebrand .plus-button .subnav a');
      var $subnavLinks = $('.header-rebrand .first-level.active .subnav a, .header-rebrand .plus-button .subnav a');
      var $subnavs = $('.header-rebrand .subnav');
      var subnavPanel = '<div class="subnav-panel"><div class="wrapper"><span class="decoration-line"></span></div></div>'

      // Add background subnav to DOM
      $subnavWrapper.append(subnavPanel);

      // Subnav trigger mouse over
      $subnavTriggers.mouseover(function () {
        var $itemWrapper = $(this).parent();
        var isTouch = $("html").hasClass("touch");

        if ($itemWrapper.find('.subnav').length !== 0 && !isTouch) {
          triggerHovering = $itemWrapper.index();
          triggerTimeout = setTimeout(function () {
            Nav.openSubnav($itemWrapper);
          }, 200);
        }
      });



      // Subnav trigger mouse leave
      $subnavTriggers.mouseout(function (e) {
        var $itemWrapper = $(this).parent();

        if (triggerHovering === $itemWrapper.index()) {
          clearTimeout(triggerTimeout);
        }

        Nav.closeSubnav($itemWrapper);

        document.onkeyup = function (event) {
          if (event.keyCode === 27) {
            Nav.closeSubnav($itemWrapper);
          }
        };
      });

      // Subnav trigger focus
      $subnavTriggers.on('focus', function () {
        var $itemWrapper = $(this).parent();
        var isTouch = $("html").hasClass("touch");

        if ($itemWrapper.find('.subnav').length !== 0 && !isTouch) {
          Nav.removeAllSubnavs();
          Nav.openSubnav($itemWrapper);
          Nav.removeSubNavItemAnimation($itemWrapper);
        }
      });

      // Subnav trigger focus
      $subnavTriggers.on('blur', function () {
        var $itemWrapper = $(this).parent();
        Nav.closeSubnav($itemWrapper);

        document.onkeyup = function (event) {
          if (event.keyCode === 27) {
            Nav.closeSubnav($itemWrapper);
          }
        };
      });

      // Subnav trigger mouse click
      $subnavTriggers.click(function (e) {
        var $itemWrapper = $(this).parent();
        var isTouch = $("html").hasClass("touch");
        var hasSubnav = $itemWrapper.find('.subnav').length !== 0;

        if (isTouch && hasSubnav) {
          e.preventDefault();

          if (!$itemWrapper.hasClass('link-cloned') && !$itemWrapper.hasClass('plus-button')) {
            var buttonText = $(this).find('.title').clone().children().remove().end().text();
            var buttonLink = $(this).attr('href');
            var clonedLink = '<li class="cloned-link"><a href="' + buttonLink + '">' + buttonText + '</a></li>';
            $itemWrapper.find('.subnav-inner > ul').prepend(clonedLink);
            $itemWrapper.addClass('link-cloned');
          }

          if ($itemWrapper.hasClass('subnav-opened')) {
            Nav.closeSubnav($itemWrapper);
          } else {
            $('.subnav-opened').removeClass('subnav-opened subnav-no-anim');
            Nav.openSubnav($itemWrapper);
          }
        }
      });

      $subnavLinks.on('focus', function () {
        // Keep menu open
        var $itemWrapper = $(this).parents('.subnav').parent();

        if ($(this).parent().is(':last-child')) {
          Nav.removeAllSubnavs();
        }

        Nav.openSubnav($itemWrapper);
        Nav.removeSubNavItemAnimation($itemWrapper);
      });

      // Subnav mouse over
      $subnavs.mouseover(function () {
        var $itemWrapper = $(this).parent();
        var itemIndex = $itemWrapper.index();
        openingSubnav = itemIndex;

        Nav.openSubnav($itemWrapper);
      });

      // Subnav mouse over
      $subnavs.mouseout(function () {
        var $itemWrapper = $(this).parent();

        Nav.closeSubnav($itemWrapper);
        Nav.closePannel();
      });
    },
    openMobile: function () {
      var $header = $('.header-rebrand-mobile');
      var delayAfterMenuIsOnDisplayBlock = 100;

      if (mobileAnimationTimeout) clearTimeout(mobileAnimationTimeout);

      $header.css('display', 'block');

      mobileAnimationTimeout = setTimeout(function () {
        $('html').addClass('mobile-nav-opened');
        menuFocusTrap.activate();
      }, delayAfterMenuIsOnDisplayBlock)
    },
    closeMobile: function () {
      var delayAfterCloseAnimation = 600;

      if (mobileAnimationTimeout) clearTimeout(mobileAnimationTimeout);

      $('html').removeClass('mobile-nav-opened');
      menuFocusTrap.deactivate();

      mobileAnimationTimeout = setTimeout(function () {
        $('.header-rebrand-mobile').css('display', 'none')
      }, delayAfterCloseAnimation)
    },
    openSubnav: function (element) {
      var $subnavPanel = $('.header-rebrand .subnav-panel');
      var $currentSubnav = element.find('.subnav');
      var height = $currentSubnav.height();

      clearTimeout(pannelClosingTimeout);
      clearTimeout(closingTimeout);
      $subnavPanel.css('height', height);

      setTimeout(function () {
        Nav.openPannel();

        if (!element.hasClass('subnav-opened')) {
          element.addClass('subnav-opened');
        }
      });
    },
    removeSubNavItemAnimation(element) {
      element.addClass('subnav-no-anim');
    },
    closeSubnav: function (element) {
      closingIndex = element.index();
      closingTimeout = setTimeout(function () {
        element.removeClass('subnav-opened subnav-no-anim');
        closingIndex = null;
      }, 150);

      Nav.closePannel();
    },
    openPannel: function () {
      var $body = $('body');
      var $subnavPanel = $('.header-rebrand .subnav-panel');

      $subnavPanel.addClass('subnav-active');
      $body.addClass('subnav-backdrop');
    },
    closePannel: function () {
      var $body = $('body');
      var $subnavPanel = $('.header-rebrand .subnav-panel');

      clearTimeout(pannelClosingTimeout);
      pannelClosingTimeout = setTimeout(function () {
        $subnavPanel.removeClass('subnav-active');
        $body.removeClass('subnav-backdrop');
      }, 400);
    },
    removeAllSubnavs: function () {
      $('.subnav-opened').removeClass('subnav-opened subnav-no-anim');
    },
    initPlusSubnav: function () {
      var activeListSelector = '.header-rebrand .first-level.active > ul';
      var $activeList = $(activeListSelector);
      var $activeListItems = $(activeListSelector + ' > li');

      var plusButton = '<li class="plus-button">' +
        '<button>+Plus</button>' +
        '<div class="subnav">' +
        '<div class="subnav-inner wrapper">' +
        '<span class="decoration-line"></span>' +
        '<ul class="plus-subnav"></ul>' +
        '</div>' +
        '</div>' +
        '</li>';

      $activeListItems.addClass('active-list-item');
      $activeListItems.each(function () {
        var width = $(this).width();
        $(this).attr('nav-width', width);
      });

      $activeList.append(plusButton);
      Nav.updatePlusSubnav();
    },
    updatePlusSubnav: function (initialLoad) {
      var activeListSelector = '.header-rebrand .first-level.active > ul';
      var activeListPadding = parseInt($(activeListSelector).css('padding-right'), 10);
      var $activeList = $(activeListSelector);
      var $activeListItems = $(activeListSelector + ' > li');
      var $plusButton = $('.plus-button');
      var $subnav = $('.plus-subnav');
      var $subnavItems = $subnav.find('.active-list-item');
      var totalWidth = 0;
      var availableSpace = $activeList.width() - activeListPadding;
      var remainingSpace = availableSpace;

      var itemsToMove = [];
      var itemsToShift = [];

      if ($subnav.find('a.active').length) {
        $plusButton.addClass('active');
      } else {
        $plusButton.removeClass('active');
      }

      // Loop items in main nav. If some don't fit, move to "+Plus" subnav
      $activeListItems.each(function () {
        if (!$(this).hasClass('plus-button')) {
          var itemWidth = Number($(this).attr('nav-width'));
          totalWidth += itemWidth;
          remainingSpace -= itemWidth;

          if (totalWidth > availableSpace) {
            itemsToMove.push($(this));
            availableSpace = 0;
          }
        }
      });

      // Loop items in "+Plus" subnav. If they could fit in main nav, move them
      $subnavItems.each(function () {
        var itemWidth = Number($(this).attr('nav-width'));

        if (itemWidth < remainingSpace) {
          $(this).insertBefore('.plus-button');
        } else {
          itemsToShift.push($(this));
        }

        remainingSpace -= itemWidth;
      });

      for (var x = 0; x < itemsToMove.length; x++) {
        itemsToMove[x].appendTo('.plus-subnav');
      }

      for (var x = 0; x < itemsToShift.length; x++) {
        itemsToShift[x].appendTo('.plus-subnav');
      }

      $subnav.find('a').each(function (i, item) {
        var $plusSubNavElem = $(item);
        $plusSubNavElem.unbind();

        $plusSubNavElem.on('focus', function () {
          var $itemWrapper = $(this).parents('.subnav').parent();
          var hasReachEndOfSubnav = $plusSubNavElem.parent().is(':last-child');

          if (hasReachEndOfSubnav) {
            Nav.removeAllSubnavs();
          }

          Nav.openSubnav($itemWrapper);
          Nav.removeSubNavItemAnimation($itemWrapper);
        });

        // Close +Plus Nav when leaving last element of the subnav
        if ($plusSubNavElem.parent().hasClass('last') && $plusSubNavElem.parents('li.active-list-item').hasClass('last')) {
          $plusSubNavElem.on('blur', function () {
            var $itemWrapper = $(this).parent();
            Nav.removeAllSubnavs();
            Nav.closeSubnav($itemWrapper);
          });
        }
      });

      if ($subnavItems.length) {
        $activeList.addClass('plus-button-active');
      } else {
        $activeList.removeClass('plus-button-active');
      }
    }
  };

  return Nav;
});



define('warnings/forcedNews', [
  'jquery',
  'UTILS',
], function ($, Utils) {

  var ForcedNews = {
    effects: {
      easing: "easeInOutExpo",
      duration: 700
    },
    init: function (context) {
      function isLocalStorageNameSupported() {
        var testKey = 'test', storage = window.sessionStorage;
        try {

          var supported = ('localStorage' in window && window['localStorage'] !== null);

          var key = prefix + '__' + Math.round(Math.random() * 1e7);
          if (supported) {
            localStorage.setItem(key, '');
            localStorage.removeItem(key);
          }


          return true;
        }
        catch (error) {
          return false;
        }
      }

      var forcedBoxState = null;
      var $forcedNewsCtn = $(context);
      var id = $forcedNewsCtn.find("a[msg-unique-key]").attr("msg-unique-key");

      if (isLocalStorageNameSupported) {
        // HANDLE THE SESSION STORAGE
        forcedBoxState = sessionStorage.getItem("forcedNew" + id);
      }

      if (forcedBoxState != "closed") {
        $.magnificPopup.open({
          items: {
            src: $forcedNewsCtn, // can be a HTML string, jQuery object, or CSS selector
            type: 'inline'
          },
          modal: true,
          callbacks: {
            open: function () {
              $("#forcedNewsHtml .lnkOk").bind("click", function (e) {
                e.preventDefault();
                $.magnificPopup.close();

                if (isLocalStorageNameSupported) {
                  try {
                    sessionStorage.setItem("forcedNew" + id, "closed");
                  } catch (e) {
                    console.log('You are in Private Browsing mode');
                  }
                }
              });
            }
          }
        });
      }
    }
  };

  return ForcedNews;
});
/*
* Foundation Responsive Library
* http://foundation.zurb.com
* Copyright 2013, ZURB
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
*/

(function ($, window, document, undefined) {
  'use strict';

  // Used to retrieve Foundation media queries from CSS.
  if ($('head').has('.foundation-mq-small').length === 0) {
    $('head').append('<meta class="foundation-mq-small">');
  }

  if ($('head').has('.foundation-mq-medium').length === 0) {
    $('head').append('<meta class="foundation-mq-medium">');
  }

  if ($('head').has('.foundation-mq-large').length === 0) {
    $('head').append('<meta class="foundation-mq-large">');
  }

  if ($('head').has('.foundation-mq-xlarge').length === 0) {
    $('head').append('<meta class="foundation-mq-xlarge">');
  }

  if ($('head').has('.foundation-mq-xxlarge').length === 0) {
    $('head').append('<meta class="foundation-mq-xxlarge">');
  }

  // Embed FastClick (this should be removed later)
  //function FastClick(layer){'use strict';var oldOnClick,self=this;this.trackingClick=false;this.trackingClickStart=0;this.targetElement=null;this.touchStartX=0;this.touchStartY=0;this.lastTouchIdentifier=0;this.touchBoundary=10;this.layer=layer;if(!layer||!layer.nodeType){throw new TypeError('Layer must be a document node');}this.onClick=function(){return FastClick.prototype.onClick.apply(self,arguments)};this.onMouse=function(){return FastClick.prototype.onMouse.apply(self,arguments)};this.onTouchStart=function(){return FastClick.prototype.onTouchStart.apply(self,arguments)};this.onTouchMove=function(){return FastClick.prototype.onTouchMove.apply(self,arguments)};this.onTouchEnd=function(){return FastClick.prototype.onTouchEnd.apply(self,arguments)};this.onTouchCancel=function(){return FastClick.prototype.onTouchCancel.apply(self,arguments)};if(FastClick.notNeeded(layer)){return}if(this.deviceIsAndroid){layer.addEventListener('mouseover',this.onMouse,true);layer.addEventListener('mousedown',this.onMouse,true);layer.addEventListener('mouseup',this.onMouse,true)}layer.addEventListener('click',this.onClick,true);layer.addEventListener('touchstart',this.onTouchStart,false);layer.addEventListener('touchmove',this.onTouchMove,false);layer.addEventListener('touchend',this.onTouchEnd,false);layer.addEventListener('touchcancel',this.onTouchCancel,false);if(!Event.prototype.stopImmediatePropagation){layer.removeEventListener=function(type,callback,capture){var rmv=Node.prototype.removeEventListener;if(type==='click'){rmv.call(layer,type,callback.hijacked||callback,capture)}else{rmv.call(layer,type,callback,capture)}};layer.addEventListener=function(type,callback,capture){var adv=Node.prototype.addEventListener;if(type==='click'){adv.call(layer,type,callback.hijacked||(callback.hijacked=function(event){if(!event.propagationStopped){callback(event)}}),capture)}else{adv.call(layer,type,callback,capture)}}}if(typeof layer.onclick==='function'){oldOnClick=layer.onclick;layer.addEventListener('click',function(event){oldOnClick(event)},false);layer.onclick=null}}FastClick.prototype.deviceIsAndroid=navigator.userAgent.indexOf('Android')>0;FastClick.prototype.deviceIsIOS=/iP(ad|hone|od)/.test(navigator.userAgent);FastClick.prototype.deviceIsIOS4=FastClick.prototype.deviceIsIOS&&(/OS 4_\d(_\d)?/).test(navigator.userAgent);FastClick.prototype.deviceIsIOSWithBadTarget=FastClick.prototype.deviceIsIOS&&(/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);FastClick.prototype.needsClick=function(target){'use strict';switch(target.nodeName.toLowerCase()){case'button':case'select':case'textarea':if(target.disabled){return true}break;case'input':if((this.deviceIsIOS&&target.type==='file')||target.disabled){return true}break;case'label':case'video':return true}return(/\bneedsclick\b/).test(target.className)};FastClick.prototype.needsFocus=function(target){'use strict';switch(target.nodeName.toLowerCase()){case'textarea':case'select':return true;case'input':switch(target.type){case'button':case'checkbox':case'file':case'image':case'radio':case'submit':return false}return!target.disabled&&!target.readOnly;default:return(/\bneedsfocus\b/).test(target.className)}};FastClick.prototype.sendClick=function(targetElement,event){'use strict';var clickEvent,touch;if(document.activeElement&&document.activeElement!==targetElement){document.activeElement.blur()}touch=event.changedTouches[0];clickEvent=document.createEvent('MouseEvents');clickEvent.initMouseEvent('click',true,true,window,1,touch.screenX,touch.screenY,touch.clientX,touch.clientY,false,false,false,false,0,null);clickEvent.forwardedTouchEvent=true;targetElement.dispatchEvent(clickEvent)};FastClick.prototype.focus=function(targetElement){'use strict';var length;if(this.deviceIsIOS&&targetElement.setSelectionRange){length=targetElement.value.length;targetElement.setSelectionRange(length,length)}else{targetElement.focus()}};FastClick.prototype.updateScrollParent=function(targetElement){'use strict';var scrollParent,parentElement;scrollParent=targetElement.fastClickScrollParent;if(!scrollParent||!scrollParent.contains(targetElement)){parentElement=targetElement;do{if(parentElement.scrollHeight>parentElement.offsetHeight){scrollParent=parentElement;targetElement.fastClickScrollParent=parentElement;break}parentElement=parentElement.parentElement}while(parentElement)}if(scrollParent){scrollParent.fastClickLastScrollTop=scrollParent.scrollTop}};FastClick.prototype.getTargetElementFromEventTarget=function(eventTarget){'use strict';if(eventTarget.nodeType===Node.TEXT_NODE){return eventTarget.parentNode}return eventTarget};FastClick.prototype.onTouchStart=function(event){'use strict';var targetElement,touch,selection;if(event.targetTouches.length>1){return true}targetElement=this.getTargetElementFromEventTarget(event.target);touch=event.targetTouches[0];if(this.deviceIsIOS){selection=window.getSelection();if(selection.rangeCount&&!selection.isCollapsed){return true}if(!this.deviceIsIOS4){if(touch.identifier===this.lastTouchIdentifier){event.preventDefault();return false}this.lastTouchIdentifier=touch.identifier;this.updateScrollParent(targetElement)}}this.trackingClick=true;this.trackingClickStart=event.timeStamp;this.targetElement=targetElement;this.touchStartX=touch.pageX;this.touchStartY=touch.pageY;if((event.timeStamp-this.lastClickTime)<200){event.preventDefault()}return true};FastClick.prototype.touchHasMoved=function(event){'use strict';var touch=event.changedTouches[0],boundary=this.touchBoundary;if(Math.abs(touch.pageX-this.touchStartX)>boundary||Math.abs(touch.pageY-this.touchStartY)>boundary){return true}return false};FastClick.prototype.onTouchMove=function(event){'use strict';if(!this.trackingClick){return true}if(this.targetElement!==this.getTargetElementFromEventTarget(event.target)||this.touchHasMoved(event)){this.trackingClick=false;this.targetElement=null}return true};FastClick.prototype.findControl=function(labelElement){'use strict';if(labelElement.control!==undefined){return labelElement.control}if(labelElement.htmlFor){return document.getElementById(labelElement.htmlFor)}return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea')};FastClick.prototype.onTouchEnd=function(event){'use strict';var forElement,trackingClickStart,targetTagName,scrollParent,touch,targetElement=this.targetElement;if(!this.trackingClick){return true}if((event.timeStamp-this.lastClickTime)<200){this.cancelNextClick=true;return true}this.lastClickTime=event.timeStamp;trackingClickStart=this.trackingClickStart;this.trackingClick=false;this.trackingClickStart=0;if(this.deviceIsIOSWithBadTarget){touch=event.changedTouches[0];targetElement=document.elementFromPoint(touch.pageX-window.pageXOffset,touch.pageY-window.pageYOffset)||targetElement;targetElement.fastClickScrollParent=this.targetElement.fastClickScrollParent}targetTagName=targetElement.tagName.toLowerCase();if(targetTagName==='label'){forElement=this.findControl(targetElement);if(forElement){this.focus(targetElement);if(this.deviceIsAndroid){return false}targetElement=forElement}}else if(this.needsFocus(targetElement)){if((event.timeStamp-trackingClickStart)>100||(this.deviceIsIOS&&window.top!==window&&targetTagName==='input')){this.targetElement=null;return false}this.focus(targetElement);if(!this.deviceIsIOS4||targetTagName!=='select'){this.targetElement=null;event.preventDefault()}return false}if(this.deviceIsIOS&&!this.deviceIsIOS4){scrollParent=targetElement.fastClickScrollParent;if(scrollParent&&scrollParent.fastClickLastScrollTop!==scrollParent.scrollTop){return true}}if(!this.needsClick(targetElement)){event.preventDefault();this.sendClick(targetElement,event)}return false};FastClick.prototype.onTouchCancel=function(){'use strict';this.trackingClick=false;this.targetElement=null};FastClick.prototype.onMouse=function(event){'use strict';if(!this.targetElement){return true}if(event.forwardedTouchEvent){return true}if(!event.cancelable){return true}if(!this.needsClick(this.targetElement)||this.cancelNextClick){if(event.stopImmediatePropagation){event.stopImmediatePropagation()}else{event.propagationStopped=true}event.stopPropagation();event.preventDefault();return false}return true};FastClick.prototype.onClick=function(event){'use strict';var permitted;if(this.trackingClick){this.targetElement=null;this.trackingClick=false;return true}if(event.target.type==='submit'&&event.detail===0){return true}permitted=this.onMouse(event);if(!permitted){this.targetElement=null}return permitted};FastClick.prototype.destroy=function(){'use strict';var layer=this.layer;if(this.deviceIsAndroid){layer.removeEventListener('mouseover',this.onMouse,true);layer.removeEventListener('mousedown',this.onMouse,true);layer.removeEventListener('mouseup',this.onMouse,true)}layer.removeEventListener('click',this.onClick,true);layer.removeEventListener('touchstart',this.onTouchStart,false);layer.removeEventListener('touchmove',this.onTouchMove,false);layer.removeEventListener('touchend',this.onTouchEnd,false);layer.removeEventListener('touchcancel',this.onTouchCancel,false)};FastClick.notNeeded=function(layer){'use strict';var metaViewport;if(typeof window.ontouchstart==='undefined'){return true}if((/Chrome\/[0-9]+/).test(navigator.userAgent)){if(FastClick.prototype.deviceIsAndroid){metaViewport=document.querySelector('meta[name=viewport]');if(metaViewport&&metaViewport.content.indexOf('user-scalable=no')!==-1){return true}}else{return true}}if(layer.style.msTouchAction==='none'){return true}return false};FastClick.attach=function(layer){'use strict';return new FastClick(layer)};if(typeof define!=='undefined'&&define.amd){define(function(){'use strict';return FastClick})}else if(typeof module!=='undefined'&&module.exports){module.exports=FastClick.attach;module.exports.FastClick=FastClick}else{window.FastClick=FastClick}


  // Enable FastClick
  if (typeof FastClick !== 'undefined') {
    FastClick.attach(document.body);
  }

  // private Fast Selector wrapper,
  // returns jQuery object. Only use where
  // getElementById is not available.
  var S = function (selector, context) {
    if (typeof selector === 'string') {
      if (context) {
        return $(context.querySelectorAll(selector));
      }

      return $(document.querySelectorAll(selector));
    }

    return $(selector, context);
  };

  /*
    https://github.com/paulirish/matchMedia.js
  */

  window.matchMedia = window.matchMedia || (function (doc, undefined) {

    "use strict";

    var bool,
      docElem = doc.documentElement,
      refNode = docElem.firstElementChild || docElem.firstChild,
      // fakeBody required for <FF4 when executed in <head>
      fakeBody = doc.createElement("body"),
      div = doc.createElement("div");

    div.id = "mq-test-1";
    div.style.cssText = "position:absolute;top:-100em";
    fakeBody.style.background = "none";
    fakeBody.appendChild(div);

    return function (q) {

      div.innerHTML = "&shy;<style media=\"" + q + "\"> #mq-test-1 { width: 42px; }</style>";

      docElem.insertBefore(fakeBody, refNode);
      bool = div.offsetWidth === 42;
      docElem.removeChild(fakeBody);

      return {
        matches: bool,
        media: q
      };

    };

  }(document));

  /*
   * jquery.requestAnimationFrame
   * https://github.com/gnarf37/jquery-requestAnimationFrame
   * Requires jQuery 1.8+
   *
   * Copyright (c) 2012 Corey Frang
   * Licensed under the MIT license.
   */

  (function ($) {

    // requestAnimationFrame polyfill adapted from Erik Möller
    // fixes from Paul Irish and Tino Zijdel
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating


    var animating,
      lastTime = 0,
      vendors = ['webkit', 'moz'],
      requestAnimationFrame = window.requestAnimationFrame,
      cancelAnimationFrame = window.cancelAnimationFrame;

    for (; lastTime < vendors.length && !requestAnimationFrame; lastTime++) {
      requestAnimationFrame = window[vendors[lastTime] + "RequestAnimationFrame"];
      cancelAnimationFrame = cancelAnimationFrame ||
        window[vendors[lastTime] + "CancelAnimationFrame"] ||
        window[vendors[lastTime] + "CancelRequestAnimationFrame"];
    }

    function raf() {
      if (animating) {
        requestAnimationFrame(raf);
        jQuery.fx.tick();
      }
    }

    if (requestAnimationFrame) {
      // use rAF
      window.requestAnimationFrame = requestAnimationFrame;
      window.cancelAnimationFrame = cancelAnimationFrame;
      jQuery.fx.timer = function (timer) {
        if (timer() && jQuery.timers.push(timer) && !animating) {
          animating = true;
          raf();
        }
      };

      jQuery.fx.stop = function () {
        animating = false;
      };
    } else {
      // polyfill
      window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = window.setTimeout(function () {
            callback(currTime + timeToCall);
          }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };

      window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };

    }

  }(jQuery));


  function removeQuotes(string) {
    if (typeof string === 'string' || string instanceof String) {
      string = string.replace(/^[\\/'"]+|(;\s?})+|[\\/'"]+$/g, '');
    }

    return string;
  }

  window.Foundation = {
    name: 'Foundation',

    version: '5.0.0',

    media_queries: {
      small: S('.foundation-mq-small').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      medium: S('.foundation-mq-medium').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      large: S('.foundation-mq-large').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      xlarge: S('.foundation-mq-xlarge').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      xxlarge: S('.foundation-mq-xxlarge').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, '')
    },

    stylesheet: $('<style></style>').appendTo('head')[0].sheet,

    init: function (scope, libraries, method, options, response) {
      var library_arr,
        args = [scope, method, options, response],
        responses = [];

      // check RTL
      this.rtl = /rtl/i.test(S('html').attr('dir'));

      // set foundation global scope
      this.scope = scope || this.scope;

      if (libraries && typeof libraries === 'string' && !/reflow/i.test(libraries)) {
        if (this.libs.hasOwnProperty(libraries)) {
          responses.push(this.init_lib(libraries, args));
        }
      } else {
        for (var lib in this.libs) {
          responses.push(this.init_lib(lib, libraries));
        }
      }

      return scope;
    },

    init_lib: function (lib, args) {
      if (this.libs.hasOwnProperty(lib)) {
        this.patch(this.libs[lib]);

        if (args && args.hasOwnProperty(lib)) {
          return this.libs[lib].init.apply(this.libs[lib], [this.scope, args[lib]]);
        }

        return this.libs[lib].init.apply(this.libs[lib], args);
      }

      return function () { };
    },

    patch: function (lib) {
      lib.scope = this.scope;
      lib['data_options'] = this.lib_methods.data_options;
      lib['bindings'] = this.lib_methods.bindings;
      lib['S'] = S;
      lib.rtl = this.rtl;
    },

    inherit: function (scope, methods) {
      var methods_arr = methods.split(' ');

      for (var i = methods_arr.length - 1; i >= 0; i--) {
        if (this.lib_methods.hasOwnProperty(methods_arr[i])) {
          this.libs[scope.name][methods_arr[i]] = this.lib_methods[methods_arr[i]];
        }
      }
    },

    random_str: function (length) {
      var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

      if (!length) {
        length = Math.floor(Math.random() * chars.length);
      }

      var str = '';
      for (var i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
      }
      return str;
    },

    libs: {},

    // methods that can be inherited in libraries
    lib_methods: {
      throttle: function (fun, delay) {
        var timer = null;

        return function () {
          var context = this, args = arguments;

          clearTimeout(timer);
          timer = setTimeout(function () {
            fun.apply(context, args);
          }, delay);
        };
      },

      // parses data-options attribute
      data_options: function (el) {
        var opts = {}, ii, p, opts_arr, opts_len,
          data_options = el.data('options');

        if (typeof data_options === 'object') {
          return data_options;
        }

        opts_arr = (data_options || ':').split(';'),
          opts_len = opts_arr.length;

        function isNumber(o) {
          return !isNaN(o - 0) && o !== null && o !== "" && o !== false && o !== true;
        }

        function trim(str) {
          if (typeof str === 'string') return $.trim(str);
          return str;
        }

        // parse options
        for (ii = opts_len - 1; ii >= 0; ii--) {
          p = opts_arr[ii].split(':');

          if (/true/i.test(p[1])) p[1] = true;
          if (/false/i.test(p[1])) p[1] = false;
          if (isNumber(p[1])) p[1] = parseInt(p[1], 10);

          if (p.length === 2 && p[0].length > 0) {
            opts[trim(p[0])] = trim(p[1]);
          }
        }

        return opts;
      },

      delay: function (fun, delay) {
        return setTimeout(fun, delay);
      },

      // test for empty object or array
      empty: function (obj) {
        if (obj.length && obj.length > 0) return false;
        if (obj.length && obj.length === 0) return true;

        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) return false;
        }

        return true;
      },

      register_media: function (media, media_class) {
        if (Foundation.media_queries[media] === undefined) {
          $('head').append('<meta class="' + media_class + '">');
          Foundation.media_queries[media] = removeQuotes($('.' + media_class).css('font-family'));
        }
      },

      addCustomRule: function (rule, media) {
        if (media === undefined) {
          Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length);
        } else {
          var query = Foundation.media_queries[media];
          if (query !== undefined) {
            Foundation.stylesheet.insertRule('@media ' +
              Foundation.media_queries[media] + '{ ' + rule + ' }');
          }
        }
      },

      loaded: function (image, callback) {
        function loaded() {
          callback(image[0]);
        }

        function bindLoad() {
          this.one('load', loaded);

          if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
            var src = this.attr('src'),
              param = src.match(/\?/) ? '&' : '?';

            param += 'random=' + (new Date()).getTime();
            this.attr('src', src + param);
          }
        }

        if (!image.attr('src')) {
          loaded();
          return;
        }

        if (image[0].complete || image[0].readyState === 4) {
          loaded();
        } else {
          bindLoad.call(image);
        }
      },

      bindings: function (method, options) {
        var self = this,
          should_bind_events = !S(this).data(this.name + '-init');

        if (typeof method === 'string') {
          return this[method].call(this);
        }

        if (S(this.scope).is('[data-' + this.name + ']')) {
          S(this.scope).data(this.name + '-init', $.extend({}, this.settings, (options || method), this.data_options(S(this.scope))));

          if (should_bind_events) {
            this.events(this.scope);
          }

        } else {
          S('[data-' + this.name + ']', this.scope).each(function () {
            var should_bind_events = !S(this).data(self.name + '-init');

            S(this).data(self.name + '-init', $.extend({}, self.settings, (options || method), self.data_options(S(this))));

            if (should_bind_events) {
              self.events(this);
            }
          });
        }
      }
    }
  };

  $.fn.foundation = function () {
    var args = Array.prototype.slice.call(arguments, 0);

    return this.each(function () {
      Foundation.init.apply(Foundation, [this].concat(args));
      return this;
    });
  };

}(jQuery, this, this.document));

define("foundation", ["jquery"], function () { });

; (function ($, window, document, undefined) {
  'use strict';

  Foundation.libs.interchange = {
    name: 'interchange',

    version: '5.0.0',

    cache: {},

    images_loaded: false,
    nodes_loaded: false,

    settings: {
      load_attr: 'interchange',

      named_queries: {
        'default': Foundation.media_queries.small,
        small: Foundation.media_queries.small,
        medium: Foundation.media_queries.medium,
        large: Foundation.media_queries.large,
        xlarge: Foundation.media_queries.xlarge,
        xxlarge: Foundation.media_queries.xxlarge,
        landscape: 'only screen and (orientation: landscape)',
        portrait: 'only screen and (orientation: portrait)',
        retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' +
          'only screen and (min--moz-device-pixel-ratio: 2),' +
          'only screen and (-o-min-device-pixel-ratio: 2/1),' +
          'only screen and (min-device-pixel-ratio: 2),' +
          'only screen and (min-resolution: 192dpi),' +
          'only screen and (min-resolution: 2dppx)'
      },

      directives: {
        replace: function (el, path, trigger) {
          // The trigger argument, if called within the directive, fires
          // an event named after the directive on the element, passing
          // any parameters along to the event that you pass to trigger.
          //
          // ex. trigger(), trigger([a, b, c]), or trigger(a, b, c)
          //
          // This allows you to bind a callback like so:
          // $('#interchangeContainer').on('replace', function (e, a, b, c) {
          //   console.log($(this).html(), a, b, c);
          // });


          if (/IMG/.test(el[0].nodeName)) {
            var orig_path = el[0].src;

            if (new RegExp(path, 'i').test(orig_path)) return;
            if ($(el).hasClass("lazyload")) {
              $(el).attr("data-original");
            } else {
              el[0].src = path;
            }


            return trigger(el[0].src);
          }
          var last_path = el.data('interchange-last-path');

          if (last_path == path) return;


          var regex = "/^.(\.jpg|\.jpeg|\.png|\.gif|\.tiff|\.bmp)\??|#?./";

          if (new RegExp(regex, 'i').test(path)) {

            if ($(el).hasClass("lazyload")) {
              $(el).attr("data-original", path);
            } else {
              $(el).css('background-image', 'url(' + path + ')');
            }


            el.data('interchange-last-path', path);
            return trigger(path);
          }

          return trigger(path);

        }
      }
    },

    init: function (scope, method, options) {
      Foundation.inherit(this, 'throttle');

      this.data_attr = 'data-' + this.settings.load_attr;

      $.extend(true, this.settings, method, options);
      this.bindings(method, options);
      this.load('images');
      this.load('nodes');
    },

    events: function () {
      var self = this;

      $(window)
        .off('.interchange')
        .on('resize.fndtn.interchange', self.throttle(function () {
          self.resize.call(self);
        }, 50));

      return this;
    },

    resize: function () {
      var cache = this.cache;

      if (!this.images_loaded || !this.nodes_loaded) {
        setTimeout($.proxy(this.resize, this), 50);
        return;
      }

      for (var uuid in cache) {
        if (cache.hasOwnProperty(uuid)) {
          var passed = this.results(uuid, cache[uuid]);

          if (passed) {
            this.settings.directives[passed
              .scenario[1]](passed.el, passed.scenario[0], function () {
                if (arguments[0] instanceof Array) {
                  var args = arguments[0];
                } else {
                  var args = Array.prototype.slice.call(arguments, 0);
                }

                passed.el.trigger(passed.scenario[1], args);
              });
          }
        }
      }

    },

    results: function (uuid, scenarios) {
      var count = scenarios.length;

      if (count > 0) {
        var el = this.S('[data-uuid="' + uuid + '"]');

        for (var i = count - 1; i >= 0; i--) {
          var mq, rule = scenarios[i][2];
          if (this.settings.named_queries.hasOwnProperty(rule)) {
            mq = matchMedia(this.settings.named_queries[rule]);
          } else {
            mq = matchMedia(rule);
          }
          if (mq.matches) {
            return { el: el, scenario: scenarios[i] };
          }
        }
      }

      return false;
    },

    load: function (type, force_update) {
      if (typeof this['cached_' + type] === 'undefined' || force_update) {
        this['update_' + type]();
      }

      return this['cached_' + type];
    },

    update_images: function () {
      var images = this.S('img[' + this.data_attr + ']'),
        count = images.length,
        loaded_count = 0,
        data_attr = this.data_attr;

      this.cache = {};
      this.cached_images = [];
      this.images_loaded = (count === 0);

      for (var i = count - 1; i >= 0; i--) {
        loaded_count++;
        if (images[i]) {
          var str = images[i].getAttribute(data_attr) || '';

          if (str.length > 0) {
            this.cached_images.push(images[i]);
          }
        }

        if (loaded_count === count) {
          this.images_loaded = true;
          this.enhance('images');
        }
      }

      return this;
    },

    update_nodes: function () {
      var nodes = this.S('[' + this.data_attr + ']:not(img)'),
        count = nodes.length,
        loaded_count = 0,
        data_attr = this.data_attr;

      this.cached_nodes = [];
      // Set nodes_loaded to true if there are no nodes
      // this.nodes_loaded = false;
      this.nodes_loaded = (count === 0);


      for (var i = count - 1; i >= 0; i--) {
        loaded_count++;
        var str = nodes[i].getAttribute(data_attr) || '';

        if (str.length > 0) {
          this.cached_nodes.push(nodes[i]);
        }

        if (loaded_count === count) {
          this.nodes_loaded = true;
          this.enhance('nodes');
        }
      }

      return this;
    },

    enhance: function (type) {
      var count = this['cached_' + type].length;

      for (var i = count - 1; i >= 0; i--) {
        this.object($(this['cached_' + type][i]));
      }

      return $(window).trigger('resize');
    },

    parse_params: function (path, directive, mq) {
      return [this.trim(path), this.convert_directive(directive), this.trim(mq)];
    },

    convert_directive: function (directive) {

      var trimmed = this.trim(directive);

      if (trimmed.length > 0) {
        return trimmed;
      }

      return 'replace';
    },

    object: function (el) {
      var raw_arr = this.parse_data_attr(el),
        scenarios = [], count = raw_arr.length;

      if (count > 0) {
        for (var i = count - 1; i >= 0; i--) {
          var split = raw_arr[i].split(/\((.*?)(\))$/);

          if (split.length > 1) {
            var cached_split = split[0].split(','),
              params = this.parse_params(cached_split[0],
                cached_split[1], split[1]);

            scenarios.push(params);
          }
        }
      }

      return this.store(el, scenarios);
    },

    uuid: function (separator) {
      var delim = separator || "-";

      function S4() {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
      }

      return (S4() + S4() + delim + S4() + delim + S4()
        + delim + S4() + delim + S4() + S4() + S4());
    },

    store: function (el, scenarios) {
      var uuid = this.uuid(),
        current_uuid = el.data('uuid');

      if (current_uuid) return this.cache[current_uuid];

      el.attr('data-uuid', uuid);

      return this.cache[uuid] = scenarios;
    },

    trim: function (str) {

      if (typeof str === 'string') {
        return $.trim(str);
      }

      return '';
    },

    parse_data_attr: function (el) {

      var raw = el.data(this.settings.load_attr).split(/\[(.*?)\]/),
        count = raw.length, output = [];

      for (var i = count - 1; i >= 0; i--) {
        if (raw[i].replace(/[\W\d]+/, '').length > 4) {
          output.push(raw[i]);
        }
      }

      return output;
    },

    reflow: function () {
      this.load('images', true);
      this.load('nodes', true);
    }

  };

}(jQuery, this, this.document));

define("interchange", ["jquery", "foundation"], function () { });

define('uiTools/retinaImages', [
  'jquery',
  'UTILS',
  'foundation',
  'interchange'
], function ($, Utils) {

  var RetinaImages = {
    init: function (context) {


      if (!Utils.isIE8OrLower()) {
        if ($(document).attr("data-retinized") !== true) {

          setTimeout(function () {
            $(document).foundation('interchange', {
              named_queries: {
                normal: 'only screen and (min-width: 1px)',
                retina: 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)',
                desktop: 'only screen and (min-width: 641px)',
                mobile: 'only screen and (max-width: 640px)'
              }
            });
          }, 0);

          $(document).attr("data-retinized", true);
        } else {

          if ($(document).attr("data-retinized-recent") !== true) {
            $(document).foundation('interchange', 'reflow');
            $(document).attr("data-retinized-recent", true);

            //fix commerce listing pushnav retina image
            setTimeout(function () {
              $(document).attr("data-retinized-recent", false);
            }, 1000);
          }
        }
      } else {

        // Fallback for ie8
        $(context).each(function () {
          var $item = $(this);
          var data = $item.attr("data-interchange");

          data = data.replace(/\[/g, "");
          data = data.replace(/\]/g, "");
          data = data.split(",");
          var count = data.length;

          for (var i = count - 1; i >= 0; i--) {
            if (data[i].indexOf("(normal)") > -1 || data[i].indexOf("(desktop)") > -1) {

              if ($item.prop("tagName") === "img" || $item.prop("tagName") === "IMG") {
                if ($item.hasClass("lazyload")) {
                  $item.attr("data-original", data[i - 1]);
                } else {
                  $item.attr("src", data[i - 1]);
                }

              } else {

                if (new RegExp("/^.(\.jpg|\.jpeg|\.png|\.gif|\.tiff|\.bmp)\??|#?./", 'i').test(data[i - 1])) {
                  console.log("retina image :", data[i - 1]);



                  if ($item.hasClass("lazyload")) {
                    $item.attr("data-original", data[i - 1]);
                  } else {
                    $item.css('background-image', 'url(' + data[i - 1] + ')');
                    $item.find(".background-size-polyfill img").attr("src", data[i - 1]);
                  }


                } else {
                  /* $.get(data[i-1], function (response) {
                       $item.html(response);
                   });
                   */
                }
              }
            }
          }

        });
      }
    }
  };

  return RetinaImages;
});
/*
* qTip2 - Pretty powerful tooltips - v2.2.0
* http://qtip2.com
*
* Copyright (c) 2014 Craig Michael Thompson
* Released under the MIT, GPL licenses
* http://jquery.org/license
*
* Date: Sun Mar 16 2014 12:44 EDT-0400
* Plugins: tips
* Styles: None
*/
/*global window: false, jQuery: false, console: false, define: false */

/* Cache window, document, undefined */
(function (window, document, undefined) {

  // Uses AMD or browser globals to create a jQuery plugin.
  (function (factory) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
      define('qtip2', ['jquery'], factory);
    }
    else if (jQuery && !jQuery.fn.qtip) {
      factory(jQuery);
    }
  }
    (function ($) {
      "use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

      ;// Munge the primitives - Paul Irish tip
      var TRUE = true,
        FALSE = false,
        NULL = null,

        // Common variables
        X = 'x', Y = 'y',
        WIDTH = 'width',
        HEIGHT = 'height',

        // Positioning sides
        TOP = 'top',
        LEFT = 'left',
        BOTTOM = 'bottom',
        RIGHT = 'right',
        CENTER = 'center',

        // Position adjustment types
        FLIP = 'flip',
        FLIPINVERT = 'flipinvert',
        SHIFT = 'shift',

        // Shortcut vars
        QTIP, PROTOTYPE, CORNER, CHECKS,
        PLUGINS = {},
        NAMESPACE = 'qtip',
        ATTR_HAS = 'data-hasqtip',
        ATTR_ID = 'data-qtip-id',
        WIDGET = ['ui-widget', 'ui-tooltip'],
        SELECTOR = '.' + NAMESPACE,
        INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),

        CLASS_FIXED = NAMESPACE + '-fixed',
        CLASS_DEFAULT = NAMESPACE + '-default',
        CLASS_FOCUS = NAMESPACE + '-focus',
        CLASS_HOVER = NAMESPACE + '-hover',
        CLASS_DISABLED = NAMESPACE + '-disabled',

        replaceSuffix = '_replacedByqTip',
        oldtitle = 'oldtitle',
        trackingBound,

        // Browser detection
        BROWSER = {
          /*
           * IE version detection
           *
           * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
           * Credit to James Padolsey for the original implemntation!
           */
          ie: (function () {
            var v = 3, div = document.createElement('div');
            while ((div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->')) {
              if (!div.getElementsByTagName('i')[0]) { break; }
            }
            return v > 4 ? v : NaN;
          }()),

          /*
           * iOS version detection
           */
          iOS: parseFloat(
            ('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1])
              .replace('undefined', '3_2').replace('_', '.').replace('_', '')
          ) || FALSE
        };

      ; function QTip(target, options, id, attr) {
        // Elements and ID
        this.id = id;
        this.target = target;
        this.tooltip = NULL;
        this.elements = { target: target };

        // Internal constructs
        this._id = NAMESPACE + '-' + id;
        this.timers = { img: {} };
        this.options = options;
        this.plugins = {};

        // Cache object
        this.cache = {
          event: {},
          target: $(),
          disabled: FALSE,
          attr: attr,
          onTooltip: FALSE,
          lastClass: ''
        };

        // Set the initial flags
        this.rendered = this.destroyed = this.disabled = this.waiting =
          this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
      }
      PROTOTYPE = QTip.prototype;

      PROTOTYPE._when = function (deferreds) {
        return $.when.apply($, deferreds);
      };

      PROTOTYPE.render = function (show) {
        if (this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit

        var self = this,
          options = this.options,
          cache = this.cache,
          elements = this.elements,
          text = options.content.text,
          title = options.content.title,
          button = options.content.button,
          posOptions = options.position,
          namespace = '.' + this._id + ' ',
          deferreds = [],
          tooltip;

        // Add ARIA attributes to target
        $.attr(this.target[0], 'aria-describedby', this._id);

        // Create tooltip element
        this.tooltip = elements.tooltip = tooltip = $('<div/>', {
          'id': this._id,
          'class': [NAMESPACE, CLASS_DEFAULT, options.style.classes, NAMESPACE + '-pos-' + options.position.my.abbrev()].join(' '),
          'width': options.style.width || '',
          'height': options.style.height || '',
          'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

          /* ARIA specific attributes */
          'role': 'alert',
          'aria-live': 'polite',
          'aria-atomic': FALSE,
          'aria-describedby': this._id + '-content',
          'aria-hidden': TRUE
        })
          .toggleClass(CLASS_DISABLED, this.disabled)
          .attr(ATTR_ID, this.id)
          .data(NAMESPACE, this)
          .appendTo(posOptions.container)
          .append(
            // Create content element
            elements.content = $('<div />', {
              'class': NAMESPACE + '-content',
              'id': this._id + '-content',
              'aria-atomic': TRUE
            })
          );

        // Set rendered flag and prevent redundant reposition calls for now
        this.rendered = -1;
        this.positioning = TRUE;

        // Create title...
        if (title) {
          this._createTitle();

          // Update title only if its not a callback (called in toggle if so)
          if (!$.isFunction(title)) {
            deferreds.push(this._updateTitle(title, FALSE));
          }
        }

        // Create button
        if (button) { this._createButton(); }

        // Set proper rendered flag and update content if not a callback function (called in toggle)
        if (!$.isFunction(text)) {
          deferreds.push(this._updateContent(text, FALSE));
        }
        this.rendered = TRUE;

        // Setup widget classes
        this._setWidget();

        // Initialize 'render' plugins
        $.each(PLUGINS, function (name) {
          var instance;
          if (this.initialize === 'render' && (instance = this(self))) {
            self.plugins[name] = instance;
          }
        });

        // Unassign initial events and assign proper events
        this._unassignEvents();
        this._assignEvents();

        // When deferreds have completed
        this._when(deferreds).then(function () {
          // tooltiprender event
          self._trigger('render');

          // Reset flags
          self.positioning = FALSE;

          // Show tooltip if not hidden during wait period
          if (!self.hiddenDuringWait && (options.show.ready || show)) {
            self.toggle(TRUE, cache.event, FALSE);
          }
          self.hiddenDuringWait = FALSE;
        });

        // Expose API
        QTIP.api[this.id] = this;

        return this;
      };

      PROTOTYPE.destroy = function (immediate) {
        // Set flag the signify destroy is taking place to plugins
        // and ensure it only gets destroyed once!
        if (this.destroyed) { return this.target; }

        function process() {
          if (this.destroyed) { return; }
          this.destroyed = TRUE;

          var target = this.target,
            title = target.attr(oldtitle);

          // Destroy tooltip if rendered
          if (this.rendered) {
            this.tooltip.stop(1, 0).find('*').remove().end().remove();
          }

          // Destroy all plugins
          $.each(this.plugins, function (name) {
            this.destroy && this.destroy();
          });

          // Clear timers and remove bound events
          clearTimeout(this.timers.show);
          clearTimeout(this.timers.hide);
          this._unassignEvents();

          // Remove api object and ARIA attributes
          target.removeData(NAMESPACE)
            .removeAttr(ATTR_ID)
            .removeAttr(ATTR_HAS)
            .removeAttr('aria-describedby');

          // Reset old title attribute if removed
          if (this.options.suppress && title) {
            target.attr('title', title).removeAttr(oldtitle);
          }

          // Remove qTip events associated with this API
          this._unbind(target);

          // Remove ID from used id objects, and delete object references
          // for better garbage collection and leak protection
          this.options = this.elements = this.cache = this.timers =
            this.plugins = this.mouse = NULL;

          // Delete epoxsed API object
          delete QTIP.api[this.id];
        }

        // If an immediate destory is needed
        if ((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {
          this.tooltip.one('tooltiphidden', $.proxy(process, this));
          !this.triggering && this.hide();
        }

        // If we're not in the process of hiding... process
        else { process.call(this); }

        return this.target;
      };

      ; function invalidOpt(a) {
        return a === NULL || $.type(a) !== 'object';
      }

      function invalidContent(c) {
        return !($.isFunction(c) || (c && c.attr) || c.length || ($.type(c) === 'object' && (c.jquery || c.then)));
      }

      // Option object sanitizer
      function sanitizeOptions(opts) {
        var content, text, ajax, once;

        if (invalidOpt(opts)) { return FALSE; }

        if (invalidOpt(opts.metadata)) {
          opts.metadata = { type: opts.metadata };
        }

        if ('content' in opts) {
          content = opts.content;

          if (invalidOpt(content) || content.jquery || content.done) {
            content = opts.content = {
              text: (text = invalidContent(content) ? FALSE : content)
            };
          }
          else { text = content.text; }

          // DEPRECATED - Old content.ajax plugin functionality
          // Converts it into the proper Deferred syntax
          if ('ajax' in content) {
            ajax = content.ajax;
            once = ajax && ajax.once !== FALSE;
            delete content.ajax;

            content.text = function (event, api) {
              var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',

                deferred = $.ajax(
                  $.extend({}, ajax, { context: api })
                )
                  .then(ajax.success, NULL, ajax.error)
                  .then(function (content) {
                    if (content && once) { api.set('content.text', content); }
                    return content;
                  },
                    function (xhr, status, error) {
                      if (api.destroyed || xhr.status === 0) { return; }
                      api.set('content.text', status + ': ' + error);
                    });

              return !once ? (api.set('content.text', loading), deferred) : loading;
            };
          }

          if ('title' in content) {
            if (!invalidOpt(content.title)) {
              content.button = content.title.button;
              content.title = content.title.text;
            }

            if (invalidContent(content.title || FALSE)) {
              content.title = FALSE;
            }
          }
        }

        if ('position' in opts && invalidOpt(opts.position)) {
          opts.position = { my: opts.position, at: opts.position };
        }

        if ('show' in opts && invalidOpt(opts.show)) {
          opts.show = opts.show.jquery ? { target: opts.show } :
            opts.show === TRUE ? { ready: TRUE } : { event: opts.show };
        }

        if ('hide' in opts && invalidOpt(opts.hide)) {
          opts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };
        }

        if ('style' in opts && invalidOpt(opts.style)) {
          opts.style = { classes: opts.style };
        }

        // Sanitize plugin options
        $.each(PLUGINS, function () {
          this.sanitize && this.sanitize(opts);
        });

        return opts;
      }

      // Setup builtin .set() option checks
      CHECKS = PROTOTYPE.checks = {
        builtin: {
          // Core checks
          '^id$': function (obj, o, v, prev) {
            var id = v === TRUE ? QTIP.nextid : v,
              new_id = NAMESPACE + '-' + id;

            if (id !== FALSE && id.length > 0 && !$('#' + new_id).length) {
              this._id = new_id;

              if (this.rendered) {
                this.tooltip[0].id = this._id;
                this.elements.content[0].id = this._id + '-content';
                this.elements.title[0].id = this._id + '-title';
              }
            }
            else { obj[o] = prev; }
          },
          '^prerender': function (obj, o, v) {
            v && !this.rendered && this.render(this.options.show.ready);
          },

          // Content checks
          '^content.text$': function (obj, o, v) {
            this._updateContent(v);
          },
          '^content.attr$': function (obj, o, v, prev) {
            if (this.options.content.text === this.target.attr(prev)) {
              this._updateContent(this.target.attr(v));
            }
          },
          '^content.title$': function (obj, o, v) {
            // Remove title if content is null
            if (!v) { return this._removeTitle(); }

            // If title isn't already created, create it now and update
            v && !this.elements.title && this._createTitle();
            this._updateTitle(v);
          },
          '^content.button$': function (obj, o, v) {
            this._updateButton(v);
          },
          '^content.title.(text|button)$': function (obj, o, v) {
            this.set('content.' + o, v); // Backwards title.text/button compat
          },

          // Position checks
          '^position.(my|at)$': function (obj, o, v) {
            'string' === typeof v && (obj[o] = new CORNER(v, o === 'at'));
          },
          '^position.container$': function (obj, o, v) {
            this.rendered && this.tooltip.appendTo(v);
          },

          // Show checks
          '^show.ready$': function (obj, o, v) {
            v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
          },

          // Style checks
          '^style.classes$': function (obj, o, v, p) {
            this.rendered && this.tooltip.removeClass(p).addClass(v);
          },
          '^style.(width|height)': function (obj, o, v) {
            this.rendered && this.tooltip.css(o, v);
          },
          '^style.widget|content.title': function () {
            this.rendered && this._setWidget();
          },
          '^style.def': function (obj, o, v) {
            this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
          },

          // Events check
          '^events.(render|show|move|hide|focus|blur)$': function (obj, o, v) {
            this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip' + o, v);
          },

          // Properties which require event reassignment
          '^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function () {
            if (!this.rendered) { return; }

            // Set tracking flag
            var posOptions = this.options.position;
            this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

            // Reassign events
            this._unassignEvents();
            this._assignEvents();
          }
        }
      };

      // Dot notation converter
      function convertNotation(options, notation) {
        var i = 0, obj, option = options,

          // Split notation into array
          levels = notation.split('.');

        // Loop through
        while (option = option[levels[i++]]) {
          if (i < levels.length) { obj = option; }
        }

        return [obj || options, levels.pop()];
      }

      PROTOTYPE.get = function (notation) {
        if (this.destroyed) { return this; }

        var o = convertNotation(this.options, notation.toLowerCase()),
          result = o[0][o[1]];

        return result.precedance ? result.string() : result;
      };

      function setCallback(notation, args) {
        var category, rule, match;

        for (category in this.checks) {
          for (rule in this.checks[category]) {
            if (match = (new RegExp(rule, 'i')).exec(notation)) {
              args.push(match);

              if (category === 'builtin' || this.plugins[category]) {
                this.checks[category][rule].apply(
                  this.plugins[category] || this, args
                );
              }
            }
          }
        }
      }

      var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i,
        rrender = /^prerender|show\.ready/i;

      PROTOTYPE.set = function (option, value) {
        if (this.destroyed) { return this; }

        var rendered = this.rendered,
          reposition = FALSE,
          options = this.options,
          checks = this.checks,
          name;

        // Convert singular option/value pair into object form
        if ('string' === typeof option) {
          name = option; option = {}; option[name] = value;
        }
        else { option = $.extend({}, option); }

        // Set all of the defined options to their new values
        $.each(option, function (notation, value) {
          if (rendered && rrender.test(notation)) {
            delete option[notation]; return;
          }

          // Set new obj value
          var obj = convertNotation(options, notation.toLowerCase()), previous;
          previous = obj[0][obj[1]];
          obj[0][obj[1]] = value && value.nodeType ? $(value) : value;

          // Also check if we need to reposition
          reposition = rmove.test(notation) || reposition;

          // Set the new params for the callback
          option[notation] = [obj[0], obj[1], value, previous];
        });

        // Re-sanitize options
        sanitizeOptions(options);

        /*
         * Execute any valid callbacks for the set options
         * Also set positioning flag so we don't get loads of redundant repositioning calls.
         */
        this.positioning = TRUE;
        $.each(option, $.proxy(setCallback, this));
        this.positioning = FALSE;

        // Update position if needed
        if (this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
          this.reposition(options.position.target === 'mouse' ? NULL : this.cache.event);
        }

        return this;
      };

      ; PROTOTYPE._update = function (content, element, reposition) {
        var self = this,
          cache = this.cache;

        // Make sure tooltip is rendered and content is defined. If not return
        if (!this.rendered || !content) { return FALSE; }

        // Use function to parse content
        if ($.isFunction(content)) {
          content = content.call(this.elements.target, cache.event, this) || '';
        }

        // Handle deferred content
        if ($.isFunction(content.then)) {
          cache.waiting = TRUE;
          return content.then(function (c) {
            cache.waiting = FALSE;
            return self._update(c, element);
          }, NULL, function (e) {
            return self._update(e, element);
          });
        }

        // If content is null... return false
        if (content === FALSE || (!content && content !== '')) { return FALSE; }

        // Append new content if its a DOM array and show it if hidden
        if (content.jquery && content.length > 0) {
          element.empty().append(
            content.css({ display: 'block', visibility: 'visible' })
          );
        }

        // Content is a regular string, insert the new content
        else { element.html(content); }

        // Wait for content to be loaded, and reposition
        return this._waitForContent(element).then(function (images) {
          if (images.images && images.images.length && self.rendered && self.tooltip[0].offsetWidth > 0) {
            self.reposition(cache.event, !images.length);
          }
        });
      };

      PROTOTYPE._waitForContent = function (element) {
        var cache = this.cache;

        // Set flag
        cache.waiting = TRUE;

        // If imagesLoaded is included, ensure images have loaded and return promise
        return ($.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([]))
          .done(function () { cache.waiting = FALSE; })
          .promise();
      };

      PROTOTYPE._updateContent = function (content, reposition) {
        this._update(content, this.elements.content, reposition);
      };

      PROTOTYPE._updateTitle = function (content, reposition) {
        if (this._update(content, this.elements.title, reposition) === FALSE) {
          this._removeTitle(FALSE);
        }
      };

      PROTOTYPE._createTitle = function () {
        var elements = this.elements,
          id = this._id + '-title';

        // Destroy previous title element, if present
        if (elements.titlebar) { this._removeTitle(); }

        // Create title bar and title elements
        elements.titlebar = $('<div />', {
          'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')
        })
          .append(
            elements.title = $('<div />', {
              'id': id,
              'class': NAMESPACE + '-title',
              'aria-atomic': TRUE
            })
          )
          .insertBefore(elements.content)

          // Button-specific events
          .delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function (event) {
            $(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
          })
          .delegate('.qtip-close', 'mouseover mouseout', function (event) {
            $(this).toggleClass('ui-state-hover', event.type === 'mouseover');
          });

        // Create button if enabled
        if (this.options.content.button) { this._createButton(); }
      };

      PROTOTYPE._removeTitle = function (reposition) {
        var elements = this.elements;

        if (elements.title) {
          elements.titlebar.remove();
          elements.titlebar = elements.title = elements.button = NULL;

          // Reposition if enabled
          if (reposition !== FALSE) { this.reposition(); }
        }
      };

      ; PROTOTYPE.reposition = function (event, effect) {
        if (!this.rendered || this.positioning || this.destroyed) { return this; }

        // Set positioning flag
        this.positioning = TRUE;

        var cache = this.cache,
          tooltip = this.tooltip,
          posOptions = this.options.position,
          target = posOptions.target,
          my = posOptions.my,
          at = posOptions.at,
          viewport = posOptions.viewport,
          container = posOptions.container,
          adjust = posOptions.adjust,
          method = adjust.method.split(' '),
          tooltipWidth = tooltip.outerWidth(FALSE),
          tooltipHeight = tooltip.outerHeight(FALSE),
          targetWidth = 0,
          targetHeight = 0,
          type = tooltip.css('position'),
          position = { left: 0, top: 0 },
          visible = tooltip[0].offsetWidth > 0,
          isScroll = event && event.type === 'scroll',
          win = $(window),
          doc = container[0].ownerDocument,
          mouse = this.mouse,
          pluginCalculations, offset;

        // Check if absolute position was passed
        if ($.isArray(target) && target.length === 2) {
          // Force left top and set position
          at = { x: LEFT, y: TOP };
          position = { left: target[0], top: target[1] };
        }

        // Check if mouse was the target
        else if (target === 'mouse') {
          // Force left top to allow flipping
          at = { x: LEFT, y: TOP };

          // Use the cached mouse coordinates if available, or passed event has no coordinates
          if (mouse && mouse.pageX && (adjust.mouse || !event || !event.pageX)) {
            event = mouse;
          }

          // If the passed event has no coordinates (such as a scroll event)
          else if (!event || !event.pageX) {
            // Use the mouse origin that caused the show event, if distance hiding is enabled
            if ((!adjust.mouse || this.options.show.distance) && cache.origin && cache.origin.pageX) {
              event = cache.origin;
            }

            // Use cached event for resize/scroll events
            else if (!event || (event && (event.type === 'resize' || event.type === 'scroll'))) {
              event = cache.event;
            }
          }

          // Calculate body and container offset and take them into account below
          if (type !== 'static') { position = container.offset(); }
          if (doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
            offset = $(document.body).offset();
          }

          // Use event coordinates for position
          position = {
            left: event.pageX - position.left + (offset && offset.left || 0),
            top: event.pageY - position.top + (offset && offset.top || 0)
          };

          // Scroll events are a pain, some browsers
          if (adjust.mouse && isScroll && mouse) {
            position.left -= (mouse.scrollX || 0) - win.scrollLeft();
            position.top -= (mouse.scrollY || 0) - win.scrollTop();
          }
        }

        // Target wasn't mouse or absolute...
        else {
          // Check if event targetting is being used
          if (target === 'event') {
            if (event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
              cache.target = $(event.target);
            }
            else if (!event.target) {
              cache.target = this.elements.target;
            }
          }
          else if (target !== 'event') {
            cache.target = $(target.jquery ? target : this.elements.target);
          }
          target = cache.target;

          // Parse the target into a jQuery object and make sure there's an element present
          target = $(target).eq(0);
          if (target.length === 0) { return this; }

          // Check if window or document is the target
          else if (target[0] === document || target[0] === window) {
            targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
            targetHeight = BROWSER.iOS ? window.innerHeight : target.height();

            if (target[0] === window) {
              position = {
                top: (viewport || target).scrollTop(),
                left: (viewport || target).scrollLeft()
              };
            }
          }

          // Check if the target is an <AREA> element
          else if (PLUGINS.imagemap && target.is('area')) {
            pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
          }

          // Check if the target is an SVG element
          else if (PLUGINS.svg && target && target[0].ownerSVGElement) {
            pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
          }

          // Otherwise use regular jQuery methods
          else {
            targetWidth = target.outerWidth(FALSE);
            targetHeight = target.outerHeight(FALSE);
            position = target.offset();
          }

          // Parse returned plugin values into proper variables
          if (pluginCalculations) {
            targetWidth = pluginCalculations.width;
            targetHeight = pluginCalculations.height;
            offset = pluginCalculations.offset;
            position = pluginCalculations.position;
          }

          // Adjust position to take into account offset parents
          position = this.reposition.offset(target, position, container);

          // Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)
          if ((BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1) ||
            (BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33) ||
            (!BROWSER.iOS && type === 'fixed')
          ) {
            position.left -= win.scrollLeft();
            position.top -= win.scrollTop();
          }

          // Adjust position relative to target
          if (!pluginCalculations || (pluginCalculations && pluginCalculations.adjustable !== FALSE)) {
            position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
            position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
          }
        }

        // Adjust position relative to tooltip
        position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
        position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);

        // Use viewport adjustment plugin if enabled
        if (PLUGINS.viewport) {
          position.adjusted = PLUGINS.viewport(
            this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight
          );

          // Apply offsets supplied by positioning plugin (if used)
          if (offset && position.adjusted.left) { position.left += offset.left; }
          if (offset && position.adjusted.top) { position.top += offset.top; }
        }

        // Viewport adjustment is disabled, set values to zero
        else { position.adjusted = { left: 0, top: 0 }; }

        // tooltipmove event
        if (!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }
        delete position.adjusted;

        // If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
        if (effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
          tooltip.css(position);
        }

        // Use custom function if provided
        else if ($.isFunction(posOptions.effect)) {
          posOptions.effect.call(tooltip, this, $.extend({}, position));
          tooltip.queue(function (next) {
            // Reset attributes to avoid cross-browser rendering bugs
            $(this).css({ opacity: '', height: '' });
            if (BROWSER.ie) { this.style.removeAttribute('filter'); }

            next();
          });
        }

        // Set positioning flag
        this.positioning = FALSE;

        return this;
      };

      // Custom (more correct for qTip!) offset calculator
      PROTOTYPE.reposition.offset = function (elem, pos, container) {
        if (!container[0]) { return pos; }

        var ownerDocument = $(elem[0].ownerDocument),
          quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',
          parent = container[0],
          scrolled, position, parentOffset, overflow;

        function scroll(e, i) {
          pos.left += i * e.scrollLeft();
          pos.top += i * e.scrollTop();
        }

        // Compensate for non-static containers offset
        do {
          if ((position = $.css(parent, 'position')) !== 'static') {
            if (position === 'fixed') {
              parentOffset = parent.getBoundingClientRect();
              scroll(ownerDocument, -1);
            }
            else {
              parentOffset = $(parent).position();
              parentOffset.left += (parseFloat($.css(parent, 'borderLeftWidth')) || 0);
              parentOffset.top += (parseFloat($.css(parent, 'borderTopWidth')) || 0);
            }

            pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);
            pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);

            // If this is the first parent element with an overflow of "scroll" or "auto", store it
            if (!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }
          }
        }
        while ((parent = parent.offsetParent));

        // Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)
        if (scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
          scroll(scrolled, 1);
        }

        return pos;
      };

      // Corner class
      var C = (CORNER = PROTOTYPE.reposition.Corner = function (corner, forceY) {
        corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();
        this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
        this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();
        this.forceY = !!forceY;

        var f = corner.charAt(0);
        this.precedance = (f === 't' || f === 'b' ? Y : X);
      }).prototype;

      C.invert = function (z, center) {
        this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
      };

      C.string = function () {
        var x = this.x, y = this.y;
        return x === y ? x : this.precedance === Y || (this.forceY && y !== 'center') ? y + ' ' + x : x + ' ' + y;
      };

      C.abbrev = function () {
        var result = this.string().split(' ');
        return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');
      };

      C.clone = function () {
        return new CORNER(this.string(), this.forceY);
      };;
      PROTOTYPE.toggle = function (state, event) {
        var cache = this.cache,
          options = this.options,
          tooltip = this.tooltip;

        // Try to prevent flickering when tooltip overlaps show element
        if (event) {
          if ((/over|enter/).test(event.type) && (/out|leave/).test(cache.event.type) &&
            options.show.target.add(event.target).length === options.show.target.length &&
            tooltip.has(event.relatedTarget).length) {
            return this;
          }

          // Cache event
          cache.event = cloneEvent(event);
        }

        // If we're currently waiting and we've just hidden... stop it
        this.waiting && !state && (this.hiddenDuringWait = TRUE);

        // Render the tooltip if showing and it isn't already
        if (!this.rendered) { return state ? this.render(1) : this; }
        else if (this.destroyed || this.disabled) { return this; }

        var type = state ? 'show' : 'hide',
          opts = this.options[type],
          otherOpts = this.options[!state ? 'show' : 'hide'],
          posOptions = this.options.position,
          contentOptions = this.options.content,
          width = this.tooltip.css('width'),
          visible = this.tooltip.is(':visible'),
          animate = state || opts.target.length === 1,
          sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,
          identicalState, allow, showEvent, delay, after;

        // Detect state if valid one isn't provided
        if ((typeof state).search('boolean|number')) { state = !visible; }

        // Check if the tooltip is in an identical state to the new would-be state
        identicalState = !tooltip.is(':animated') && visible === state && sameTarget;

        // Fire tooltip(show/hide) event and check if destroyed
        allow = !identicalState ? !!this._trigger(type, [90]) : NULL;

        // Check to make sure the tooltip wasn't destroyed in the callback
        if (this.destroyed) { return this; }

        // If the user didn't stop the method prematurely and we're showing the tooltip, focus it
        if (allow !== FALSE && state) { this.focus(event); }

        // If the state hasn't changed or the user stopped it, return early
        if (!allow || identicalState) { return this; }

        // Set ARIA hidden attribute
        $.attr(tooltip[0], 'aria-hidden', !!!state);

        // Execute state specific properties
        if (state) {
          // Store show origin coordinates
          cache.origin = cloneEvent(this.mouse);

          // Update tooltip content & title if it's a dynamic function
          if ($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }
          if ($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }

          // Cache mousemove events for positioning purposes (if not already tracking)
          if (!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
            $(document).bind('mousemove.' + NAMESPACE, this._storeMouse);
            trackingBound = TRUE;
          }

          // Update the tooltip position (set width first to prevent viewport/max-width issues)
          if (!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }
          this.reposition(event, arguments[2]);
          if (!width) { tooltip.css('width', ''); }

          // Hide other tooltips if tooltip is solo
          if (!!opts.solo) {
            (typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))
              .not(tooltip).not(opts.target).qtip('hide', $.Event('tooltipsolo'));
          }
        }
        else {
          // Clear show timer if we're hiding
          clearTimeout(this.timers.show);

          // Remove cached origin on hide
          delete cache.origin;

          // Remove mouse tracking event if not needed (all tracking qTips are hidden)
          if (trackingBound && !$(SELECTOR + '[tracking="true"]:visible', opts.solo).not(tooltip).length) {
            $(document).unbind('mousemove.' + NAMESPACE);
            trackingBound = FALSE;
          }

          // Blur the tooltip
          this.blur(event);
        }

        // Define post-animation, state specific properties
        after = $.proxy(function () {
          if (state) {
            // Prevent antialias from disappearing in IE by removing filter
            if (BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }

            // Remove overflow setting to prevent tip bugs
            tooltip.css('overflow', '');

            // Autofocus elements if enabled
            if ('string' === typeof opts.autofocus) {
              $(this.options.show.autofocus, tooltip).focus();
            }

            // If set, hide tooltip when inactive for delay period
            this.options.show.target.trigger('qtip-' + this.id + '-inactive');
          }
          else {
            // Reset CSS states
            tooltip.css({
              display: '',
              visibility: '',
              opacity: '',
              left: '',
              top: ''
            });
          }

          // tooltipvisible/tooltiphidden events
          this._trigger(state ? 'visible' : 'hidden');
        }, this);

        // If no effect type is supplied, use a simple toggle
        if (opts.effect === FALSE || animate === FALSE) {
          tooltip[type]();
          after();
        }

        // Use custom function if provided
        else if ($.isFunction(opts.effect)) {
          tooltip.stop(1, 1);
          opts.effect.call(tooltip, this);
          tooltip.queue('fx', function (n) {
            after(); n();
          });
        }

        // Use basic fade function by default
        else { tooltip.fadeTo(90, state ? 1 : 0, after); }

        // If inactive hide method is set, active it
        if (state) { opts.target.trigger('qtip-' + this.id + '-inactive'); }

        return this;
      };

      PROTOTYPE.show = function (event) { return this.toggle(TRUE, event); };

      PROTOTYPE.hide = function (event) { return this.toggle(FALSE, event); };

      ; PROTOTYPE.focus = function (event) {
        if (!this.rendered || this.destroyed) { return this; }

        var qtips = $(SELECTOR),
          tooltip = this.tooltip,
          curIndex = parseInt(tooltip[0].style.zIndex, 10),
          newIndex = QTIP.zindex + qtips.length,
          focusedElem;

        // Only update the z-index if it has changed and tooltip is not already focused
        if (!tooltip.hasClass(CLASS_FOCUS)) {
          // tooltipfocus event
          if (this._trigger('focus', [newIndex], event)) {
            // Only update z-index's if they've changed
            if (curIndex !== newIndex) {
              // Reduce our z-index's and keep them properly ordered
              qtips.each(function () {
                if (this.style.zIndex > curIndex) {
                  this.style.zIndex = this.style.zIndex - 1;
                }
              });

              // Fire blur event for focused tooltip
              qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);
            }

            // Set the new z-index
            tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
          }
        }

        return this;
      };

      PROTOTYPE.blur = function (event) {
        if (!this.rendered || this.destroyed) { return this; }

        // Set focused status to FALSE
        this.tooltip.removeClass(CLASS_FOCUS);

        // tooltipblur event
        this._trigger('blur', [this.tooltip.css('zIndex')], event);

        return this;
      };

      ; PROTOTYPE.disable = function (state) {
        if (this.destroyed) { return this; }

        // If 'toggle' is passed, toggle the current state
        if (state === 'toggle') {
          state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
        }

        // Disable if no state passed
        else if ('boolean' !== typeof state) {
          state = TRUE;
        }

        if (this.rendered) {
          this.tooltip.toggleClass(CLASS_DISABLED, state)
            .attr('aria-disabled', state);
        }

        this.disabled = !!state;

        return this;
      };

      PROTOTYPE.enable = function () { return this.disable(FALSE); };

      ; PROTOTYPE._createButton = function () {
        var self = this,
          elements = this.elements,
          tooltip = elements.tooltip,
          button = this.options.content.button,
          isString = typeof button === 'string',
          close = isString ? button : 'Close tooltip';

        if (elements.button) { elements.button.remove(); }

        // Use custom button if one was supplied by user, else use default
        if (button.jquery) {
          elements.button = button;
        }
        else {
          elements.button = $('<a />', {
            'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE + '-icon'),
            'title': close,
            'aria-label': close
          })
            .prepend(
              $('<span />', {
                'class': 'ui-icon ui-icon-close',
                'html': '&times;'
              })
            );
        }

        // Create button and setup attributes
        elements.button.appendTo(elements.titlebar || tooltip)
          .attr('role', 'button')
          .click(function (event) {
            if (!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }
            return FALSE;
          });
      };

      PROTOTYPE._updateButton = function (button) {
        // Make sure tooltip is rendered and if not, return
        if (!this.rendered) { return FALSE; }

        var elem = this.elements.button;
        if (button) { this._createButton(); }
        else { elem.remove(); }
      };

      ;// Widget class creator
      function createWidgetClass(cls) {
        return WIDGET.concat('').join(cls ? '-' + cls + ' ' : ' ');
      }

      // Widget class setter method
      PROTOTYPE._setWidget = function () {
        var on = this.options.style.widget,
          elements = this.elements,
          tooltip = elements.tooltip,
          disabled = tooltip.hasClass(CLASS_DISABLED);

        tooltip.removeClass(CLASS_DISABLED);
        CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';
        tooltip.toggleClass(CLASS_DISABLED, disabled);

        tooltip.toggleClass('ui-helper-reset ' + createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);

        if (elements.content) {
          elements.content.toggleClass(createWidgetClass('content'), on);
        }
        if (elements.titlebar) {
          elements.titlebar.toggleClass(createWidgetClass('header'), on);
        }
        if (elements.button) {
          elements.button.toggleClass(NAMESPACE + '-icon', !on);
        }
      };; function cloneEvent(event) {
        return event && {
          type: event.type,
          pageX: event.pageX,
          pageY: event.pageY,
          target: event.target,
          relatedTarget: event.relatedTarget,
          scrollX: event.scrollX || window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft,
          scrollY: event.scrollY || window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop
        } || {};
      }

      function delay(callback, duration) {
        // If tooltip has displayed, start hide timer
        if (duration > 0) {
          return setTimeout(
            $.proxy(callback, this), duration
          );
        }
        else { callback.call(this); }
      }

      function showMethod(event) {
        if (this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }

        // Clear hide timers
        clearTimeout(this.timers.show);
        clearTimeout(this.timers.hide);

        // Start show timer
        this.timers.show = delay.call(this,
          function () { this.toggle(TRUE, event); },
          this.options.show.delay
        );
      }

      function hideMethod(event) {
        if (this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }

        // Check if new target was actually the tooltip element
        var relatedTarget = $(event.relatedTarget),
          ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],
          ontoTarget = relatedTarget[0] === this.options.show.target[0];

        // Clear timers and stop animation queue
        clearTimeout(this.timers.show);
        clearTimeout(this.timers.hide);

        // Prevent hiding if tooltip is fixed and event target is the tooltip.
        // Or if mouse positioning is enabled and cursor momentarily overlaps
        if (this !== relatedTarget[0] &&
          (this.options.position.target === 'mouse' && ontoTooltip) ||
          (this.options.hide.fixed && (
            (/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))
          )) {
          try {
            event.preventDefault();
            event.stopImmediatePropagation();
          } catch (e) { }

          return;
        }

        // If tooltip has displayed, start hide timer
        this.timers.hide = delay.call(this,
          function () { this.toggle(FALSE, event); },
          this.options.hide.delay,
          this
        );
      }

      function inactiveMethod(event) {
        if (this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return FALSE; }

        // Clear timer
        clearTimeout(this.timers.inactive);

        this.timers.inactive = delay.call(this,
          function () { this.hide(event); },
          this.options.hide.inactive
        );
      }

      function repositionMethod(event) {
        if (this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }
      }

      // Store mouse coordinates
      PROTOTYPE._storeMouse = function (event) {
        (this.mouse = cloneEvent(event)).type = 'mousemove';
      };

      // Bind events
      PROTOTYPE._bind = function (targets, events, method, suffix, context) {
        var ns = '.' + this._id + (suffix ? '-' + suffix : '');
        events.length && $(targets).bind(
          (events.split ? events : events.join(ns + ' ')) + ns,
          $.proxy(method, context || this)
        );
      };
      PROTOTYPE._unbind = function (targets, suffix) {
        $(targets).unbind('.' + this._id + (suffix ? '-' + suffix : ''));
      };

      // Apply common event handlers using delegate (avoids excessive .bind calls!)
      var ns = '.' + NAMESPACE;
      function delegate(selector, events, method) {
        $(document.body).delegate(selector,
          (events.split ? events : events.join(ns + ' ')) + ns,
          function () {
            var api = QTIP.api[$.attr(this, ATTR_ID)];
            api && !api.disabled && method.apply(api, arguments);
          }
        );
      }

      $(function () {
        delegate(SELECTOR, ['mouseenter', 'mouseleave'], function (event) {
          var state = event.type === 'mouseenter',
            tooltip = $(event.currentTarget),
            target = $(event.relatedTarget || event.target),
            options = this.options;

          // On mouseenter...
          if (state) {
            // Focus the tooltip on mouseenter (z-index stacking)
            this.focus(event);

            // Clear hide timer on tooltip hover to prevent it from closing
            tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
          }

          // On mouseleave...
          else {
            // Hide when we leave the tooltip and not onto the show target (if a hide event is set)
            if (options.position.target === 'mouse' && options.hide.event &&
              options.show.target && !target.closest(options.show.target[0]).length) {
              this.hide(event);
            }
          }

          // Add hover class
          tooltip.toggleClass(CLASS_HOVER, state);
        });

        // Define events which reset the 'inactive' event handler
        delegate('[' + ATTR_ID + ']', INACTIVE_EVENTS, inactiveMethod);
      });

      // Event trigger
      PROTOTYPE._trigger = function (type, args, event) {
        var callback = $.Event('tooltip' + type);
        callback.originalEvent = (event && $.extend({}, event)) || this.cache.event || NULL;

        this.triggering = type;
        this.tooltip.trigger(callback, [this].concat(args || []));
        this.triggering = FALSE;

        return !callback.isDefaultPrevented();
      };

      PROTOTYPE._bindEvents = function (showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod) {
        // If hide and show targets are the same...
        if (hideTarget.add(showTarget).length === hideTarget.length) {
          var toggleEvents = [];

          // Filter identical show/hide events
          hideEvents = $.map(hideEvents, function (type) {
            var showIndex = $.inArray(type, showEvents);

            // Both events are identical, remove from both hide and show events
            // and append to toggleEvents
            if (showIndex > -1) {
              toggleEvents.push(showEvents.splice(showIndex, 1)[0]);
              return;
            }

            return type;
          });

          // Toggle events are special case of identical show/hide events, which happen in sequence
          toggleEvents.length && this._bind(showTarget, toggleEvents, function (event) {
            var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
            (state ? hideMethod : showMethod).call(this, event);
          });
        }

        // Apply show/hide/toggle events
        this._bind(showTarget, showEvents, showMethod);
        this._bind(hideTarget, hideEvents, hideMethod);
      };

      PROTOTYPE._assignInitialEvents = function (event) {
        var options = this.options,
          showTarget = options.show.target,
          hideTarget = options.hide.target,
          showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
          hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];

        /*
         * Make sure hoverIntent functions properly by using mouseleave as a hide event if
         * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
         */
        if (/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
          hideEvents.push('mouseleave');
        }

        /*
         * Also make sure initial mouse targetting works correctly by caching mousemove coords
         * on show targets before the tooltip has rendered. Also set onTarget when triggered to
         * keep mouse tracking working.
         */
        this._bind(showTarget, 'mousemove', function (event) {
          this._storeMouse(event);
          this.cache.onTarget = TRUE;
        });

        // Define hoverIntent function
        function hoverIntent(event) {
          // Only continue if tooltip isn't disabled
          if (this.disabled || this.destroyed) { return FALSE; }

          // Cache the event data
          this.cache.event = cloneEvent(event);
          this.cache.target = event ? $(event.target) : [undefined];

          // Start the event sequence
          clearTimeout(this.timers.show);
          this.timers.show = delay.call(this,
            function () { this.render(typeof event === 'object' || options.show.ready); },
            options.show.delay
          );
        }

        // Filter and bind events
        this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function () {
          clearTimeout(this.timers.show);
        });

        // Prerendering is enabled, create tooltip now
        if (options.show.ready || options.prerender) { hoverIntent.call(this, event); }
      };

      // Event assignment method
      PROTOTYPE._assignEvents = function () {
        var self = this,
          options = this.options,
          posOptions = options.position,

          tooltip = this.tooltip,
          showTarget = options.show.target,
          hideTarget = options.hide.target,
          containerTarget = posOptions.container,
          viewportTarget = posOptions.viewport,
          documentTarget = $(document),
          bodyTarget = $(document.body),
          windowTarget = $(window),

          showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
          hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];


        // Assign passed event callbacks
        $.each(options.events, function (name, callback) {
          self._bind(tooltip, name === 'toggle' ? ['tooltipshow', 'tooltiphide'] : ['tooltip' + name], callback, null, tooltip);
        });

        // Hide tooltips when leaving current window/frame (but not select/option elements)
        if (/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {
          this._bind(documentTarget, ['mouseout', 'blur'], function (event) {
            if (!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
              this.hide(event);
            }
          });
        }

        // Enable hide.fixed by adding appropriate class
        if (options.hide.fixed) {
          hideTarget = hideTarget.add(tooltip.addClass(CLASS_FIXED));
        }

        /*
         * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
         * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
         */
        else if (/mouse(over|enter)/i.test(options.show.event)) {
          this._bind(hideTarget, 'mouseleave', function () {
            clearTimeout(this.timers.show);
          });
        }

        // Hide tooltip on document mousedown if unfocus events are enabled
        if (('' + options.hide.event).indexOf('unfocus') > -1) {
          this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function (event) {
            var elem = $(event.target),
              enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,
              isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;

            if (elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&
              !this.target.has(elem[0]).length && enabled
            ) {
              this.hide(event);
            }
          });
        }

        // Check if the tooltip hides when inactive
        if ('number' === typeof options.hide.inactive) {
          // Bind inactive method to show target(s) as a custom event
          this._bind(showTarget, 'qtip-' + this.id + '-inactive', inactiveMethod);

          // Define events which reset the 'inactive' event handler
          this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod, '-inactive');
        }

        // Filter and bind events
        this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);

        // Mouse movement bindings
        this._bind(showTarget.add(tooltip), 'mousemove', function (event) {
          // Check if the tooltip hides when mouse is moved a certain distance
          if ('number' === typeof options.hide.distance) {
            var origin = this.cache.origin || {},
              limit = this.options.hide.distance,
              abs = Math.abs;

            // Check if the movement has gone beyond the limit, and hide it if so
            if (abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
              this.hide(event);
            }
          }

          // Cache mousemove coords on show targets
          this._storeMouse(event);
        });

        // Mouse positioning events
        if (posOptions.target === 'mouse') {
          // If mouse adjustment is on...
          if (posOptions.adjust.mouse) {
            // Apply a mouseleave event so we don't get problems with overlapping
            if (options.hide.event) {
              // Track if we're on the target or not
              this._bind(showTarget, ['mouseenter', 'mouseleave'], function (event) {
                this.cache.onTarget = event.type === 'mouseenter';
              });
            }

            // Update tooltip position on mousemove
            this._bind(documentTarget, 'mousemove', function (event) {
              // Update the tooltip position only if the tooltip is visible and adjustment is enabled
              if (this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
                this.reposition(event);
              }
            });
          }
        }

        // Adjust positions of the tooltip on window resize if enabled
        if (posOptions.adjust.resize || viewportTarget.length) {
          this._bind($.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod);
        }

        // Adjust tooltip position on scroll of the window or viewport element if present
        if (posOptions.adjust.scroll) {
          this._bind(windowTarget.add(posOptions.container), 'scroll', repositionMethod);
        }
      };

      // Un-assignment method
      PROTOTYPE._unassignEvents = function () {
        var targets = [
          this.options.show.target[0],
          this.options.hide.target[0],
          this.rendered && this.tooltip[0],
          this.options.position.container[0],
          this.options.position.viewport[0],
          this.options.position.container.closest('html')[0], // unfocus
          window,
          document
        ];

        this._unbind($([]).pushStack($.grep(targets, function (i) {
          return typeof i === 'object';
        })));
      };

      ;// Initialization method
      function init(elem, id, opts) {
        var obj, posOptions, attr, config, title,

          // Setup element references
          docBody = $(document.body),

          // Use document body instead of document element if needed
          newTarget = elem[0] === document ? docBody : elem,

          // Grab metadata from element if plugin is present
          metadata = (elem.metadata) ? elem.metadata(opts.metadata) : NULL,

          // If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
          metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

          // Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
          html5 = elem.data(opts.metadata.name || 'qtipopts');

        // If we don't get an object returned attempt to parse it manualyl without parseJSON
        try { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; } catch (e) { }

        // Merge in and sanitize metadata
        config = $.extend(TRUE, {}, QTIP.defaults, opts,
          typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
          sanitizeOptions(metadata5 || metadata));

        // Re-grab our positioning options now we've merged our metadata and set id to passed value
        posOptions = config.position;
        config.id = id;

        // Setup missing content if none is detected
        if ('boolean' === typeof config.content.text) {
          attr = elem.attr(config.content.attr);

          // Grab from supplied attribute if available
          if (config.content.attr !== FALSE && attr) { config.content.text = attr; }

          // No valid content was found, abort render
          else { return FALSE; }
        }

        // Setup target options
        if (!posOptions.container.length) { posOptions.container = docBody; }
        if (posOptions.target === FALSE) { posOptions.target = newTarget; }
        if (config.show.target === FALSE) { config.show.target = newTarget; }
        if (config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }
        if (config.hide.target === FALSE) { config.hide.target = newTarget; }
        if (config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

        // Ensure we only use a single container
        posOptions.container = posOptions.container.eq(0);

        // Convert position corner values into x and y strings
        posOptions.at = new CORNER(posOptions.at, TRUE);
        posOptions.my = new CORNER(posOptions.my);

        // Destroy previous tooltip if overwrite is enabled, or skip element if not
        if (elem.data(NAMESPACE)) {
          if (config.overwrite) {
            elem.qtip('destroy', true);
          }
          else if (config.overwrite === FALSE) {
            return FALSE;
          }
        }

        // Add has-qtip attribute
        elem.attr(ATTR_HAS, id);

        // Remove title attribute and store it if present
        if (config.suppress && (title = elem.attr('title'))) {
          // Final attr call fixes event delegatiom and IE default tooltip showing problem
          elem.removeAttr('title').attr(oldtitle, title).attr('title', '');
        }

        // Initialize the tooltip and add API reference
        obj = new QTip(elem, config, id, !!attr);
        elem.data(NAMESPACE, obj);

        // Catch remove/removeqtip events on target element to destroy redundant tooltip
        elem.one('remove.qtip-' + id + ' removeqtip.qtip-' + id, function () {
          var api; if ((api = $(this).data(NAMESPACE))) { api.destroy(true); }
        });

        return obj;
      }

      // jQuery $.fn extension method
      QTIP = $.fn.qtip = function (options, notation, newValue) {
        var command = ('' + options).toLowerCase(), // Parse command
          returned = NULL,
          args = $.makeArray(arguments).slice(1),
          event = args[args.length - 1],
          opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;

        // Check for API request
        if ((!arguments.length && opts) || command === 'api') {
          return opts;
        }

        // Execute API command if present
        else if ('string' === typeof options) {
          this.each(function () {
            var api = $.data(this, NAMESPACE);
            if (!api) { return TRUE; }

            // Cache the event if possible
            if (event && event.timeStamp) { api.cache.event = event; }

            // Check for specific API commands
            if (notation && (command === 'option' || command === 'options')) {
              if (newValue !== undefined || $.isPlainObject(notation)) {
                api.set(notation, newValue);
              }
              else {
                returned = api.get(notation);
                return FALSE;
              }
            }

            // Execute API command
            else if (api[command]) {
              api[command].apply(api, args);
            }
          });

          return returned !== NULL ? returned : this;
        }

        // No API commands. validate provided options and setup qTips
        else if ('object' === typeof options || !arguments.length) {
          // Sanitize options first
          opts = sanitizeOptions($.extend(TRUE, {}, options));

          return this.each(function (i) {
            var api, id;

            // Find next available ID, or use custom ID if provided
            id = $.isArray(opts.id) ? opts.id[i] : opts.id;
            id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;

            // Initialize the qTip and re-grab newly sanitized options
            api = init($(this), id, opts);
            if (api === FALSE) { return TRUE; }
            else { QTIP.api[id] = api; }

            // Initialize plugins
            $.each(PLUGINS, function () {
              if (this.initialize === 'initialize') { this(api); }
            });

            // Assign initial pre-render events
            api._assignInitialEvents(event);
          });
        }
      };

      // Expose class
      $.qtip = QTip;

      // Populated in render method
      QTIP.api = {};
      ; $.each({
        /* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
        attr: function (attr, val) {
          if (this.length) {
            var self = this[0],
              title = 'title',
              api = $.data(self, 'qtip');

            if (attr === title && api && 'object' === typeof api && api.options.suppress) {
              if (arguments.length < 2) {
                return $.attr(self, oldtitle);
              }

              // If qTip is rendered and title was originally used as content, update it
              if (api && api.options.content.attr === title && api.cache.attr) {
                api.set('content.text', val);
              }

              // Use the regular attr method to set, then cache the result
              return this.attr(oldtitle, val);
            }
          }

          return $.fn['attr' + replaceSuffix].apply(this, arguments);
        },

        /* Allow clone to correctly retrieve cached title attributes */
        clone: function (keepData) {
          var titles = $([]), title = 'title',

            // Clone our element using the real clone method
            elems = $.fn['clone' + replaceSuffix].apply(this, arguments);

          // Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false
          if (!keepData) {
            elems.filter('[' + oldtitle + ']').attr('title', function () {
              return $.attr(this, oldtitle);
            })
              .removeAttr(oldtitle);
          }

          return elems;
        }
      }, function (name, func) {
        if (!func || $.fn[name + replaceSuffix]) { return TRUE; }

        var old = $.fn[name + replaceSuffix] = $.fn[name];
        $.fn[name] = function () {
          return func.apply(this, arguments) || old.apply(this, arguments);
        };
      });

      /* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).
       * This snippet is taken directly from jQuery UI source code found here:
       *     https://code.jquery.com/ui/jquery-ui-git.js
       */
      if (!$.ui) {
        $['cleanData' + replaceSuffix] = $.cleanData;
        $.cleanData = function (elems) {
          for (var i = 0, elem; (elem = $(elems[i])).length; i++) {
            if (elem.attr(ATTR_HAS)) {
              try { elem.triggerHandler('removeqtip'); }
              catch (e) { }
            }
          }
          $['cleanData' + replaceSuffix].apply(this, arguments);
        };
      }

      ;// qTip version
      QTIP.version = '2.2.0';

      // Base ID for all qTips
      QTIP.nextid = 0;

      // Inactive events array
      QTIP.inactiveEvents = INACTIVE_EVENTS;

      // Base z-index for all qTips
      QTIP.zindex = 15000;

      // Define configuration defaults
      QTIP.defaults = {
        prerender: FALSE,
        id: FALSE,
        overwrite: TRUE,
        suppress: TRUE,
        content: {
          text: TRUE,
          attr: 'title',
          title: FALSE,
          button: FALSE
        },
        position: {
          my: 'top left',
          at: 'bottom right',
          target: FALSE,
          container: FALSE,
          viewport: FALSE,
          adjust: {
            x: 0, y: 0,
            mouse: TRUE,
            scroll: TRUE,
            resize: TRUE,
            method: 'flipinvert flipinvert'
          },
          effect: function (api, pos, viewport) {
            $(this).animate(pos, {
              duration: 200,
              queue: FALSE
            });
          }
        },
        show: {
          target: FALSE,
          event: 'mouseenter',
          effect: TRUE,
          delay: 90,
          solo: FALSE,
          ready: FALSE,
          autofocus: FALSE
        },
        hide: {
          target: FALSE,
          event: 'mouseleave',
          effect: TRUE,
          delay: 0,
          fixed: FALSE,
          inactive: FALSE,
          leave: 'window',
          distance: FALSE
        },
        style: {
          classes: '',
          widget: FALSE,
          width: FALSE,
          height: FALSE,
          def: TRUE
        },
        events: {
          render: NULL,
          move: NULL,
          show: NULL,
          hide: NULL,
          toggle: NULL,
          visible: NULL,
          hidden: NULL,
          focus: NULL,
          blur: NULL
        }
      };

      ; var TIP,

        // .bind()/.on() namespace
        TIPNS = '.qtip-tip',

        // Common CSS strings
        MARGIN = 'margin',
        BORDER = 'border',
        COLOR = 'color',
        BG_COLOR = 'background-color',
        TRANSPARENT = 'transparent',
        IMPORTANT = ' !important',

        // Check if the browser supports <canvas/> elements
        HASCANVAS = !!document.createElement('canvas').getContext,

        // Invalid colour values used in parseColours()
        INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;

      // Camel-case method, taken from jQuery source
      // https://code.jquery.com/jquery-1.8.0.js
      function camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

      /*
       * Modified from Modernizr's testPropsAll()
       * http://modernizr.com/downloads/modernizr-latest.js
       */
      var cssProps = {}, cssPrefixes = ["Webkit", "O", "Moz", "ms"];
      function vendorCss(elem, prop) {
        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
          props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),
          cur, val, i = 0;

        // If the property has already been mapped...
        if (cssProps[prop]) { return elem.css(cssProps[prop]); }

        while ((cur = props[i++])) {
          if ((val = elem.css(cur)) !== undefined) {
            return cssProps[prop] = cur, val;
          }
        }
      }

      // Parse a given elements CSS property into an int
      function intCss(elem, prop) {
        return Math.ceil(parseFloat(vendorCss(elem, prop)));
      }


      // VML creation (for IE only)
      if (!HASCANVAS) {
        var createVML = function (tag, props, style) {
          return '<qtipvml:' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" ' + (props || '') +
            ' style="behavior: url(#default#VML); ' + (style || '') + '" />';
        };
      }

      // Canvas only definitions
      else {
        var PIXEL_RATIO = window.devicePixelRatio || 1,
          BACKING_STORE_RATIO = (function () {
            var context = document.createElement('canvas').getContext('2d');
            return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio ||
              context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
          }()),
          SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
      }


      function Tip(qtip, options) {
        this._ns = 'tip';
        this.options = options;
        this.offset = options.offset;
        this.size = [options.width, options.height];

        // Initialize
        this.init((this.qtip = qtip));
      }

      $.extend(Tip.prototype, {
        init: function (qtip) {
          var context, tip;

          // Create tip element and prepend to the tooltip
          tip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE + '-tip' }).prependTo(qtip.tooltip);

          // Create tip drawing element(s)
          if (HASCANVAS) {
            // save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!
            context = $('<canvas />').appendTo(this.element)[0].getContext('2d');

            // Setup constant parameters
            context.lineJoin = 'miter';
            context.miterLimit = 100000;
            context.save();
          }
          else {
            context = createVML('shape', 'coordorigin="0,0"', 'position:absolute;');
            this.element.html(context + context);

            // Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML
            qtip._bind($('*', tip).add(tip), ['click', 'mousedown'], function (event) { event.stopPropagation(); }, this._ns);
          }

          // Bind update events
          qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);

          // Create it
          this.create();
        },

        _swapDimensions: function () {
          this.size[0] = this.options.height;
          this.size[1] = this.options.width;
        },
        _resetDimensions: function () {
          this.size[0] = this.options.width;
          this.size[1] = this.options.height;
        },

        _useTitle: function (corner) {
          var titlebar = this.qtip.elements.titlebar;
          return titlebar && (
            corner.y === TOP || (corner.y === CENTER && this.element.position().top + (this.size[1] / 2) + this.options.offset < titlebar.outerHeight(TRUE))
          );
        },

        _parseCorner: function (corner) {
          var my = this.qtip.options.position.my;

          // Detect corner and mimic properties
          if (corner === FALSE || my === FALSE) {
            corner = FALSE;
          }
          else if (corner === TRUE) {
            corner = new CORNER(my.string());
          }
          else if (!corner.string) {
            corner = new CORNER(corner);
            corner.fixed = TRUE;
          }

          return corner;
        },

        _parseWidth: function (corner, side, use) {
          var elements = this.qtip.elements,
            prop = BORDER + camel(side) + 'Width';

          return (use ? intCss(use, prop) : (
            intCss(elements.content, prop) ||
            intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
            intCss(elements.tooltip, prop)
          )) || 0;
        },

        _parseRadius: function (corner) {
          var elements = this.qtip.elements,
            prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';

          return BROWSER.ie < 9 ? 0 :
            intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
            intCss(elements.tooltip, prop) || 0;
        },

        _invalidColour: function (elem, prop, compare) {
          var val = elem.css(prop);
          return !val || (compare && val === elem.css(compare)) || INVALID.test(val) ? FALSE : val;
        },

        _parseColours: function (corner) {
          var elements = this.qtip.elements,
            tip = this.element.css('cssText', ''),
            borderSide = BORDER + camel(corner[corner.precedance]) + camel(COLOR),
            colorElem = this._useTitle(corner) && elements.titlebar || elements.content,
            css = this._invalidColour, color = [];

          // Attempt to detect the background colour from various elements, left-to-right precedance
          color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) ||
            css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);

          // Attempt to detect the correct border side colour from various elements, left-to-right precedance
          color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) ||
            css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);

          // Reset background and border colours
          $('*', tip).add(tip).css('cssText', BG_COLOR + ':' + TRANSPARENT + IMPORTANT + ';' + BORDER + ':0' + IMPORTANT + ';');

          return color;
        },

        _calculateSize: function (corner) {
          var y = corner.precedance === Y,
            width = this.options['width'],
            height = this.options['height'],
            isCenter = corner.abbrev() === 'c',
            base = (y ? width : height) * (isCenter ? 0.5 : 1),
            pow = Math.pow,
            round = Math.round,
            bigHyp, ratio, result,

            smallHyp = Math.sqrt(pow(base, 2) + pow(height, 2)),
            hyp = [(this.border / base) * smallHyp, (this.border / height) * smallHyp];

          hyp[2] = Math.sqrt(pow(hyp[0], 2) - pow(this.border, 2));
          hyp[3] = Math.sqrt(pow(hyp[1], 2) - pow(this.border, 2));

          bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
          ratio = bigHyp / smallHyp;

          result = [round(ratio * width), round(ratio * height)];
          return y ? result : result.reverse();
        },

        // Tip coordinates calculator
        _calculateTip: function (corner, size, scale) {
          scale = scale || 1;
          size = size || this.size;

          var width = size[0] * scale,
            height = size[1] * scale,
            width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),

            // Define tip coordinates in terms of height and width values
            tips = {
              br: [0, 0, width, height, width, 0],
              bl: [0, 0, width, 0, 0, height],
              tr: [0, height, width, 0, width, height],
              tl: [0, 0, 0, height, width, height],
              tc: [0, height, width2, 0, width, height],
              bc: [0, 0, width, 0, width2, height],
              rc: [0, 0, width, height2, 0, height],
              lc: [width, 0, width, height, 0, height2]
            };

          // Set common side shapes
          tips.lt = tips.br; tips.rt = tips.bl;
          tips.lb = tips.tr; tips.rb = tips.tl;

          return tips[corner.abbrev()];
        },

        // Tip coordinates drawer (canvas)
        _drawCoords: function (context, coords) {
          context.beginPath();
          context.moveTo(coords[0], coords[1]);
          context.lineTo(coords[2], coords[3]);
          context.lineTo(coords[4], coords[5]);
          context.closePath();
        },

        create: function () {
          // Determine tip corner
          var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);

          // If we have a tip corner...
          if ((this.enabled = !!this.corner && this.corner.abbrev() !== 'c')) {
            // Cache it
            this.qtip.cache.corner = c.clone();

            // Create it
            this.update();
          }

          // Toggle tip element
          this.element.toggle(this.enabled);

          return this.corner;
        },

        update: function (corner, position) {
          if (!this.enabled) { return this; }

          var elements = this.qtip.elements,
            tip = this.element,
            inner = tip.children(),
            options = this.options,
            curSize = this.size,
            mimic = options.mimic,
            round = Math.round,
            color, precedance, context,
            coords, bigCoords, translate, newSize, border, BACKING_STORE_RATIO;

          // Re-determine tip if not already set
          if (!corner) { corner = this.qtip.cache.corner || this.corner; }

          // Use corner property if we detect an invalid mimic value
          if (mimic === FALSE) { mimic = corner; }

          // Otherwise inherit mimic properties from the corner object as necessary
          else {
            mimic = new CORNER(mimic);
            mimic.precedance = corner.precedance;

            if (mimic.x === 'inherit') { mimic.x = corner.x; }
            else if (mimic.y === 'inherit') { mimic.y = corner.y; }
            else if (mimic.x === mimic.y) {
              mimic[corner.precedance] = corner[corner.precedance];
            }
          }
          precedance = mimic.precedance;

          // Ensure the tip width.height are relative to the tip position
          if (corner.precedance === X) { this._swapDimensions(); }
          else { this._resetDimensions(); }

          // Update our colours
          color = this.color = this._parseColours(corner);

          // Detect border width, taking into account colours
          if (color[1] !== TRANSPARENT) {
            // Grab border width
            border = this.border = this._parseWidth(corner, corner[corner.precedance]);

            // If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)
            if (options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }

            // Set border width (use detected border width if options.border is true)
            this.border = border = options.border !== TRUE ? options.border : border;
          }

          // Border colour was invalid, set border to zero
          else { this.border = border = 0; }

          // Determine tip size
          newSize = this.size = this._calculateSize(corner);
          tip.css({
            width: newSize[0],
            height: newSize[1],
            lineHeight: newSize[1] + 'px'
          });

          // Calculate tip translation
          if (corner.precedance === Y) {
            translate = [
              round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),
              round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)
            ];
          }
          else {
            translate = [
              round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),
              round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)
            ];
          }

          // Canvas drawing implementation
          if (HASCANVAS) {
            // Grab canvas context and clear/save it
            context = inner[0].getContext('2d');
            context.restore(); context.save();
            context.clearRect(0, 0, 6000, 6000);

            // Calculate coordinates
            coords = this._calculateTip(mimic, curSize, SCALE);
            bigCoords = this._calculateTip(mimic, this.size, SCALE);

            // Set the canvas size using calculated size
            inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
            inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);

            // Draw the outer-stroke tip
            this._drawCoords(context, bigCoords);
            context.fillStyle = color[1];
            context.fill();

            // Draw the actual tip
            context.translate(translate[0] * SCALE, translate[1] * SCALE);
            this._drawCoords(context, coords);
            context.fillStyle = color[0];
            context.fill();
          }

          // VML (IE Proprietary implementation)
          else {
            // Calculate coordinates
            coords = this._calculateTip(mimic);

            // Setup coordinates string
            coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +
              ',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';

            // Setup VML-specific offset for pixel-perfection
            translate[2] = border && /^(r|b)/i.test(corner.string()) ?
              BROWSER.ie === 8 ? 2 : 1 : 0;

            // Set initial CSS
            inner.css({
              coordsize: (newSize[0] + border) + ' ' + (newSize[1] + border),
              antialias: '' + (mimic.string().indexOf(CENTER) > -1),
              left: translate[0] - (translate[2] * Number(precedance === X)),
              top: translate[1] - (translate[2] * Number(precedance === Y)),
              width: newSize[0] + border,
              height: newSize[1] + border
            })
              .each(function (i) {
                var $this = $(this);

                // Set shape specific attributes
                $this[$this.prop ? 'prop' : 'attr']({
                  coordsize: (newSize[0] + border) + ' ' + (newSize[1] + border),
                  path: coords,
                  fillcolor: color[0],
                  filled: !!i,
                  stroked: !i
                })
                  .toggle(!!(border || i));

                // Check if border is enabled and add stroke element
                !i && $this.html(createVML(
                  'stroke', 'weight="' + (border * 2) + 'px" color="' + color[1] + '" miterlimit="1000" joinstyle="miter"'
                ));
              });
          }

          // Opera bug #357 - Incorrect tip position
          // https://github.com/Craga89/qTip2/issues/367
          window.opera && setTimeout(function () {
            elements.tip.css({
              display: 'inline-block',
              visibility: 'visible'
            });
          }, 1);

          // Position if needed
          if (position !== FALSE) { this.calculate(corner, newSize); }
        },

        calculate: function (corner, size) {
          if (!this.enabled) { return FALSE; }

          var self = this,
            elements = this.qtip.elements,
            tip = this.element,
            userOffset = this.options.offset,
            isWidget = elements.tooltip.hasClass('ui-widget'),
            position = {},
            precedance, corners;

          // Inherit corner if not provided
          corner = corner || this.corner;
          precedance = corner.precedance;

          // Determine which tip dimension to use for adjustment
          size = size || this._calculateSize(corner);

          // Setup corners and offset array
          corners = [corner.x, corner.y];
          if (precedance === X) { corners.reverse(); }

          // Calculate tip position
          $.each(corners, function (i, side) {
            var b, bc, br;

            if (side === CENTER) {
              b = precedance === Y ? LEFT : TOP;
              position[b] = '50%';
              position[MARGIN + '-' + b] = -Math.round(size[precedance === Y ? 0 : 1] / 2) + userOffset;
            }
            else {
              b = self._parseWidth(corner, side, elements.tooltip);
              bc = self._parseWidth(corner, side, elements.content);
              br = self._parseRadius(corner);

              position[side] = Math.max(-self.border, i ? bc : (userOffset + (br > b ? br : -b)));
            }
          });

          // Adjust for tip size
          position[corner[precedance]] -= size[precedance === X ? 0 : 1];

          // Set and return new position
          tip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);
          return position;
        },

        reposition: function (event, api, pos, viewport) {
          if (!this.enabled) { return; }

          var cache = api.cache,
            newCorner = this.corner.clone(),
            adjust = pos.adjusted,
            method = api.options.position.adjust.method.split(' '),
            horizontal = method[0],
            vertical = method[1] || method[0],
            shift = { left: FALSE, top: FALSE, x: 0, y: 0 },
            offset, css = {}, props;

          function shiftflip(direction, precedance, popposite, side, opposite) {
            // Horizontal - Shift or flip method
            if (direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
              newCorner.precedance = newCorner.precedance === X ? Y : X;
            }
            else if (direction !== SHIFT && adjust[side]) {
              newCorner[precedance] = newCorner[precedance] === CENTER ?
                (adjust[side] > 0 ? side : opposite) : (newCorner[precedance] === side ? opposite : side);
            }
          }

          function shiftonly(xy, side, opposite) {
            if (newCorner[xy] === CENTER) {
              css[MARGIN + '-' + side] = shift[xy] = offset[MARGIN + '-' + side] - adjust[side];
            }
            else {
              props = offset[opposite] !== undefined ?
                [adjust[side], -offset[side]] : [-adjust[side], offset[side]];

              if ((shift[xy] = Math.max(props[0], props[1])) > props[0]) {
                pos[side] -= adjust[side];
                shift[side] = FALSE;
              }

              css[offset[opposite] !== undefined ? opposite : side] = shift[xy];
            }
          }

          // If our tip position isn't fixed e.g. doesn't adjust with viewport...
          if (this.corner.fixed !== TRUE) {
            // Perform shift/flip adjustments
            shiftflip(horizontal, X, Y, LEFT, RIGHT);
            shiftflip(vertical, Y, X, TOP, BOTTOM);

            // Update and redraw the tip if needed (check cached details of last drawn tip)
            if (newCorner.string() !== cache.corner.string() && (cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left)) {
              this.update(newCorner, FALSE);
            }
          }

          // Setup tip offset properties
          offset = this.calculate(newCorner);

          // Readjust offset object to make it left/top
          if (offset.right !== undefined) { offset.left = -offset.right; }
          if (offset.bottom !== undefined) { offset.top = -offset.bottom; }
          offset.user = this.offset;

          // Perform shift adjustments
          if (shift.left = (horizontal === SHIFT && !!adjust.left)) { shiftonly(X, LEFT, RIGHT); }
          if (shift.top = (vertical === SHIFT && !!adjust.top)) { shiftonly(Y, TOP, BOTTOM); }

          /*
           * If the tip is adjusted in both dimensions, or in a
           * direction that would cause it to be anywhere but the
           * outer border, hide it!
           */
          this.element.css(css).toggle(
            !((shift.x && shift.y) || (newCorner.x === CENTER && shift.y) || (newCorner.y === CENTER && shift.x))
          );

          // Adjust position to accomodate tip dimensions
          pos.left -= offset.left.charAt ? offset.user :
            horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
          pos.top -= offset.top.charAt ? offset.user :
            vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;

          // Cache details
          cache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;
          cache.corner = newCorner.clone();
        },

        destroy: function () {
          // Unbind events
          this.qtip._unbind(this.qtip.tooltip, this._ns);

          // Remove the tip element(s)
          if (this.qtip.elements.tip) {
            this.qtip.elements.tip.find('*')
              .remove().end().remove();
          }
        }
      });

      TIP = PLUGINS.tip = function (api) {
        return new Tip(api, api.options.style.tip);
      };

      // Initialize tip on render
      TIP.initialize = 'render';

      // Setup plugin sanitization options
      TIP.sanitize = function (options) {
        if (options.style && 'tip' in options.style) {
          var opts = options.style.tip;
          if (typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }
          if (!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }
        }
      };

      // Add new option checks for the plugin
      CHECKS.tip = {
        '^position.my|style.tip.(corner|mimic|border)$': function () {
          // Make sure a tip can be drawn
          this.create();

          // Reposition the tooltip
          this.qtip.reposition();
        },
        '^style.tip.(height|width)$': function (obj) {
          // Re-set dimensions and redraw the tip
          this.size = [obj.width, obj.height];
          this.update();

          // Reposition the tooltip
          this.qtip.reposition();
        },
        '^content.title|style.(classes|widget)$': function () {
          this.update();
        }
      };

      // Extend original qTip defaults
      $.extend(TRUE, QTIP.defaults, {
        style: {
          tip: {
            corner: TRUE,
            mimic: FALSE,
            width: 6,
            height: 6,
            border: TRUE,
            offset: 0
          }
        }
      });

      ;
    }));
}(window, document));



/***
* Generic Tooltip
*
* Align{default: "left"} :  add "data-tooltip-align" ( "right" , "left", "center" )
* Open{default: "mouseenter"}:  add "data-tooltip-show" ( "mouseenter" , "click")
* Hide{default: "mouseleave"}: add "data-tooltip-hide" ("mouseleave", "unfocus")
* Adjust the position of tooltip {default: "0,0"}: add "data-tooltip-adjust" (ex:"-5,-10" == x,y)
* Type: add data-tooltip-contenttype ("text","ajax","dom")
*
* Example:
* Load AJAX content to put in tooltip
* <a href='#' data-enhance="genericTooltip" data-tooltip-show="mouseenter" data-tooltip-ajaxurl="ajax.html" data-tooltip-contenttype="ajax">Example with ajax</a>
*
* Tooltip with simple text
* <a href='#' data-enhance="genericTooltip" data-tooltip-show="click" data-tooltip-hide="unfocus" data-tooltip-contenttype="text" data-tooltip-text="Lorem ipsum dolor sit amet, consectetur adipiscing elit">Example with text</a>
*
* Tooltip with DOM Element
* <a href='#' data-enhance="genericTooltip" data-tooltip-show="click" data-tooltip-hide="unfocus" data-tooltip-contenttype="dom" data-tooltip-content=".tooltipExampleMarkdown">Example with markdown</a><br/>
*/


define('uiTools/tooltips', [
  'jquery',
  'UTILS',
  'qtip2'
], function ($, Utils) {

  var eventEmitter;

  function TooltipOptions() { }
  TooltipOptions.prototype.showEvent = "mousedown";
  TooltipOptions.prototype.hideEvent = "mouseleave";
  TooltipOptions.prototype.viewport = $(window);
  TooltipOptions.prototype.options = {
    position: {
      my: 'bottom center',  // Position my top left...
      at: 'top center', // at the bottom right of...
      effect: false,
      viewport: $(window),
      adjust: {
        method: 'flip flip'
      }
    },
    show: "",
    hide: ""
  };

  TooltipOptions.prototype.getOverrideOptions = function (opts) {


    var optsAlign = opts.align;
    if (Utils.getPlatform() === "mobile") {
      optsAlign = opts.align || "left";
    } else {
      optsAlign = opts.align || "center";
    }

    var optsAdjust = opts.adjust || this.adjust,
      optsShowEvent = opts.show || this.show,
      optsHideEvent = opts.hide || this.hide,
      newOpts,
      // Override Position Options
      currentPosition = { target: opts.target, my: "bottom" + optsAlign, at: 'top' + optsAlign, adjust: optsAdjust },
      position = $.extend(this.options.position, currentPosition),
      // Override Show Options
      currentShow = { event: optsShowEvent },
      show = $.extend(this.options.show, currentShow),
      // Override Hide Options
      currentHide = { event: optsHideEvent, target: opts.target },
      hide = $.extend(this.options.hide, currentHide);

    return { position: position, show: show, hide: hide };
  };


  function TooltipDomOptions() { }
  TooltipDomOptions.prototype = new TooltipOptions();
  TooltipDomOptions.prototype.getQtipOptions = function (opts) {

    var overrideOptions = this.getOverrideOptions(opts),
      newOpts;

    newOpts = {
      content: opts.contentHtml,
      position: overrideOptions.position,
      show: overrideOptions.show,
      hide: overrideOptions.hide
    };

    $.extend(this.options, newOpts);

    return this.options;
  };

  function TooltipAjaxOptions() { }
  TooltipAjaxOptions.prototype = new TooltipOptions();
  TooltipAjaxOptions.prototype.getQtipOptions = function (opts) {

    var overrideOptions = this.getOverrideOptions(opts),
      newOpts = {};

    // TODO :: New to be recoded with the new options structure of qtips2 2.20
    /* newOpts = {
         content: {
             button: 'close 2',
             text:  function(event, api) {
                 $.ajax({ url: opts.contentUrl })
                     .done(function(html) {
                         var $tooltip = $(html).find("#click-tooltip").parent();
                         api.set('content.text', $tooltip.html());
                     })
                     .fail(function(xhr, status, error) {
                         console.log('content.text', status + ': ' + error)
                     });

                 return ' <div class="preloader"></div>';
             }
         },
         position: overrideOptions.position,
         show: overrideOptions.show,
         hide: overrideOptions.hide
     };*/


    $.extend(this.options, newOpts);

    console.log();

    return this.options;
  };

  function TooltipTextOptions() { }
  TooltipTextOptions.prototype = new TooltipOptions();
  TooltipTextOptions.prototype.getQtipOptions = function (opts) {
    var overrideOptions = this.getOverrideOptions(opts),
      newOpts;

    newOpts = {
      content: {
        text: overrideOptions.contentText
      },
      position: overrideOptions.position,
      show: overrideOptions.show
    };

    $.extend(this.options, newOpts);

    return this.options;
  };

  /******************************************* INITIALIZATION *****************************************/

  var tooltips = {
    init: function (context) {
      var $tooltips = $(context).find(".info-tooltip");

      $($tooltips).each(function (index, el) {
        new ToolTipInstance(el);
      });

    }
  };

  function ToolTipInstance(el) {

    var $this = $(el),
      isTouch = $("html").hasClass("touch"),
      tooltipType = $this.data("tooltipContenttype"),
      tooltipObj,
      tooltipOptions,
      tooltipAdjust = $this.data("tooltipAdjust") ? $this.data("tooltipAdjust").split(",") : [0, 0],
      tooltipAdjust = { x: Number(tooltipAdjust[0]), y: Number(tooltipAdjust[1]) },
      tooltipShow = isTouch ? "click" : $this.data("tooltipShow"),
      tooltipHide = isTouch ? "mouseleave" : $this.data("tooltipHide");

    console.log("   ");
    console.log("   ");
    console.log("   ");
    console.log("tooltipType", isTouch);


    switch (tooltipType) {
      case "ajax":
        tooltipObj = TooltipAjaxOptions;
        tooltipOptions = {
          show: tooltipShow,
          hide: tooltipHide,
          contentUrl: $this.data("tooltip-ajaxurl"),
          target: $this,
          align: $this.data("tooltip-align"),
          adjust: tooltipAdjust
        };

        break;

      case "dom":
        tooltipObj = TooltipDomOptions;
        console.log();
        console.log($this.data("tooltipHide"));
        tooltipOptions = {
          show: tooltipShow,
          hide: tooltipHide,
          contentHtml: $this.find($this.data("tooltip-content")),
          target: $this,
          align: $this.data("tooltip-align"),
          adjust: tooltipAdjust
        };
        break;

      case "text":
      default:
        tooltipObj = TooltipTextOptions;
        tooltipOptions = {
          show: tooltipShow,
          hide: tooltipHide,
          content: $this.data("tooltip-text"),
          target: $this,
          align: $this.data("tooltip-align"),
          adjust: tooltipAdjust
        };
        break;

    }

    var currOptions = new tooltipObj(),
      qTipOptions = currOptions.getQtipOptions(tooltipOptions);

    if (tooltipShow == "click" || tooltipShow == "mousedown") {

      $this.on("click", function (evt) {
        evt.preventDefault();
      });
    }

    qTipOptions = $.extend(qTipOptions, {
      events: {
        show: function (event, api) {
          $this.addClass('tooltipShown');
        },
        hide: function (event, api) {
          $this.removeClass('tooltipShown');
        }
      }
    }),
      $this.qtip(qTipOptions);

    $this.on("keyup", function (evt) {
      if (evt.keyCode === 13) {
        if ($this.hasClass('tooltipShown')) {
          $this.qtip('hide');
        } else {
          $this.qtip('show');
        }
      } else if (evt.keyCode === 27) {
        if ($this.hasClass('tooltipShown')) {
          $this.qtip('hide')
        }
      }
    });

    $this.on("blur", function (evt) {
      $this.qtip('hide')
    });


  }

  return tooltips;
});

define('i18n/chosen', [], function () {


  var i18n = ADM.i18n.chosen;

  var Choseni18n = {
    "no_results_text": i18n.noResultMatch
  };

  return Choseni18n;
});
/*
* This is based on ideas from a technique described by Alen Grakalic in
* http://cssglobe.com/post/8802/custom-styling-of-the-select-elements
*/
(function ($) {
  $.fn.customSelect = function (settings) {
    var config = {
      replacedClass: 'replaced custom', // Class name added to replaced selects
      customSelectClass: 'custom-select', // Class name of the (outer) inserted span element
      activeClass: 'active', // Class name assigned to the fake select when the real select is in hover/focus state
      openedClass: 'openend',
      wrapperElement: '<div class="customselect-container" />', // Element that wraps the select to enable positioning
      theme: 'plain',
      onCreateCompleted: null,
      onChangeCompleted: null,
      onEnter: null
    };
    if (settings) {
      $.extend(config, settings);
    }
    this.each(function () {


      var select = $(this);
      select.addClass(config.replacedClass);
      config.wrapperElement = $(config.wrapperElement).addClass(config.theme);
      select.wrap(config.wrapperElement);




      var update = function () {
        val = $('option:selected', this).text();
        value = $('option:selected', this).val();
        $(this).val(value);
        span.find('.label').text(val);

        if (config.onCreateCompleted !== null) {
          config.onChangeCompleted(span);
        }

      };
      // Update the fake select when the real select’s value changes

      select.change(update);
      select.on("update:customselect", update);


      /* Gecko browsers don't trigger onchange until the select closes, so
       * changes made by using the arrow keys aren't reflected in the fake select.
       * See https://bugzilla.mozilla.org/show_bug.cgi?id=126379.
       * IE normally triggers onchange when you use the arrow keys to change the selected
       * option of a closed select menu. Unfortunately jQuery doesn’t seem able to bind to this.
       * As a workaround the text is also updated when any key is pressed and then released
       * in all browsers, not just in Firefox.
       */
      select.keyup(update);
      /* Create and insert the spans that will be styled as the fake select
       * To prevent (modern) screen readers from announcing the fake select in addition to the real one,
       * aria-hidden is used to hide it.
       */
      // Three nested spans? The only way I could get text-overflow:ellipsis to work in IE7.





      var span = $('<span class="' + config.customSelectClass + '" aria-hidden="true"><span class="label">' + $('option:selected', this).text() + '</span><span class="control"><span class="icon"></span></span></span>');
      //span.width(select.outerWidth());

      //adjust the replacement size to fit the select behind it
      select.after(span);

      if (config.onCreateCompleted !== null) {
        config.onCreateCompleted(span);
      }



      // Change class names to enable styling of hover/focus states
      select.bind({
        mouseenter: function () {
          if (config.onEnter !== null) {
            config.onEnter();
            span.addClass(config.activeClass);
          } else {
            span.addClass(config.activeClass);
          }
        },
        mouseleave: function () {
          span.removeClass(config.activeClass);
        },
        focus: function () {
          span.addClass(config.activeClass);
        },
        blur: function () {
          span.removeClass(config.activeClass);
        }
      });
    });
  };
})(jQuery);
define("customSelect", ["jquery"], function () { });

// Chosen, a Select Box Enhancer for jQuery and Prototype
// by Patrick Filler for Harvest, http://getharvest.com
//
// Version 1.0.0
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// This file is generated by `grunt build`, do not edit it by hand.
(function () {
  var $, AbstractChosen, Chosen, SelectParser, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function (child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SelectParser = (function () {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function (child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function (group) {
      var group_position, option, _i, _len, _ref, _results;

      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: this.escapeExpression(group.label),
        children: 0,
        disabled: group.disabled
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function (option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    SelectParser.prototype.escapeExpression = function (text) {
      var map, unsafe_chars;

      if ((text == null) || text === false) {
        return "";
      }
      if (!/[\&\<\>\"\'\`]/.test(text)) {
        return text;
      }
      map = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      unsafe_chars = /&(?!\w+;)|[\<\>\"\'\`]/g;
      return text.replace(unsafe_chars, function (chr) {
        return map[chr] || "&amp;";
      });
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function (select) {
    var child, parser, _i, _len, _ref;

    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  AbstractChosen = (function () {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      if (!AbstractChosen.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
    }

    AbstractChosen.prototype.set_default_values = function () {
      var _this = this;

      this.click_test_action = function (evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function (evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.result_single_selected = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.group_search = this.options.group_search != null ? this.options.group_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      this.inherit_select_classes = this.options.inherit_select_classes || false;
      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;
      return this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;
    };

    AbstractChosen.prototype.set_default_text = function () {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
    };

    AbstractChosen.prototype.mouse_enter = function () {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function () {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function (evt) {
      var _this = this;

      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function () {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function (evt) {
      var _this = this;

      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function () {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.results_option_build = function (options) {
      var content, data, _i, _len, _ref;

      content = '';
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else {
          content += this.result_add_option(data);
        }
        if (options != null ? options.first : void 0) {
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.single_set_selected_text(data.text);
          }
        }
      }
      return content;
    };

    AbstractChosen.prototype.result_add_option = function (option) {
      var classes, style;

      if (!option.search_match) {
        return '';
      }
      if (!this.include_option_in_results(option)) {
        return '';
      }
      classes = [];
      if (!option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("active-result");
      }
      if (option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("disabled-result");
      }
      if (option.selected) {
        classes.push("result-selected");
      }
      if (option.group_array_index != null) {
        classes.push("group-option");
      }
      if (option.classes !== "") {
        classes.push(option.classes);
      }
      style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
      return "<li class=\"" + (classes.join(' ')) + "\"" + style + " data-option-array-index=\"" + option.array_index + "\">" + option.search_text + "</li>";
    };

    AbstractChosen.prototype.result_add_group = function (group) {
      if (!(group.search_match || group.group_match)) {
        return '';
      }
      if (!(group.active_options > 0)) {
        return '';
      }
      return "<li class=\"group-result\">" + group.search_text + "</li>";
    };

    AbstractChosen.prototype.results_update_field = function () {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.result_single_selected = null;
      this.results_build();
      if (this.results_showing) {
        return this.winnow_results();
      }
    };

    AbstractChosen.prototype.results_toggle = function () {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function (evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.winnow_results = function () {
      var escapedSearchText, option, regex, regexAnchor, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;

      this.no_results_clear();
      results = 0;
      searchText = this.get_search_text();
      escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      regexAnchor = this.search_contains ? "" : "^";
      regex = new RegExp(regexAnchor + escapedSearchText, 'i');
      zregex = new RegExp(escapedSearchText, 'i');
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        option.search_match = false;
        results_group = null;
        if (this.include_option_in_results(option)) {
          if (option.group) {
            option.group_match = false;
            option.active_options = 0;
          }
          if ((option.group_array_index != null) && this.results_data[option.group_array_index]) {
            results_group = this.results_data[option.group_array_index];
            if (results_group.active_options === 0 && results_group.search_match) {
              results += 1;
            }
            results_group.active_options += 1;
          }
          if (!(option.group && !this.group_search)) {
            option.search_text = option.group ? option.label : option.html;
            option.search_match = this.search_string_match(option.search_text, regex);
            if (option.search_match && !option.group) {
              results += 1;
            }
            if (option.search_match) {
              if (searchText.length) {
                startpos = option.search_text.search(zregex);
                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);
                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              }
              if (results_group != null) {
                results_group.group_match = true;
              }
            } else if ((option.group_array_index != null) && this.results_data[option.group_array_index].search_match) {
              option.search_match = true;
            }
          }
        }
      }
      this.result_clear_highlight();
      if (results < 1 && searchText.length) {
        this.update_results_content("");
        return this.no_results(searchText);
      } else {
        this.update_results_content(this.results_option_build());
        return this.winnow_results_set_highlight();
      }
    };

    AbstractChosen.prototype.search_string_match = function (search_string, regex) {
      var part, parts, _i, _len;

      if (regex.test(search_string)) {
        return true;
      } else if (this.enable_split_word_search && (search_string.indexOf(" ") >= 0 || search_string.indexOf("[") === 0)) {
        parts = search_string.replace(/\[|\]/g, "").split(" ");
        if (parts.length) {
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (regex.test(part)) {
              return true;
            }
          }
        }
      }
    };

    AbstractChosen.prototype.choices_count = function () {
      var option, _i, _len, _ref;

      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };

    AbstractChosen.prototype.choices_click = function (evt) {
      evt.preventDefault();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function (evt) {
      var stroke, _ref;

      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.container_width = function () {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return "" + this.form_field.offsetWidth + "px";
      }
    };

    AbstractChosen.prototype.include_option_in_results = function (option) {
      if (this.is_multiple && (!this.display_selected_options && option.selected)) {
        return false;
      }
      if (!this.display_disabled_options && option.disabled) {
        return false;
      }
      if (option.empty) {
        return false;
      }
      return true;
    };

    AbstractChosen.browser_is_supported = function () {
      if (window.navigator.appName === "Microsoft Internet Explorer") {
        return document.documentMode >= 8;
      }
      if (/iP(od|hone)/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (/Android/i.test(window.navigator.userAgent)) {
        if (/Mobile/i.test(window.navigator.userAgent)) {
          return false;
        }
      }
      return true;
    };

    AbstractChosen.default_multiple_text = "Select Some Options";

    AbstractChosen.default_single_text = "Select an Option";

    AbstractChosen.default_no_result_text = "No results match";

    return AbstractChosen;

  })();

  $ = jQuery;

  $.fn.extend({
    chosen: function (options) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function (input_field) {
        var $this, chosen;

        $this = $(this);
        chosen = $this.data('chosen');
        if (options === 'destroy' && chosen) {
          chosen.destroy();
        } else if (!chosen) {
          $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function (_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function () {
      this.form_field_jq = $(this.form_field);
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.is_rtl = this.form_field_jq.hasClass("chosen-rtl");
    };

    Chosen.prototype.set_up_html = function () {
      var container_classes, container_props;

      container_classes = ["chosen-container"];
      container_classes.push("chosen-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chosen-rtl");
      }
      container_props = {
        'class': container_classes.join(' '),
        'style': "width: " + (this.container_width()) + ";",
        'title': this.form_field.title
      };
      if (this.form_field.id.length) {
        container_props.id = this.form_field.id.replace(/[^\w]/g, '_') + "_chosen";
      }
      this.container = $("<div />", container_props);
      if (this.is_multiple) {
        this.container.html('<ul class="chosen-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chosen-drop"><ul class="chosen-results"></ul></div>');
      } else {
        this.container.html('<a class="chosen-single chosen-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chosen-drop"><div class="chosen-search"><input type="text" autocomplete="off" /></div><ul class="chosen-results"></ul></div>');
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find('div.chosen-drop').first();
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chosen-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chosen-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chosen-search').first();
        this.selected_item = this.container.find('.chosen-single').first();
      }
      this.results_build();
      this.set_tab_index();
      this.set_label_behavior();
      return this.form_field_jq.trigger("chosen:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function () {
      var _this = this;

      this.container.bind('mousedown.chosen', function (evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind('mouseup.chosen', function (evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind('mouseenter.chosen', function (evt) {
        _this.mouse_enter(evt);
      });
      this.container.bind('mouseleave.chosen', function (evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.bind('mouseup.chosen', function (evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.bind('mouseover.chosen', function (evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.bind('mouseout.chosen', function (evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind('mousewheel.chosen DOMMouseScroll.chosen', function (evt) {
        _this.search_results_mousewheel(evt);
      });
      this.form_field_jq.bind("chosen:updated.chosen", function (evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind("chosen:activate.chosen", function (evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind("chosen:open.chosen", function (evt) {
        _this.container_mousedown(evt);
      });
      this.search_field.bind('blur.chosen', function (evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('keyup.chosen', function (evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.bind('keydown.chosen', function (evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.bind('focus.chosen', function (evt) {
        _this.input_focus(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.bind('click.chosen', function (evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.bind('click.chosen', function (evt) {
          evt.preventDefault();
        });
      }
    };

    Chosen.prototype.destroy = function () {
      $(document).unbind("click.chosen", this.click_test_action);
      if (this.search_field[0].tabIndex) {
        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;
      }
      this.container.remove();
      this.form_field_jq.removeData('chosen');
      return this.form_field_jq.show();
    };

    Chosen.prototype.search_field_disabled = function () {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chosen-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus.chosen", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chosen-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus.chosen", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function (evt) {
      if (!this.is_disabled) {
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.preventDefault();
        }
        if (!((evt != null) && ($(evt.target)).hasClass("search-choice-close"))) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(document).bind('click.chosen', this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chosen-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        }
      }
    };

    Chosen.prototype.container_mouseup = function (evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.search_results_mousewheel = function (evt) {
      var delta, _ref1, _ref2;

      delta = -((_ref1 = evt.originalEvent) != null ? _ref1.wheelDelta : void 0) || ((_ref2 = evt.originialEvent) != null ? _ref2.detail : void 0);
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === 'DOMMouseScroll') {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };

    Chosen.prototype.blur_test = function (evt) {
      if (!this.active_field && this.container.hasClass("chosen-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function () {
      $(document).unbind("click.chosen", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chosen-container-active");
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function () {
      this.container.addClass("chosen-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function (evt) {
      if (this.container.is($(evt.target).closest('.chosen-container'))) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function () {
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find("li.search-choice").remove();
      } else if (!this.is_multiple) {
        this.single_set_selected_text();
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass("chosen-container-single-nosearch");
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass("chosen-container-single-nosearch");
        }
      }
      this.update_results_content(this.results_option_build({
        first: true
      }));
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      return this.parsing = false;
    };

    Chosen.prototype.result_do_highlight = function (el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;

      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function () {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function () {
      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
        this.form_field_jq.trigger("chosen:maxselected", {
          chosen: this
        });
        return false;
      }
      this.container.addClass("chosen-with-drop");
      this.form_field_jq.trigger("chosen:showing_dropdown", {
        chosen: this
      });
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      return this.winnow_results();
    };

    Chosen.prototype.update_results_content = function (content) {
      return this.search_results.html(content);
    };

    Chosen.prototype.results_hide = function () {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass("chosen-with-drop");
        this.form_field_jq.trigger("chosen:hiding_dropdown", {
          chosen: this
        });
      }
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function (el) {
      var ti;

      if (this.form_field.tabIndex) {
        ti = this.form_field.tabIndex;
        this.form_field.tabIndex = -1;
        return this.search_field[0].tabIndex = ti;
      }
    };

    Chosen.prototype.set_label_behavior = function () {
      var _this = this;

      this.form_field_label = this.form_field_jq.parents("label");
      if (!this.form_field_label.length && this.form_field.id.length) {
        this.form_field_label = $("label[for='" + this.form_field.id + "']");
      }
      if (this.form_field_label.length > 0) {
        return this.form_field_label.bind('click.chosen', function (evt) {
          if (_this.is_multiple) {
            return _this.container_mousedown(evt);
          } else {
            return _this.activate_field();
          }
        });
      }
    };

    Chosen.prototype.show_search_field_default = function () {
      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function (evt) {
      var target;

      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function (evt) {
      var target;

      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function (evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choice_build = function (item) {
      var choice, close_link,
        _this = this;

      choice = $('<li />', {
        "class": "search-choice"
      }).html("<span>" + item.html + "</span>");
      if (item.disabled) {
        choice.addClass('search-choice-disabled');
      } else {
        close_link = $('<a />', {
          "class": 'search-choice-close',
          'data-option-array-index': item.array_index
        });
        close_link.bind('click.chosen', function (evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };

    Chosen.prototype.choice_destroy_link_click = function (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };

    Chosen.prototype.choice_destroy = function (link) {
      if (this.result_deselect(link[0].getAttribute("data-option-array-index"))) {
        this.show_search_field_default();
        if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        link.parents('li').first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function () {
      this.form_field.options[0].selected = true;
      this.selected_option_count = null;
      this.single_set_selected_text();
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function () {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function (evt) {
      var high, item, selected_index;

      if (this.result_highlight) {
        high = this.result_highlight;
        this.result_clear_highlight();
        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
          this.form_field_jq.trigger("chosen:maxselected", {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass("active-result");
        } else {
          if (this.result_single_selected) {
            this.result_single_selected.removeClass("result-selected");
            selected_index = this.result_single_selected[0].getAttribute('data-option-array-index');
            this.results_data[selected_index].selected = false;
          }
          this.result_single_selected = high;
        }
        high.addClass("result-selected");
        item = this.results_data[high[0].getAttribute("data-option-array-index")];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.single_set_selected_text(item.text);
        }
        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
          this.results_hide();
        }
        this.search_field.val("");
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        return this.search_field_scale();
      }
    };

    Chosen.prototype.single_set_selected_text = function (text) {
      if (text == null) {
        text = this.default_text;
      }
      if (text === this.default_text) {
        this.selected_item.addClass("chosen-default");
      } else {
        this.single_deselect_control_build();
        this.selected_item.removeClass("chosen-default");
      }
      return this.selected_item.find("span").text(text);
    };

    Chosen.prototype.result_deselect = function (pos) {
      var result_data;

      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        this.result_clear_highlight();
        if (this.results_showing) {
          this.winnow_results();
        }
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function () {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find("abbr").length) {
        this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
      return this.selected_item.addClass("chosen-single-with-deselect");
    };

    Chosen.prototype.get_search_text = function () {
      if (this.search_field.val() === this.default_text) {
        return "";
      } else {
        return $('<div/>').text($.trim(this.search_field.val())).html();
      }
    };

    Chosen.prototype.winnow_results_set_highlight = function () {
      var do_high, selected_results;

      selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
      do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
      if (do_high != null) {
        return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function (terms) {
      var no_results_html;

      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      return this.search_results.append(no_results_html);
    };

    Chosen.prototype.no_results_clear = function () {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function () {
      var next_sib;

      if (this.results_showing && this.result_highlight) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function () {
      var prev_sibs;

      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function () {
      var next_available_destroy;

      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function () {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function (evt) {
      var stroke, _ref1;

      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          evt.preventDefault();
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function () {
      var div, f_width, h, style, style_block, styles, w, _i, _len;

      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        f_width = this.container.outerWidth();
        if (w > f_width - 10) {
          w = f_width - 10;
        }
        return this.search_field.css({
          'width': w + 'px'
        });
      }
    };

    return Chosen;

  })(AbstractChosen);

}).call(this);

define("chosen", ["jquery"], function () { });

/*! Select2 4.1.0-rc.0 | https://github.com/select2/select2/blob/master/LICENSE.md */
!function (n) { "function" == typeof define && define.amd ? define('select2', ["jquery"], n) : "object" == typeof module && module.exports ? module.exports = function (e, t) { return void 0 === t && (t = "undefined" != typeof window ? require("jquery") : require("jquery")(e)), n(t), t } : n(jQuery) }(function (t) { var e, n, s, p, r, o, h, f, g, m, y, v, i, a, _, s = (t && t.fn && t.fn.select2 && t.fn.select2.amd && (u = t.fn.select2.amd), u && u.requirejs || (u ? n = u : u = {}, g = {}, m = {}, y = {}, v = {}, i = Object.prototype.hasOwnProperty, a = [].slice, _ = /\.js$/, h = function (e, t) { var n, s, i = c(e), r = i[0], t = t[1]; return e = i[1], r && (n = x(r = l(r, t))), r ? e = n && n.normalize ? n.normalize(e, (s = t, function (e) { return l(e, s) })) : l(e, t) : (r = (i = c(e = l(e, t)))[0], e = i[1], r && (n = x(r))), { f: r ? r + "!" + e : e, n: e, pr: r, p: n } }, f = { require: function (e) { return w(e) }, exports: function (e) { var t = g[e]; return void 0 !== t ? t : g[e] = {} }, module: function (e) { return { id: e, uri: "", exports: g[e], config: (t = e, function () { return y && y.config && y.config[t] || {} }) }; var t } }, r = function (e, t, n, s) { var i, r, o, a, l, c = [], u = typeof n, d = A(s = s || e); if ("undefined" == u || "function" == u) { for (t = !t.length && n.length ? ["require", "exports", "module"] : t, a = 0; a < t.length; a += 1)if ("require" === (r = (o = h(t[a], d)).f)) c[a] = f.require(e); else if ("exports" === r) c[a] = f.exports(e), l = !0; else if ("module" === r) i = c[a] = f.module(e); else if (b(g, r) || b(m, r) || b(v, r)) c[a] = x(r); else { if (!o.p) throw new Error(e + " missing " + r); o.p.load(o.n, w(s, !0), function (t) { return function (e) { g[t] = e } }(r), {}), c[a] = g[r] } u = n ? n.apply(g[e], c) : void 0, e && (i && i.exports !== p && i.exports !== g[e] ? g[e] = i.exports : u === p && l || (g[e] = u)) } else e && (g[e] = n) }, e = n = o = function (e, t, n, s, i) { if ("string" == typeof e) return f[e] ? f[e](t) : x(h(e, A(t)).f); if (!e.splice) { if ((y = e).deps && o(y.deps, y.callback), !t) return; t.splice ? (e = t, t = n, n = null) : e = p } return t = t || function () { }, "function" == typeof n && (n = s, s = i), s ? r(p, e, t, n) : setTimeout(function () { r(p, e, t, n) }, 4), o }, o.config = function (e) { return o(e) }, e._defined = g, (s = function (e, t, n) { if ("string" != typeof e) throw new Error("See almond README: incorrect module build, no module name"); t.splice || (n = t, t = []), b(g, e) || b(m, e) || (m[e] = [e, t, n]) }).amd = { jQuery: !0 }, u.requirejs = e, u.require = n, u.define = s), u.define("almond", function () { }), u.define("jquery", [], function () { var e = t || $; return null == e && console && console.error && console.error("Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."), e }), u.define("select2/utils", ["jquery"], function (r) { var s = {}; function c(e) { var t, n = e.prototype, s = []; for (t in n) "function" == typeof n[t] && "constructor" !== t && s.push(t); return s } s.Extend = function (e, t) { var n, s = {}.hasOwnProperty; function i() { this.constructor = e } for (n in t) s.call(t, n) && (e[n] = t[n]); return i.prototype = t.prototype, e.prototype = new i, e.__super__ = t.prototype, e }, s.Decorate = function (s, i) { var e = c(i), t = c(s); function r() { var e = Array.prototype.unshift, t = i.prototype.constructor.length, n = s.prototype.constructor; 0 < t && (e.call(arguments, s.prototype.constructor), n = i.prototype.constructor), n.apply(this, arguments) } i.displayName = s.displayName, r.prototype = new function () { this.constructor = r }; for (var n = 0; n < t.length; n++) { var o = t[n]; r.prototype[o] = s.prototype[o] } for (var a = 0; a < e.length; a++) { var l = e[a]; r.prototype[l] = function (e) { var t = function () { }; e in r.prototype && (t = r.prototype[e]); var n = i.prototype[e]; return function () { return Array.prototype.unshift.call(arguments, t), n.apply(this, arguments) } }(l) } return r }; function e() { this.listeners = {} } e.prototype.on = function (e, t) { this.listeners = this.listeners || {}, e in this.listeners ? this.listeners[e].push(t) : this.listeners[e] = [t] }, e.prototype.trigger = function (e) { var t = Array.prototype.slice, n = t.call(arguments, 1); this.listeners = this.listeners || {}, null == n && (n = []), 0 === n.length && n.push({}), (n[0]._type = e) in this.listeners && this.invoke(this.listeners[e], t.call(arguments, 1)), "*" in this.listeners && this.invoke(this.listeners["*"], arguments) }, e.prototype.invoke = function (e, t) { for (var n = 0, s = e.length; n < s; n++)e[n].apply(this, t) }, s.Observable = e, s.generateChars = function (e) { for (var t = "", n = 0; n < e; n++)t += Math.floor(36 * Math.random()).toString(36); return t }, s.bind = function (e, t) { return function () { e.apply(t, arguments) } }, s._convertData = function (e) { for (var t in e) { var n = t.split("-"), s = e; if (1 !== n.length) { for (var i = 0; i < n.length; i++) { var r = n[i]; (r = r.substring(0, 1).toLowerCase() + r.substring(1)) in s || (s[r] = {}), i == n.length - 1 && (s[r] = e[t]), s = s[r] } delete e[t] } } return e }, s.hasScroll = function (e, t) { var n = r(t), s = t.style.overflowX, i = t.style.overflowY; return (s !== i || "hidden" !== i && "visible" !== i) && ("scroll" === s || "scroll" === i || (n.innerHeight() < t.scrollHeight || n.innerWidth() < t.scrollWidth)) }, s.escapeMarkup = function (e) { var t = { "\\": "&#92;", "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#47;" }; return "string" != typeof e ? e : String(e).replace(/[&<>"'\/\\]/g, function (e) { return t[e] }) }, s.__cache = {}; var n = 0; return s.GetUniqueElementId = function (e) { var t = e.getAttribute("data-select2-id"); return null != t || (t = e.id ? "select2-data-" + e.id : "select2-data-" + (++n).toString() + "-" + s.generateChars(4), e.setAttribute("data-select2-id", t)), t }, s.StoreData = function (e, t, n) { e = s.GetUniqueElementId(e); s.__cache[e] || (s.__cache[e] = {}), s.__cache[e][t] = n }, s.GetData = function (e, t) { var n = s.GetUniqueElementId(e); return t ? s.__cache[n] && null != s.__cache[n][t] ? s.__cache[n][t] : r(e).data(t) : s.__cache[n] }, s.RemoveData = function (e) { var t = s.GetUniqueElementId(e); null != s.__cache[t] && delete s.__cache[t], e.removeAttribute("data-select2-id") }, s.copyNonInternalCssClasses = function (e, t) { var n = (n = e.getAttribute("class").trim().split(/\s+/)).filter(function (e) { return 0 === e.indexOf("select2-") }), t = (t = t.getAttribute("class").trim().split(/\s+/)).filter(function (e) { return 0 !== e.indexOf("select2-") }), t = n.concat(t); e.setAttribute("class", t.join(" ")) }, s }), u.define("select2/results", ["jquery", "./utils"], function (d, p) { function s(e, t, n) { this.$element = e, this.data = n, this.options = t, s.__super__.constructor.call(this) } return p.Extend(s, p.Observable), s.prototype.render = function () { var e = d('<ul class="select2-results__options" role="listbox"></ul>'); return this.options.get("multiple") && e.attr("aria-multiselectable", "true"), this.$results = e }, s.prototype.clear = function () { this.$results.empty() }, s.prototype.displayMessage = function (e) { var t = this.options.get("escapeMarkup"); this.clear(), this.hideLoading(); var n = d('<li role="alert" aria-live="assertive" class="select2-results__option"></li>'), s = this.options.get("translations").get(e.message); n.append(t(s(e.args))), n[0].className += " select2-results__message", this.$results.append(n) }, s.prototype.hideMessages = function () { this.$results.find(".select2-results__message").remove() }, s.prototype.append = function (e) { this.hideLoading(); var t = []; if (null != e.results && 0 !== e.results.length) { e.results = this.sort(e.results); for (var n = 0; n < e.results.length; n++) { var s = e.results[n], s = this.option(s); t.push(s) } this.$results.append(t) } else 0 === this.$results.children().length && this.trigger("results:message", { message: "noResults" }) }, s.prototype.position = function (e, t) { t.find(".select2-results").append(e) }, s.prototype.sort = function (e) { return this.options.get("sorter")(e) }, s.prototype.highlightFirstItem = function () { var e = this.$results.find(".select2-results__option--selectable"), t = e.filter(".select2-results__option--selected"); (0 < t.length ? t : e).first().trigger("mouseenter"), this.ensureHighlightVisible() }, s.prototype.setClasses = function () { var t = this; this.data.current(function (e) { var s = e.map(function (e) { return e.id.toString() }); t.$results.find(".select2-results__option--selectable").each(function () { var e = d(this), t = p.GetData(this, "data"), n = "" + t.id; null != t.element && t.element.selected || null == t.element && -1 < s.indexOf(n) ? (this.classList.add("select2-results__option--selected"), e.attr("aria-selected", "true")) : (this.classList.remove("select2-results__option--selected"), e.attr("aria-selected", "false")) }) }) }, s.prototype.showLoading = function (e) { this.hideLoading(); e = { disabled: !0, loading: !0, text: this.options.get("translations").get("searching")(e) }, e = this.option(e); e.className += " loading-results", this.$results.prepend(e) }, s.prototype.hideLoading = function () { this.$results.find(".loading-results").remove() }, s.prototype.option = function (e) { var t = document.createElement("li"); t.classList.add("select2-results__option"), t.classList.add("select2-results__option--selectable"); var n, s = { role: "option" }, i = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector; for (n in (null != e.element && i.call(e.element, ":disabled") || null == e.element && e.disabled) && (s["aria-disabled"] = "true", t.classList.remove("select2-results__option--selectable"), t.classList.add("select2-results__option--disabled")), null == e.id && t.classList.remove("select2-results__option--selectable"), null != e._resultId && (t.id = e._resultId), e.title && (t.title = e.title), e.children && (s.role = "group", s["aria-label"] = e.text, t.classList.remove("select2-results__option--selectable"), t.classList.add("select2-results__option--group")), s) { var r = s[n]; t.setAttribute(n, r) } if (e.children) { var o = d(t), a = document.createElement("strong"); a.className = "select2-results__group", this.template(e, a); for (var l = [], c = 0; c < e.children.length; c++) { var u = e.children[c], u = this.option(u); l.push(u) } i = d("<ul></ul>", { class: "select2-results__options select2-results__options--nested", role: "none" }); i.append(l), o.append(a), o.append(i) } else this.template(e, t); return p.StoreData(t, "data", e), t }, s.prototype.bind = function (t, e) { var i = this, n = t.id + "-results"; this.$results.attr("id", n), t.on("results:all", function (e) { i.clear(), i.append(e.data), t.isOpen() && (i.setClasses(), i.highlightFirstItem()) }), t.on("results:append", function (e) { i.append(e.data), t.isOpen() && i.setClasses() }), t.on("query", function (e) { i.hideMessages(), i.showLoading(e) }), t.on("select", function () { t.isOpen() && (i.setClasses(), i.options.get("scrollAfterSelect") && i.highlightFirstItem()) }), t.on("unselect", function () { t.isOpen() && (i.setClasses(), i.options.get("scrollAfterSelect") && i.highlightFirstItem()) }), t.on("open", function () { i.$results.attr("aria-expanded", "true"), i.$results.attr("aria-hidden", "false"), i.setClasses(), i.ensureHighlightVisible() }), t.on("close", function () { i.$results.attr("aria-expanded", "false"), i.$results.attr("aria-hidden", "true"), i.$results.removeAttr("aria-activedescendant") }), t.on("results:toggle", function () { var e = i.getHighlightedResults(); 0 !== e.length && e.trigger("mouseup") }), t.on("results:select", function () { var e, t = i.getHighlightedResults(); 0 !== t.length && (e = p.GetData(t[0], "data"), t.hasClass("select2-results__option--selected") ? i.trigger("close", {}) : i.trigger("select", { data: e })) }), t.on("results:previous", function () { var e, t = i.getHighlightedResults(), n = i.$results.find(".select2-results__option--selectable"), s = n.index(t); s <= 0 || (e = s - 1, 0 === t.length && (e = 0), (s = n.eq(e)).trigger("mouseenter"), t = i.$results.offset().top, n = s.offset().top, s = i.$results.scrollTop() + (n - t), 0 === e ? i.$results.scrollTop(0) : n - t < 0 && i.$results.scrollTop(s)) }), t.on("results:next", function () { var e, t = i.getHighlightedResults(), n = i.$results.find(".select2-results__option--selectable"), s = n.index(t) + 1; s >= n.length || ((e = n.eq(s)).trigger("mouseenter"), t = i.$results.offset().top + i.$results.outerHeight(!1), n = e.offset().top + e.outerHeight(!1), e = i.$results.scrollTop() + n - t, 0 === s ? i.$results.scrollTop(0) : t < n && i.$results.scrollTop(e)) }), t.on("results:focus", function (e) { e.element[0].classList.add("select2-results__option--highlighted"), e.element[0].setAttribute("aria-selected", "true") }), t.on("results:message", function (e) { i.displayMessage(e) }), d.fn.mousewheel && this.$results.on("mousewheel", function (e) { var t = i.$results.scrollTop(), n = i.$results.get(0).scrollHeight - t + e.deltaY, t = 0 < e.deltaY && t - e.deltaY <= 0, n = e.deltaY < 0 && n <= i.$results.height(); t ? (i.$results.scrollTop(0), e.preventDefault(), e.stopPropagation()) : n && (i.$results.scrollTop(i.$results.get(0).scrollHeight - i.$results.height()), e.preventDefault(), e.stopPropagation()) }), this.$results.on("mouseup", ".select2-results__option--selectable", function (e) { var t = d(this), n = p.GetData(this, "data"); t.hasClass("select2-results__option--selected") ? i.options.get("multiple") ? i.trigger("unselect", { originalEvent: e, data: n }) : i.trigger("close", {}) : i.trigger("select", { originalEvent: e, data: n }) }), this.$results.on("mouseenter", ".select2-results__option--selectable", function (e) { var t = p.GetData(this, "data"); i.getHighlightedResults().removeClass("select2-results__option--highlighted").attr("aria-selected", "false"), i.trigger("results:focus", { data: t, element: d(this) }) }) }, s.prototype.getHighlightedResults = function () { return this.$results.find(".select2-results__option--highlighted") }, s.prototype.destroy = function () { this.$results.remove() }, s.prototype.ensureHighlightVisible = function () { var e, t, n, s, i = this.getHighlightedResults(); 0 !== i.length && (e = this.$results.find(".select2-results__option--selectable").index(i), s = this.$results.offset().top, t = i.offset().top, n = this.$results.scrollTop() + (t - s), s = t - s, n -= 2 * i.outerHeight(!1), e <= 2 ? this.$results.scrollTop(0) : (s > this.$results.outerHeight() || s < 0) && this.$results.scrollTop(n)) }, s.prototype.template = function (e, t) { var n = this.options.get("templateResult"), s = this.options.get("escapeMarkup"), e = n(e, t); null == e ? t.style.display = "none" : "string" == typeof e ? t.innerHTML = s(e) : d(t).append(e) }, s }), u.define("select2/keys", [], function () { return { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, DELETE: 46 } }), u.define("select2/selection/base", ["jquery", "../utils", "../keys"], function (n, s, i) { function r(e, t) { this.$element = e, this.options = t, r.__super__.constructor.call(this) } return s.Extend(r, s.Observable), r.prototype.render = function () { var e = n('<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>'); return this._tabindex = 0, null != s.GetData(this.$element[0], "old-tabindex") ? this._tabindex = s.GetData(this.$element[0], "old-tabindex") : null != this.$element.attr("tabindex") && (this._tabindex = this.$element.attr("tabindex")), e.attr("title", this.$element.attr("title")), e.attr("tabindex", this._tabindex), e.attr("aria-disabled", "false"), this.$selection = e }, r.prototype.bind = function (e, t) { var n = this, s = e.id + "-results"; this.container = e, this.$selection.on("focus", function (e) { n.trigger("focus", e) }), this.$selection.on("blur", function (e) { n._handleBlur(e) }), this.$selection.on("keydown", function (e) { n.trigger("keypress", e), e.which === i.SPACE && e.preventDefault() }), e.on("results:focus", function (e) { n.$selection.attr("aria-activedescendant", e.data._resultId) }), e.on("selection:update", function (e) { n.update(e.data) }), e.on("open", function () { n.$selection.attr("aria-expanded", "true"), n.$selection.attr("aria-owns", s), n._attachCloseHandler(e) }), e.on("close", function () { n.$selection.attr("aria-expanded", "false"), n.$selection.removeAttr("aria-activedescendant"), n.$selection.removeAttr("aria-owns"), n.$selection.trigger("focus"), n._detachCloseHandler(e) }), e.on("enable", function () { n.$selection.attr("tabindex", n._tabindex), n.$selection.attr("aria-disabled", "false") }), e.on("disable", function () { n.$selection.attr("tabindex", "-1"), n.$selection.attr("aria-disabled", "true") }) }, r.prototype._handleBlur = function (e) { var t = this; window.setTimeout(function () { document.activeElement == t.$selection[0] || n.contains(t.$selection[0], document.activeElement) || t.trigger("blur", e) }, 1) }, r.prototype._attachCloseHandler = function (e) { n(document.body).on("mousedown.select2." + e.id, function (e) { var t = n(e.target).closest(".select2"); n(".select2.select2-container--open").each(function () { this != t[0] && s.GetData(this, "element").select2("close") }) }) }, r.prototype._detachCloseHandler = function (e) { n(document.body).off("mousedown.select2." + e.id) }, r.prototype.position = function (e, t) { t.find(".selection").append(e) }, r.prototype.destroy = function () { this._detachCloseHandler(this.container) }, r.prototype.update = function (e) { throw new Error("The `update` method must be defined in child classes.") }, r.prototype.isEnabled = function () { return !this.isDisabled() }, r.prototype.isDisabled = function () { return this.options.get("disabled") }, r }), u.define("select2/selection/single", ["jquery", "./base", "../utils", "../keys"], function (e, t, n, s) { function i() { i.__super__.constructor.apply(this, arguments) } return n.Extend(i, t), i.prototype.render = function () { var e = i.__super__.render.call(this); return e[0].classList.add("select2-selection--single"), e.html('<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'), e }, i.prototype.bind = function (t, e) { var n = this; i.__super__.bind.apply(this, arguments); var s = t.id + "-container"; this.$selection.find(".select2-selection__rendered").attr("id", s).attr("role", "textbox").attr("aria-readonly", "true"), this.$selection.attr("aria-labelledby", s), this.$selection.attr("aria-controls", s), this.$selection.on("mousedown", function (e) { 1 === e.which && n.trigger("toggle", { originalEvent: e }) }), this.$selection.on("focus", function (e) { }), this.$selection.on("blur", function (e) { }), t.on("focus", function (e) { t.isOpen() || n.$selection.trigger("focus") }) }, i.prototype.clear = function () { var e = this.$selection.find(".select2-selection__rendered"); e.empty(), e.removeAttr("title") }, i.prototype.display = function (e, t) { var n = this.options.get("templateSelection"); return this.options.get("escapeMarkup")(n(e, t)) }, i.prototype.selectionContainer = function () { return e("<span></span>") }, i.prototype.update = function (e) { var t, n; 0 !== e.length ? (n = e[0], t = this.$selection.find(".select2-selection__rendered"), e = this.display(n, t), t.empty().append(e), (n = n.title || n.text) ? t.attr("title", n) : t.removeAttr("title")) : this.clear() }, i }), u.define("select2/selection/multiple", ["jquery", "./base", "../utils"], function (i, e, c) { function r(e, t) { r.__super__.constructor.apply(this, arguments) } return c.Extend(r, e), r.prototype.render = function () { var e = r.__super__.render.call(this); return e[0].classList.add("select2-selection--multiple"), e.html('<ul class="select2-selection__rendered"></ul>'), e }, r.prototype.bind = function (e, t) { var n = this; r.__super__.bind.apply(this, arguments); var s = e.id + "-container"; this.$selection.find(".select2-selection__rendered").attr("id", s), this.$selection.on("click", function (e) { n.trigger("toggle", { originalEvent: e }) }), this.$selection.on("click", ".select2-selection__choice__remove", function (e) { var t; n.isDisabled() || (t = i(this).parent(), t = c.GetData(t[0], "data"), n.trigger("unselect", { originalEvent: e, data: t })) }), this.$selection.on("keydown", ".select2-selection__choice__remove", function (e) { n.isDisabled() || e.stopPropagation() }) }, r.prototype.clear = function () { var e = this.$selection.find(".select2-selection__rendered"); e.empty(), e.removeAttr("title") }, r.prototype.display = function (e, t) { var n = this.options.get("templateSelection"); return this.options.get("escapeMarkup")(n(e, t)) }, r.prototype.selectionContainer = function () { return i('<li class="select2-selection__choice"><button type="button" class="select2-selection__choice__remove" tabindex="-1"><span aria-hidden="true">&times;</span></button><span class="select2-selection__choice__display"></span></li>') }, r.prototype.update = function (e) { if (this.clear(), 0 !== e.length) { for (var t = [], n = this.$selection.find(".select2-selection__rendered").attr("id") + "-choice-", s = 0; s < e.length; s++) { var i = e[s], r = this.selectionContainer(), o = this.display(i, r), a = n + c.generateChars(4) + "-"; i.id ? a += i.id : a += c.generateChars(4), r.find(".select2-selection__choice__display").append(o).attr("id", a); var l = i.title || i.text; l && r.attr("title", l); o = this.options.get("translations").get("removeItem"), l = r.find(".select2-selection__choice__remove"); l.attr("title", o()), l.attr("aria-label", o()), l.attr("aria-describedby", a), c.StoreData(r[0], "data", i), t.push(r) } this.$selection.find(".select2-selection__rendered").append(t) } }, r }), u.define("select2/selection/placeholder", [], function () { function e(e, t, n) { this.placeholder = this.normalizePlaceholder(n.get("placeholder")), e.call(this, t, n) } return e.prototype.normalizePlaceholder = function (e, t) { return "string" == typeof t && (t = { id: "", text: t }), t }, e.prototype.createPlaceholder = function (e, t) { var n = this.selectionContainer(); n.html(this.display(t)), n[0].classList.add("select2-selection__placeholder"), n[0].classList.remove("select2-selection__choice"); t = t.title || t.text || n.text(); return this.$selection.find(".select2-selection__rendered").attr("title", t), n }, e.prototype.update = function (e, t) { var n = 1 == t.length && t[0].id != this.placeholder.id; if (1 < t.length || n) return e.call(this, t); this.clear(); t = this.createPlaceholder(this.placeholder); this.$selection.find(".select2-selection__rendered").append(t) }, e }), u.define("select2/selection/allowClear", ["jquery", "../keys", "../utils"], function (i, s, a) { function e() { } return e.prototype.bind = function (e, t, n) { var s = this; e.call(this, t, n), null == this.placeholder && this.options.get("debug") && window.console && console.error && console.error("Select2: The `allowClear` option should be used in combination with the `placeholder` option."), this.$selection.on("mousedown", ".select2-selection__clear", function (e) { s._handleClear(e) }), t.on("keypress", function (e) { s._handleKeyboardClear(e, t) }) }, e.prototype._handleClear = function (e, t) { if (!this.isDisabled()) { var n = this.$selection.find(".select2-selection__clear"); if (0 !== n.length) { t.stopPropagation(); var s = a.GetData(n[0], "data"), i = this.$element.val(); this.$element.val(this.placeholder.id); var r = { data: s }; if (this.trigger("clear", r), r.prevented) this.$element.val(i); else { for (var o = 0; o < s.length; o++)if (r = { data: s[o] }, this.trigger("unselect", r), r.prevented) return void this.$element.val(i); this.$element.trigger("input").trigger("change"), this.trigger("toggle", {}) } } } }, e.prototype._handleKeyboardClear = function (e, t, n) { n.isOpen() || t.which != s.DELETE && t.which != s.BACKSPACE || this._handleClear(t) }, e.prototype.update = function (e, t) { var n, s; e.call(this, t), this.$selection.find(".select2-selection__clear").remove(), this.$selection[0].classList.remove("select2-selection--clearable"), 0 < this.$selection.find(".select2-selection__placeholder").length || 0 === t.length || (n = this.$selection.find(".select2-selection__rendered").attr("id"), s = this.options.get("translations").get("removeAllItems"), (e = i('<button type="button" class="select2-selection__clear" tabindex="-1"><span aria-hidden="true">&times;</span></button>')).attr("title", s()), e.attr("aria-label", s()), e.attr("aria-describedby", n), a.StoreData(e[0], "data", t), this.$selection.prepend(e), this.$selection[0].classList.add("select2-selection--clearable")) }, e }), u.define("select2/selection/search", ["jquery", "../utils", "../keys"], function (s, a, l) { function e(e, t, n) { e.call(this, t, n) } return e.prototype.render = function (e) { var t = this.options.get("translations").get("search"), n = s('<span class="select2-search select2-search--inline"><textarea class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" ></textarea></span>'); this.$searchContainer = n, this.$search = n.find("textarea"), this.$search.prop("autocomplete", this.options.get("autocomplete")), this.$search.attr("aria-label", t()); e = e.call(this); return this._transferTabIndex(), e.append(this.$searchContainer), e }, e.prototype.bind = function (e, t, n) { var s = this, i = t.id + "-results", r = t.id + "-container"; e.call(this, t, n), s.$search.attr("aria-describedby", r), t.on("open", function () { s.$search.attr("aria-controls", i), s.$search.trigger("focus") }), t.on("close", function () { s.$search.val(""), s.resizeSearch(), s.$search.removeAttr("aria-controls"), s.$search.removeAttr("aria-activedescendant"), s.$search.trigger("focus") }), t.on("enable", function () { s.$search.prop("disabled", !1), s._transferTabIndex() }), t.on("disable", function () { s.$search.prop("disabled", !0) }), t.on("focus", function (e) { s.$search.trigger("focus") }), t.on("results:focus", function (e) { e.data._resultId ? s.$search.attr("aria-activedescendant", e.data._resultId) : s.$search.removeAttr("aria-activedescendant") }), this.$selection.on("focusin", ".select2-search--inline", function (e) { s.trigger("focus", e) }), this.$selection.on("focusout", ".select2-search--inline", function (e) { s._handleBlur(e) }), this.$selection.on("keydown", ".select2-search--inline", function (e) { var t; e.stopPropagation(), s.trigger("keypress", e), s._keyUpPrevented = e.isDefaultPrevented(), e.which !== l.BACKSPACE || "" !== s.$search.val() || 0 < (t = s.$selection.find(".select2-selection__choice").last()).length && (t = a.GetData(t[0], "data"), s.searchRemoveChoice(t), e.preventDefault()) }), this.$selection.on("click", ".select2-search--inline", function (e) { s.$search.val() && e.stopPropagation() }); var t = document.documentMode, o = t && t <= 11; this.$selection.on("input.searchcheck", ".select2-search--inline", function (e) { o ? s.$selection.off("input.search input.searchcheck") : s.$selection.off("keyup.search") }), this.$selection.on("keyup.search input.search", ".select2-search--inline", function (e) { var t; o && "input" === e.type ? s.$selection.off("input.search input.searchcheck") : (t = e.which) != l.SHIFT && t != l.CTRL && t != l.ALT && t != l.TAB && s.handleSearch(e) }) }, e.prototype._transferTabIndex = function (e) { this.$search.attr("tabindex", this.$selection.attr("tabindex")), this.$selection.attr("tabindex", "-1") }, e.prototype.createPlaceholder = function (e, t) { this.$search.attr("placeholder", t.text) }, e.prototype.update = function (e, t) { var n = this.$search[0] == document.activeElement; this.$search.attr("placeholder", ""), e.call(this, t), this.resizeSearch(), n && this.$search.trigger("focus") }, e.prototype.handleSearch = function () { var e; this.resizeSearch(), this._keyUpPrevented || (e = this.$search.val(), this.trigger("query", { term: e })), this._keyUpPrevented = !1 }, e.prototype.searchRemoveChoice = function (e, t) { this.trigger("unselect", { data: t }), this.$search.val(t.text), this.handleSearch() }, e.prototype.resizeSearch = function () { this.$search.css("width", "25px"); var e = "100%"; "" === this.$search.attr("placeholder") && (e = .75 * (this.$search.val().length + 1) + "em"), this.$search.css("width", e) }, e }), u.define("select2/selection/selectionCss", ["../utils"], function (n) { function e() { } return e.prototype.render = function (e) { var t = e.call(this), e = this.options.get("selectionCssClass") || ""; return -1 !== e.indexOf(":all:") && (e = e.replace(":all:", ""), n.copyNonInternalCssClasses(t[0], this.$element[0])), t.addClass(e), t }, e }), u.define("select2/selection/eventRelay", ["jquery"], function (o) { function e() { } return e.prototype.bind = function (e, t, n) { var s = this, i = ["open", "opening", "close", "closing", "select", "selecting", "unselect", "unselecting", "clear", "clearing"], r = ["opening", "closing", "selecting", "unselecting", "clearing"]; e.call(this, t, n), t.on("*", function (e, t) { var n; -1 !== i.indexOf(e) && (t = t || {}, n = o.Event("select2:" + e, { params: t }), s.$element.trigger(n), -1 !== r.indexOf(e) && (t.prevented = n.isDefaultPrevented())) }) }, e }), u.define("select2/translation", ["jquery", "require"], function (t, n) { function s(e) { this.dict = e || {} } return s.prototype.all = function () { return this.dict }, s.prototype.get = function (e) { return this.dict[e] }, s.prototype.extend = function (e) { this.dict = t.extend({}, e.all(), this.dict) }, s._cache = {}, s.loadPath = function (e) { var t; return e in s._cache || (t = n(e), s._cache[e] = t), new s(s._cache[e]) }, s }), u.define("select2/diacritics", [], function () { return { "Ⓐ": "A", "Ａ": "A", "À": "A", "Á": "A", "Â": "A", "Ầ": "A", "Ấ": "A", "Ẫ": "A", "Ẩ": "A", "Ã": "A", "Ā": "A", "Ă": "A", "Ằ": "A", "Ắ": "A", "Ẵ": "A", "Ẳ": "A", "Ȧ": "A", "Ǡ": "A", "Ä": "A", "Ǟ": "A", "Ả": "A", "Å": "A", "Ǻ": "A", "Ǎ": "A", "Ȁ": "A", "Ȃ": "A", "Ạ": "A", "Ậ": "A", "Ặ": "A", "Ḁ": "A", "Ą": "A", "Ⱥ": "A", "Ɐ": "A", "Ꜳ": "AA", "Æ": "AE", "Ǽ": "AE", "Ǣ": "AE", "Ꜵ": "AO", "Ꜷ": "AU", "Ꜹ": "AV", "Ꜻ": "AV", "Ꜽ": "AY", "Ⓑ": "B", "Ｂ": "B", "Ḃ": "B", "Ḅ": "B", "Ḇ": "B", "Ƀ": "B", "Ƃ": "B", "Ɓ": "B", "Ⓒ": "C", "Ｃ": "C", "Ć": "C", "Ĉ": "C", "Ċ": "C", "Č": "C", "Ç": "C", "Ḉ": "C", "Ƈ": "C", "Ȼ": "C", "Ꜿ": "C", "Ⓓ": "D", "Ｄ": "D", "Ḋ": "D", "Ď": "D", "Ḍ": "D", "Ḑ": "D", "Ḓ": "D", "Ḏ": "D", "Đ": "D", "Ƌ": "D", "Ɗ": "D", "Ɖ": "D", "Ꝺ": "D", "Ǳ": "DZ", "Ǆ": "DZ", "ǲ": "Dz", "ǅ": "Dz", "Ⓔ": "E", "Ｅ": "E", "È": "E", "É": "E", "Ê": "E", "Ề": "E", "Ế": "E", "Ễ": "E", "Ể": "E", "Ẽ": "E", "Ē": "E", "Ḕ": "E", "Ḗ": "E", "Ĕ": "E", "Ė": "E", "Ë": "E", "Ẻ": "E", "Ě": "E", "Ȅ": "E", "Ȇ": "E", "Ẹ": "E", "Ệ": "E", "Ȩ": "E", "Ḝ": "E", "Ę": "E", "Ḙ": "E", "Ḛ": "E", "Ɛ": "E", "Ǝ": "E", "Ⓕ": "F", "Ｆ": "F", "Ḟ": "F", "Ƒ": "F", "Ꝼ": "F", "Ⓖ": "G", "Ｇ": "G", "Ǵ": "G", "Ĝ": "G", "Ḡ": "G", "Ğ": "G", "Ġ": "G", "Ǧ": "G", "Ģ": "G", "Ǥ": "G", "Ɠ": "G", "Ꞡ": "G", "Ᵹ": "G", "Ꝿ": "G", "Ⓗ": "H", "Ｈ": "H", "Ĥ": "H", "Ḣ": "H", "Ḧ": "H", "Ȟ": "H", "Ḥ": "H", "Ḩ": "H", "Ḫ": "H", "Ħ": "H", "Ⱨ": "H", "Ⱶ": "H", "Ɥ": "H", "Ⓘ": "I", "Ｉ": "I", "Ì": "I", "Í": "I", "Î": "I", "Ĩ": "I", "Ī": "I", "Ĭ": "I", "İ": "I", "Ï": "I", "Ḯ": "I", "Ỉ": "I", "Ǐ": "I", "Ȉ": "I", "Ȋ": "I", "Ị": "I", "Į": "I", "Ḭ": "I", "Ɨ": "I", "Ⓙ": "J", "Ｊ": "J", "Ĵ": "J", "Ɉ": "J", "Ⓚ": "K", "Ｋ": "K", "Ḱ": "K", "Ǩ": "K", "Ḳ": "K", "Ķ": "K", "Ḵ": "K", "Ƙ": "K", "Ⱪ": "K", "Ꝁ": "K", "Ꝃ": "K", "Ꝅ": "K", "Ꞣ": "K", "Ⓛ": "L", "Ｌ": "L", "Ŀ": "L", "Ĺ": "L", "Ľ": "L", "Ḷ": "L", "Ḹ": "L", "Ļ": "L", "Ḽ": "L", "Ḻ": "L", "Ł": "L", "Ƚ": "L", "Ɫ": "L", "Ⱡ": "L", "Ꝉ": "L", "Ꝇ": "L", "Ꞁ": "L", "Ǉ": "LJ", "ǈ": "Lj", "Ⓜ": "M", "Ｍ": "M", "Ḿ": "M", "Ṁ": "M", "Ṃ": "M", "Ɱ": "M", "Ɯ": "M", "Ⓝ": "N", "Ｎ": "N", "Ǹ": "N", "Ń": "N", "Ñ": "N", "Ṅ": "N", "Ň": "N", "Ṇ": "N", "Ņ": "N", "Ṋ": "N", "Ṉ": "N", "Ƞ": "N", "Ɲ": "N", "Ꞑ": "N", "Ꞥ": "N", "Ǌ": "NJ", "ǋ": "Nj", "Ⓞ": "O", "Ｏ": "O", "Ò": "O", "Ó": "O", "Ô": "O", "Ồ": "O", "Ố": "O", "Ỗ": "O", "Ổ": "O", "Õ": "O", "Ṍ": "O", "Ȭ": "O", "Ṏ": "O", "Ō": "O", "Ṑ": "O", "Ṓ": "O", "Ŏ": "O", "Ȯ": "O", "Ȱ": "O", "Ö": "O", "Ȫ": "O", "Ỏ": "O", "Ő": "O", "Ǒ": "O", "Ȍ": "O", "Ȏ": "O", "Ơ": "O", "Ờ": "O", "Ớ": "O", "Ỡ": "O", "Ở": "O", "Ợ": "O", "Ọ": "O", "Ộ": "O", "Ǫ": "O", "Ǭ": "O", "Ø": "O", "Ǿ": "O", "Ɔ": "O", "Ɵ": "O", "Ꝋ": "O", "Ꝍ": "O", "Œ": "OE", "Ƣ": "OI", "Ꝏ": "OO", "Ȣ": "OU", "Ⓟ": "P", "Ｐ": "P", "Ṕ": "P", "Ṗ": "P", "Ƥ": "P", "Ᵽ": "P", "Ꝑ": "P", "Ꝓ": "P", "Ꝕ": "P", "Ⓠ": "Q", "Ｑ": "Q", "Ꝗ": "Q", "Ꝙ": "Q", "Ɋ": "Q", "Ⓡ": "R", "Ｒ": "R", "Ŕ": "R", "Ṙ": "R", "Ř": "R", "Ȑ": "R", "Ȓ": "R", "Ṛ": "R", "Ṝ": "R", "Ŗ": "R", "Ṟ": "R", "Ɍ": "R", "Ɽ": "R", "Ꝛ": "R", "Ꞧ": "R", "Ꞃ": "R", "Ⓢ": "S", "Ｓ": "S", "ẞ": "S", "Ś": "S", "Ṥ": "S", "Ŝ": "S", "Ṡ": "S", "Š": "S", "Ṧ": "S", "Ṣ": "S", "Ṩ": "S", "Ș": "S", "Ş": "S", "Ȿ": "S", "Ꞩ": "S", "Ꞅ": "S", "Ⓣ": "T", "Ｔ": "T", "Ṫ": "T", "Ť": "T", "Ṭ": "T", "Ț": "T", "Ţ": "T", "Ṱ": "T", "Ṯ": "T", "Ŧ": "T", "Ƭ": "T", "Ʈ": "T", "Ⱦ": "T", "Ꞇ": "T", "Ꜩ": "TZ", "Ⓤ": "U", "Ｕ": "U", "Ù": "U", "Ú": "U", "Û": "U", "Ũ": "U", "Ṹ": "U", "Ū": "U", "Ṻ": "U", "Ŭ": "U", "Ü": "U", "Ǜ": "U", "Ǘ": "U", "Ǖ": "U", "Ǚ": "U", "Ủ": "U", "Ů": "U", "Ű": "U", "Ǔ": "U", "Ȕ": "U", "Ȗ": "U", "Ư": "U", "Ừ": "U", "Ứ": "U", "Ữ": "U", "Ử": "U", "Ự": "U", "Ụ": "U", "Ṳ": "U", "Ų": "U", "Ṷ": "U", "Ṵ": "U", "Ʉ": "U", "Ⓥ": "V", "Ｖ": "V", "Ṽ": "V", "Ṿ": "V", "Ʋ": "V", "Ꝟ": "V", "Ʌ": "V", "Ꝡ": "VY", "Ⓦ": "W", "Ｗ": "W", "Ẁ": "W", "Ẃ": "W", "Ŵ": "W", "Ẇ": "W", "Ẅ": "W", "Ẉ": "W", "Ⱳ": "W", "Ⓧ": "X", "Ｘ": "X", "Ẋ": "X", "Ẍ": "X", "Ⓨ": "Y", "Ｙ": "Y", "Ỳ": "Y", "Ý": "Y", "Ŷ": "Y", "Ỹ": "Y", "Ȳ": "Y", "Ẏ": "Y", "Ÿ": "Y", "Ỷ": "Y", "Ỵ": "Y", "Ƴ": "Y", "Ɏ": "Y", "Ỿ": "Y", "Ⓩ": "Z", "Ｚ": "Z", "Ź": "Z", "Ẑ": "Z", "Ż": "Z", "Ž": "Z", "Ẓ": "Z", "Ẕ": "Z", "Ƶ": "Z", "Ȥ": "Z", "Ɀ": "Z", "Ⱬ": "Z", "Ꝣ": "Z", "ⓐ": "a", "ａ": "a", "ẚ": "a", "à": "a", "á": "a", "â": "a", "ầ": "a", "ấ": "a", "ẫ": "a", "ẩ": "a", "ã": "a", "ā": "a", "ă": "a", "ằ": "a", "ắ": "a", "ẵ": "a", "ẳ": "a", "ȧ": "a", "ǡ": "a", "ä": "a", "ǟ": "a", "ả": "a", "å": "a", "ǻ": "a", "ǎ": "a", "ȁ": "a", "ȃ": "a", "ạ": "a", "ậ": "a", "ặ": "a", "ḁ": "a", "ą": "a", "ⱥ": "a", "ɐ": "a", "ꜳ": "aa", "æ": "ae", "ǽ": "ae", "ǣ": "ae", "ꜵ": "ao", "ꜷ": "au", "ꜹ": "av", "ꜻ": "av", "ꜽ": "ay", "ⓑ": "b", "ｂ": "b", "ḃ": "b", "ḅ": "b", "ḇ": "b", "ƀ": "b", "ƃ": "b", "ɓ": "b", "ⓒ": "c", "ｃ": "c", "ć": "c", "ĉ": "c", "ċ": "c", "č": "c", "ç": "c", "ḉ": "c", "ƈ": "c", "ȼ": "c", "ꜿ": "c", "ↄ": "c", "ⓓ": "d", "ｄ": "d", "ḋ": "d", "ď": "d", "ḍ": "d", "ḑ": "d", "ḓ": "d", "ḏ": "d", "đ": "d", "ƌ": "d", "ɖ": "d", "ɗ": "d", "ꝺ": "d", "ǳ": "dz", "ǆ": "dz", "ⓔ": "e", "ｅ": "e", "è": "e", "é": "e", "ê": "e", "ề": "e", "ế": "e", "ễ": "e", "ể": "e", "ẽ": "e", "ē": "e", "ḕ": "e", "ḗ": "e", "ĕ": "e", "ė": "e", "ë": "e", "ẻ": "e", "ě": "e", "ȅ": "e", "ȇ": "e", "ẹ": "e", "ệ": "e", "ȩ": "e", "ḝ": "e", "ę": "e", "ḙ": "e", "ḛ": "e", "ɇ": "e", "ɛ": "e", "ǝ": "e", "ⓕ": "f", "ｆ": "f", "ḟ": "f", "ƒ": "f", "ꝼ": "f", "ⓖ": "g", "ｇ": "g", "ǵ": "g", "ĝ": "g", "ḡ": "g", "ğ": "g", "ġ": "g", "ǧ": "g", "ģ": "g", "ǥ": "g", "ɠ": "g", "ꞡ": "g", "ᵹ": "g", "ꝿ": "g", "ⓗ": "h", "ｈ": "h", "ĥ": "h", "ḣ": "h", "ḧ": "h", "ȟ": "h", "ḥ": "h", "ḩ": "h", "ḫ": "h", "ẖ": "h", "ħ": "h", "ⱨ": "h", "ⱶ": "h", "ɥ": "h", "ƕ": "hv", "ⓘ": "i", "ｉ": "i", "ì": "i", "í": "i", "î": "i", "ĩ": "i", "ī": "i", "ĭ": "i", "ï": "i", "ḯ": "i", "ỉ": "i", "ǐ": "i", "ȉ": "i", "ȋ": "i", "ị": "i", "į": "i", "ḭ": "i", "ɨ": "i", "ı": "i", "ⓙ": "j", "ｊ": "j", "ĵ": "j", "ǰ": "j", "ɉ": "j", "ⓚ": "k", "ｋ": "k", "ḱ": "k", "ǩ": "k", "ḳ": "k", "ķ": "k", "ḵ": "k", "ƙ": "k", "ⱪ": "k", "ꝁ": "k", "ꝃ": "k", "ꝅ": "k", "ꞣ": "k", "ⓛ": "l", "ｌ": "l", "ŀ": "l", "ĺ": "l", "ľ": "l", "ḷ": "l", "ḹ": "l", "ļ": "l", "ḽ": "l", "ḻ": "l", "ſ": "l", "ł": "l", "ƚ": "l", "ɫ": "l", "ⱡ": "l", "ꝉ": "l", "ꞁ": "l", "ꝇ": "l", "ǉ": "lj", "ⓜ": "m", "ｍ": "m", "ḿ": "m", "ṁ": "m", "ṃ": "m", "ɱ": "m", "ɯ": "m", "ⓝ": "n", "ｎ": "n", "ǹ": "n", "ń": "n", "ñ": "n", "ṅ": "n", "ň": "n", "ṇ": "n", "ņ": "n", "ṋ": "n", "ṉ": "n", "ƞ": "n", "ɲ": "n", "ŉ": "n", "ꞑ": "n", "ꞥ": "n", "ǌ": "nj", "ⓞ": "o", "ｏ": "o", "ò": "o", "ó": "o", "ô": "o", "ồ": "o", "ố": "o", "ỗ": "o", "ổ": "o", "õ": "o", "ṍ": "o", "ȭ": "o", "ṏ": "o", "ō": "o", "ṑ": "o", "ṓ": "o", "ŏ": "o", "ȯ": "o", "ȱ": "o", "ö": "o", "ȫ": "o", "ỏ": "o", "ő": "o", "ǒ": "o", "ȍ": "o", "ȏ": "o", "ơ": "o", "ờ": "o", "ớ": "o", "ỡ": "o", "ở": "o", "ợ": "o", "ọ": "o", "ộ": "o", "ǫ": "o", "ǭ": "o", "ø": "o", "ǿ": "o", "ɔ": "o", "ꝋ": "o", "ꝍ": "o", "ɵ": "o", "œ": "oe", "ƣ": "oi", "ȣ": "ou", "ꝏ": "oo", "ⓟ": "p", "ｐ": "p", "ṕ": "p", "ṗ": "p", "ƥ": "p", "ᵽ": "p", "ꝑ": "p", "ꝓ": "p", "ꝕ": "p", "ⓠ": "q", "ｑ": "q", "ɋ": "q", "ꝗ": "q", "ꝙ": "q", "ⓡ": "r", "ｒ": "r", "ŕ": "r", "ṙ": "r", "ř": "r", "ȑ": "r", "ȓ": "r", "ṛ": "r", "ṝ": "r", "ŗ": "r", "ṟ": "r", "ɍ": "r", "ɽ": "r", "ꝛ": "r", "ꞧ": "r", "ꞃ": "r", "ⓢ": "s", "ｓ": "s", "ß": "s", "ś": "s", "ṥ": "s", "ŝ": "s", "ṡ": "s", "š": "s", "ṧ": "s", "ṣ": "s", "ṩ": "s", "ș": "s", "ş": "s", "ȿ": "s", "ꞩ": "s", "ꞅ": "s", "ẛ": "s", "ⓣ": "t", "ｔ": "t", "ṫ": "t", "ẗ": "t", "ť": "t", "ṭ": "t", "ț": "t", "ţ": "t", "ṱ": "t", "ṯ": "t", "ŧ": "t", "ƭ": "t", "ʈ": "t", "ⱦ": "t", "ꞇ": "t", "ꜩ": "tz", "ⓤ": "u", "ｕ": "u", "ù": "u", "ú": "u", "û": "u", "ũ": "u", "ṹ": "u", "ū": "u", "ṻ": "u", "ŭ": "u", "ü": "u", "ǜ": "u", "ǘ": "u", "ǖ": "u", "ǚ": "u", "ủ": "u", "ů": "u", "ű": "u", "ǔ": "u", "ȕ": "u", "ȗ": "u", "ư": "u", "ừ": "u", "ứ": "u", "ữ": "u", "ử": "u", "ự": "u", "ụ": "u", "ṳ": "u", "ų": "u", "ṷ": "u", "ṵ": "u", "ʉ": "u", "ⓥ": "v", "ｖ": "v", "ṽ": "v", "ṿ": "v", "ʋ": "v", "ꝟ": "v", "ʌ": "v", "ꝡ": "vy", "ⓦ": "w", "ｗ": "w", "ẁ": "w", "ẃ": "w", "ŵ": "w", "ẇ": "w", "ẅ": "w", "ẘ": "w", "ẉ": "w", "ⱳ": "w", "ⓧ": "x", "ｘ": "x", "ẋ": "x", "ẍ": "x", "ⓨ": "y", "ｙ": "y", "ỳ": "y", "ý": "y", "ŷ": "y", "ỹ": "y", "ȳ": "y", "ẏ": "y", "ÿ": "y", "ỷ": "y", "ẙ": "y", "ỵ": "y", "ƴ": "y", "ɏ": "y", "ỿ": "y", "ⓩ": "z", "ｚ": "z", "ź": "z", "ẑ": "z", "ż": "z", "ž": "z", "ẓ": "z", "ẕ": "z", "ƶ": "z", "ȥ": "z", "ɀ": "z", "ⱬ": "z", "ꝣ": "z", "Ά": "Α", "Έ": "Ε", "Ή": "Η", "Ί": "Ι", "Ϊ": "Ι", "Ό": "Ο", "Ύ": "Υ", "Ϋ": "Υ", "Ώ": "Ω", "ά": "α", "έ": "ε", "ή": "η", "ί": "ι", "ϊ": "ι", "ΐ": "ι", "ό": "ο", "ύ": "υ", "ϋ": "υ", "ΰ": "υ", "ώ": "ω", "ς": "σ", "’": "'" } }), u.define("select2/data/base", ["../utils"], function (n) { function s(e, t) { s.__super__.constructor.call(this) } return n.Extend(s, n.Observable), s.prototype.current = function (e) { throw new Error("The `current` method must be defined in child classes.") }, s.prototype.query = function (e, t) { throw new Error("The `query` method must be defined in child classes.") }, s.prototype.bind = function (e, t) { }, s.prototype.destroy = function () { }, s.prototype.generateResultId = function (e, t) { e = e.id + "-result-"; return e += n.generateChars(4), null != t.id ? e += "-" + t.id.toString() : e += "-" + n.generateChars(4), e }, s }), u.define("select2/data/select", ["./base", "../utils", "jquery"], function (e, a, l) { function n(e, t) { this.$element = e, this.options = t, n.__super__.constructor.call(this) } return a.Extend(n, e), n.prototype.current = function (e) { var t = this; e(Array.prototype.map.call(this.$element[0].querySelectorAll(":checked"), function (e) { return t.item(l(e)) })) }, n.prototype.select = function (i) { var e, r = this; if (i.selected = !0, null != i.element && "option" === i.element.tagName.toLowerCase()) return i.element.selected = !0, void this.$element.trigger("input").trigger("change"); this.$element.prop("multiple") ? this.current(function (e) { var t = []; (i = [i]).push.apply(i, e); for (var n = 0; n < i.length; n++) { var s = i[n].id; -1 === t.indexOf(s) && t.push(s) } r.$element.val(t), r.$element.trigger("input").trigger("change") }) : (e = i.id, this.$element.val(e), this.$element.trigger("input").trigger("change")) }, n.prototype.unselect = function (i) { var r = this; if (this.$element.prop("multiple")) { if (i.selected = !1, null != i.element && "option" === i.element.tagName.toLowerCase()) return i.element.selected = !1, void this.$element.trigger("input").trigger("change"); this.current(function (e) { for (var t = [], n = 0; n < e.length; n++) { var s = e[n].id; s !== i.id && -1 === t.indexOf(s) && t.push(s) } r.$element.val(t), r.$element.trigger("input").trigger("change") }) } }, n.prototype.bind = function (e, t) { var n = this; (this.container = e).on("select", function (e) { n.select(e.data) }), e.on("unselect", function (e) { n.unselect(e.data) }) }, n.prototype.destroy = function () { this.$element.find("*").each(function () { a.RemoveData(this) }) }, n.prototype.query = function (t, e) { var n = [], s = this; this.$element.children().each(function () { var e; "option" !== this.tagName.toLowerCase() && "optgroup" !== this.tagName.toLowerCase() || (e = l(this), e = s.item(e), null !== (e = s.matches(t, e)) && n.push(e)) }), e({ results: n }) }, n.prototype.addOptions = function (e) { this.$element.append(e) }, n.prototype.option = function (e) { var t; e.children ? (t = document.createElement("optgroup")).label = e.text : void 0 !== (t = document.createElement("option")).textContent ? t.textContent = e.text : t.innerText = e.text, void 0 !== e.id && (t.value = e.id), e.disabled && (t.disabled = !0), e.selected && (t.selected = !0), e.title && (t.title = e.title); e = this._normalizeItem(e); return e.element = t, a.StoreData(t, "data", e), l(t) }, n.prototype.item = function (e) { var t = {}; if (null != (t = a.GetData(e[0], "data"))) return t; var n = e[0]; if ("option" === n.tagName.toLowerCase()) t = { id: e.val(), text: e.text(), disabled: e.prop("disabled"), selected: e.prop("selected"), title: e.prop("title") }; else if ("optgroup" === n.tagName.toLowerCase()) { t = { text: e.prop("label"), children: [], title: e.prop("title") }; for (var s = e.children("option"), i = [], r = 0; r < s.length; r++) { var o = l(s[r]), o = this.item(o); i.push(o) } t.children = i } return (t = this._normalizeItem(t)).element = e[0], a.StoreData(e[0], "data", t), t }, n.prototype._normalizeItem = function (e) { e !== Object(e) && (e = { id: e, text: e }); return null != (e = l.extend({}, { text: "" }, e)).id && (e.id = e.id.toString()), null != e.text && (e.text = e.text.toString()), null == e._resultId && e.id && null != this.container && (e._resultId = this.generateResultId(this.container, e)), l.extend({}, { selected: !1, disabled: !1 }, e) }, n.prototype.matches = function (e, t) { return this.options.get("matcher")(e, t) }, n }), u.define("select2/data/array", ["./select", "../utils", "jquery"], function (e, t, c) { function s(e, t) { this._dataToConvert = t.get("data") || [], s.__super__.constructor.call(this, e, t) } return t.Extend(s, e), s.prototype.bind = function (e, t) { s.__super__.bind.call(this, e, t), this.addOptions(this.convertToOptions(this._dataToConvert)) }, s.prototype.select = function (n) { var e = this.$element.find("option").filter(function (e, t) { return t.value == n.id.toString() }); 0 === e.length && (e = this.option(n), this.addOptions(e)), s.__super__.select.call(this, n) }, s.prototype.convertToOptions = function (e) { var t = this, n = this.$element.find("option"), s = n.map(function () { return t.item(c(this)).id }).get(), i = []; for (var r = 0; r < e.length; r++) { var o, a, l = this._normalizeItem(e[r]); 0 <= s.indexOf(l.id) ? (o = n.filter(function (e) { return function () { return c(this).val() == e.id } }(l)), a = this.item(o), a = c.extend(!0, {}, l, a), a = this.option(a), o.replaceWith(a)) : (a = this.option(l), l.children && (l = this.convertToOptions(l.children), a.append(l)), i.push(a)) } return i }, s }), u.define("select2/data/ajax", ["./array", "../utils", "jquery"], function (e, t, r) { function n(e, t) { this.ajaxOptions = this._applyDefaults(t.get("ajax")), null != this.ajaxOptions.processResults && (this.processResults = this.ajaxOptions.processResults), n.__super__.constructor.call(this, e, t) } return t.Extend(n, e), n.prototype._applyDefaults = function (e) { var t = { data: function (e) { return r.extend({}, e, { q: e.term }) }, transport: function (e, t, n) { e = r.ajax(e); return e.then(t), e.fail(n), e } }; return r.extend({}, t, e, !0) }, n.prototype.processResults = function (e) { return e }, n.prototype.query = function (t, n) { var s = this; null != this._request && ("function" == typeof this._request.abort && this._request.abort(), this._request = null); var i = r.extend({ type: "GET" }, this.ajaxOptions); function e() { var e = i.transport(i, function (e) { e = s.processResults(e, t); s.options.get("debug") && window.console && console.error && (e && e.results && Array.isArray(e.results) || console.error("Select2: The AJAX results did not return an array in the `results` key of the response.")), n(e) }, function () { "status" in e && (0 === e.status || "0" === e.status) || s.trigger("results:message", { message: "errorLoading" }) }); s._request = e } "function" == typeof i.url && (i.url = i.url.call(this.$element, t)), "function" == typeof i.data && (i.data = i.data.call(this.$element, t)), this.ajaxOptions.delay && null != t.term ? (this._queryTimeout && window.clearTimeout(this._queryTimeout), this._queryTimeout = window.setTimeout(e, this.ajaxOptions.delay)) : e() }, n }), u.define("select2/data/tags", ["jquery"], function (t) { function e(e, t, n) { var s = n.get("tags"), i = n.get("createTag"); void 0 !== i && (this.createTag = i); i = n.get("insertTag"); if (void 0 !== i && (this.insertTag = i), e.call(this, t, n), Array.isArray(s)) for (var r = 0; r < s.length; r++) { var o = s[r], o = this._normalizeItem(o), o = this.option(o); this.$element.append(o) } } return e.prototype.query = function (e, c, u) { var d = this; this._removeOldTags(), null != c.term && null == c.page ? e.call(this, c, function e(t, n) { for (var s = t.results, i = 0; i < s.length; i++) { var r = s[i], o = null != r.children && !e({ results: r.children }, !0); if ((r.text || "").toUpperCase() === (c.term || "").toUpperCase() || o) return !n && (t.data = s, void u(t)) } if (n) return !0; var a, l = d.createTag(c); null != l && ((a = d.option(l)).attr("data-select2-tag", "true"), d.addOptions([a]), d.insertTag(s, l)), t.results = s, u(t) }) : e.call(this, c, u) }, e.prototype.createTag = function (e, t) { if (null == t.term) return null; t = t.term.trim(); return "" === t ? null : { id: t, text: t } }, e.prototype.insertTag = function (e, t, n) { t.unshift(n) }, e.prototype._removeOldTags = function (e) { this.$element.find("option[data-select2-tag]").each(function () { this.selected || t(this).remove() }) }, e }), u.define("select2/data/tokenizer", ["jquery"], function (c) { function e(e, t, n) { var s = n.get("tokenizer"); void 0 !== s && (this.tokenizer = s), e.call(this, t, n) } return e.prototype.bind = function (e, t, n) { e.call(this, t, n), this.$search = t.dropdown.$search || t.selection.$search || n.find(".select2-search__field") }, e.prototype.query = function (e, t, n) { var s = this; t.term = t.term || ""; var i = this.tokenizer(t, this.options, function (e) { var t, n = s._normalizeItem(e); s.$element.find("option").filter(function () { return c(this).val() === n.id }).length || ((t = s.option(n)).attr("data-select2-tag", !0), s._removeOldTags(), s.addOptions([t])), t = n, s.trigger("select", { data: t }) }); i.term !== t.term && (this.$search.length && (this.$search.val(i.term), this.$search.trigger("focus")), t.term = i.term), e.call(this, t, n) }, e.prototype.tokenizer = function (e, t, n, s) { for (var i = n.get("tokenSeparators") || [], r = t.term, o = 0, a = this.createTag || function (e) { return { id: e.term, text: e.term } }; o < r.length;) { var l = r[o]; -1 !== i.indexOf(l) ? (l = r.substr(0, o), null != (l = a(c.extend({}, t, { term: l }))) ? (s(l), r = r.substr(o + 1) || "", o = 0) : o++) : o++ } return { term: r } }, e }), u.define("select2/data/minimumInputLength", [], function () { function e(e, t, n) { this.minimumInputLength = n.get("minimumInputLength"), e.call(this, t, n) } return e.prototype.query = function (e, t, n) { t.term = t.term || "", t.term.length < this.minimumInputLength ? this.trigger("results:message", { message: "inputTooShort", args: { minimum: this.minimumInputLength, input: t.term, params: t } }) : e.call(this, t, n) }, e }), u.define("select2/data/maximumInputLength", [], function () { function e(e, t, n) { this.maximumInputLength = n.get("maximumInputLength"), e.call(this, t, n) } return e.prototype.query = function (e, t, n) { t.term = t.term || "", 0 < this.maximumInputLength && t.term.length > this.maximumInputLength ? this.trigger("results:message", { message: "inputTooLong", args: { maximum: this.maximumInputLength, input: t.term, params: t } }) : e.call(this, t, n) }, e }), u.define("select2/data/maximumSelectionLength", [], function () { function e(e, t, n) { this.maximumSelectionLength = n.get("maximumSelectionLength"), e.call(this, t, n) } return e.prototype.bind = function (e, t, n) { var s = this; e.call(this, t, n), t.on("select", function () { s._checkIfMaximumSelected() }) }, e.prototype.query = function (e, t, n) { var s = this; this._checkIfMaximumSelected(function () { e.call(s, t, n) }) }, e.prototype._checkIfMaximumSelected = function (e, t) { var n = this; this.current(function (e) { e = null != e ? e.length : 0; 0 < n.maximumSelectionLength && e >= n.maximumSelectionLength ? n.trigger("results:message", { message: "maximumSelected", args: { maximum: n.maximumSelectionLength } }) : t && t() }) }, e }), u.define("select2/dropdown", ["jquery", "./utils"], function (t, e) { function n(e, t) { this.$element = e, this.options = t, n.__super__.constructor.call(this) } return e.Extend(n, e.Observable), n.prototype.render = function () { var e = t('<span class="select2-dropdown"><span class="select2-results"></span></span>'); return e.attr("dir", this.options.get("dir")), this.$dropdown = e }, n.prototype.bind = function () { }, n.prototype.position = function (e, t) { }, n.prototype.destroy = function () { this.$dropdown.remove() }, n }), u.define("select2/dropdown/search", ["jquery"], function (r) { function e() { } return e.prototype.render = function (e) { var t = e.call(this), n = this.options.get("translations").get("search"), e = r('<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></span>'); return this.$searchContainer = e, this.$search = e.find("input"), this.$search.prop("autocomplete", this.options.get("autocomplete")), this.$search.attr("aria-label", n()), t.prepend(e), t }, e.prototype.bind = function (e, t, n) { var s = this, i = t.id + "-results"; e.call(this, t, n), this.$search.on("keydown", function (e) { s.trigger("keypress", e), s._keyUpPrevented = e.isDefaultPrevented() }), this.$search.on("input", function (e) { r(this).off("keyup") }), this.$search.on("keyup input", function (e) { s.handleSearch(e) }), t.on("open", function () { s.$search.attr("tabindex", 0), s.$search.attr("aria-controls", i), s.$search.trigger("focus"), window.setTimeout(function () { s.$search.trigger("focus") }, 0) }), t.on("close", function () { s.$search.attr("tabindex", -1), s.$search.removeAttr("aria-controls"), s.$search.removeAttr("aria-activedescendant"), s.$search.val(""), s.$search.trigger("blur") }), t.on("focus", function () { t.isOpen() || s.$search.trigger("focus") }), t.on("results:all", function (e) { null != e.query.term && "" !== e.query.term || (s.showSearch(e) ? s.$searchContainer[0].classList.remove("select2-search--hide") : s.$searchContainer[0].classList.add("select2-search--hide")) }), t.on("results:focus", function (e) { e.data._resultId ? s.$search.attr("aria-activedescendant", e.data._resultId) : s.$search.removeAttr("aria-activedescendant") }) }, e.prototype.handleSearch = function (e) { var t; this._keyUpPrevented || (t = this.$search.val(), this.trigger("query", { term: t })), this._keyUpPrevented = !1 }, e.prototype.showSearch = function (e, t) { return !0 }, e }), u.define("select2/dropdown/hidePlaceholder", [], function () { function e(e, t, n, s) { this.placeholder = this.normalizePlaceholder(n.get("placeholder")), e.call(this, t, n, s) } return e.prototype.append = function (e, t) { t.results = this.removePlaceholder(t.results), e.call(this, t) }, e.prototype.normalizePlaceholder = function (e, t) { return "string" == typeof t && (t = { id: "", text: t }), t }, e.prototype.removePlaceholder = function (e, t) { for (var n = t.slice(0), s = t.length - 1; 0 <= s; s--) { var i = t[s]; this.placeholder.id === i.id && n.splice(s, 1) } return n }, e }), u.define("select2/dropdown/infiniteScroll", ["jquery"], function (n) { function e(e, t, n, s) { this.lastParams = {}, e.call(this, t, n, s), this.$loadingMore = this.createLoadingMore(), this.loading = !1 } return e.prototype.append = function (e, t) { this.$loadingMore.remove(), this.loading = !1, e.call(this, t), this.showLoadingMore(t) && (this.$results.append(this.$loadingMore), this.loadMoreIfNeeded()) }, e.prototype.bind = function (e, t, n) { var s = this; e.call(this, t, n), t.on("query", function (e) { s.lastParams = e, s.loading = !0 }), t.on("query:append", function (e) { s.lastParams = e, s.loading = !0 }), this.$results.on("scroll", this.loadMoreIfNeeded.bind(this)) }, e.prototype.loadMoreIfNeeded = function () { var e = n.contains(document.documentElement, this.$loadingMore[0]); !this.loading && e && (e = this.$results.offset().top + this.$results.outerHeight(!1), this.$loadingMore.offset().top + this.$loadingMore.outerHeight(!1) <= e + 50 && this.loadMore()) }, e.prototype.loadMore = function () { this.loading = !0; var e = n.extend({}, { page: 1 }, this.lastParams); e.page++, this.trigger("query:append", e) }, e.prototype.showLoadingMore = function (e, t) { return t.pagination && t.pagination.more }, e.prototype.createLoadingMore = function () { var e = n('<li class="select2-results__option select2-results__option--load-more"role="option" aria-disabled="true"></li>'), t = this.options.get("translations").get("loadingMore"); return e.html(t(this.lastParams)), e }, e }), u.define("select2/dropdown/attachBody", ["jquery", "../utils"], function (u, o) { function e(e, t, n) { this.$dropdownParent = u(n.get("dropdownParent") || document.body), e.call(this, t, n) } return e.prototype.bind = function (e, t, n) { var s = this; e.call(this, t, n), t.on("open", function () { s._showDropdown(), s._attachPositioningHandler(t), s._bindContainerResultHandlers(t) }), t.on("close", function () { s._hideDropdown(), s._detachPositioningHandler(t) }), this.$dropdownContainer.on("mousedown", function (e) { e.stopPropagation() }) }, e.prototype.destroy = function (e) { e.call(this), this.$dropdownContainer.remove() }, e.prototype.position = function (e, t, n) { t.attr("class", n.attr("class")), t[0].classList.remove("select2"), t[0].classList.add("select2-container--open"), t.css({ position: "absolute", top: -999999 }), this.$container = n }, e.prototype.render = function (e) { var t = u("<span></span>"), e = e.call(this); return t.append(e), this.$dropdownContainer = t }, e.prototype._hideDropdown = function (e) { this.$dropdownContainer.detach() }, e.prototype._bindContainerResultHandlers = function (e, t) { var n; this._containerResultsHandlersBound || (n = this, t.on("results:all", function () { n._positionDropdown(), n._resizeDropdown() }), t.on("results:append", function () { n._positionDropdown(), n._resizeDropdown() }), t.on("results:message", function () { n._positionDropdown(), n._resizeDropdown() }), t.on("select", function () { n._positionDropdown(), n._resizeDropdown() }), t.on("unselect", function () { n._positionDropdown(), n._resizeDropdown() }), this._containerResultsHandlersBound = !0) }, e.prototype._attachPositioningHandler = function (e, t) { var n = this, s = "scroll.select2." + t.id, i = "resize.select2." + t.id, r = "orientationchange.select2." + t.id, t = this.$container.parents().filter(o.hasScroll); t.each(function () { o.StoreData(this, "select2-scroll-position", { x: u(this).scrollLeft(), y: u(this).scrollTop() }) }), t.on(s, function (e) { var t = o.GetData(this, "select2-scroll-position"); u(this).scrollTop(t.y) }), u(window).on(s + " " + i + " " + r, function (e) { n._positionDropdown(), n._resizeDropdown() }) }, e.prototype._detachPositioningHandler = function (e, t) { var n = "scroll.select2." + t.id, s = "resize.select2." + t.id, t = "orientationchange.select2." + t.id; this.$container.parents().filter(o.hasScroll).off(n), u(window).off(n + " " + s + " " + t) }, e.prototype._positionDropdown = function () { var e = u(window), t = this.$dropdown[0].classList.contains("select2-dropdown--above"), n = this.$dropdown[0].classList.contains("select2-dropdown--below"), s = null, i = this.$container.offset(); i.bottom = i.top + this.$container.outerHeight(!1); var r = { height: this.$container.outerHeight(!1) }; r.top = i.top, r.bottom = i.top + r.height; var o = this.$dropdown.outerHeight(!1), a = e.scrollTop(), l = e.scrollTop() + e.height(), c = a < i.top - o, e = l > i.bottom + o, a = { left: i.left, top: r.bottom }, l = this.$dropdownParent; "static" === l.css("position") && (l = l.offsetParent()); i = { top: 0, left: 0 }; (u.contains(document.body, l[0]) || l[0].isConnected) && (i = l.offset()), a.top -= i.top, a.left -= i.left, t || n || (s = "below"), e || !c || t ? !c && e && t && (s = "below") : s = "above", ("above" == s || t && "below" !== s) && (a.top = r.top - i.top - o), null != s && (this.$dropdown[0].classList.remove("select2-dropdown--below"), this.$dropdown[0].classList.remove("select2-dropdown--above"), this.$dropdown[0].classList.add("select2-dropdown--" + s), this.$container[0].classList.remove("select2-container--below"), this.$container[0].classList.remove("select2-container--above"), this.$container[0].classList.add("select2-container--" + s)), this.$dropdownContainer.css(a) }, e.prototype._resizeDropdown = function () { var e = { width: this.$container.outerWidth(!1) + "px" }; this.options.get("dropdownAutoWidth") && (e.minWidth = e.width, e.position = "relative", e.width = "auto"), this.$dropdown.css(e) }, e.prototype._showDropdown = function (e) { this.$dropdownContainer.appendTo(this.$dropdownParent), this._positionDropdown(), this._resizeDropdown() }, e }), u.define("select2/dropdown/minimumResultsForSearch", [], function () { function e(e, t, n, s) { this.minimumResultsForSearch = n.get("minimumResultsForSearch"), this.minimumResultsForSearch < 0 && (this.minimumResultsForSearch = 1 / 0), e.call(this, t, n, s) } return e.prototype.showSearch = function (e, t) { return !(function e(t) { for (var n = 0, s = 0; s < t.length; s++) { var i = t[s]; i.children ? n += e(i.children) : n++ } return n }(t.data.results) < this.minimumResultsForSearch) && e.call(this, t) }, e }), u.define("select2/dropdown/selectOnClose", ["../utils"], function (s) { function e() { } return e.prototype.bind = function (e, t, n) { var s = this; e.call(this, t, n), t.on("close", function (e) { s._handleSelectOnClose(e) }) }, e.prototype._handleSelectOnClose = function (e, t) { if (t && null != t.originalSelect2Event) { var n = t.originalSelect2Event; if ("select" === n._type || "unselect" === n._type) return } n = this.getHighlightedResults(); n.length < 1 || (null != (n = s.GetData(n[0], "data")).element && n.element.selected || null == n.element && n.selected || this.trigger("select", { data: n })) }, e }), u.define("select2/dropdown/closeOnSelect", [], function () { function e() { } return e.prototype.bind = function (e, t, n) { var s = this; e.call(this, t, n), t.on("select", function (e) { s._selectTriggered(e) }), t.on("unselect", function (e) { s._selectTriggered(e) }) }, e.prototype._selectTriggered = function (e, t) { var n = t.originalEvent; n && (n.ctrlKey || n.metaKey) || this.trigger("close", { originalEvent: n, originalSelect2Event: t }) }, e }), u.define("select2/dropdown/dropdownCss", ["../utils"], function (n) { function e() { } return e.prototype.render = function (e) { var t = e.call(this), e = this.options.get("dropdownCssClass") || ""; return -1 !== e.indexOf(":all:") && (e = e.replace(":all:", ""), n.copyNonInternalCssClasses(t[0], this.$element[0])), t.addClass(e), t }, e }), u.define("select2/dropdown/tagsSearchHighlight", ["../utils"], function (s) { function e() { } return e.prototype.highlightFirstItem = function (e) { var t = this.$results.find(".select2-results__option--selectable:not(.select2-results__option--selected)"); if (0 < t.length) { var n = t.first(), t = s.GetData(n[0], "data").element; if (t && t.getAttribute && "true" === t.getAttribute("data-select2-tag")) return void n.trigger("mouseenter") } e.call(this) }, e }), u.define("select2/i18n/en", [], function () { return { errorLoading: function () { return "The results could not be loaded." }, inputTooLong: function (e) { var t = e.input.length - e.maximum, e = "Please delete " + t + " character"; return 1 != t && (e += "s"), e }, inputTooShort: function (e) { return "Please enter " + (e.minimum - e.input.length) + " or more characters" }, loadingMore: function () { return "Loading more results…" }, maximumSelected: function (e) { var t = "You can only select " + e.maximum + " item"; return 1 != e.maximum && (t += "s"), t }, noResults: function () { return "No results found" }, searching: function () { return "Searching…" }, removeAllItems: function () { return "Remove all items" }, removeItem: function () { return "Remove item" }, search: function () { return "Search" } } }), u.define("select2/defaults", ["jquery", "./results", "./selection/single", "./selection/multiple", "./selection/placeholder", "./selection/allowClear", "./selection/search", "./selection/selectionCss", "./selection/eventRelay", "./utils", "./translation", "./diacritics", "./data/select", "./data/array", "./data/ajax", "./data/tags", "./data/tokenizer", "./data/minimumInputLength", "./data/maximumInputLength", "./data/maximumSelectionLength", "./dropdown", "./dropdown/search", "./dropdown/hidePlaceholder", "./dropdown/infiniteScroll", "./dropdown/attachBody", "./dropdown/minimumResultsForSearch", "./dropdown/selectOnClose", "./dropdown/closeOnSelect", "./dropdown/dropdownCss", "./dropdown/tagsSearchHighlight", "./i18n/en"], function (l, r, o, a, c, u, d, p, h, f, g, t, m, y, v, _, b, $, w, x, A, D, S, E, O, C, L, T, q, I, e) { function n() { this.reset() } return n.prototype.apply = function (e) { var t; null == (e = l.extend(!0, {}, this.defaults, e)).dataAdapter && (null != e.ajax ? e.dataAdapter = v : null != e.data ? e.dataAdapter = y : e.dataAdapter = m, 0 < e.minimumInputLength && (e.dataAdapter = f.Decorate(e.dataAdapter, $)), 0 < e.maximumInputLength && (e.dataAdapter = f.Decorate(e.dataAdapter, w)), 0 < e.maximumSelectionLength && (e.dataAdapter = f.Decorate(e.dataAdapter, x)), e.tags && (e.dataAdapter = f.Decorate(e.dataAdapter, _)), null == e.tokenSeparators && null == e.tokenizer || (e.dataAdapter = f.Decorate(e.dataAdapter, b))), null == e.resultsAdapter && (e.resultsAdapter = r, null != e.ajax && (e.resultsAdapter = f.Decorate(e.resultsAdapter, E)), null != e.placeholder && (e.resultsAdapter = f.Decorate(e.resultsAdapter, S)), e.selectOnClose && (e.resultsAdapter = f.Decorate(e.resultsAdapter, L)), e.tags && (e.resultsAdapter = f.Decorate(e.resultsAdapter, I))), null == e.dropdownAdapter && (e.multiple ? e.dropdownAdapter = A : (t = f.Decorate(A, D), e.dropdownAdapter = t), 0 !== e.minimumResultsForSearch && (e.dropdownAdapter = f.Decorate(e.dropdownAdapter, C)), e.closeOnSelect && (e.dropdownAdapter = f.Decorate(e.dropdownAdapter, T)), null != e.dropdownCssClass && (e.dropdownAdapter = f.Decorate(e.dropdownAdapter, q)), e.dropdownAdapter = f.Decorate(e.dropdownAdapter, O)), null == e.selectionAdapter && (e.multiple ? e.selectionAdapter = a : e.selectionAdapter = o, null != e.placeholder && (e.selectionAdapter = f.Decorate(e.selectionAdapter, c)), e.allowClear && (e.selectionAdapter = f.Decorate(e.selectionAdapter, u)), e.multiple && (e.selectionAdapter = f.Decorate(e.selectionAdapter, d)), null != e.selectionCssClass && (e.selectionAdapter = f.Decorate(e.selectionAdapter, p)), e.selectionAdapter = f.Decorate(e.selectionAdapter, h)), e.language = this._resolveLanguage(e.language), e.language.push("en"); for (var n = [], s = 0; s < e.language.length; s++) { var i = e.language[s]; -1 === n.indexOf(i) && n.push(i) } return e.language = n, e.translations = this._processTranslations(e.language, e.debug), e }, n.prototype.reset = function () { function a(e) { return e.replace(/[^\u0000-\u007E]/g, function (e) { return t[e] || e }) } this.defaults = { amdLanguageBase: "./i18n/", autocomplete: "off", closeOnSelect: !0, debug: !1, dropdownAutoWidth: !1, escapeMarkup: f.escapeMarkup, language: {}, matcher: function e(t, n) { if (null == t.term || "" === t.term.trim()) return n; if (n.children && 0 < n.children.length) { for (var s = l.extend(!0, {}, n), i = n.children.length - 1; 0 <= i; i--)null == e(t, n.children[i]) && s.children.splice(i, 1); return 0 < s.children.length ? s : e(t, s) } var r = a(n.text).toUpperCase(), o = a(t.term).toUpperCase(); return -1 < r.indexOf(o) ? n : null }, minimumInputLength: 0, maximumInputLength: 0, maximumSelectionLength: 0, minimumResultsForSearch: 0, selectOnClose: !1, scrollAfterSelect: !1, sorter: function (e) { return e }, templateResult: function (e) { return e.text }, templateSelection: function (e) { return e.text }, theme: "default", width: "resolve" } }, n.prototype.applyFromElement = function (e, t) { var n = e.language, s = this.defaults.language, i = t.prop("lang"), t = t.closest("[lang]").prop("lang"), t = Array.prototype.concat.call(this._resolveLanguage(i), this._resolveLanguage(n), this._resolveLanguage(s), this._resolveLanguage(t)); return e.language = t, e }, n.prototype._resolveLanguage = function (e) { if (!e) return []; if (l.isEmptyObject(e)) return []; if (l.isPlainObject(e)) return [e]; for (var t, n = Array.isArray(e) ? e : [e], s = [], i = 0; i < n.length; i++)s.push(n[i]), "string" == typeof n[i] && 0 < n[i].indexOf("-") && (t = n[i].split("-")[0], s.push(t)); return s }, n.prototype._processTranslations = function (e, t) { for (var n = new g, s = 0; s < e.length; s++) { var i = new g, r = e[s]; if ("string" == typeof r) try { i = g.loadPath(r) } catch (e) { try { r = this.defaults.amdLanguageBase + r, i = g.loadPath(r) } catch (e) { t && window.console && console.warn && console.warn('Select2: The language file for "' + r + '" could not be automatically loaded. A fallback will be used instead.') } } else i = l.isPlainObject(r) ? new g(r) : r; n.extend(i) } return n }, n.prototype.set = function (e, t) { var n = {}; n[l.camelCase(e)] = t; n = f._convertData(n); l.extend(!0, this.defaults, n) }, new n }), u.define("select2/options", ["jquery", "./defaults", "./utils"], function (c, n, u) { function e(e, t) { this.options = e, null != t && this.fromElement(t), null != t && (this.options = n.applyFromElement(this.options, t)), this.options = n.apply(this.options) } return e.prototype.fromElement = function (e) { var t = ["select2"]; null == this.options.multiple && (this.options.multiple = e.prop("multiple")), null == this.options.disabled && (this.options.disabled = e.prop("disabled")), null == this.options.autocomplete && e.prop("autocomplete") && (this.options.autocomplete = e.prop("autocomplete")), null == this.options.dir && (e.prop("dir") ? this.options.dir = e.prop("dir") : e.closest("[dir]").prop("dir") ? this.options.dir = e.closest("[dir]").prop("dir") : this.options.dir = "ltr"), e.prop("disabled", this.options.disabled), e.prop("multiple", this.options.multiple), u.GetData(e[0], "select2Tags") && (this.options.debug && window.console && console.warn && console.warn('Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'), u.StoreData(e[0], "data", u.GetData(e[0], "select2Tags")), u.StoreData(e[0], "tags", !0)), u.GetData(e[0], "ajaxUrl") && (this.options.debug && window.console && console.warn && console.warn("Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."), e.attr("ajax--url", u.GetData(e[0], "ajaxUrl")), u.StoreData(e[0], "ajax-Url", u.GetData(e[0], "ajaxUrl"))); var n = {}; function s(e, t) { return t.toUpperCase() } for (var i = 0; i < e[0].attributes.length; i++) { var r = e[0].attributes[i].name, o = "data-"; r.substr(0, o.length) == o && (r = r.substring(o.length), o = u.GetData(e[0], r), n[r.replace(/-([a-z])/g, s)] = o) } c.fn.jquery && "1." == c.fn.jquery.substr(0, 2) && e[0].dataset && (n = c.extend(!0, {}, e[0].dataset, n)); var a, l = c.extend(!0, {}, u.GetData(e[0]), n); for (a in l = u._convertData(l)) -1 < t.indexOf(a) || (c.isPlainObject(this.options[a]) ? c.extend(this.options[a], l[a]) : this.options[a] = l[a]); return this }, e.prototype.get = function (e) { return this.options[e] }, e.prototype.set = function (e, t) { this.options[e] = t }, e }), u.define("select2/core", ["jquery", "./options", "./utils", "./keys"], function (t, i, r, s) { var o = function (e, t) { null != r.GetData(e[0], "select2") && r.GetData(e[0], "select2").destroy(), this.$element = e, this.id = this._generateId(e), t = t || {}, this.options = new i(t, e), o.__super__.constructor.call(this); var n = e.attr("tabindex") || 0; r.StoreData(e[0], "old-tabindex", n), e.attr("tabindex", "-1"); t = this.options.get("dataAdapter"); this.dataAdapter = new t(e, this.options); n = this.render(); this._placeContainer(n); t = this.options.get("selectionAdapter"); this.selection = new t(e, this.options), this.$selection = this.selection.render(), this.selection.position(this.$selection, n); t = this.options.get("dropdownAdapter"); this.dropdown = new t(e, this.options), this.$dropdown = this.dropdown.render(), this.dropdown.position(this.$dropdown, n); n = this.options.get("resultsAdapter"); this.results = new n(e, this.options, this.dataAdapter), this.$results = this.results.render(), this.results.position(this.$results, this.$dropdown); var s = this; this._bindAdapters(), this._registerDomEvents(), this._registerDataEvents(), this._registerSelectionEvents(), this._registerDropdownEvents(), this._registerResultsEvents(), this._registerEvents(), this.dataAdapter.current(function (e) { s.trigger("selection:update", { data: e }) }), e[0].classList.add("select2-hidden-accessible"), e.attr("aria-hidden", "true"), this._syncAttributes(), r.StoreData(e[0], "select2", this), e.data("select2", this) }; return r.Extend(o, r.Observable), o.prototype._generateId = function (e) { return "select2-" + (null != e.attr("id") ? e.attr("id") : null != e.attr("name") ? e.attr("name") + "-" + r.generateChars(2) : r.generateChars(4)).replace(/(:|\.|\[|\]|,)/g, "") }, o.prototype._placeContainer = function (e) { e.insertAfter(this.$element); var t = this._resolveWidth(this.$element, this.options.get("width")); null != t && e.css("width", t) }, o.prototype._resolveWidth = function (e, t) { var n = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i; if ("resolve" == t) { var s = this._resolveWidth(e, "style"); return null != s ? s : this._resolveWidth(e, "element") } if ("element" == t) { s = e.outerWidth(!1); return s <= 0 ? "auto" : s + "px" } if ("style" != t) return "computedstyle" != t ? t : window.getComputedStyle(e[0]).width; e = e.attr("style"); if ("string" != typeof e) return null; for (var i = e.split(";"), r = 0, o = i.length; r < o; r += 1) { var a = i[r].replace(/\s/g, "").match(n); if (null !== a && 1 <= a.length) return a[1] } return null }, o.prototype._bindAdapters = function () { this.dataAdapter.bind(this, this.$container), this.selection.bind(this, this.$container), this.dropdown.bind(this, this.$container), this.results.bind(this, this.$container) }, o.prototype._registerDomEvents = function () { var t = this; this.$element.on("change.select2", function () { t.dataAdapter.current(function (e) { t.trigger("selection:update", { data: e }) }) }), this.$element.on("focus.select2", function (e) { t.trigger("focus", e) }), this._syncA = r.bind(this._syncAttributes, this), this._syncS = r.bind(this._syncSubtree, this), this._observer = new window.MutationObserver(function (e) { t._syncA(), t._syncS(e) }), this._observer.observe(this.$element[0], { attributes: !0, childList: !0, subtree: !1 }) }, o.prototype._registerDataEvents = function () { var n = this; this.dataAdapter.on("*", function (e, t) { n.trigger(e, t) }) }, o.prototype._registerSelectionEvents = function () { var n = this, s = ["toggle", "focus"]; this.selection.on("toggle", function () { n.toggleDropdown() }), this.selection.on("focus", function (e) { n.focus(e) }), this.selection.on("*", function (e, t) { -1 === s.indexOf(e) && n.trigger(e, t) }) }, o.prototype._registerDropdownEvents = function () { var n = this; this.dropdown.on("*", function (e, t) { n.trigger(e, t) }) }, o.prototype._registerResultsEvents = function () { var n = this; this.results.on("*", function (e, t) { n.trigger(e, t) }) }, o.prototype._registerEvents = function () { var n = this; this.on("open", function () { n.$container[0].classList.add("select2-container--open") }), this.on("close", function () { n.$container[0].classList.remove("select2-container--open") }), this.on("enable", function () { n.$container[0].classList.remove("select2-container--disabled") }), this.on("disable", function () { n.$container[0].classList.add("select2-container--disabled") }), this.on("blur", function () { n.$container[0].classList.remove("select2-container--focus") }), this.on("query", function (t) { n.isOpen() || n.trigger("open", {}), this.dataAdapter.query(t, function (e) { n.trigger("results:all", { data: e, query: t }) }) }), this.on("query:append", function (t) { this.dataAdapter.query(t, function (e) { n.trigger("results:append", { data: e, query: t }) }) }), this.on("keypress", function (e) { var t = e.which; n.isOpen() ? t === s.ESC || t === s.UP && e.altKey ? (n.close(e), e.preventDefault()) : t === s.ENTER || t === s.TAB ? (n.trigger("results:select", {}), e.preventDefault()) : t === s.SPACE && e.ctrlKey ? (n.trigger("results:toggle", {}), e.preventDefault()) : t === s.UP ? (n.trigger("results:previous", {}), e.preventDefault()) : t === s.DOWN && (n.trigger("results:next", {}), e.preventDefault()) : (t === s.ENTER || t === s.SPACE || t === s.DOWN && e.altKey) && (n.open(), e.preventDefault()) }) }, o.prototype._syncAttributes = function () { this.options.set("disabled", this.$element.prop("disabled")), this.isDisabled() ? (this.isOpen() && this.close(), this.trigger("disable", {})) : this.trigger("enable", {}) }, o.prototype._isChangeMutation = function (e) { var t = this; if (e.addedNodes && 0 < e.addedNodes.length) { for (var n = 0; n < e.addedNodes.length; n++)if (e.addedNodes[n].selected) return !0 } else { if (e.removedNodes && 0 < e.removedNodes.length) return !0; if (Array.isArray(e)) return e.some(function (e) { return t._isChangeMutation(e) }) } return !1 }, o.prototype._syncSubtree = function (e) { var e = this._isChangeMutation(e), t = this; e && this.dataAdapter.current(function (e) { t.trigger("selection:update", { data: e }) }) }, o.prototype.trigger = function (e, t) { var n = o.__super__.trigger, s = { open: "opening", close: "closing", select: "selecting", unselect: "unselecting", clear: "clearing" }; if (void 0 === t && (t = {}), e in s) { var i = s[e], s = { prevented: !1, name: e, args: t }; if (n.call(this, i, s), s.prevented) return void (t.prevented = !0) } n.call(this, e, t) }, o.prototype.toggleDropdown = function () { this.isDisabled() || (this.isOpen() ? this.close() : this.open()) }, o.prototype.open = function () { this.isOpen() || this.isDisabled() || this.trigger("query", {}) }, o.prototype.close = function (e) { this.isOpen() && this.trigger("close", { originalEvent: e }) }, o.prototype.isEnabled = function () { return !this.isDisabled() }, o.prototype.isDisabled = function () { return this.options.get("disabled") }, o.prototype.isOpen = function () { return this.$container[0].classList.contains("select2-container--open") }, o.prototype.hasFocus = function () { return this.$container[0].classList.contains("select2-container--focus") }, o.prototype.focus = function (e) { this.hasFocus() || (this.$container[0].classList.add("select2-container--focus"), this.trigger("focus", {})) }, o.prototype.enable = function (e) { this.options.get("debug") && window.console && console.warn && console.warn('Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'), null != e && 0 !== e.length || (e = [!0]); e = !e[0]; this.$element.prop("disabled", e) }, o.prototype.data = function () { this.options.get("debug") && 0 < arguments.length && window.console && console.warn && console.warn('Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.'); var t = []; return this.dataAdapter.current(function (e) { t = e }), t }, o.prototype.val = function (e) { if (this.options.get("debug") && window.console && console.warn && console.warn('Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'), null == e || 0 === e.length) return this.$element.val(); e = e[0]; Array.isArray(e) && (e = e.map(function (e) { return e.toString() })), this.$element.val(e).trigger("input").trigger("change") }, o.prototype.destroy = function () { r.RemoveData(this.$container[0]), this.$container.remove(), this._observer.disconnect(), this._observer = null, this._syncA = null, this._syncS = null, this.$element.off(".select2"), this.$element.attr("tabindex", r.GetData(this.$element[0], "old-tabindex")), this.$element[0].classList.remove("select2-hidden-accessible"), this.$element.attr("aria-hidden", "false"), r.RemoveData(this.$element[0]), this.$element.removeData("select2"), this.dataAdapter.destroy(), this.selection.destroy(), this.dropdown.destroy(), this.results.destroy(), this.dataAdapter = null, this.selection = null, this.dropdown = null, this.results = null }, o.prototype.render = function () { var e = t('<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>'); return e.attr("dir", this.options.get("dir")), this.$container = e, this.$container[0].classList.add("select2-container--" + this.options.get("theme")), r.StoreData(e[0], "element", this.$element), e }, o }), u.define("jquery-mousewheel", ["jquery"], function (e) { return e }), u.define("jquery.select2", ["jquery", "jquery-mousewheel", "./select2/core", "./select2/defaults", "./select2/utils"], function (i, e, r, t, o) { var a; return null == i.fn.select2 && (a = ["open", "close", "destroy"], i.fn.select2 = function (t) { if ("object" == typeof (t = t || {})) return this.each(function () { var e = i.extend(!0, {}, t); new r(i(this), e) }), this; if ("string" != typeof t) throw new Error("Invalid arguments for Select2: " + t); var n, s = Array.prototype.slice.call(arguments, 1); return this.each(function () { var e = o.GetData(this, "select2"); null == e && window.console && console.error && console.error("The select2('" + t + "') method was called on an element that is not using Select2."), n = e[t].apply(e, s) }), -1 < a.indexOf(t) ? this : n }), null == i.fn.select2.defaults && (i.fn.select2.defaults = t), r }), { define: u.define, require: u.require }); function b(e, t) { return i.call(e, t) } function l(e, t) { var n, s, i, r, o, a, l, c, u, d, p = t && t.split("/"), h = y.map, f = h && h["*"] || {}; if (e) { for (t = (e = e.split("/")).length - 1, y.nodeIdCompat && _.test(e[t]) && (e[t] = e[t].replace(_, "")), "." === e[0].charAt(0) && p && (e = p.slice(0, p.length - 1).concat(e)), c = 0; c < e.length; c++)"." === (d = e[c]) ? (e.splice(c, 1), --c) : ".." === d && (0 === c || 1 === c && ".." === e[2] || ".." === e[c - 1] || 0 < c && (e.splice(c - 1, 2), c -= 2)); e = e.join("/") } if ((p || f) && h) { for (c = (n = e.split("/")).length; 0 < c; --c) { if (s = n.slice(0, c).join("/"), p) for (u = p.length; 0 < u; --u)if (i = h[p.slice(0, u).join("/")], i = i && i[s]) { r = i, o = c; break } if (r) break; !a && f && f[s] && (a = f[s], l = c) } !r && a && (r = a, o = l), r && (n.splice(0, o, r), e = n.join("/")) } return e } function w(t, n) { return function () { var e = a.call(arguments, 0); return "string" != typeof e[0] && 1 === e.length && e.push(null), o.apply(p, e.concat([t, n])) } } function x(e) { var t; if (b(m, e) && (t = m[e], delete m[e], v[e] = !0, r.apply(p, t)), !b(g, e) && !b(v, e)) throw new Error("No " + e); return g[e] } function c(e) { var t, n = e ? e.indexOf("!") : -1; return -1 < n && (t = e.substring(0, n), e = e.substring(n + 1, e.length)), [t, e] } function A(e) { return e ? c(e) : [] } var u = s.require("jquery.select2"); return t.fn.select2.amd = s, u });
define('uiTools/customSelect', [
  "jquery",
  "i18n/chosen",
  "UTILS",
  "customSelect",
  "chosen",
  "select2",
], function ($, i18n, Utils) {
  var eventEmitter;

  var CustomSelect = {
    init: function (context) {
      eventEmitter = ADM.eventEmitter;

      var $selects = $(context);
      var closeSelect;

      $(Utils.removeHighlightedCodeFromContext($selects)).each(function () {
        var attr = $(this).attr("multiple");
        if (typeof attr !== "undefined" && attr !== false) {
          CustomSelect.multiple(this);
        } else {
          CustomSelect.single(this);
        }
      });
    },
    single: function (elem) {
      var $el = $(elem),
        CONFIG = {
          theme: $el.attr("data-theme") || "dark",
          triggerEvent: $el.data("customselect-triggerevent") || undefined,
        };

      $el.customSelect({
        theme: CONFIG.theme,
      });

      if (typeof CONFIG.triggerEvent != "undefined") {
        $el.on("change", function () {
          var activeOpt = $(this).find(":selected");

          eventEmitter.emitEvent(CONFIG.triggerEvent, [
            "customselect-updated",
            activeOpt,
          ]);
        });
      }

      if ($(".countrySelector").siblings().find(".label").length > 0) {
        var dataCountry = $(".countrySelector").val().split("|");
        var flagCountry = dataCountry[1];
        $(".countrySelector").siblings().find(".label").remove();
        $(".countrySelector")
          .siblings()
          .prepend(
            '<span class="labelFlag"><img src="/sites/all/themes/custom/angani/images/flags/' +
            flagCountry.toLowerCase() +
            '"/></span>'
          );
      }
    },
    multiple: function (elem) {

      var $currentSelect = $(elem);

      $currentSelect.select2({
        placeholder: $currentSelect.attr("data-placeholder"),
        readonly: true,
        formatNoMatches: "",
        minimumResultsForSearch: -1,
        showSearchBox: false,
        width: "100%",
      });
      var id = $currentSelect.attr("id")
      $currentSelect.parent().find(`label[for="${id}"]`).attr("id", `${id}--label`)
      $currentSelect.parent().find(".select2-selection.select2-selection--multiple").attr("aria-labelledby", `${id}--label`)
      $currentSelect.on("select2:open", function () {
        var values = $(this).val();
        var pop_up_selection = $(".select2-results__options");
        if (values != null) {
          pop_up_selection.find("li[aria-selected=true]").hide();
        } else {
          pop_up_selection.find("li[aria-selected=true]").show();
        }
      });
      $currentSelect.on("change", function (e) {
        var $closeButtons = $(".select2-selection__choice__remove");
        $closeButtons.prop("tabindex", 0);
        if (closeSelect !== undefined) {
          $timeout.cancel(closeSelect);
        }
        //to fix a bug of page layout (fix back nav top position fixed) on ios7
        closeSelect = setTimeout(function () {
          $currentSelect.trigger({
            type: "select2:close",
            params: {},
          });
        }, 300);
      });
    },
  };

  return CustomSelect;
});

/*! http://mths.be/placeholder v2.0.7 by @mathias */
; (function (window, document, $) {

  var isInputSupported = 'placeholder' in document.createElement('input'),
    isTextareaSupported = 'placeholder' in document.createElement('textarea'),
    prototype = $.fn,
    valHooks = $.valHooks,
    hooks,
    placeholder;

  if (isInputSupported && isTextareaSupported) {

    placeholder = prototype.placeholder = function () {
      return this;
    };

    placeholder.input = placeholder.textarea = true;

  } else {

    placeholder = prototype.placeholder = function () {
      var $this = this;
      $this
        .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
        .not('.placeholder')
        .bind({
          'focus.placeholder': clearPlaceholder,
          'blur.placeholder': setPlaceholder
        })
        .data('placeholder-enabled', true)
        .trigger('blur.placeholder');
      return $this;
    };

    placeholder.input = isInputSupported;
    placeholder.textarea = isTextareaSupported;

    hooks = {
      'get': function (element) {
        var $element = $(element);
        return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
      },
      'set': function (element, value) {
        var $element = $(element);
        if (!$element.data('placeholder-enabled')) {
          return element.value = value;
        }
        if (value == '') {
          element.value = value;
          // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
          if (element != document.activeElement) {
            // We can’t use `triggerHandler` here because of dummy text/password inputs :(
            setPlaceholder.call(element);
          }
        } else if ($element.hasClass('placeholder')) {
          clearPlaceholder.call(element, true, value) || (element.value = value);
        } else {
          element.value = value;
        }
        // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
        return $element;
      }
    };

    isInputSupported || (valHooks.input = hooks);
    isTextareaSupported || (valHooks.textarea = hooks);

    $(function () {
      // Look for forms
      $(document).delegate('form', 'submit.placeholder', function () {
        // Clear the placeholder values so they don’t get submitted
        var $inputs = $('.placeholder', this).each(clearPlaceholder);
        setTimeout(function () {
          $inputs.each(setPlaceholder);
        }, 10);
      });
    });

    // Clear placeholder values upon page reload
    $(window).bind('beforeunload.placeholder', function () {
      $('.placeholder').each(function () {
        this.value = '';
      });
    });

  }

  function args(elem) {
    // Return an object of element attributes
    var newAttrs = {},
      rinlinejQuery = /^jQuery\d+$/;
    $.each(elem.attributes, function (i, attr) {
      if (attr.specified && !rinlinejQuery.test(attr.name)) {
        newAttrs[attr.name] = attr.value;
      }
    });
    return newAttrs;
  }

  function clearPlaceholder(event, value) {
    var input = this,
      $input = $(input);
    if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
      if ($input.data('placeholder-password')) {
        $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
        // If `clearPlaceholder` was called from `$.valHooks.input.set`
        if (event === true) {
          return $input[0].value = value;
        }
        $input.focus();
      } else {
        input.value = '';
        $input.removeClass('placeholder');
        input == document.activeElement && input.select();
      }
    }
  }

  function setPlaceholder() {
    var $replacement,
      input = this,
      $input = $(input),
      $origInput = $input,
      id = this.id;
    if (input.value == '') {
      if (input.type == 'password') {
        if (!$input.data('placeholder-textinput')) {
          try {
            $replacement = $input.clone().attr({ 'type': 'text' });
          } catch (e) {
            $replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
          }
          $replacement
            .removeAttr('name')
            .data({
              'placeholder-password': true,
              'placeholder-id': id
            })
            .bind('focus.placeholder', clearPlaceholder);
          $input
            .data({
              'placeholder-textinput': $replacement,
              'placeholder-id': id
            })
            .before($replacement);
        }
        $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
        // Note: `$input[0] != input` now!
      }
      $input.addClass('placeholder');
      $input[0].value = $input.attr('placeholder');
    } else {
      $input.removeClass('placeholder');
    }
  }

}(this, document, jQuery));
define("placeholder", function () { });



define('uiTools/placeholder', [
  'jquery',
  'UTILS',
  'placeholder'
], function ($, Utils) {


  var Placeholder = {
    init: function (context) {

      $(Utils.removeHighlightedCodeFromContext($(context).find('input, textarea'))).placeholder();

    }
  };

  return Placeholder;
});
/***
* @author : Julie Cardinal
*
* DOCUMENTATION
*
* Usage:
*
* Data-attribute:
*
* data-buttonsgroup-multisection { default:false }: allow to select multiple buttons or not
* data-buttonsgroup-inactiveclass { default:"buttonsgroup-button-inactive" }: The class applied to the element when is selected
* data-buttonsgroup-trigger : jQuery selector to target the buttons group
*
*
* Example:
* <ul class="enhance" data-buttonsgroup-multisection="true" data-buttonsgroup-inactiveclass="button-skin1-inactive" data-buttonsgroup-trigger=".button-skin1" data-enhance="buttonsgroup">
*      <li><a href="#" class="button-skin1"> Aujourdhui </a></li>
*      <li><a href="#" class="button-skin1 button-skin1-inactive last">Demain</a></li>
* </ul>
*/

// TODO :; Need to trigger events with array of selected items with arguments


define('buttonGroup', [
  'jquery',
  'UTILS'
], function ($, Utils) {

  var eventEmitter;
  /***********************************  Parking  ****************************************/

  var BoutonsGroup = {
    init: function (context) {
      var _t = this;

      eventEmitter = ADM.eventEmitter;
      $(context).each(function (index, el) {
        new ButtonsGroupInstance(el);
      });
    }
  };

  function ButtonsGroupInstance(el) {

    var $el = $(el),
      triggerEvent = $el.data("buttonsgroup-triggerevent") || null,
      multiselection = $el.data('buttonsgroup-multisection') || false,
      $triggers = $el.find($el.data('buttonsgroup-trigger')),
      inactiveClass = $el.data('buttonsgroup-inactiveclass') || "buttonsgroup-button-inactive",
      activeClass = $el.data('buttonsgroup-activeclass') || "buttonsgroup-button-active";

    function init() {
      createEvents();

      var isActive = $el.hasClass(activeClass);

      if (isActive) {
        $el.parent().addClass("li-selected");
      }

    }

    function createEvents() {

      $triggers.on("click", function (evt) {
        evt.preventDefault();

        //fix for analytics
        if (triggerEvent === "tableauvols-filtersupdate") {
          dataLayer.push({
            'event': $(this).attr("id") + '_' + Utils.getLang()
          });
        }

        handleButtonState($(this), true);
      });

      $triggers.on("selectall.buttonsgroup", function (evt) {
        evt.preventDefault();
        handleSelectAllButtons();
      });

      $triggers.on("deselectall.buttonsgroup", function (evt) {
        evt.preventDefault();
        handleDeselectAllButtons();
      });

      $triggers.on("update.buttonsgroup", function (evt) {
        //TODO :: Select just one item
        evt.preventDefault();
        handleButtonState($(this), false);
      });
    }

    function handleSelectAllButtons() {
      $triggers.removeClass(inactiveClass);
      $triggers.attr("aria-current", "false");
      triggerUpdateEvent();
    }

    function handleDeselectAllButtons() {
      $triggers.addClass(inactiveClass);
      $triggers.find(".li-selected").removeClass("li-selected");
      $triggers.attr("aria-current", "false");
      triggerUpdateEvent();
    }

    function handleButtonState($el, canTriggerEvent) {
      var isInactive = $el.hasClass(inactiveClass);
      var isActive = $el.hasClass(activeClass);

      if (isActive) {
        $el.parent().addClass("li-selected");
      }

      if (multiselection) {
        if (!isInactive && isMoreThanOneButtonSelected() > 1) {
          $el.addClass(inactiveClass);
          $el.parents().removeClass("li-selected");
          triggerUpdateEvent(canTriggerEvent);
        } else if (isInactive) {
          $el.removeClass(inactiveClass);
          triggerUpdateEvent(canTriggerEvent);
        }

      } else {
        $triggers.addClass(inactiveClass);
        $triggers.removeClass(activeClass);
        $triggers.parent().removeClass("li-selected");
        $triggers.attr("aria-current", "false");
        $el.removeClass(inactiveClass);
        $el.addClass(activeClass);
        $el.parent().addClass("li-selected");
        $el.attr("aria-current", "location");
        triggerUpdateEvent(canTriggerEvent);
      }
    }

    function triggerUpdateEvent(canTriggerEvent) {
      var activeBtns = $triggers.not("." + inactiveClass);
      activeBtns.parent().addClass("li-selected");
      if (canTriggerEvent && triggerEvent) eventEmitter.emitEvent(triggerEvent, ["buttonsgroup-updated", activeBtns]);
    }

    function isMoreThanOneButtonSelected() {
      var numItemsActive = 0;

      $triggers.each(function (index, el) {
        var $el = $(el),
          isInactive = $el.hasClass(inactiveClass);
        if (!isInactive) numItemsActive++;
      });
      return numItemsActive;
    }

    init();
  }

  return BoutonsGroup;
});

/*
* Copyright (c) 2011 Róbert Pataki
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
* ----------------------------------------------------------------------------------------
*
* Check out my GitHub:	http://github.com/heartcode/
* Send me an email:		heartcode@robertpataki.com
* Follow me on Twitter:	http://twitter.com/#iHeartcode
* Blog:					http://heartcode.robertpataki.com
*/

/**
* CanvasLoader uses the HTML5 canvas element in modern browsers and VML in IE6/7/8 to create and animate the most popular preloader shapes (oval, spiral, rectangle, square and rounded rectangle).<br/><br/>
* It is important to note that CanvasLoader doesn't show up and starts rendering automatically on instantiation. To start rendering and display the loader use the <code>show()</code> method.
* @module CanvasLoader
**/
(function (window) {
  "use strict";
  /**
   * CanvasLoader is a JavaScript UI library that draws and animates circular preloaders using the Canvas HTML object.<br/><br/>
   * A CanvasLoader instance creates two canvas elements which are placed into a placeholder div (the id of the div has to be passed in the constructor). The second canvas is invisible and used for caching purposes only.<br/><br/>
   * If no id is passed in the constructor, the canvas objects are paced in the document directly.
   * @class CanvasLoader
   * @constructor
   * @param id {String} The id of the placeholder div
   * @param opt {Object} Optional parameters<br/><br/>
   * <strong>Possible values of optional parameters:</strong><br/>
   * <ul>
   * <li><strong>id (String):</strong> The id of the CanvasLoader instance</li>
   * <li><strong>safeVML (Boolean):</strong> If set to true, the amount of CanvasLoader shapes are limited in VML mode. It prevents CPU overkilling when rendering loaders with high density. The default value is true.</li>
   **/
  var CanvasLoader = function (id, opt) {
    if (typeof (opt) == "undefined") { opt = {}; }
    this.init(id, opt);
  }, p = CanvasLoader.prototype, engine, engines = ["canvas", "vml"], shapes = ["oval", "spiral", "square", "rect", "roundRect"], cRX = /^\#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/, ie8 = navigator.appVersion.indexOf("MSIE") !== -1 && parseFloat(navigator.appVersion.split("MSIE")[1]) === 8 ? true : false, canSup = !!document.createElement('canvas').getContext, safeDensity = 40, safeVML = true,
    /**
     * Creates a new element with the tag and applies the passed properties on it
     * @method addEl
     * @protected
     * @param tag {String} The tag to be created
     * @param par {String} The DOM element the new element will be appended to
     * @param opt {Object} Additional properties passed to the new DOM element
     * @return {Object} The DOM element
     */
    addEl = function (tag, par, opt) {
      var el = document.createElement(tag), n;
      for (n in opt) { el[n] = opt[n]; }
      if (typeof (par) !== "undefined") {
        if (par !== null) {
          par.appendChild(el);
        }

      }
      return el;
    },
    /**
     * Sets the css properties on the element
     * @method setCSS
     * @protected
     * @param el {Object} The DOM element to be styled
     * @param opt {Object} The style properties
     * @return {Object} The DOM element
     */
    setCSS = function (el, opt) {
      for (var n in opt) { el.style[n] = opt[n]; }
      return el;
    },
    /**
     * Sets the attributes on the element
     * @method setAttr
     * @protected
     * @param el {Object} The DOM element to add the attributes to
     * @param opt {Object} The attributes
     * @return {Object} The DOM element
     */
    setAttr = function (el, opt) {
      for (var n in opt) { el.setAttribute(n, opt[n]); }
      return el;
    },
    /**
     * Transforms the cache canvas before drawing
     * @method transCon
     * @protected
     * @param	x {Object} The canvas context to be transformed
     * @param	x {Number} x translation
     * @param	y {Number} y translation
     * @param	r {Number} Rotation radians
     */
    transCon = function (c, x, y, r) {
      c.save();
      c.translate(x, y);
      c.rotate(r);
      c.translate(-x, -y);
      c.beginPath();
    };
  /**
   * Initialization method
   * @method init
   * @protected
   * @param id {String} The id of the placeholder div, where the loader will be nested into
   * @param opt {Object} Optional parameters<br/><br/>
   * <strong>Possible values of optional parameters:</strong><br/>
   * <ul>
   * <li><strong>id (String):</strong> The id of the CanvasLoader instance</li>
   * <li><strong>safeVML (Boolean):</strong> If set to true, the amount of CanvasLoader shapes are limited in VML mode. It prevents CPU overkilling when rendering loaders with high density. The default value is true.</li>
   **/
  p.init = function (pId, opt) {

    if (typeof (opt.safeVML) === "boolean") { safeVML = opt.safeVML; }

    /*
     * Find the containing div by id
     * If the container element cannot be found we use the document body itself
     */
    try {
      // Look for the parent element
      if (document.getElementById(pId) !== undefined) {
        this.mum = document.getElementById(pId);
      } else {
        this.mum = document.body;
      }
    } catch (error) {
      this.mum = document.body;
    }
    // Creates the parent div of the loader instance
    opt.id = typeof (opt.id) !== "undefined" ? opt.id : "canvasLoader";
    this.cont = addEl("div", this.mum, { id: opt.id });
    if (canSup) {
      // For browsers with Canvas support...
      engine = engines[0];
      // Create the canvas element
      this.can = addEl("canvas", this.cont);
      this.con = this.can.getContext("2d");
      // Create the cache canvas element
      this.cCan = setCSS(addEl("canvas", this.cont), { display: "none" });
      this.cCon = this.cCan.getContext("2d");
    } else {
      // For browsers without Canvas support...
      engine = engines[1];
      // Adds the VML stylesheet
      if (typeof (CanvasLoader.vmlSheet) === "undefined") {
        document.getElementsByTagName("head")[0].appendChild(addEl("style"));
        CanvasLoader.vmlSheet = document.styleSheets[document.styleSheets.length - 1];
        var a = ["group", "oval", "roundrect", "fill"], n;
        for (var n = 0; n < a.length; ++n) { CanvasLoader.vmlSheet.addRule(a[n], "behavior:url(#default#VML); position:absolute;"); }
      }
      this.vml = addEl("group", this.cont);
    }
    // Set the RGB color object
    this.setColor(this.color);
    // Draws the shapes on the canvas
    this.draw();
    //Hides the preloader
    setCSS(this.cont, { display: "none" });
  };
  /////////////////////////////////////////////////////////////////////////////////////////////
  // Property declarations
  /**
   * The div we place the canvas object into
   * @property cont
   * @protected
   * @type Object
   **/
  p.cont = {};
  /**
   * The div we draw the shapes into
   * @property can
   * @protected
   * @type Object
   **/
  p.can = {};
  /**
   * The canvas context
   * @property con
   * @protected
   * @type Object
   **/
  p.con = {};
  /**
   * The canvas we use for caching
   * @property cCan
   * @protected
   * @type Object
   **/
  p.cCan = {};
  /**
   * The context of the cache canvas
   * @property cCon
   * @protected
   * @type Object
   **/
  p.cCon = {};
  /**
   * Adds a timer for the rendering
   * @property timer
   * @protected
   * @type Boolean
   **/
  p.timer = {};
  /**
   * The active shape id for rendering
   * @property activeId
   * @protected
   * @type Number
   **/
  p.activeId = 0;
  /**
   * The diameter of the loader
   * @property diameter
   * @protected
   * @type Number
   * @default 40
   **/
  p.diameter = 40;
  /**
   * Sets the diameter of the loader
   * @method setDiameter
   * @public
   * @param diameter {Number} The default value is 40
   **/
  p.setDiameter = function (diameter) { this.diameter = Math.round(Math.abs(diameter)); this.redraw(); };
  /**
   * Returns the diameter of the loader.
   * @method getDiameter
   * @public
   * @return {Number}
   **/
  p.getDiameter = function () { return this.diameter; };
  /**
   * The color of the loader shapes in RGB
   * @property cRGB
   * @protected
   * @type Object
   **/
  p.cRGB = {};
  /**
   * The color of the loader shapes in HEX
   * @property color
   * @protected
   * @type String
   * @default "#000000"
   **/
  p.color = "#000000";
  /**
   * Sets hexadecimal color of the loader
   * @method setColor
   * @public
   * @param color {String} The default value is '#000000'
   **/
  p.setColor = function (color) { this.color = cRX.test(color) ? color : "#000000"; this.cRGB = this.getRGB(this.color); this.redraw(); };
  /**
   * Returns the loader color in a hexadecimal form
   * @method getColor
   * @public
   * @return {String}
   **/
  p.getColor = function () { return this.color; };
  /**
   * The type of the loader shapes
   * @property shape
   * @protected
   * @type String
   * @default "oval"
   **/
  p.shape = shapes[0];
  /**
   * Sets the type of the loader shapes.<br/>
   * <br/><b>The acceptable values are:</b>
   * <ul>
   * <li>'oval'</li>
   * <li>'spiral'</li>
   * <li>'square'</li>
   * <li>'rect'</li>
   * <li>'roundRect'</li>
   * </ul>
   * @method setShape
   * @public
   * @param shape {String} The default value is 'oval'
   **/
  p.setShape = function (shape) {
    var n;
    for (n in shapes) {
      if (shape === shapes[n]) { this.shape = shape; this.redraw(); break; }
    }
  };
  /**
   * Returns the type of the loader shapes
   * @method getShape
   * @public
   * @return {String}
   **/
  p.getShape = function () { return this.shape; };
  /**
   * The number of shapes drawn on the loader canvas
   * @property density
   * @protected
   * @type Number
   * @default 40
   **/
  p.density = 40;
  /**
   * Sets the number of shapes drawn on the loader canvas
   * @method setDensity
   * @public
   * @param density {Number} The default value is 40
   **/
  p.setDensity = function (density) {
    if (safeVML && engine === engines[1]) {
      this.density = Math.round(Math.abs(density)) <= safeDensity ? Math.round(Math.abs(density)) : safeDensity;
    } else {
      this.density = Math.round(Math.abs(density));
    }
    if (this.density > 360) { this.density = 360; }
    this.activeId = 0;
    this.redraw();
  };
  /**
   * Returns the number of shapes drawn on the loader canvas
   * @method getDensity
   * @public
   * @return {Number}
   **/
  p.getDensity = function () { return this.density; };
  /**
   * The amount of the modified shapes in percent.
   * @property range
   * @protected
   * @type Number
   **/
  p.range = 1.3;
  /**
   * Sets the amount of the modified shapes in percent.<br/>
   * With this value the user can set what range of the shapes should be scaled and/or faded. The shapes that are out of this range will be scaled and/or faded with a minimum amount only.<br/>
   * This minimum amount is 0.1 which means every shape which is out of the range is scaled and/or faded to 10% of the original values.<br/>
   * The visually acceptable range value should be between 0.4 and 1.5.
   * @method setRange
   * @public
   * @param range {Number} The default value is 1.3
   **/
  p.setRange = function (range) { this.range = Math.abs(range); this.redraw(); };
  /**
   * Returns the modified shape range in percent
   * @method getRange
   * @public
   * @return {Number}
   **/
  p.getRange = function () { return this.range; };
  /**
   * The speed of the loader animation
   * @property speed
   * @protected
   * @type Number
   **/
  p.speed = 2;
  /**
   * Sets the speed of the loader animation.<br/>
   * This value tells the loader how many shapes to skip by each tick.<br/>
   * Using the right combination of the <code>setFPS</code> and the <code>setSpeed</code> methods allows the users to optimize the CPU usage of the loader whilst keeping the animation on a visually pleasing level.
   * @method setSpeed
   * @public
   * @param speed {Number} The default value is 2
   **/
  p.setSpeed = function (speed) { this.speed = Math.round(Math.abs(speed)); };
  /**
   * Returns the speed of the loader animation
   * @method getSpeed
   * @public
   * @return {Number}
   **/
  p.getSpeed = function () { return this.speed; };
  /**
   * The FPS value of the loader animation rendering
   * @property fps
   * @protected
   * @type Number
   **/
  p.fps = 24;
  /**
   * Sets the rendering frequency.<br/>
   * This value tells the loader how many times to refresh and modify the canvas in 1 second.<br/>
   * Using the right combination of the <code>setSpeed</code> and the <code>setFPS</code> methods allows the users to optimize the CPU usage of the loader whilst keeping the animation on a visually pleasing level.
   * @method setFPS
   * @public
   * @param fps {Number} The default value is 24
   **/
  p.setFPS = function (fps) { this.fps = Math.round(Math.abs(fps)); this.reset(); };
  /**
   * Returns the fps of the loader
   * @method getFPS
   * @public
   * @return {Number}
   **/
  p.getFPS = function () { return this.fps; };
  // End of Property declarations
  /////////////////////////////////////////////////////////////////////////////////////////////	
  /**
   * Return the RGB values of the passed color
   * @method getRGB
   * @protected
   * @param color {String} The HEX color value to be converted to RGB
   */
  p.getRGB = function (c) {
    c = c.charAt(0) === "#" ? c.substring(1, 7) : c;
    return { r: parseInt(c.substring(0, 2), 16), g: parseInt(c.substring(2, 4), 16), b: parseInt(c.substring(4, 6), 16) };
  };
  /**
   * Draw the shapes on the canvas
   * @method draw
   * @protected
   */
  p.draw = function () {
    var i = 0, size, w, h, x, y, ang, rads, rad, de = this.density, animBits = Math.round(de * this.range), bitMod, minBitMod = 0, s, g, sh, f, d = 1000, arc = 0, c = this.cCon, di = this.diameter, e = 0.47;
    if (engine === engines[0]) {
      c.clearRect(0, 0, d, d);
      setAttr(this.can, { width: di, height: di });
      setAttr(this.cCan, { width: di, height: di });
      while (i < de) {
        bitMod = i <= animBits ? 1 - ((1 - minBitMod) / animBits * i) : bitMod = minBitMod;
        ang = 270 - 360 / de * i;
        rads = ang / 180 * Math.PI;
        c.fillStyle = "rgba(" + this.cRGB.r + "," + this.cRGB.g + "," + this.cRGB.b + "," + bitMod.toString() + ")";
        switch (this.shape) {
          case shapes[0]:
          case shapes[1]:
            size = di * 0.07;
            x = di * e + Math.cos(rads) * (di * e - size) - di * e;
            y = di * e + Math.sin(rads) * (di * e - size) - di * e;
            c.beginPath();
            if (this.shape === shapes[1]) { c.arc(di * 0.5 + x, di * 0.5 + y, size * bitMod, 0, Math.PI * 2, false); } else { c.arc(di * 0.5 + x, di * 0.5 + y, size, 0, Math.PI * 2, false); }
            break;
          case shapes[2]:
            size = di * 0.12;
            x = Math.cos(rads) * (di * e - size) + di * 0.5;
            y = Math.sin(rads) * (di * e - size) + di * 0.5;
            transCon(c, x, y, rads);
            c.fillRect(x, y - size * 0.5, size, size);
            break;
          case shapes[3]:
          case shapes[4]:
            w = di * 0.3;
            h = w * 0.27;
            x = Math.cos(rads) * (h + (di - h) * 0.13) + di * 0.5;
            y = Math.sin(rads) * (h + (di - h) * 0.13) + di * 0.5;
            transCon(c, x, y, rads);
            if (this.shape === shapes[3]) {
              c.fillRect(x, y - h * 0.5, w, h);
            } else {
              rad = h * 0.55;
              c.moveTo(x + rad, y - h * 0.5);
              c.lineTo(x + w - rad, y - h * 0.5);
              c.quadraticCurveTo(x + w, y - h * 0.5, x + w, y - h * 0.5 + rad);
              c.lineTo(x + w, y - h * 0.5 + h - rad);
              c.quadraticCurveTo(x + w, y - h * 0.5 + h, x + w - rad, y - h * 0.5 + h);
              c.lineTo(x + rad, y - h * 0.5 + h);
              c.quadraticCurveTo(x, y - h * 0.5 + h, x, y - h * 0.5 + h - rad);
              c.lineTo(x, y - h * 0.5 + rad);
              c.quadraticCurveTo(x, y - h * 0.5, x + rad, y - h * 0.5);
            }
            break;
        }
        c.closePath();
        c.fill();
        c.restore();
        ++i;
      }
    } else {
      setCSS(this.cont, { width: di, height: di });
      setCSS(this.vml, { width: di, height: di });
      switch (this.shape) {
        case shapes[0]:
        case shapes[1]:
          sh = "oval";
          size = d * 0.14;
          break;
        case shapes[2]:
          sh = "roundrect";
          size = d * 0.12;
          break;
        case shapes[3]:
        case shapes[4]:
          sh = "roundrect";
          size = d * 0.3;
          break;
      }
      w = h = size;
      x = d * 0.5 - h;
      y = -h * 0.5;
      while (i < de) {
        bitMod = i <= animBits ? 1 - ((1 - minBitMod) / animBits * i) : bitMod = minBitMod;
        ang = 270 - 360 / de * i;
        switch (this.shape) {
          case shapes[1]:
            w = h = size * bitMod;
            x = d * 0.5 - size * 0.5 - size * bitMod * 0.5;
            y = (size - size * bitMod) * 0.5;
            break;
          case shapes[0]:
          case shapes[2]:
            if (ie8) {
              y = 0;
              if (this.shape === shapes[2]) {
                x = d * 0.5 - h * 0.5;
              }
            }
            break;
          case shapes[3]:
          case shapes[4]:
            w = size * 0.95;
            h = w * 0.28;
            if (ie8) {
              x = 0;
              y = d * 0.5 - h * 0.5;
            } else {
              x = d * 0.5 - w;
              y = -h * 0.5;
            }
            arc = this.shape === shapes[4] ? 0.6 : 0;
            break;
        }
        g = setAttr(setCSS(addEl("group", this.vml), { width: d, height: d, rotation: ang }), { coordsize: d + "," + d, coordorigin: -d * 0.5 + "," + (-d * 0.5) });
        s = setCSS(addEl(sh, g, { stroked: false, arcSize: arc }), { width: w, height: h, top: y, left: x });
        f = addEl("fill", s, { color: this.color, opacity: bitMod });
        ++i;
      }
    }
    this.tick(true);
  };
  /**
   * Cleans the canvas
   * @method clean
   * @protected
   */
  p.clean = function () {
    if (engine === engines[0]) {
      this.con.clearRect(0, 0, 1000, 1000);
    } else {
      var v = this.vml;
      if (v.hasChildNodes()) {
        while (v.childNodes.length >= 1) {
          v.removeChild(v.firstChild);
        }
      }
    }
  };
  /**
   * Redraws the canvas
   * @method redraw
   * @protected
   */
  p.redraw = function () {
    this.clean();
    this.draw();
  };
  /**
   * Resets the timer
   * @method reset
   * @protected
   */
  p.reset = function () {
    if (typeof (this.timer) === "number") {
      this.hide();
      this.show();
    }
  };
  /**
   * Renders the loader animation
   * @method tick
   * @protected
   */
  p.tick = function (init) {
    var c = this.con, di = this.diameter;
    if (!init) { this.activeId += 360 / this.density * this.speed; }
    if (engine === engines[0]) {
      c.clearRect(0, 0, di, di);
      transCon(c, di * 0.5, di * 0.5, this.activeId / 180 * Math.PI);
      c.drawImage(this.cCan, 0, 0, di, di);
      c.restore();
    } else {
      if (this.activeId >= 360) { this.activeId -= 360; }
      setCSS(this.vml, { rotation: this.activeId });
    }
  };
  /**
   * Shows the rendering of the loader animation
   * @method show
   * @public
   */
  p.show = function () {
    if (typeof (this.timer) !== "number") {
      var t = this;
      this.timer = self.setInterval(function () { t.tick(); }, Math.round(1000 / this.fps));
      setCSS(this.cont, { display: "block" });
    }
  };
  /**
   * Stops the rendering of the loader animation and hides the loader
   * @method hide
   * @public
   */
  p.hide = function () {
    if (typeof (this.timer) === "number") {
      clearInterval(this.timer);
      delete this.timer;
      setCSS(this.cont, { display: "none" });
    }
  };
  /**
   * Removes the CanvasLoader instance and all its references
   * @method kill
   * @public
   */
  p.kill = function () {
    var c = this.cont;
    if (typeof (this.timer) === "number") { this.hide(); }
    if (engine === engines[0]) {
      c.removeChild(this.can);
      c.removeChild(this.cCan);
    } else {
      c.removeChild(this.vml);
    }
    var n;
    for (n in this) { delete this[n]; }
  };
  window.CanvasLoader = CanvasLoader;
}(window));

define("canvasLoader", function () { });

// TODO :: Make documentation

define('UTILS_PRELOADER', [
  'jquery',
  'UTILS',
  'canvasLoader'
], function ($, Utils) {


  function Preloader(opts) {


    var loaderClass = "dataprovider-loader",
      $spinner,
      uniqueId = Utils.getUniqueId(),
      $ctn = opts.$ctn,
      ctnClass = opts.ctnClass || "dataprovider-isloading",
      spinnerCtnId = "canvasloader-container-" + uniqueId,
      spinnerId = "canvasLoader-" + uniqueId,
      speed = opts.speed || 2,
      diameter = opts.diameter || 30,
      color = opts.color || "#000000",
      fps = 31;
    position = opts.position || 'relative',
      loaderCss = { position: "absolute", top: 0, right: 0, bottom: 0, left: 0, "z-index": 400, "display": "none" },
      spinnerCss = { position: "absolute", top: "50%", left: "50%", "margin-left": -(diameter / 2), "margin-top": -(diameter / 2) },
      loaderOpts = opts.loaderCss || {},
      spinnerOpts = opts.spinnerCss || {};

    $.extend(loaderCss, loaderOpts);
    $.extend(spinnerCss, spinnerOpts);

    function init() {
      if (position != null) {
        $ctn.css("position", position);
      }

      $loader = $("<div id='" + spinnerCtnId + "' class='" + loaderClass + "' style='" + loaderCss + "'></div>");
      $loader.css(loaderCss);
      $ctn.append($loader);

      $spinner = new CanvasLoader(spinnerCtnId, { id: spinnerId });
      $spinner.setSpeed(speed);
      $spinner.setDiameter(diameter);
      $spinner.setColor(color);
      $spinner.setFPS(fps);
      $spinner.hide();
      $("#" + spinnerId).css(spinnerCss);
    }

    init();

    return {
      show: function () {
        $loader.css("display", "block");
        $ctn.addClass(ctnClass);
        $spinner.show();
      },
      hide: function () {
        $loader.css("display", "none");
        $ctn.removeClass(ctnClass);
        $spinner.hide();
      },
      remove: function () {
        $ctn.removeClass(ctnClass);
        $spinner.hide();
        $spinner.kill();
        $ctn.find("." + loaderClass).remove();
      }
    }
  }
  return Preloader;
});
define('i18n/modal', [], function () {

  var i18n = ADM.i18n.modal;

  return i18n;
});

/*! Magnific Popup - v0.9.9 - 2013-12-27
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2013 Dmitry Semenov; */
; (function ($) {

  /*>>core*/
  /**
   *
   * Magnific Popup Core JS file
   *
   */


  /**
   * Private static constants
   */
  var CLOSE_EVENT = 'Close',
    BEFORE_CLOSE_EVENT = 'BeforeClose',
    AFTER_CLOSE_EVENT = 'AfterClose',
    BEFORE_APPEND_EVENT = 'BeforeAppend',
    MARKUP_PARSE_EVENT = 'MarkupParse',
    OPEN_EVENT = 'Open',
    CHANGE_EVENT = 'Change',
    NS = 'mfp',
    EVENT_NS = '.' + NS,
    READY_CLASS = 'mfp-ready',
    REMOVING_CLASS = 'mfp-removing',
    PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


  /**
   * Private vars
   */
  var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
    MagnificPopup = function () { },
    _isJQ = !!(window.jQuery),
    _prevStatus,
    _window = $(window),
    _body,
    _document,
    _prevContentType,
    _wrapClasses,
    _currPopupType;


  /**
   * Private functions
   */
  var _mfpOn = function (name, f) {
    mfp.ev.on(NS + name + EVENT_NS, f);
  },
    _getEl = function (className, appendTo, html, raw) {
      var el = document.createElement('div');
      el.className = 'mfp-' + className;
      if (html) {
        el.innerHTML = html;
      }
      if (!raw) {
        el = $(el);
        if (appendTo) {
          el.appendTo(appendTo);
        }
      } else if (appendTo) {
        appendTo.appendChild(el);
      }
      return el;
    },
    _mfpTrigger = function (e, data) {
      mfp.ev.triggerHandler(NS + e, data);

      if (mfp.st.callbacks) {
        // converts "mfpEventName" to "eventName" callback and triggers it if it's present
        e = e.charAt(0).toLowerCase() + e.slice(1);
        if (mfp.st.callbacks[e]) {
          mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
        }
      }
    },
    _getCloseBtn = function (type) {
      if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
        mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace('%title%', mfp.st.tClose));
        _currPopupType = type;
      }
      return mfp.currTemplate.closeBtn;
    },
    // Initialize Magnific Popup only when called at least once
    _checkInstance = function () {
      if (!$.magnificPopup.instance) {
        mfp = new MagnificPopup();
        mfp.init();
        $.magnificPopup.instance = mfp;
      }
    },
    // CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
    supportsTransitions = function () {
      var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
        v = ['ms', 'O', 'Moz', 'Webkit']; // 'v' for vendor

      if (s['transition'] !== undefined) {
        return true;
      }

      while (v.length) {
        if (v.pop() + 'Transition' in s) {
          return true;
        }
      }

      return false;
    };



  /**
   * Public functions
   */
  MagnificPopup.prototype = {

    constructor: MagnificPopup,

    /**
     * Initializes Magnific Popup plugin.
     * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
     */
    init: function () {
      var appVersion = navigator.appVersion;
      mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1;
      mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
      mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
      mfp.isAndroid = (/android/gi).test(appVersion);
      mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
      mfp.supportsTransition = supportsTransitions();

      // We disable fixed positioned lightbox on devices that don't handle it nicely.
      // If you know a better way of detecting this - let me know.
      mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent));
      _document = $(document);

      mfp.popupsCache = {};
    },

    /**
     * Opens popup
     * @param  data [description]
     */
    open: function (data) {

      if (!_body) {
        _body = $(document.body);
      }

      var i;

      if (data.isObj === false) {
        // convert jQuery collection to array to avoid conflicts later
        mfp.items = data.items.toArray();

        mfp.index = 0;
        var items = data.items,
          item;
        for (i = 0; i < items.length; i++) {
          item = items[i];
          if (item.parsed) {
            item = item.el[0];
          }
          if (item === data.el[0]) {
            mfp.index = i;
            break;
          }
        }
      } else {
        mfp.items = $.isArray(data.items) ? data.items : [data.items];
        mfp.index = data.index || 0;
      }

      // if popup is already opened - we just update the content
      if (mfp.isOpen) {
        mfp.updateItemHTML();
        return;
      }

      mfp.types = [];
      _wrapClasses = '';
      if (data.mainEl && data.mainEl.length) {
        mfp.ev = data.mainEl.eq(0);
      } else {
        mfp.ev = _document;
      }

      if (data.key) {
        if (!mfp.popupsCache[data.key]) {
          mfp.popupsCache[data.key] = {};
        }
        mfp.currTemplate = mfp.popupsCache[data.key];
      } else {
        mfp.currTemplate = {};
      }



      mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
      mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

      if (mfp.st.modal) {
        mfp.st.closeOnContentClick = false;
        mfp.st.closeOnBgClick = false;
        mfp.st.showCloseBtn = false;
        mfp.st.enableEscapeKey = false;
      }


      // Building markup
      // main containers are created only once
      if (!mfp.bgOverlay) {

        // Dark overlay
        mfp.bgOverlay = _getEl('bg').on('click' + EVENT_NS, function () {
          mfp.close();
        });

        mfp.wrap = _getEl('wrap').attr('tabindex', -1).attr('role', 'dialog').attr('aria-label', 'Modal window').on('click' + EVENT_NS, function (e) {
          if (mfp._checkIfClose(e.target)) {
            mfp.close();
          }
        });

        mfp.container = _getEl('container', mfp.wrap);
      }

      mfp.contentContainer = _getEl('content');
      if (mfp.st.preloader) {
        mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
      }


      // Initializing modules
      var modules = $.magnificPopup.modules;
      for (i = 0; i < modules.length; i++) {
        var n = modules[i];
        n = n.charAt(0).toUpperCase() + n.slice(1);
        mfp['init' + n].call(mfp);
      }
      _mfpTrigger('BeforeOpen');


      if (mfp.st.showCloseBtn) {
        // Close button
        if (!mfp.st.closeBtnInside) {
          mfp.wrap.append(_getCloseBtn());
        } else {
          _mfpOn(MARKUP_PARSE_EVENT, function (e, template, values, item) {
            values.close_replaceWith = _getCloseBtn(item.type);
          });
          _wrapClasses += ' mfp-close-btn-in';
        }
      }

      if (mfp.st.alignTop) {
        _wrapClasses += ' mfp-align-top';
      }



      if (mfp.fixedContentPos) {
        mfp.wrap.css({
          overflow: mfp.st.overflowY,
          overflowX: 'hidden',
          overflowY: mfp.st.overflowY
        });
      } else {
        mfp.wrap.css({
          top: _window.scrollTop(),
          position: 'absolute'
        });
      }
      if (mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos)) {
        mfp.bgOverlay.css({
          height: _document.height(),
          position: 'absolute'
        });
      }



      if (mfp.st.enableEscapeKey) {
        // Close on ESC key
        _document.on('keyup' + EVENT_NS, function (e) {
          if (e.keyCode === 27) {
            mfp.close();
          }
        });
      }

      _window.on('resize' + EVENT_NS, function () {
        mfp.updateSize();
      });


      if (!mfp.st.closeOnContentClick) {
        _wrapClasses += ' mfp-auto-cursor';
      }

      if (_wrapClasses)
        mfp.wrap.addClass(_wrapClasses);


      // this triggers recalculation of layout, so we get it once to not to trigger twice
      var windowHeight = mfp.wH = _window.height();


      var windowStyles = {};

      if (mfp.fixedContentPos) {
        if (mfp._hasScrollBar(windowHeight)) {
          var s = mfp._getScrollbarSize();
          if (s) {
            windowStyles.marginRight = s;
          }
        }
      }

      if (mfp.fixedContentPos) {
        if (!mfp.isIE7) {
          windowStyles.overflow = 'hidden';
        } else {
          // ie7 double-scroll bug
          $('body, html').css('overflow', 'hidden');
        }
      }



      var classesToadd = mfp.st.mainClass;
      if (mfp.isIE7) {
        classesToadd += ' mfp-ie7';
      }
      if (classesToadd) {
        mfp._addClassToMFP(classesToadd);
      }

      // add content
      mfp.updateItemHTML();

      _mfpTrigger('BuildControls');

      // remove scrollbar, add margin e.t.c
      $('html').css(windowStyles);

      // add everything to DOM
      mfp.bgOverlay.add(mfp.wrap).prependTo(mfp.st.prependTo || _body);

      // Save last focused element
      mfp._lastFocusedEl = document.activeElement;

      // Wait for next cycle to allow CSS transition
      setTimeout(function () {

        if (mfp.content) {
          mfp._addClassToMFP(READY_CLASS);
          mfp._setFocus();
        } else {
          // if content is not defined (not loaded e.t.c) we add class only for BG
          mfp.bgOverlay.addClass(READY_CLASS);
        }

        // Trap the focus in popup
        _document.on('focusin' + EVENT_NS, mfp._onFocusIn);

      }, 16);

      mfp.isOpen = true;
      mfp.updateSize(windowHeight);
      _mfpTrigger(OPEN_EVENT);

      return data;
    },

    /**
     * Closes the popup
     */
    close: function () {
      if (!mfp.isOpen) return;
      _mfpTrigger(BEFORE_CLOSE_EVENT);

      mfp.isOpen = false;
      // for CSS3 animation
      if (mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition) {
        mfp._addClassToMFP(REMOVING_CLASS);
        setTimeout(function () {
          mfp._close();
        }, mfp.st.removalDelay);
      } else {
        mfp._close();
      }
    },

    /**
     * Helper for close() function
     */
    _close: function () {
      _mfpTrigger(CLOSE_EVENT);

      var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

      mfp.bgOverlay.detach();
      mfp.wrap.detach();
      mfp.container.empty();

      if (mfp.st.mainClass) {
        classesToRemove += mfp.st.mainClass + ' ';
      }

      mfp._removeClassFromMFP(classesToRemove);

      if (mfp.fixedContentPos) {
        var windowStyles = { marginRight: '' };
        if (mfp.isIE7) {
          $('body, html').css('overflow', '');
        } else {
          windowStyles.overflow = '';
        }
        $('html').css(windowStyles);
      }

      _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
      mfp.ev.off(EVENT_NS);

      // clean up DOM elements that aren't removed
      mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
      mfp.bgOverlay.attr('class', 'mfp-bg');
      mfp.container.attr('class', 'mfp-container');

      // remove close button from target element
      if (mfp.st.showCloseBtn &&
        (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
        if (mfp.currTemplate.closeBtn)
          mfp.currTemplate.closeBtn.detach();
      }


      if (mfp._lastFocusedEl) {
        $(mfp._lastFocusedEl).focus(); // put tab focus back
      }
      mfp.currItem = null;
      mfp.content = null;
      mfp.currTemplate = null;
      mfp.prevHeight = 0;

      _mfpTrigger(AFTER_CLOSE_EVENT);
    },

    updateSize: function (winHeight) {

      if (mfp.isIOS) {
        // fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
        var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
        var height = window.innerHeight * zoomLevel;
        mfp.wrap.css('height', height);
        mfp.wH = height;
      } else {
        mfp.wH = winHeight || _window.height();
      }
      // Fixes #84: popup incorrectly positioned with position:relative on body
      if (!mfp.fixedContentPos) {
        mfp.wrap.css('height', mfp.wH);
      }

      _mfpTrigger('Resize');

    },

    /**
     * Set content of popup based on current index
     */
    updateItemHTML: function () {
      var item = mfp.items[mfp.index];

      // Detach and perform modifications
      mfp.contentContainer.detach();

      if (mfp.content)
        mfp.content.detach();

      if (!item.parsed) {
        item = mfp.parseEl(mfp.index);
      }

      var type = item.type;

      _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
      // BeforeChange event works like so:
      // _mfpOn('BeforeChange', function(e, prevType, newType) { });

      mfp.currItem = item;





      if (!mfp.currTemplate[type]) {
        var markup = mfp.st[type] ? mfp.st[type].markup : false;

        // allows to modify markup
        _mfpTrigger('FirstMarkupParse', markup);

        if (markup) {
          mfp.currTemplate[type] = $(markup);
        } else {
          // if there is no markup found we just define that template is parsed
          mfp.currTemplate[type] = true;
        }
      }

      if (_prevContentType && _prevContentType !== item.type) {
        mfp.container.removeClass('mfp-' + _prevContentType + '-holder');
      }

      var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
      mfp.appendContent(newContent, type);

      item.preloaded = true;

      _mfpTrigger(CHANGE_EVENT, item);
      _prevContentType = item.type;

      // Append container back after its content changed
      mfp.container.prepend(mfp.contentContainer);

      _mfpTrigger('AfterChange');
    },


    /**
     * Set HTML content of popup
     */
    appendContent: function (newContent, type) {
      mfp.content = newContent;

      if (newContent) {
        if (mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
          mfp.currTemplate[type] === true) {
          // if there is no markup, we just append close button element inside
          if (!mfp.content.find('.mfp-close').length) {
            mfp.content.append(_getCloseBtn());
          }
        } else {
          mfp.content = newContent;
        }
      } else {
        mfp.content = '';
      }

      _mfpTrigger(BEFORE_APPEND_EVENT);
      mfp.container.addClass('mfp-' + type + '-holder');

      mfp.contentContainer.append(mfp.content);
    },




    /**
     * Creates Magnific Popup data object based on given data
     * @param  {int} index Index of item to parse
     */
    parseEl: function (index) {
      var item = mfp.items[index],
        type;

      if (item.tagName) {
        item = { el: $(item) };
      } else {
        type = item.type;
        item = { data: item, src: item.src };
      }

      if (item.el) {
        var types = mfp.types;

        // check for 'mfp-TYPE' class
        for (var i = 0; i < types.length; i++) {
          if (item.el.hasClass('mfp-' + types[i])) {
            type = types[i];
            break;
          }
        }

        item.src = item.el.attr('data-mfp-src');
        if (!item.src) {
          item.src = item.el.attr('href');
        }
      }

      item.type = type || mfp.st.type || 'inline';
      item.index = index;
      item.parsed = true;
      mfp.items[index] = item;
      _mfpTrigger('ElementParse', item);

      return mfp.items[index];
    },


    /**
     * Initializes single popup or a group of popups
     */
    addGroup: function (el, options) {
      var eHandler = function (e) {
        e.mfpEl = this;
        mfp._openClick(e, el, options);
      };

      if (!options) {
        options = {};
      }

      var eName = 'click.magnificPopup';
      options.mainEl = el;

      if (options.items) {
        options.isObj = true;
        el.off(eName).on(eName, eHandler);
      } else {
        options.isObj = false;
        if (options.delegate) {
          el.off(eName).on(eName, options.delegate, eHandler);
        } else {
          options.items = el;
          el.off(eName).on(eName, eHandler);
        }
      }
    },
    _openClick: function (e, el, options) {
      var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


      if (!midClick && (e.which === 2 || e.ctrlKey || e.metaKey)) {
        return;
      }

      var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

      if (disableOn) {
        if ($.isFunction(disableOn)) {
          if (!disableOn.call(mfp)) {
            return true;
          }
        } else { // else it's number
          if (_window.width() < disableOn) {
            return true;
          }
        }
      }

      if (e.type) {
        e.preventDefault();

        // This will prevent popup from closing if element is inside and popup is already opened
        if (mfp.isOpen) {
          e.stopPropagation();
        }
      }


      options.el = $(e.mfpEl);
      if (options.delegate) {
        options.items = el.find(options.delegate);
      }
      mfp.open(options);
    },


    /**
     * Updates text on preloader
     */
    updateStatus: function (status, text) {

      if (mfp.preloader) {
        if (_prevStatus !== status) {
          mfp.container.removeClass('mfp-s-' + _prevStatus);
        }

        if (!text && status === 'loading') {
          text = mfp.st.tLoading;
        }

        var data = {
          status: status,
          text: text
        };
        // allows to modify status
        _mfpTrigger('UpdateStatus', data);

        status = data.status;
        text = data.text;

        mfp.preloader.html(text);

        mfp.preloader.find('a').on('click', function (e) {
          e.stopImmediatePropagation();
        });

        mfp.container.addClass('mfp-s-' + status);
        _prevStatus = status;
      }
    },


    /*
     "Private" helpers that aren't private at all
     */
    // Check to close popup or not
    // "target" is an element that was clicked
    _checkIfClose: function (target) {

      if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
        return;
      }

      var closeOnContent = mfp.st.closeOnContentClick;
      var closeOnBg = mfp.st.closeOnBgClick;

      if (closeOnContent && closeOnBg) {
        return true;
      } else {

        // We close the popup if click is on close button or on preloader. Or if there is no content.
        if (!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0])) {
          return true;
        }

        // if click is outside the content
        if ((target !== mfp.content[0] && !$.contains(mfp.content[0], target))) {
          if (closeOnBg) {
            // last check, if the clicked element is in DOM, (in case it's removed onclick)
            if ($.contains(document, target)) {
              return true;
            }
          }
        } else if (closeOnContent) {
          return true;
        }

      }
      return false;
    },
    _addClassToMFP: function (cName) {
      mfp.bgOverlay.addClass(cName);
      mfp.wrap.addClass(cName);
    },
    _removeClassFromMFP: function (cName) {
      this.bgOverlay.removeClass(cName);
      mfp.wrap.removeClass(cName);
    },
    _hasScrollBar: function (winHeight) {
      return ((mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()));
    },
    _setFocus: function () {
      (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
    },
    _onFocusIn: function (e) {
      if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
        mfp._setFocus();
        return false;
      }
    },
    _parseMarkup: function (template, values, item) {
      var arr;
      if (item.data) {
        values = $.extend(item.data, values);
      }
      _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item]);

      $.each(values, function (key, value) {
        if (value === undefined || value === false) {
          return true;
        }
        arr = key.split('_');
        if (arr.length > 1) {
          var el = template.find(EVENT_NS + '-' + arr[0]);

          if (el.length > 0) {
            var attr = arr[1];
            if (attr === 'replaceWith') {
              if (el[0] !== value[0]) {
                el.replaceWith(value);
              }
            } else if (attr === 'img') {
              if (el.is('img')) {
                el.attr('src', value);
              } else {
                el.replaceWith('<img src="' + value + '" class="' + el.attr('class') + '" />');
              }
            } else {
              el.attr(arr[1], value);
            }
          }

        } else {
          template.find(EVENT_NS + '-' + key).html(value);
        }
      });
    },

    _getScrollbarSize: function () {
      // thx David
      if (mfp.scrollbarSize === undefined) {
        var scrollDiv = document.createElement("div");
        scrollDiv.id = "mfp-sbm";
        scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
        document.body.appendChild(scrollDiv);
        mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
      }
      return mfp.scrollbarSize;
    }

  }; /* MagnificPopup core prototype end */




  /**
   * Public static functions
   */
  $.magnificPopup = {
    instance: null,
    proto: MagnificPopup.prototype,
    modules: [],

    open: function (options, index) {
      _checkInstance();

      if (!options) {
        options = {};
      } else {
        options = $.extend(true, {}, options);
      }


      options.isObj = true;
      options.index = index || 0;
      return this.instance.open(options);
    },

    close: function () {
      return $.magnificPopup.instance && $.magnificPopup.instance.close();
    },

    registerModule: function (name, module) {
      if (module.options) {
        $.magnificPopup.defaults[name] = module.options;
      }
      $.extend(this.proto, module.proto);
      this.modules.push(name);
    },

    defaults: {

      // Info about options is in docs:
      // http://dimsemenov.com/plugins/magnific-popup/documentation.html#options

      disableOn: 0,

      key: null,

      midClick: false,

      mainClass: '',

      preloader: true,

      focus: '', // CSS selector of input to focus after popup is opened

      closeOnContentClick: false,

      closeOnBgClick: true,

      closeBtnInside: true,

      showCloseBtn: true,

      enableEscapeKey: true,

      modal: false,

      alignTop: false,

      removalDelay: 0,

      prependTo: null,

      fixedContentPos: 'auto',

      fixedBgPos: 'auto',

      overflowY: 'auto',

      closeMarkup: '<button aria-label="%title%" type="button" class="mfp-close">&times;</button>',

      tClose: 'Close (Esc)',

      tLoading: 'Loading...'

    }
  };



  $.fn.magnificPopup = function (options) {
    _checkInstance();

    var jqEl = $(this);

    // We call some API method of first param is a string
    if (typeof options === "string") {

      if (options === 'open') {
        var items,
          itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
          index = parseInt(arguments[1], 10) || 0;

        if (itemOpts.items) {
          items = itemOpts.items[index];
        } else {
          items = jqEl;
          if (itemOpts.delegate) {
            items = items.find(itemOpts.delegate);
          }
          items = items.eq(index);
        }
        mfp._openClick({ mfpEl: items }, jqEl, itemOpts);
      } else {
        if (mfp.isOpen)
          mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
      }

    } else {
      // clone options obj
      options = $.extend(true, {}, options);

      /*
       * As Zepto doesn't support .data() method for objects
       * and it works only in normal browsers
       * we assign "options" object directly to the DOM element. FTW!
       */
      if (_isJQ) {
        jqEl.data('magnificPopup', options);
      } else {
        jqEl[0].magnificPopup = options;
      }

      mfp.addGroup(jqEl, options);

    }
    return jqEl;
  };


  //Quick benchmark
  /*
   var start = performance.now(),
   i,
   rounds = 1000;

   for(i = 0; i < rounds; i++) {

   }
   console.log('Test #1:', performance.now() - start);

   start = performance.now();
   for(i = 0; i < rounds; i++) {

   }
   console.log('Test #2:', performance.now() - start);
   */


  /*>>core*/

  /*>>inline*/

  var INLINE_NS = 'inline',
    _hiddenClass,
    _inlinePlaceholder,
    _lastInlineElement,
    _putInlineElementsBack = function () {
      if (_lastInlineElement) {
        _inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach();
        _lastInlineElement = null;
      }
    };

  $.magnificPopup.registerModule(INLINE_NS, {
    options: {
      hiddenClass: 'hide', // will be appended with `mfp-` prefix
      markup: '',
      tNotFound: 'Content not found'
    },
    proto: {

      initInline: function () {
        mfp.types.push(INLINE_NS);

        _mfpOn(CLOSE_EVENT + '.' + INLINE_NS, function () {
          _putInlineElementsBack();
        });
      },

      getInline: function (item, template) {

        _putInlineElementsBack();

        if (item.src) {
          var inlineSt = mfp.st.inline,
            el = $(item.src);

          if (el.length) {

            // If target element has parent - we replace it with placeholder and put it back after popup is closed
            var parent = el[0].parentNode;
            if (parent && parent.tagName) {
              if (!_inlinePlaceholder) {
                _hiddenClass = inlineSt.hiddenClass;
                _inlinePlaceholder = _getEl(_hiddenClass);
                _hiddenClass = 'mfp-' + _hiddenClass;
              }
              // replace target inline element with placeholder
              _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
            }

            mfp.updateStatus('ready');
          } else {
            mfp.updateStatus('error', inlineSt.tNotFound);
            el = $('<div>');
          }

          item.inlineElement = el;
          return el;
        }

        mfp.updateStatus('ready');
        mfp._parseMarkup(template, {}, item);
        return template;
      }
    }
  });

  /*>>inline*/

  /*>>ajax*/
  var AJAX_NS = 'ajax',
    _ajaxCur,
    _removeAjaxCursor = function () {
      if (_ajaxCur) {
        _body.removeClass(_ajaxCur);
      }
    },
    _destroyAjaxRequest = function () {
      _removeAjaxCursor();
      if (mfp.req) {
        mfp.req.abort();
      }
    };

  $.magnificPopup.registerModule(AJAX_NS, {

    options: {
      settings: null,
      cursor: 'mfp-ajax-cur',
      tError: '<a href="%url%">The content</a> could not be loaded.'
    },

    proto: {
      initAjax: function () {
        mfp.types.push(AJAX_NS);
        _ajaxCur = mfp.st.ajax.cursor;

        _mfpOn(CLOSE_EVENT + '.' + AJAX_NS, _destroyAjaxRequest);
        _mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
      },
      getAjax: function (item) {

        if (_ajaxCur)
          _body.addClass(_ajaxCur);

        mfp.updateStatus('loading');

        var opts = $.extend({
          url: item.src,
          success: function (data, textStatus, jqXHR) {
            var temp = {
              data: data,
              xhr: jqXHR
            };

            _mfpTrigger('ParseAjax', temp);

            mfp.appendContent($(temp.data), AJAX_NS);

            item.finished = true;

            _removeAjaxCursor();

            mfp._setFocus();

            setTimeout(function () {
              mfp.wrap.addClass(READY_CLASS);
            }, 16);

            mfp.updateStatus('ready');

            _mfpTrigger('AjaxContentAdded');
          },
          error: function () {
            _removeAjaxCursor();
            item.finished = item.loadError = true;
            mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
          }
        }, mfp.st.ajax.settings);

        mfp.req = $.ajax(opts);

        return '';
      }
    }
  });







  /*>>ajax*/

  /*>>image*/
  var _imgInterval,
    _getTitle = function (item) {
      if (item.data && item.data.title !== undefined)
        return item.data.title;

      var src = mfp.st.image.titleSrc;

      if (src) {
        if ($.isFunction(src)) {
          return src.call(mfp, item);
        } else if (item.el) {
          return item.el.attr(src) || '';
        }
      }
      return '';
    };

  $.magnificPopup.registerModule('image', {

    options: {
      markup: '<div class="mfp-figure">' +
        '<div class="mfp-close"></div>' +
        '<figure>' +
        '<div class="mfp-img"></div>' +
        '<figcaption>' +
        '<div class="mfp-bottom-bar">' +
        '<div class="mfp-title"></div>' +
        '<div class="mfp-counter"></div>' +
        '</div>' +
        '</figcaption>' +
        '</figure>' +
        '</div>',
      cursor: 'mfp-zoom-out-cur',
      titleSrc: 'title',
      verticalFit: true,
      tError: '<a href="%url%">The image</a> could not be loaded.'
    },

    proto: {
      initImage: function () {
        var imgSt = mfp.st.image,
          ns = '.image';

        mfp.types.push('image');

        _mfpOn(OPEN_EVENT + ns, function () {
          if (mfp.currItem.type === 'image' && imgSt.cursor) {
            _body.addClass(imgSt.cursor);
          }
        });

        _mfpOn(CLOSE_EVENT + ns, function () {
          if (imgSt.cursor) {
            _body.removeClass(imgSt.cursor);
          }
          _window.off('resize' + EVENT_NS);
        });

        _mfpOn('Resize' + ns, mfp.resizeImage);
        if (mfp.isLowIE) {
          _mfpOn('AfterChange', mfp.resizeImage);
        }
      },
      resizeImage: function () {
        var item = mfp.currItem;
        if (!item || !item.img) return;

        if (mfp.st.image.verticalFit) {
          var decr = 0;
          // fix box-sizing in ie7/8
          if (mfp.isLowIE) {
            decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'), 10);
          }
          item.img.css('max-height', mfp.wH - decr);
        }
      },
      _onImageHasSize: function (item) {
        if (item.img) {

          item.hasSize = true;

          if (_imgInterval) {
            clearInterval(_imgInterval);
          }

          item.isCheckingImgSize = false;

          _mfpTrigger('ImageHasSize', item);

          if (item.imgHidden) {
            if (mfp.content)
              mfp.content.removeClass('mfp-loading');

            item.imgHidden = false;
          }

        }
      },

      /**
       * Function that loops until the image has size to display elements that rely on it asap
       */
      findImageSize: function (item) {

        var counter = 0,
          img = item.img[0],
          mfpSetInterval = function (delay) {

            if (_imgInterval) {
              clearInterval(_imgInterval);
            }
            // decelerating interval that checks for size of an image
            _imgInterval = setInterval(function () {
              if (img.naturalWidth > 0) {
                mfp._onImageHasSize(item);
                return;
              }

              if (counter > 200) {
                clearInterval(_imgInterval);
              }

              counter++;
              if (counter === 3) {
                mfpSetInterval(10);
              } else if (counter === 40) {
                mfpSetInterval(50);
              } else if (counter === 100) {
                mfpSetInterval(500);
              }
            }, delay);
          };

        mfpSetInterval(1);
      },

      getImage: function (item, template) {

        var guard = 0,

          // image load complete handler
          onLoadComplete = function () {
            if (item) {
              if (item.img[0].complete) {
                item.img.off('.mfploader');

                if (item === mfp.currItem) {
                  mfp._onImageHasSize(item);

                  mfp.updateStatus('ready');
                }

                item.hasSize = true;
                item.loaded = true;

                _mfpTrigger('ImageLoadComplete');

              }
              else {
                // if image complete check fails 200 times (20 sec), we assume that there was an error.
                guard++;
                if (guard < 200) {
                  setTimeout(onLoadComplete, 100);
                } else {
                  onLoadError();
                }
              }
            }
          },

          // image error handler
          onLoadError = function () {
            if (item) {
              item.img.off('.mfploader');
              if (item === mfp.currItem) {
                mfp._onImageHasSize(item);
                mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
              }

              item.hasSize = true;
              item.loaded = true;
              item.loadError = true;
            }
          },
          imgSt = mfp.st.image;


        var el = template.find('.mfp-img');
        if (el.length) {
          var img = document.createElement('img');
          // code taken from a commit merged in later version of the library to resolve the alt problem
          // https://github.com/dimsemenov/Magnific-Popup/pull/496/
          img.className = 'mfp-img';
          img.alt = item.el.find('img').attr('alt');
          item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
          img.src = item.src;

          // without clone() "error" event is not firing when IMG is replaced by new IMG
          // TODO: find a way to avoid such cloning
          if (el.is('img')) {
            item.img = item.img.clone();
          }

          img = item.img[0];
          if (img.naturalWidth > 0) {
            item.hasSize = true;
          } else if (!img.width) {
            item.hasSize = false;
          }
        }

        mfp._parseMarkup(template, {
          title: _getTitle(item),
          img_replaceWith: item.img
        }, item);

        mfp.resizeImage();

        if (item.hasSize) {
          if (_imgInterval) clearInterval(_imgInterval);

          if (item.loadError) {
            template.addClass('mfp-loading');
            mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
          } else {
            template.removeClass('mfp-loading');
            mfp.updateStatus('ready');
          }
          return template;
        }

        mfp.updateStatus('loading');
        item.loading = true;

        if (!item.hasSize) {
          item.imgHidden = true;
          template.addClass('mfp-loading');
          mfp.findImageSize(item);
        }

        return template;
      }
    }
  });



  /*>>image*/

  /*>>zoom*/
  var hasMozTransform,
    getHasMozTransform = function () {
      if (hasMozTransform === undefined) {
        hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
      }
      return hasMozTransform;
    };

  $.magnificPopup.registerModule('zoom', {

    options: {
      enabled: false,
      easing: 'ease-in-out',
      duration: 300,
      opener: function (element) {
        return element.is('img') ? element : element.find('img');
      }
    },

    proto: {

      initZoom: function () {
        var zoomSt = mfp.st.zoom,
          ns = '.zoom',
          image;

        if (!zoomSt.enabled || !mfp.supportsTransition) {
          return;
        }

        var duration = zoomSt.duration,
          getElToAnimate = function (image) {
            var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
              transition = 'all ' + (zoomSt.duration / 1000) + 's ' + zoomSt.easing,
              cssObj = {
                position: 'fixed',
                zIndex: 9999,
                left: 0,
                top: 0,
                '-webkit-backface-visibility': 'hidden'
              },
              t = 'transition';

            cssObj['-webkit-' + t] = cssObj['-moz-' + t] = cssObj['-o-' + t] = cssObj[t] = transition;

            newImg.css(cssObj);
            return newImg;
          },
          showMainContent = function () {
            mfp.content.css('visibility', 'visible');
          },
          openTimeout,
          animatedImg;

        _mfpOn('BuildControls' + ns, function () {
          if (mfp._allowZoom()) {

            clearTimeout(openTimeout);
            mfp.content.css('visibility', 'hidden');

            // Basically, all code below does is clones existing image, puts in on top of the current one and animated it

            image = mfp._getItemToZoom();

            if (!image) {
              showMainContent();
              return;
            }

            animatedImg = getElToAnimate(image);

            animatedImg.css(mfp._getOffset());

            mfp.wrap.append(animatedImg);

            openTimeout = setTimeout(function () {
              animatedImg.css(mfp._getOffset(true));
              openTimeout = setTimeout(function () {

                showMainContent();

                setTimeout(function () {
                  animatedImg.remove();
                  image = animatedImg = null;
                  _mfpTrigger('ZoomAnimationEnded');
                }, 16); // avoid blink when switching images

              }, duration); // this timeout equals animation duration

            }, 16); // by adding this timeout we avoid short glitch at the beginning of animation


            // Lots of timeouts...
          }
        });
        _mfpOn(BEFORE_CLOSE_EVENT + ns, function () {
          if (mfp._allowZoom()) {

            clearTimeout(openTimeout);

            mfp.st.removalDelay = duration;

            if (!image) {
              image = mfp._getItemToZoom();
              if (!image) {
                return;
              }
              animatedImg = getElToAnimate(image);
            }


            animatedImg.css(mfp._getOffset(true));
            mfp.wrap.append(animatedImg);
            mfp.content.css('visibility', 'hidden');

            setTimeout(function () {
              animatedImg.css(mfp._getOffset());
            }, 16);
          }

        });

        _mfpOn(CLOSE_EVENT + ns, function () {
          if (mfp._allowZoom()) {
            showMainContent();
            if (animatedImg) {
              animatedImg.remove();
            }
            image = null;
          }
        });
      },

      _allowZoom: function () {
        return mfp.currItem.type === 'image';
      },

      _getItemToZoom: function () {
        if (mfp.currItem.hasSize) {
          return mfp.currItem.img;
        } else {
          return false;
        }
      },

      // Get element postion relative to viewport
      _getOffset: function (isLarge) {
        var el;
        if (isLarge) {
          el = mfp.currItem.img;
        } else {
          el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
        }

        var offset = el.offset();
        var paddingTop = parseInt(el.css('padding-top'), 10);
        var paddingBottom = parseInt(el.css('padding-bottom'), 10);
        offset.top -= ($(window).scrollTop() - paddingTop);


        /*

         Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

         */
        var obj = {
          width: el.width(),
          // fix Zepto height+padding issue
          height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
        };

        // I hate to do this, but there is no another option
        if (getHasMozTransform()) {
          obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
        } else {
          obj.left = offset.left;
          obj.top = offset.top;
        }
        return obj;
      }

    }
  });



  /*>>zoom*/

  /*>>iframe*/

  var IFRAME_NS = 'iframe',
    _emptyPage = '//about:blank',

    _fixIframeBugs = function (isShowing) {
      if (mfp.currTemplate[IFRAME_NS]) {
        var el = mfp.currTemplate[IFRAME_NS].find('iframe');
        if (el.length) {
          // reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
          if (!isShowing) {
            el[0].src = _emptyPage;
          }

          // IE8 black screen bug fix
          if (mfp.isIE8) {
            el.css('display', isShowing ? 'block' : 'none');
          }
        }
      }
    };

  $.magnificPopup.registerModule(IFRAME_NS, {

    options: {
      markup: '<div class="mfp-iframe-scaler">' +
        '<div class="mfp-close"></div>' +
        '<iframe class="mfp-iframe" src="//about:blank" allowfullscreen></iframe>' +
        '</div>',

      srcAction: 'iframe_src',

      // we don't care and support only one default type of URL by default
      patterns: {
        youtube: {
          index: 'youtube.com',
          id: 'v=',
          src: '//www.youtube.com/embed/%id%?autoplay=1'
        },
        vimeo: {
          index: 'vimeo.com/',
          id: '/',
          src: '//player.vimeo.com/video/%id%?autoplay=1'
        },
        gmaps: {
          index: '//maps.google.',
          src: '%id%&output=embed'
        }
      }
    },

    proto: {
      initIframe: function () {
        mfp.types.push(IFRAME_NS);

        _mfpOn('BeforeChange', function (e, prevType, newType) {
          if (prevType !== newType) {
            if (prevType === IFRAME_NS) {
              _fixIframeBugs(); // iframe if removed
            } else if (newType === IFRAME_NS) {
              _fixIframeBugs(true); // iframe is showing
            }
          }// else {
          // iframe source is switched, don't do anything
          //}
        });

        _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function () {
          _fixIframeBugs();
        });
      },

      getIframe: function (item, template) {
        var embedSrc = item.src;
        var iframeSt = mfp.st.iframe;

        $.each(iframeSt.patterns, function () {
          if (embedSrc.indexOf(this.index) > -1) {
            if (this.id) {
              if (typeof this.id === 'string') {
                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
              } else {
                embedSrc = this.id.call(this, embedSrc);
              }
            }
            embedSrc = this.src.replace('%id%', embedSrc);
            return false; // break;
          }
        });

        var dataObj = {};
        if (iframeSt.srcAction) {
          dataObj[iframeSt.srcAction] = embedSrc;
        }
        mfp._parseMarkup(template, dataObj, item);

        mfp.updateStatus('ready');

        return template;
      }
    }
  });



  /*>>iframe*/

  /*>>gallery*/
  /**
   * Get looped index depending on number of slides
   */
  var _getLoopedId = function (index) {
    var numSlides = mfp.items.length;
    if (index > numSlides - 1) {
      return index - numSlides;
    } else if (index < 0) {
      return numSlides + index;
    }
    return index;
  },
    _replaceCurrTotal = function (text, curr, total) {
      return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
    };

  $.magnificPopup.registerModule('gallery', {

    options: {
      enabled: false,
      arrowMarkup: '<button aria-label="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
      preload: [0, 2],
      navigateByImgClick: true,
      arrows: true,

      tPrev: 'Previous (Left arrow key)',
      tNext: 'Next (Right arrow key)',
      tCounter: '%curr% of %total%'
    },

    proto: {
      initGallery: function () {

        var gSt = mfp.st.gallery,
          ns = '.mfp-gallery',
          supportsFastClick = Boolean($.fn.mfpFastClick);

        mfp.direction = true; // true - next, false - prev

        if (!gSt || !gSt.enabled) return false;

        _wrapClasses += ' mfp-gallery';

        _mfpOn(OPEN_EVENT + ns, function () {

          if (gSt.navigateByImgClick) {
            mfp.wrap.on('click' + ns, '.mfp-img', function () {
              if (mfp.items.length > 1) {
                mfp.next();
                return false;
              }
            });
          }

          _document.on('keydown' + ns, function (e) {
            if (e.keyCode === 37) {
              mfp.prev();
            } else if (e.keyCode === 39) {
              mfp.next();
            }
          });
        });

        _mfpOn('UpdateStatus' + ns, function (e, data) {
          if (data.text) {
            data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
          }
        });

        _mfpOn(MARKUP_PARSE_EVENT + ns, function (e, element, values, item) {
          var l = mfp.items.length;
          values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
        });

        _mfpOn('BuildControls' + ns, function () {
          if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
            var markup = gSt.arrowMarkup,
              arrowLeft = mfp.arrowLeft = $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left')).addClass(PREVENT_CLOSE_CLASS),
              arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right')).addClass(PREVENT_CLOSE_CLASS);

            var eName = supportsFastClick ? 'mfpFastClick' : 'click';
            arrowLeft[eName](function () {
              mfp.prev();
            });
            arrowRight[eName](function () {
              mfp.next();
            });

            // Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b)
            if (mfp.isIE7) {
              _getEl('b', arrowLeft[0], false, true);
              _getEl('a', arrowLeft[0], false, true);
              _getEl('b', arrowRight[0], false, true);
              _getEl('a', arrowRight[0], false, true);
            }

            mfp.container.append(arrowLeft.add(arrowRight));
          }
        });

        _mfpOn(CHANGE_EVENT + ns, function () {
          if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

          mfp._preloadTimeout = setTimeout(function () {
            mfp.preloadNearbyImages();
            mfp._preloadTimeout = null;
          }, 16);
        });


        _mfpOn(CLOSE_EVENT + ns, function () {
          _document.off(ns);
          mfp.wrap.off('click' + ns);

          if (mfp.arrowLeft && supportsFastClick) {
            mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
          }
          mfp.arrowRight = mfp.arrowLeft = null;
        });

      },
      next: function () {
        mfp.direction = true;
        mfp.index = _getLoopedId(mfp.index + 1);
        mfp.updateItemHTML();
      },
      prev: function () {
        mfp.direction = false;
        mfp.index = _getLoopedId(mfp.index - 1);
        mfp.updateItemHTML();
      },
      goTo: function (newIndex) {
        mfp.direction = (newIndex >= mfp.index);
        mfp.index = newIndex;
        mfp.updateItemHTML();
      },
      preloadNearbyImages: function () {
        var p = mfp.st.gallery.preload,
          preloadBefore = Math.min(p[0], mfp.items.length),
          preloadAfter = Math.min(p[1], mfp.items.length),
          i;

        for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
          mfp._preloadItem(mfp.index + i);
        }
        for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
          mfp._preloadItem(mfp.index - i);
        }
      },
      _preloadItem: function (index) {
        index = _getLoopedId(index);

        if (mfp.items[index].preloaded) {
          return;
        }

        var item = mfp.items[index];
        if (!item.parsed) {
          item = mfp.parseEl(index);
        }

        _mfpTrigger('LazyLoad', item);

        if (item.type === 'image') {
          item.img = $('<img class="mfp-img" />').on('load.mfploader', function () {
            item.hasSize = true;
          }).on('error.mfploader', function () {
            item.hasSize = true;
            item.loadError = true;
            _mfpTrigger('LazyLoadError', item);
          }).attr('src', item.src);
        }


        item.preloaded = true;
      }
    }
  });

  /*
   Touch Support that might be implemented some day

   addSwipeGesture: function() {
   var startX,
   moved,
   multipleTouches;

   return;

   var namespace = '.mfp',
   addEventNames = function(pref, down, move, up, cancel) {
   mfp._tStart = pref + down + namespace;
   mfp._tMove = pref + move + namespace;
   mfp._tEnd = pref + up + namespace;
   mfp._tCancel = pref + cancel + namespace;
   };

   if(window.navigator.msPointerEnabled) {
   addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
   } else if('ontouchstart' in window) {
   addEventNames('touch', 'start', 'move', 'end', 'cancel');
   } else {
   return;
   }
   _window.on(mfp._tStart, function(e) {
   var oE = e.originalEvent;
   multipleTouches = moved = false;
   startX = oE.pageX || oE.changedTouches[0].pageX;
   }).on(mfp._tMove, function(e) {
   if(e.originalEvent.touches.length > 1) {
   multipleTouches = e.originalEvent.touches.length;
   } else {
   //e.preventDefault();
   moved = true;
   }
   }).on(mfp._tEnd + ' ' + mfp._tCancel, function(e) {
   if(moved && !multipleTouches) {
   var oE = e.originalEvent,
   diff = startX - (oE.pageX || oE.changedTouches[0].pageX);

   if(diff > 20) {
   mfp.next();
   } else if(diff < -20) {
   mfp.prev();
   }
   }
   });
   },
   */


  /*>>gallery*/

  /*>>retina*/

  var RETINA_NS = 'retina';

  $.magnificPopup.registerModule(RETINA_NS, {
    options: {
      replaceSrc: function (item) {
        return item.src.replace(/\.\w+$/, function (m) { return '@2x' + m; });
      },
      ratio: 1 // Function or number.  Set to 1 to disable.
    },
    proto: {
      initRetina: function () {
        if (window.devicePixelRatio > 1) {

          var st = mfp.st.retina,
            ratio = st.ratio;

          ratio = !isNaN(ratio) ? ratio : ratio();

          if (ratio > 1) {
            _mfpOn('ImageHasSize' + '.' + RETINA_NS, function (e, item) {
              item.img.css({
                'max-width': item.img[0].naturalWidth / ratio,
                'width': '100%'
              });
            });
            _mfpOn('ElementParse' + '.' + RETINA_NS, function (e, item) {
              item.src = st.replaceSrc(item, ratio);
            });
          }
        }

      }
    }
  });

  /*>>retina*/

  /*>>fastclick*/
  /**
   * FastClick event implementation. (removes 300ms delay on touch devices)
   * Based on https://developers.google.com/mobile/articles/fast_buttons
   *
   * You may use it outside the Magnific Popup by calling just:
   *
   * $('.your-el').mfpFastClick(function() {
*     console.log('Clicked!');
* });
   *
   * To unbind:
   * $('.your-el').destroyMfpFastClick();
   *
   *
   * Note that it's a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
   * If you need something more advanced, use plugin by FT Labs https://github.com/ftlabs/fastclick
   *
   */

  (function () {
    var ghostClickDelay = 1000,
      supportsTouch = 'ontouchstart' in window,
      unbindTouchMove = function () {
        _window.off('touchmove' + ns + ' touchend' + ns);
      },
      eName = 'mfpFastClick',
      ns = '.' + eName;


    // As Zepto.js doesn't have an easy way to add custom events (like jQuery), so we implement it in this way
    $.fn.mfpFastClick = function (callback) {

      return $(this).each(function () {

        var elem = $(this),
          lock;

        if (supportsTouch) {

          var timeout,
            startX,
            startY,
            pointerMoved,
            point,
            numPointers;

          elem.on('touchstart' + ns, function (e) {
            pointerMoved = false;
            numPointers = 1;

            point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
            startX = point.clientX;
            startY = point.clientY;

            _window.on('touchmove' + ns, function (e) {
              point = e.originalEvent ? e.originalEvent.touches : e.touches;
              numPointers = point.length;
              point = point[0];
              if (Math.abs(point.clientX - startX) > 10 ||
                Math.abs(point.clientY - startY) > 10) {
                pointerMoved = true;
                unbindTouchMove();
              }
            }).on('touchend' + ns, function (e) {
              unbindTouchMove();
              if (pointerMoved || numPointers > 1) {
                return;
              }
              lock = true;
              e.preventDefault();
              clearTimeout(timeout);
              timeout = setTimeout(function () {
                lock = false;
              }, ghostClickDelay);
              callback();
            });
          });

        }

        elem.on('click' + ns, function () {
          if (!lock) {
            callback();
          }
        });
      });
    };

    $.fn.destroyMfpFastClick = function () {
      $(this).off('touchstart' + ns + ' click' + ns);
      if (supportsTouch) _window.off('touchmove' + ns + ' touchend' + ns);
    };
  })();

  /*>>fastclick*/
  _checkInstance();
})(window.jQuery || window.Zepto);
define("magnificPopup", ["jquery"], function () { });

/* 
* Author : Mathieu Sylvain - mathieu.sylvain@nurun.com
* Date : 2010
* Modified By: Michel Gratton - michel.gratton@nurun.com, michel.gratton@nadrox.com
* 				Billy Rancourt - billy.rancourt@nurun.com
* 				Alexandre Paquette - alexandre.paquette@nurun.com, alexandre.paquette@nadrox.com
*				Anthony Bucci - anthony.bucci@nurun.com
* 				Etienne Dion - etienne.dion@nurun.com
*
* Modified Date : March 22, 2013
Enhance.js

A javascript library for progressive enhancement

Usage:
// Apply all enhancements to the whole document
jQuery(document).enhance();

// Apply all enhancements to a specific part of the page (after ajax or dhtml)
jQuery("#pageSection1").enhance();

// Register a new enhancement by id
jQuery.enhance(function (targets) {
// some code here...
}, {
id: "ajaxPagingBehavior",
title: "adding ajax behavior on paging"
});

// Register a new enhancement by group
jQuery.enhance(function (targets) {
// some code here...
}, {
id: "ajaxPagingBehavior",
title: "adding ajax behavior on paging"
group: "ajax"
});

// Clear Enhancement for this element
jQuery("#element").clearEnhance();



Upcomming features:
- Provide a callback for when enhancement are complete
- Specify a method to test if requirements are met

* October 13, 2011 Update - AP
* Added "elems" attribute of the enhancement object which is an array of the
* elements where the same data-enhance attribute is applied.
* Also enhanced elements are flagged so the same enchancement is not runned twice
*
* November 8, 2012 Update - ED
* -Clear Enhancement
* -Console log for already enhanced elements
* -Remove data-enhance for enhanced elements (enhance-***-applied become the only flag to determine if elements hanve already been enhance) so it is easy to remove this class to re-enhance element
* -Grouped log to clean the console
* -Log time and grouped log for ie
*
* September 9, 2013 Update - ED
* - Add Support for AMD / Require.js
* January 6, 2014 Update - ED
* - Add Support for QUnit
*/


(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('enhance', ['jquery'], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {
  var hasConsole = typeof console !== "undefined",
    hasConsoleLog = hasConsole && typeof console.log !== "undefined",
    hasConsoleTime = hasConsole && typeof console.time !== "undefined",
    hasConsoleTimeEnd = hasConsole && typeof console.timeEnd !== "undefined",
    hasConsoleGroupCollapsed = hasConsole && typeof console.groupCollapsed !== "undefined",
    hasConsoleGroupEnd = hasConsole && typeof console.groupEnd !== "undefined",
    hasConsoleDir = hasConsole && typeof console.dir !== "undefined",
    hasConsoleError = hasConsole && typeof console.error !== "undefined",
    hasConsoleWarn = hasConsole && typeof console.warn !== "undefined",
    enhancements = [],
    enhancementGroups = { global: [] },
    enhanceCnt = 0, // Use for auto id
    enhOptions = {
      "class": "enhance", // default className selector
      "dataHandler": "enhance" // default data attribute [data-enhance]
    },
    timers = {},
    counter = 0,
    errors = 0;
  indentForIE = "";

  if (!hasConsoleTime) {
    indentForIE = "      ";
  }
  if (!hasConsole) {
    console = { assert: function () { }, clear: function () { }, count: function () { }, debug: function () { }, dir: function () { }, dirxml: function () { }, error: function () { }, exception: function () { }, group: function () { }, groupCollapsed: function () { }, groupEnd: function () { }, info: function () { }, log: function () { }, memoryProfile: function () { }, memoryProfileEnd: function () { }, profile: function () { }, profileEnd: function () { }, table: function () { }, time: function () { }, timeEnd: function () { }, timeStamp: function () { }, trace: function () { }, warn: function () { } };
  }

  if (typeof window.QUnit !== 'undefined') {
    if (hasConsoleError) {
      var originalerror = console.error;
      console.error = function (msg, arguments) {
        test("Console Error :", function () {
          ok(false, "Error: " + msg);
        });
        originalerror.apply(console, msg, arguments);
      }
    }
  }
  function logGroup(group, elem, status) {
    elem = elem || "";

    if (hasConsoleTime && typeof window.QUnit === 'undefined') {

      if (status === "start") {
        if (hasConsoleGroupCollapsed) console.groupCollapsed(group, elem);
      } else {
        if (hasConsoleGroupEnd) console.groupEnd();
      }


    } else {
      if (status === "start") {

        var selector = $(elem).prop("tagName") || "",
          id = $(elem).attr("id"),
          classNames = $(elem).attr("class");

        if (id) {
          selector += "#" + id;
        }
        if (classNames) {
          selector += "." + $.trim(classNames).replace(/\s/gi, ".");
        }

        if (hasConsoleLog) console.log(group, selector);

      }
    }
  };

  function startTimer(id) {
    function instance(id) {
      this.id = id;
      var date = new Date;
      this.start = date.getTime();
    }
    if (hasConsoleTime && typeof window.QUnit === 'undefined') {
      console.time(id);
    } else {
      timers[id] = [];
      var timerInstance = new instance(id);
      timers[id].push(timerInstance);
    }

  }

  function time(id) {
    var date = new Date;
    var end = date.getTime();
    var time = end - timers[id][0].start;

    return time;
  }
  function logTime(id) {

    if (hasConsoleTime && hasConsoleTimeEnd && typeof window.QUnit === 'undefined') {
      console.timeEnd(id);
    } else {
      if (hasConsoleLog) console.log(id + " : " + time(id) + "ms");
    }

  }

  function getTargetElems(target) {
    var elems = [];

    // Check if the target or one of its decendents has the enhance trigger class
    // Ex: in $(document).enhance(); "$(document)" is the target.

    if (target.hasClass(enhOptions["class"])) {
      elems.push($(target)[0]);
    }

    target.find('.' + enhOptions["class"]).each(function () {
      elems.push($(this)[0]);
    });

    return elems;
  }

  function getGroupeContext(gc) {
    var list,
      globalIndex;

    if (typeof gc == "undefined" || gc.length == 0 || gc[0] == "") {
      return false;
    }


    // replace asterisk with actual global group name
    list = $.trim(gc).split(/\s+/);
    globalIndex = $.inArray('*', list);
    if (globalIndex != -1) {
      list[globalIndex] = 'global';
    }
    return list;
  }

  function applyEnhancements() {
    var target = this,
      group,
      elems,
      execGroups = {},
      enhs = {};

    elems = getTargetElems(target);

    $.each(elems, function (index, value) {
      var g, i, eni;

      g = getGroupeContext($(this).data(enhOptions.dataHandler) || "");

      if (g) {
        for (i = 0; i < g.length; i++) {

          group = enhancementGroups[g[i]];

          if (typeof group !== "undefined") {
            execGroups[g[i]] = g[i];

            for (eni = 0; group[eni]; eni++) {

              if (!enhs[group[eni].id]) {
                enhs[group[eni].id] = group[eni];
                //reset previously added elements in global scope
                enhs[group[eni].id].elems = [];
                enhs[group[eni].id].groupId = index;
              } else {
                // if(hasConsoleWarn) console.warn('Already in a group ', enhs[group[eni].id]);
              }


              if (!!!$(value).hasClass("enhance-" + group[eni].id + "-applied")) {
                enhs[group[eni].id].elems.push(value);
                enhs[group[eni].id].groupId = index;
              } else {
                if (typeof window.QUnit === 'undefined') {
                  if (hasConsoleWarn) console.warn('Already applied enhancement ', enhs[group[eni].id]);
                }
              }
            }
          } else {
            if (typeof window.QUnit === 'undefined') {
              if (hasConsoleWarn) console.warn('No enhancement "' + g[i] + '" found.');
            }
          }
        }
      }
    });



    logGroup("--- Enhancement Detail ", null, "start");

    /*** DEBUG ***/
    if (hasConsoleLog) {
      console.log("All Enhancements to apply : ");
    }

    if (hasConsoleDir && typeof window.QUnit === 'undefined') {
      console.dir(enhs);
    }

    /*** END DEBUG ***/

    startTimer("--- Enhanced Time");

    var index = 0,
      groupId = 0;

    $.each(enhs, function () {
      var id = (this.id !== null) ? "#" + this.id + ": " : "",
        desc = "Enhanced: " + id + this.title,
        _this = this;


      function tryCatch() {
        //try {

        startTimer(indentForIE + indentForIE + desc);

        //$(_this.elems).data("enhance-"+ _this.id + "-applied", true);
        //data 'enhance-'..'-applied' removed (class is there already we dont need 2 flag)
        $(_this.elems).addClass("enhance-" + _this.id + "-applied");
        _this.handler($(_this.elems), target);

        counter = counter + 1;
        logTime(indentForIE + indentForIE + desc);

        if (typeof window.QUnit !== 'undefined') {

          ok(true, "Enhance Success");
          console.log("Enhance Test " + desc + ": Success");

        }


        /*} catch(e) {
            errors = errors+1;
            if (hasConsole){
                if(hasConsoleError) {
                    console.error("Enhancement failed: " + _this.title);
                    console.log("Error :");
                }
                if(hasConsoleDir) {
                    if(typeof window.QUnit === 'undefined'){
                        console.dir({
                            "exception": e,
                            "enhancement": _this,
                            "target": target
                        });
                    }
                }
            }

            if(typeof window.QUnit !== 'undefined'){
                console.log("Enhance Test "+desc+": Fail");
                ok( false, "Enhance Fail" );
            }
       // }
       */
      }


      if (groupId !== _this.groupId) {

        logGroup("", null, "end");

        groupId = _this.groupId;
        logGroup(indentForIE + "for element(s) : ", _this.elems, "start");


      } else {
        if (index === 0) {
          logGroup(indentForIE + "for element(s) : ", _this.elems, "start");
        }


      }
      if (typeof window.QUnit !== 'undefined') {
        test("Test Enhance :" + id + this.title, function () {
          tryCatch();
        });
      } else {
        tryCatch();
      }

      index = index + 1;

    });


    logGroup("", null, "end");
    logGroup("", null, "end");
    if (typeof window.QUnit === 'undefined') {
      if (hasConsoleError && errors) {
        console.error("--- Nb of elements enhanced :", counter, "; Nb of errors :", errors);
      } else {
        if (hasConsoleLog) console.log("--- Nb of elements enhanced :", counter, "; Nb of errors :", errors);
      }

      logTime("--- Enhanced Time");
    } else {

      test("Global Test :", function () {
        if (hasConsoleError && errors) {
          ok(false, "Error");
          console.error("--- Nb of elements enhanced :", counter, "; Nb of errors :", errors);
        } else {
          if (hasConsoleLog) console.log("--- Nb of elements enhanced :", counter, "; Nb of errors :", errors);
          console.log("Global Test : Done");
          ok(true, "Done");

          test("Delayed Test :", function () {
            var y = 0;
            for (var i = 0; i <= 1000000000; i++) {
              y = i;
            }
            for (var i = 0; i <= 1000000000; i++) {
              y = i;
            }
            for (var i = 0; i <= 500000000; i++) {
              y = i;
            }
            for (var i = 0; i <= 500000000; i++) {
              y = i;
            }
            console.log("Delayed Test : Done");
            ok(true, "Done");


          });
        }

      });
    }

    counter = 0;

    return this;
  }

  function Enhancement(handler, _options) {
    this.handler = handler;
    var o = this.option = $.extend({}, _options);
    this.id = o.id || 'enhancejs-' + (++enhanceCnt);
    this.title = o.title || "";
    var group = o.group || "";
    if (o.id) group = group + " " + o.id;
    this.groups = getGroupeContext(group);
    this.elems = [];//will contain all elements from the group
  }

  function registerEnhancement(handler, _options) {
    if ($.isFunction(handler)) {
      var enh = new Enhancement(handler, _options);
      enhancements.push(enh);
      $.each(enh.groups, function () {
        var g = this.toString();
        if (typeof enhancementGroups[g] == "undefined") {
          enhancementGroups[g] = [];
        }
        enhancementGroups[g].push(enh);
      });
    } else {
      enhOptions = $.extend(enhOptions, handler);
    }
  }

  function clearEnhancements() {
    var $this = $(this);

    var classNames = $this.attr("class");
    if (classNames) {

      var classArray = classNames.split(" ");

      for (var i = 0; i < classArray.length; i++) {

        var regexp = new RegExp("^enhance\\-.+\\-applied$");

        if (classArray[i].match(regexp)) {

          $this.removeClass(classArray[i]);
        }

      }
    }
    return this;
  }

  function array_merge(first, second, byVal) {
    if (typeof byVal !== "undefined" && byVal) {
      var i = first.length,
        j = 0;

      if (typeof second.length === "number") {
        for (var l = second.length; j < l; j++) {
          if ($.inArray(second[j], first) === -1) {
            first[i++] = second[j];
          }
        }

      } else {
        while (second[j] !== undefined) {
          if ($.inArray(second[j], first) === -1) {
            first[i++] = second[j++];
          }
        }
      }

      first.length = i;

      return first;
    } else {
      return $.merge(first, second);
    }
  }
  // Check if jQuery is loaded
  if ($) {
    $.fn.array_merge = $.array_merge = array_merge;
    $.fn.enhance = applyEnhancements;
    $.fn.clearEnhance = clearEnhancements;
    $.enhance = registerEnhancement;
  }
}));
define('uiTools/modals', [
  'jquery',
  'UTILS',
  'UTILS_PRELOADER',
  'i18n/modal',
  'focusTrap',
  'magnificPopup',
  'enhance'
], function ($, Utils, Preloader, i18n, focusTrap) {

  var eventEmitter;
  var galleryFocusTrap;

  var Modals = {
    init: function (context, type) {

      eventEmitter = ADM.eventEmitter;

      $.extend(true, $.magnificPopup.defaults, {
        tClose: i18n.tClose, // Alt text on close button
        tLoading: i18n.tLoading, // Text that is displayed during loading. Can contain %curr% and %total% keys
        gallery: {
          tPrev: i18n.tPrev, // Alt text on left arrow
          tNext: i18n.tNext, // Alt text on right arrow
          tCounter: i18n.tCounter // Markup for "1 of 7" counter
        },
        image: {
          tError: i18n['image.tError'] // Error message when image could not be loaded
        },
        ajax: {
          tError: i18n['ajax.tError'] // Error message when ajax request failed
        }
      });

      //ie7 close compatibility popup
      $(".mfp-container.alreadyshowded .magnific-popup-close-link").click(function () {
        $(".mfp-bg").remove();
        $("#compatibilitypopup").remove();
        $("html").attr("style", "");
        $("html").attr({
          "margin-right": 0,
          "overflow": "visible"
        });
      });


      var $popup = $(context);
      var popup_open = 0;

      $(Utils.removeHighlightedCodeFromContext($popup)).each(function () {

        var $el = $(this),
          settings = {},
          ctnSelector,
          pptype = $el.attr('data-magnific-popup-type') || type;

        settings.closeOnContentClick = false;

        switch (pptype) {
          case "image":

            settings.items = {
              src: $el.attr('href')
            };
            settings.type = 'image';
            settings.preloader = true;
            settings.closeOnContentClick = true;
            settings.closeBtnInside = false;
            settings.callbacks = {
              beforeOpen: function () {

                $(window).bind('orientationchange', function () {
                  setTimeout(function () {
                    $.magnificPopup.close();
                  }, 200);
                });

              }
            };


            break;
          case "selector":
            ctnSelector = $el.attr('href');

            settings.src = $el.attr('href');
            settings.type = 'inline';

            if ($el.attr('data-magnific-popup-closeButton') !== undefined) {
              settings.modal = true;
            }

            break;
          case "video":  //youtube
          case "youtube":  //youtube

            settings.src = $el.attr('href');
            settings.type = 'iframe';
            settings.preloader = false;
            settings.closeBtnInside = false;
            settings.closeOnContentClick = false;
            settings.disableOn = 640;
            break;
          case "ajax":

            settings.src = $el.attr('href');
            settings.type = 'ajax';
            settings.preloader = true;
            settings.closeOnContentClick = false;
            settings.closeBtnInside = false;
            settings.disableOn = 640;
            break;

          case "interactivemap":


            settings.src = $el.attr('href');
            settings.type = 'ajax';
            settings.preloader = false;
            settings.closeOnContentClick = false;
            settings.closeBtnInside = false;
            //Do not remove this line
            //To prevent to close the popup with the Google Autocomplete...
            settings.closeOnBgClick = false;
            //Close the popup when the window width is less then
            settings.disableOn = 640;
            // Class that is added to popup wrapper and background
            settings.mainClass = "interactive-map";

            settings.callbacks = {
              beforeOpen: function () {
                // Will fire before the popup is opened

                //Scroll Top to prevent the google AdresseAutoComplete (".pac-container")
                $(window).scrollTop(0);
              },
              parseAjax: function (mfpResponse) {

                //Set the HTML
                mfpResponse.data = $(mfpResponse.data).find("#interactivemap");
                //console.log('interactivemap Ajax content loaded:', mfpResponse, mfpResponse.data);

                /*
                 *  We do this only to have one main class on popup container only (Desktop/Tablet)
                 */
                $(".mfp-bg").removeClass(settings.mainClass);

                /*
                 *  Add the Url links to the 'context' enhanced to get the params if available
                 */
                mfpResponse.data.attr("data-interactivemap-params", settings.src);

                /*
                 *  It's to print map without some element in background of the overlay.
                 */
                $("html").addClass("interactivemap-print");
              },
              beforeClose: function () {
                // Will fire before the popup is closed

                //Bring back the Google AdresseAutoComplete
                var $masterContainer = $("body");
                $pacContainer = $("." + settings.mainClass).find('.pac-container').appendTo($masterContainer);
                $pacContainer.css('z-index', '9995');
              },
              close: function () {
                // Will fire when popup is closed
                $("html").removeClass("interactivemap-print");
              },
              resize: function () {
                //console.log('Interactivemap Popup Resized');
                // resize event triggers only when height is changed or layout forced
                /*
                 *  Close popup on specific size
                 */
                eventEmitter.addListener('plaformChanged', function (platform) {
                  if (platform == "mobile") {
                    $.magnificPopup.close();
                  }
                });
              }
            };

            break;
          case "gallery":
            var opts = {
              gallery: {
                enabled: true,
                navigateByImgClick: true,
                preload: [0, 1]
              },
              image: {
                cursor: null
              },
              callbacks: {
                change: function () {
                  if ($('.mfp-preloader').length) {
                    var preloader = new Preloader({
                      diameter: 40,
                      $ctn: $('.mfp-preloader'),
                      color: '#BCC1C4',
                      position: 'absolute'
                    });

                    preloader.show();
                  }

                  var commercename = $(".head-commerce-wrapper h1").text();

                  if (popup_open) {
                    dataLayer.push({
                      'event': 'commerces_carrousel_fleche',
                      'carrousel_lang': Utils.getLang(),
                      'carrousel_commerce': commercename
                    });
                  } else {
                    popup_open = 1;
                    dataLayer.push({
                      'event': 'commerces_carrousel',
                      'carrousel_lang': Utils.getLang(),
                      'carrousel_commerce': commercename
                    });
                  }

                },
                imageLoadComplete: function () {
                  $modal = $(".mfp-container.mfp-s-ready.mfp-image-holder").parent()[0];
                  galleryFocusTrap = focusTrap.createFocusTrap($modal, {});
                  galleryFocusTrap.activate();
                },
                close: function () {
                  popup_open = 0;
                  if (galleryFocusTrap) {
                    galleryFocusTrap.deactivate();
                    galleryFocusTrap = undefined;
                  }
                }
              },
              enableEscapeKey: true,
              closeOnBgClick: true,
              type: 'image',
              delegate: '.media-content a',
              tLoading: '', //using preload canvas loader
              closeMarkup: '<button type="button" class="mfp-close" aria-label="' + i18n.tClose + '"></button>',
              closeBtnInside: false,
              removalDelay: 100,
              mainClass: 'mfp-fade',
              zoom: {
                enabled: false
              },
              retina: {
                ratio: 1,
                replaceSrc: function (item, ratio) {
                  var $el = $(item.el)
                    , retina = $el.data('retina-src')
                    , src = retina || item.src;
                  return src;
                }
              }
            };

            settings.closeBtnInside = false;
            //Build options
            $.extend(settings, opts);
            break;
        }

        /* Override callbacks */
        settings.callbacks = $.extend({
          open: function () {
            // Will fire when popup is opening
          },
          ajaxContentAdded: function () {
            var $popup = $(".mfp-content");
            $popup.addClass("enhance").attr("data-enhance", "placeholder");
            $popup.clearEnhance().enhance();
          },
          close: function () {
            // Will fire when popup is closed
          }
        }, settings.callbacks || {});

        console.log(settings);
        $el.magnificPopup(settings);

        var $close = $(ctnSelector).find(".magnific-popup-close-link");
        $close.click(function () {
          $.magnificPopup.close();
        });

      });
    },

    call: function ($el, settings) {

      $.extend(true, $.magnificPopup.defaults, {
        tClose: i18n.tClose, // Alt text on close button
        tLoading: i18n.tLoading, // Text that is displayed during loading. Can contain %curr% and %total% keys
        gallery: {
          tPrev: i18n.tPrev, // Alt text on left arrow
          tNext: i18n.tNext, // Alt text on right arrow
          tCounter: i18n.tCounter // Markup for "1 of 7" counter
        },
        image: {
          tError: i18n['image.tError'] // Error message when image could not be loaded
        },
        ajax: {
          tError: i18n['ajax.tError'] // Error message when ajax request failed
        }
      });

      /*************************************
      * Extends settings for callback
      * "data.status" - current status type, can be "loading", "error", "ready"
      **************************************/
      var defaults = {
        callbacks: {
          open: function (data) {
            // Called on opened
          },
          close: function (data) {
            // Called on closed
          }
        },
        closeOnContentClick: true,
        modal: false,
        closeBtnInside: true
      };
      settings = $.extend(defaults, settings);

      /*************************************
       * Define MagnificPopup
       *************************************/
      console.log("config ", settings);
      var mp = $el.magnificPopup(defaults);
      mp.magnificPopup('open');

      /*************************************
       * When user clicks close button
       *************************************/
      $('.mfp-close', $el).click(function () {
        mp.magnificPopup('close');
      });

      $('.magnific-popup-close-link', $el).click(function () {
        mp.magnificPopup('close');
      });

    }
  };

  return Modals;
});

define('a11y/footnote', [
  'jquery',
], function ($) {
  /*
      Used on /fr/acces/stationnement?jsdebug=true
  */

  function findMatch($node, callback) {
    var html = $node.html();
    var re = /\*+/g
    var matches = html.matchAll(re);
    var offset = 0;

    for (match of matches) {
      var label = match[0]
      var textIndex = match.index + offset;

      var changes = callback(html, label, textIndex);

      offset = changes.length - html.length;
      html = changes;
    }

    $node.html(html);
  }

  function insertAnchor(html, label, textIndex) {
    var id = ['footnote', label.length].join('-');

    return addTextAtIndex(html, '<div id="' + id + '" tabindex="-1"></div>', textIndex);
  }

  function makeLinkToFootnote(html, label, textIndex) {
    var id = ['footnote', label.length].join('-');
    var link = [
      '<a href="#' + id + '"',
      'aria-describedby="' + id + '"',
      'data-footnote-link="true">',
      label,
      '</a>'
    ].join(' ');

    return replaceText(html, textIndex, label.length, link);
  }

  function replaceText(text, index, length, replacement) {
    return text.substr(0, index) + replacement + text.substr(index + length);
  }

  function addTextAtIndex(source, addText, index) {
    return source.slice(0, index) + addText + source.slice(index);
  }

  return function makeFootnoteA11y($footnote, $mention) {
    $footnote.each(function () {
      findMatch($(this), insertAnchor);
    });

    $mention.each(function () {
      findMatch($(this), makeLinkToFootnote);
    });

    $mention.on('click', '[data-footnote-link]', function (event) {
      event.preventDefault();

      var $link = $(this);
      var $footnote = $($link.attr('href'));

      if ($footnote) {
        var y = $footnote.offset().top;
        var $header = $('.header-rebrand');
        var offset = $header.height() + $header.position().top + 50;

        $('html,body').animate({ scrollTop: parseInt(y - offset) }, 500, function () {
          $footnote.focus();
        });
      }
    })
  }
});
/*!
* FooTable - Awesome Responsive Tables
* Version : 2.0.1
* http://fooplugins.com/plugins/footable-jquery/
*
* Requires jQuery - http://jquery.com/
*
* Copyright 2013 Steven Usher & Brad Vincent
* Released under the MIT license
* You are free to use FooTable in commercial projects as long as this copyright header is left intact.
*
* Date: 31 Aug 2013
*/
(function ($, w, undefined) {
  w.footable = {
    options: {
      delay: 100, // The number of millseconds to wait before triggering the react event
      breakpoints: { // The different screen resolution breakpoints
        phone: 480,
        tablet: 1024
      },
      parsers: {  // The default parser to parse the value out of a cell (values are used in building up row detail)
        alpha: function (cell) {
          return $(cell).data('value') || $.trim($(cell).text());
        },
        numeric: function (cell) {
          var val = $(cell).data('value') || $(cell).text().replace(/[^0-9.\-]/g, '');
          val = parseFloat(val);
          if (isNaN(val)) val = 0;
          return val;
        }
      },
      addRowToggle: true,
      calculateWidthOverride: null,
      toggleSelector: ' > tbody > tr:not(.footable-row-detail)', //the selector to show/hide the detail row
      columnDataSelector: '> thead > tr:last-child > th, > thead > tr:last-child > td', //the selector used to find the column data in the thead
      detailSeparator: ':', //the seperator character used when building up the detail row
      createGroupedDetail: function (data) {
        var groups = { '_none': { 'name': null, 'data': [] } };
        for (var i = 0; i < data.length; i++) {
          var groupid = data[i].group;
          if (groupid !== null) {
            if (!(groupid in groups))
              groups[groupid] = { 'name': data[i].groupName || data[i].group, 'data': [] };

            groups[groupid].data.push(data[i]);
          } else {
            groups._none.data.push(data[i]);
          }
        }
        return groups;
      },
      createDetail: function (element, data, createGroupedDetail, separatorChar, classes) {
        /// <summary>This function is used by FooTable to generate the detail view seen when expanding a collapsed row.</summary>
        /// <param name="element">This is the div that contains all the detail row information, anything could be added to it.</param>
        /// <param name="data">
        ///  This is an array of objects containing the cell information for the current row.
        ///  These objects look like the below:
        ///    obj = {
        ///      'name': String, // The name of the column
        ///      'value': Object, // The value parsed from the cell using the parsers. This could be a string, a number or whatever the parser outputs.
        ///      'display': String, // This is the actual HTML from the cell, so if you have images etc you want moved this is the one to use and is the default value used.
        ///      'group': String, // This is the identifier used in the data-group attribute of the column.
        ///      'groupName': String // This is the actual name of the group the column belongs to.
        ///    }
        /// </param>
        /// <param name="createGroupedDetail">The grouping function to group the data</param>
        /// <param name="separatorChar">The separator charactor used</param>
        /// <param name="classes">The array of class names used to build up the detail row</param>

        var groups = createGroupedDetail(data);
        for (var group in groups) {
          if (groups[group].data.length === 0) continue;
          if (group !== '_none') element.append('<div class="' + classes.detailInnerGroup + '">' + groups[group].name + '</div>');

          for (var j = 0; j < groups[group].data.length; j++) {
            var separator = (groups[group].data[j].name) ? separatorChar : '';
            element.append('<div class="' + classes.detailInnerRow + '"><div class="' + classes.detailInnerName + '">' + groups[group].data[j].name + separator + '</div><div class="' + classes.detailInnerValue + '">' + groups[group].data[j].display + '</div></div>');
          }
        }
      },
      classes: {
        main: 'footable',
        loading: 'footable-loading',
        loaded: 'footable-loaded',
        toggle: 'footable-toggle',
        disabled: 'footable-disabled',
        detail: 'footable-row-detail',
        detailCell: 'footable-row-detail-cell',
        detailInner: 'footable-row-detail-inner',
        detailInnerRow: 'footable-row-detail-row',
        detailInnerGroup: 'footable-row-detail-group',
        detailInnerName: 'footable-row-detail-name',
        detailInnerValue: 'footable-row-detail-value',
        detailShow: 'footable-detail-show'
      },
      triggers: {
        initialize: 'footable_initialize',                      //trigger this event to force FooTable to reinitialize
        resize: 'footable_resize',                              //trigger this event to force FooTable to resize
        redraw: 'footable_redraw',								//trigger this event to force FooTable to redraw
        toggleRow: 'footable_toggle_row',                       //trigger this event to force FooTable to toggle a row
        untoggleAll: 'footable_untoggleall_row',                       //trigger this event to force FooTable to toggle a row
        expandFirstRow: 'footable_expand_first_row'             //trigger this event to force FooTable to expand the first row
      },
      events: {
        alreadyInitialized: 'footable_already_initialized',     //fires when the FooTable has already been initialized
        initializing: 'footable_initializing',                  //fires before FooTable starts initializing
        initialized: 'footable_initialized',                    //fires after FooTable has finished initializing
        resizing: 'footable_resizing',                          //fires before FooTable resizes
        resized: 'footable_resized',                            //fires after FooTable has resized
        redrawn: 'footable_redrawn',                            //fires after FooTable has redrawn
        breakpoint: 'footable_breakpoint',                      //fires inside the resize function, when a breakpoint is hit
        columnData: 'footable_column_data',                     //fires when setting up column data. Plugins should use this event to capture their own info about a column
        rowDetailUpdating: 'footable_row_detail_updating',      //fires before a detail row is updated
        rowDetailUpdated: 'footable_row_detail_updated',        //fires when a detail row is being updated
        rowCollapsed: 'footable_row_collapsed',                 //fires when a row is collapsed
        rowExpanded: 'footable_row_expanded',                   //fires when a row is expanded
        rowRemoved: 'footable_row_removed'                      //fires when a row is removed
      },
      debug: false, // Whether or not to log information to the console.
      log: null
    },

    version: {
      major: 0, minor: 5,
      toString: function () {
        return w.footable.version.major + '.' + w.footable.version.minor;
      },
      parse: function (str) {
        version = /(\d+)\.?(\d+)?\.?(\d+)?/.exec(str);
        return {
          major: parseInt(version[1], 10) || 0,
          minor: parseInt(version[2], 10) || 0,
          patch: parseInt(version[3], 10) || 0
        };
      }
    },

    plugins: {
      _validate: function (plugin) {
        ///<summary>Simple validation of the <paramref name="plugin"/> to make sure any members called by FooTable actually exist.</summary>
        ///<param name="plugin">The object defining the plugin, this should implement a string property called "name" and a function called "init".</param>

        if (!$.isFunction(plugin)) {
          if (w.footable.options.debug === true) console.error('Validation failed, expected type "function", received type "{0}".', typeof plugin);
          return false;
        }
        var p = new plugin();
        if (typeof p['name'] !== 'string') {
          if (w.footable.options.debug === true) console.error('Validation failed, plugin does not implement a string property called "name".', p);
          return false;
        }
        if (!$.isFunction(p['init'])) {
          if (w.footable.options.debug === true) console.error('Validation failed, plugin "' + p['name'] + '" does not implement a function called "init".', p);
          return false;
        }
        if (w.footable.options.debug === true) console.log('Validation succeeded for plugin "' + p['name'] + '".', p);
        return true;
      },
      registered: [], // An array containing all registered plugins.
      register: function (plugin, options) {
        ///<summary>Registers a <paramref name="plugin"/> and its default <paramref name="options"/> with FooTable.</summary>
        ///<param name="plugin">The plugin that should implement a string property called "name" and a function called "init".</param>
        ///<param name="options">The default options to merge with the FooTable's base options.</param>

        if (w.footable.plugins._validate(plugin)) {
          w.footable.plugins.registered.push(plugin);
          if (typeof options === 'object') $.extend(true, w.footable.options, options);
        }
      },
      load: function (instance) {
        var loaded = [], registered, i;
        for (i = 0; i < w.footable.plugins.registered.length; i++) {
          try {
            registered = w.footable.plugins.registered[i];
            loaded.push(new registered(instance));
          } catch (err) {
            if (w.footable.options.debug === true) console.error(err);
          }
        }
        return loaded;
      },
      init: function (instance) {
        ///<summary>Loops through all registered plugins and calls the "init" method supplying the current <paramref name="instance"/> of the FooTable as the first parameter.</summary>
        ///<param name="instance">The current instance of the FooTable that the plugin is being initialized for.</param>

        for (var i = 0; i < instance.plugins.length; i++) {
          try {
            instance.plugins[i]['init'](instance);
          } catch (err) {
            if (w.footable.options.debug === true) console.error(err);
          }
        }
      }
    }
  };

  var instanceCount = 0;

  $.fn.footable = function (options) {
    ///<summary>The main constructor call to initialize the plugin using the supplied <paramref name="options"/>.</summary>
    ///<param name="options">
    ///<para>A JSON object containing user defined options for the plugin to use. Any options not supplied will have a default value assigned.</para>
    ///<para>Check the documentation or the default options object above for more information on available options.</para>
    ///</param>

    options = options || {};
    var o = $.extend(true, {}, w.footable.options, options); //merge user and default options
    return this.each(function () {
      instanceCount++;
      var footable = new Footable(this, o, instanceCount);
      $(this).data('footable', footable);
    });
  };

  //helper for using timeouts
  function Timer() {
    ///<summary>Simple timer object created around a timeout.</summary>
    var t = this;
    t.id = null;
    t.busy = false;
    t.start = function (code, milliseconds) {
      ///<summary>Starts the timer and waits the specified amount of <paramref name="milliseconds"/> before executing the supplied <paramref name="code"/>.</summary>
      ///<param name="code">The code to execute once the timer runs out.</param>
      ///<param name="milliseconds">The time in milliseconds to wait before executing the supplied <paramref name="code"/>.</param>

      if (t.busy) {
        return;
      }
      t.stop();
      t.id = setTimeout(function () {
        code();
        t.id = null;
        t.busy = false;
      }, milliseconds);
      t.busy = true;
    };
    t.stop = function () {
      ///<summary>Stops the timer if its runnning and resets it back to its starting state.</summary>

      if (t.id !== null) {
        clearTimeout(t.id);
        t.id = null;
        t.busy = false;
      }
    };
  }

  function Footable(t, o, id) {
    ///<summary>Inits a new instance of the plugin.</summary>
    ///<param name="t">The main table element to apply this plugin to.</param>
    ///<param name="o">The options supplied to the plugin. Check the defaults object to see all available options.</param>
    ///<param name="id">The id to assign to this instance of the plugin.</param>

    var ft = this;
    ft.id = id;
    ft.table = t;
    ft.options = o;
    ft.breakpoints = [];
    ft.breakpointNames = '';
    ft.columns = {};
    ft.plugins = w.footable.plugins.load(ft);

    var opt = ft.options,
      cls = opt.classes,
      evt = opt.events,
      trg = opt.triggers,
      indexOffset = 0;

    // This object simply houses all the timers used in the FooTable.
    ft.timers = {
      resize: new Timer(),
      register: function (name) {
        ft.timers[name] = new Timer();
        return ft.timers[name];
      }
    };

    ft.init = function () {
      var $window = $(w), $table = $(ft.table);

      w.footable.plugins.init(ft);

      if ($table.hasClass(cls.loaded)) {
        //already loaded FooTable for the table, so don't init again
        ft.raise(evt.alreadyInitialized);
        return;
      }

      //raise the initializing event
      ft.raise(evt.initializing);

      $table.addClass(cls.loading);

      // Get the column data once for the life time of the plugin
      $table.find(opt.columnDataSelector).each(function () {
        var data = ft.getColumnData(this);
        ft.columns[data.index] = data;
      });

      // Create a nice friendly array to work with out of the breakpoints object.
      for (var name in opt.breakpoints) {
        ft.breakpoints.push({ 'name': name, 'width': opt.breakpoints[name] });
        ft.breakpointNames += (name + ' ');
      }

      // Sort the breakpoints so the smallest is checked first
      ft.breakpoints.sort(function (a, b) {
        return a['width'] - b['width'];
      });

      $table
        //bind to FooTable initialize trigger
        .bind(trg.initialize, function () {
          //remove previous "state" (to "force" a resize)
          $table.removeData('footable_info');
          $table.data('breakpoint', '');

          //trigger the FooTable resize
          $table.trigger(trg.resize);

          //remove the loading class
          $table.removeClass(cls.loading);

          //add the FooTable and loaded class
          $table.addClass(cls.loaded).addClass(cls.main);

          //raise the initialized event
          ft.raise(evt.initialized);
        })
        //bind to FooTable redraw trigger
        .bind(trg.redraw, function () {
          ft.redraw();
        })

        //bind to FooTable resize trigger
        .bind(trg.resize, function () {
          ft.resize();
        })
        //bind to FooTable expandFirstRow trigger
        .bind(trg.expandFirstRow, function () {
          $table.find(opt.toggleSelector).first().not('.' + cls.detailShow).trigger(trg.toggleRow);
        });

      //trigger a FooTable initialize
      $table.trigger(trg.initialize);

      //bind to window resize
      $window
        .bind('resize.footable', function () {
          ft.timers.resize.stop();
          ft.timers.resize.start(function () {
            ft.raise(trg.resize);
          }, opt.delay);
        });
    };

    ft.addRowToggle = function () {
      if (!opt.addRowToggle) return;

      var $table = $(ft.table),
        hasToggleColumn = false;

      //first remove all toggle spans
      $table.find('span.' + cls.toggle).remove();

      for (var c in ft.columns) {
        var col = ft.columns[c];
        if (col.toggle) {
          hasToggleColumn = true;
          var selector = '> tbody > tr:not(.' + cls.detail + ',.' + cls.disabled + ') > td:nth-child(' + (parseInt(col.index, 10) + 1) + ')';
          $table.find(selector).not('.' + cls.detailCell).prepend($('<span />').addClass(cls.toggle).attr({
            role: 'button',
            tabindex: '0',
            'aria-label': 'Icon collapse'
          }));
          return;
        }
      }
      //check if we have an toggle column. If not then add it to the first column just to be safe
      if (!hasToggleColumn) {
        $table
          .find('> tbody > tr:not(.' + cls.detail + ',.' + cls.disabled + ') > td:first-child')
          .not('.' + cls.detailCell)
          .prepend($('<span />').addClass(cls.toggle).attr({
            role: 'button',
            tabindex: '0',
            'aria-label': 'Icon collapse'
          }));
      }
    };

    ft.setColumnClasses = function () {
      $table = $(ft.table);
      for (var c in ft.columns) {
        var col = ft.columns[c];
        if (col.className !== null) {
          var selector = '', first = true;
          $.each(col.matches, function (m, match) { //support for colspans
            if (!first) selector += ', ';
            selector += '> tbody > tr:not(.' + cls.detail + ') > td:nth-child(' + (parseInt(match, 10) + 1) + ')';
            first = false;
          });
          //add the className to the cells specified by data-class="blah"
          $table.find(selector).not('.' + cls.detailCell).addClass(col.className);
        }
      }
    };

    //moved this out into it's own function so that it can be called from other add-ons
    ft.bindToggleSelectors = function () {
      var $table = $(ft.table);

      if (!ft.hasAnyBreakpointColumn()) return;

      $table.find(opt.toggleSelector).unbind(trg.toggleRow).bind(trg.toggleRow, function (e) {
        console.log("---");
        var $row = $(this).is('tr') ? $(this) : $(this).parents('tr:first');
        ft.toggleDetail($row.get(0));
      });

      $table.bind(trg.untoggleAll, function (e) {
        ft.untoggleAllDetail($(this).find(opt.toggleSelector));
      });


      $table.find(opt.toggleSelector).unbind('click.footable, keyup.footable').bind('click.footable, keyup.footable', function (e) {
        //intercept keydown that are not enter or space
        if (e.type === "keyup" && !(e.key === "Enter" || e.key === ' ')) {
          return false;
        }
        if ($table.is('.breakpoint') && $(e.target).is('td,.' + cls.toggle)) {
          $(this).trigger(trg.toggleRow);
        }
      });
    };

    ft.parse = function (cell, column) {
      var parser = opt.parsers[column.type] || opt.parsers.alpha;
      return parser(cell);
    };

    ft.getColumnData = function (th) {
      var $th = $(th), hide = $th.data('hide'), index = $th.index();
      hide = hide || '';
      hide = jQuery.map(hide.split(','), function (a) {
        return jQuery.trim(a);
      });
      var data = {
        'index': index,
        'hide': {},
        'type': $th.data('type') || 'alpha',
        'name': $th.data('name') || $.trim($th.text()),
        'ignore': $th.data('ignore') || false,
        'toggle': $th.data('toggle') || false,
        'className': $th.data('class') || null,
        'matches': [],
        'names': {},
        'group': $th.data('group') || null,
        'groupName': null
      };

      if (data.group !== null) {
        var $group = $(ft.table).find('> thead > tr.footable-group-row > th[data-group="' + data.group + '"], > thead > tr.footable-group-row > td[data-group="' + data.group + '"]').first();
        data.groupName = ft.parse($group, { 'type': 'alpha' });
      }

      var pcolspan = parseInt($th.prev().attr('colspan') || 0, 10);
      indexOffset += pcolspan > 1 ? pcolspan - 1 : 0;
      var colspan = parseInt($th.attr('colspan') || 0, 10), curindex = data.index + indexOffset;
      if (colspan > 1) {
        var names = $th.data('names');
        names = names || '';
        names = names.split(',');
        for (var i = 0; i < colspan; i++) {
          data.matches.push(i + curindex);
          if (i < names.length) data.names[i + curindex] = names[i];
        }
      } else {
        data.matches.push(curindex);
      }

      data.hide['default'] = ($th.data('hide') === "all") || ($.inArray('default', hide) >= 0);

      var hasBreakpoint = false;
      for (var name in opt.breakpoints) {
        data.hide[name] = ($th.data('hide') === "all") || ($.inArray(name, hide) >= 0);
        hasBreakpoint = hasBreakpoint || data.hide[name];
      }
      data.hasBreakpoint = hasBreakpoint;
      var e = ft.raise(evt.columnData, { 'column': { 'data': data, 'th': th } });
      return e.column.data;
    };

    ft.getViewportWidth = function () {
      return window.innerWidth || (document.body ? document.body.offsetWidth : 0);
    };

    ft.calculateWidth = function ($table, info) {
      if (jQuery.isFunction(opt.calculateWidthOverride)) {
        return opt.calculateWidthOverride($table, info);
      }
      if (info.viewportWidth < info.width) info.width = info.viewportWidth;
      if (info.parentWidth < info.width) info.width = info.parentWidth;
      return info;
    };

    ft.hasBreakpointColumn = function (breakpoint) {
      for (var c in ft.columns) {
        if (ft.columns[c].hide[breakpoint]) {
          if (ft.columns[c].ignore) {
            continue;
          }
          return true;
        }
      }
      return false;
    };

    ft.hasAnyBreakpointColumn = function () {
      for (var c in ft.columns) {
        if (ft.columns[c].hasBreakpoint) {
          return true;
        }
      }
      return false;
    };

    ft.resize = function () {
      var $table = $(ft.table);

      if (!$table.is(':visible')) {
        return;
      } //we only care about FooTables that are visible

      if (!ft.hasAnyBreakpointColumn()) {
        return;
      } //we only care about FooTables that have breakpoints

      var info = {
        'width': $table.width(),                  //the table width
        'viewportWidth': ft.getViewportWidth(),   //the width of the viewport
        'parentWidth': $table.parent().width()    //the width of the parent
      };

      info = ft.calculateWidth($table, info);

      var pinfo = $table.data('footable_info');
      $table.data('footable_info', info);
      ft.raise(evt.resizing, { 'old': pinfo, 'info': info });

      // This (if) statement is here purely to make sure events aren't raised twice as mobile safari seems to do
      if (!pinfo || (pinfo && pinfo.width && pinfo.width !== info.width)) {

        var current = null, breakpoint;
        for (var i = 0; i < ft.breakpoints.length; i++) {
          breakpoint = ft.breakpoints[i];
          if (breakpoint && breakpoint.width && info.width <= breakpoint.width) {
            current = breakpoint;
            break;
          }
        }

        var breakpointName = (current === null ? 'default' : current['name']),
          hasBreakpointFired = ft.hasBreakpointColumn(breakpointName),
          previousBreakpoint = $table.data('breakpoint');

        $table
          .data('breakpoint', breakpointName)
          .removeClass('default breakpoint').removeClass(ft.breakpointNames)
          .addClass(breakpointName + (hasBreakpointFired ? ' breakpoint' : ''));

        //only do something if the breakpoint has changed
        if (breakpointName !== previousBreakpoint) {
          //trigger a redraw
          $table.trigger(trg.redraw);
          //raise a breakpoint event
          ft.raise(evt.breakpoint, { 'breakpoint': breakpointName, 'info': info });
        }
      }

      ft.raise(evt.resized, { 'old': pinfo, 'info': info });
    };

    ft.redraw = function () {
      //add the toggler to each row
      ft.addRowToggle();

      //bind the toggle selector click events
      ft.bindToggleSelectors();

      //set any cell classes defined for the columns
      ft.setColumnClasses();

      var $table = $(ft.table),
        breakpointName = $table.data('breakpoint'),
        hasBreakpointFired = ft.hasBreakpointColumn(breakpointName);

      $table
        .find('> tbody > tr:not(.' + cls.detail + ')').data('detail_created', false).end()
        .find('> thead > tr:last-child > th')
        .each(function () {
          var data = ft.columns[$(this).index()], selector = '', first = true;
          $.each(data.matches, function (m, match) {
            if (!first) {
              selector += ', ';
            }
            var count = match + 1;
            selector += '> tbody > tr:not(.' + cls.detail + ') > td:nth-child(' + count + ')';
            selector += ', > tfoot > tr:not(.' + cls.detail + ') > td:nth-child(' + count + ')';
            selector += ', > colgroup > col:nth-child(' + count + ')';
            first = false;
          });

          selector += ', > thead > tr[data-group-row="true"] > th[data-group="' + data.group + '"]';
          var $column = $table.find(selector).add(this);
          if (data.hide[breakpointName] === false) $column.show();
          else $column.hide();

          if ($table.find('> thead > tr.footable-group-row').length === 1) {
            var $groupcols = $table.find('> thead > tr:last-child > th[data-group="' + data.group + '"]:visible, > thead > tr:last-child > th[data-group="' + data.group + '"]:visible'),
              $group = $table.find('> thead > tr.footable-group-row > th[data-group="' + data.group + '"], > thead > tr.footable-group-row > td[data-group="' + data.group + '"]'),
              groupspan = 0;

            $.each($groupcols, function () {
              groupspan += parseInt($(this).attr('colspan') || 1, 10);
            });

            if (groupspan > 0) $group.attr('colspan', groupspan).show();
            else $group.hide();
          }
        })
        .end()
        .find('> tbody > tr.' + cls.detailShow).each(function () {
          ft.createOrUpdateDetailRow(this);
        });

      $table.find('> tbody > tr.' + cls.detailShow + ':visible').each(function () {
        var $next = $(this).next();
        if ($next.hasClass(cls.detail)) {
          if (!hasBreakpointFired) $next.hide();
          else $next.show().attr('aria-expanded', 'true');
        }
      });

      // adding .footable-first-column and .footable-last-column to the first and last th and td of each row in order to allow
      // for styling if the first or last column is hidden (which won't work using :first-child or :last-child)
      $table.find('> thead > tr > th.footable-last-column, > tbody > tr > td.footable-last-column').removeClass('footable-last-column');
      $table.find('> thead > tr > th.footable-first-column, > tbody > tr > td.footable-first-column').removeClass('footable-first-column');
      $table.find('> thead > tr, > tbody > tr')
        .find('> th:visible:last, > td:visible:last')
        .addClass('footable-last-column')
        .end()
        .find('> th:visible:first, > td:visible:first')
        .addClass('footable-first-column');

      ft.raise(evt.redrawn);
    };

    ft.toggleDetail = function (row) {
      var $row = (row.jquery) ? row : $(row),
        $next = $row.next();

      //check if the row is already expanded
      if ($row.hasClass(cls.detailShow)) {
        $row.removeClass(cls.detailShow);
        $row.find('span.' + cls.toggle).attr('aria-expanded', 'false');

        //only hide the next row if it's a detail row
        if ($next.hasClass(cls.detail)) $next.hide();

        ft.raise(evt.rowCollapsed, { 'row': $row[0] });

      } else {
        ft.createOrUpdateDetailRow($row[0]);
        $row.addClass(cls.detailShow);
        $row.find('span.' + cls.toggle).attr('aria-expanded', 'true');
        $row.next().show();

        ft.raise(evt.rowExpanded, { 'row': $row[0] });
      }
    };

    ft.untoggleAllDetail = function (rows) {
      rows.each(function () {
        var $row = $(this),
          $next = $row.next();

        if ($row.hasClass(cls.detailShow)) {
          $row.removeClass(cls.detailShow);

          //only hide the next row if it's a detail row
          if ($next.hasClass(cls.detail)) $next.hide();

          ft.raise(evt.rowCollapsed, { 'row': $row[0] });

        }
      })
    };



    ft.removeRow = function (row) {
      var $row = (row.jquery) ? row : $(row);
      if ($row.hasClass(cls.detail)) {
        $row = $row.prev();
      }
      var $next = $row.next();
      if ($row.data('detail_created') === true) {
        //remove the detail row
        $next.remove();
      }
      $row.remove();

      //raise event
      ft.raise(evt.rowRemoved);
    };

    ft.appendRow = function (row) {
      var $row = (row.jquery) ? row : $(row);
      $(ft.table).find('tbody').append($row);

      //redraw the table
      ft.redraw();
    };

    ft.getColumnFromTdIndex = function (index) {
      /// <summary>Returns the correct column data for the supplied index taking into account colspans.</summary>
      /// <param name="index">The index to retrieve the column data for.</param>
      /// <returns type="json">A JSON object containing the column data for the supplied index.</returns>
      var result = null;
      for (var column in ft.columns) {
        if ($.inArray(index, ft.columns[column].matches) >= 0) {
          result = ft.columns[column];
          break;
        }
      }
      return result;
    };

    ft.createOrUpdateDetailRow = function (actualRow) {
      var $row = $(actualRow), $next = $row.next(), $detail, values = [];
      if ($row.data('detail_created') === true) return true;

      if ($row.is(':hidden')) return false; //if the row is hidden for some reason (perhaps filtered) then get out of here
      ft.raise(evt.rowDetailUpdating, { 'row': $row, 'detail': $next });
      $row.find('> td:hidden').each(function () {
        var index = $(this).index(), column = ft.getColumnFromTdIndex(index), name = column.name;
        if (column.ignore === true) return true;

        if (index in column.names) name = column.names[index];
        values.push({ 'name': name, 'value': ft.parse(this, column), 'display': $.trim($(this).html()), 'group': column.group, 'groupName': column.groupName });
        return true;
      });
      if (values.length === 0) return false; //return if we don't have any data to show
      var colspan = $row.find('> td:visible').length;
      var exists = $next.hasClass(cls.detail);
      if (!exists) { // Create
        $next = $('<tr class="' + cls.detail + '"><td class="' + cls.detailCell + '"><div class="' + cls.detailInner + '"></div></td></tr>');
        $row.after($next);
      }
      $next.find('> td:first').attr('colspan', colspan);
      $detail = $next.find('.' + cls.detailInner).empty();
      opt.createDetail($detail, values, opt.createGroupedDetail, opt.detailSeparator, cls);
      $row.data('detail_created', true);
      ft.raise(evt.rowDetailUpdated, { 'row': $row, 'detail': $next });
      return !exists;
    };

    ft.raise = function (eventName, args) {

      if (ft.options.debug === true && $.isFunction(ft.options.log)) ft.options.log(eventName, 'event');

      args = args || {};
      var def = { 'ft': ft };
      $.extend(true, def, args);
      var e = $.Event(eventName, def);
      if (!e.ft) {
        $.extend(true, e, def);
      } //pre jQuery 1.6 which did not allow data to be passed to event object constructor
      $(ft.table).trigger(e);
      return e;
    };

    ft.init();
    return ft;
  }
})(jQuery, window);

define("footable", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.footable;
  };
}(this)));

(function ($, w, undefined) {
  if (w.footable === undefined || w.footable === null)
    throw new Error('Please check and make sure footable.modified.js is included in the page and is loaded prior to this script.');

  var defaults = {
    sort: true,
    sorters: {
      alpha: function (a, b) {
        if (a === b) return 0;
        if (a < b) return -1;
        return 1;
      },
      numeric: function (a, b) {
        return a - b;
      }
    },
    classes: {
      sort: {
        sortable: 'footable-sortable',
        sorted: 'footable-sorted',
        descending: 'footable-sorted-desc',
        indicator: 'footable-sort-indicator'
      }
    },
    events: {
      sort: {
        sorting: 'footable_sorting',
        sorted: 'footable_sorted'
      }
    }
  };

  function Sort() {
    var p = this;
    p.name = 'Footable Sortable';
    p.init = function (ft) {
      p.footable = ft;
      if (ft.options.sort === true) {
        $(ft.table).bind({
          'footable_initialized': function (e) {
            var $table = $(ft.table),
              $tbody = $table.find('> tbody'),
              cls = ft.options.classes.sort,
              column, $th;

            if ($table.data('sort') === false) return;

            $table.find('> thead > tr:last-child > th, > thead > tr:last-child > td').each(function (ec) {
              $th = $(this), column = ft.columns[$th.index()];
              if (column.sort.ignore !== true && !$th.hasClass(cls.sortable)) {
                $th.addClass(cls.sortable);
                $('<span />').addClass(cls.indicator).appendTo($th);
              }
            });
            // Modified: [MTLADM-775] Add support for Enter key on heading filters
            $table.find('> thead > tr:last-child > th.' + cls.sortable + ', > thead > tr:last-child > td.' + cls.sortable).unbind('click.footable keyup.footable').bind('click.footable keyup.footable', function (ec) {
              ec.preventDefault();
              var key = ec.which;

              if ((ec.type === "keyup" && key === 13) || (ec.type === "click")) { // the enter key code
                $th = $(this);
                var ascending = !$th.hasClass(cls.sorted);
                p.doSort($th.index(), ascending);
                return false;
              }
            });

            var didSomeSorting = false;
            for (var c in ft.columns) {
              column = ft.columns[c];
              if (column.sort.initial) {
                var ascending = (column.sort.initial !== 'descending');
                p.doSort(column.index, ascending);
                break;
              }
            }
            if (didSomeSorting) {
              ft.bindToggleSelectors();
            }
          },
          'footable_redrawn': function (e) {
            var $table = $(ft.table),
              cls = ft.options.classes.sort;
            if ($table.data('sorted') >= 0) {
              $table.find('> thead > tr:last-child > th').each(function (i) {
                var $th = $(this);
                if ($th.hasClass(cls.sorted) || $th.hasClass(cls.descending)) {
                  p.doSort(i);
                  return;
                }
              });
            }
          },
          'footable_column_data': function (e) {
            var $th = $(e.column.th);
            e.column.data.sort = e.column.data.sort || {};
            e.column.data.sort.initial = $th.data('sort-initial') || false;
            e.column.data.sort.ignore = $th.data('sort-ignore') || false;
            e.column.data.sort.selector = $th.data('sort-selector') || null;

            var match = $th.data('sort-match') || 0;
            if (match >= e.column.data.matches.length) match = 0;
            e.column.data.sort.match = e.column.data.matches[match];
          }
        })
          //save the sort object onto the table so we can access it later
          .data('footable-sort', p);
      }
    };

    p.doSort = function (columnIndex, ascending) {
      var ft = p.footable;
      if ($(ft.table).data('sort') === false) return;

      var $table = $(ft.table),
        $tbody = $table.find('> tbody'),
        column = ft.columns[columnIndex],
        $th = $table.find('> thead > tr:last-child > th:eq(' + columnIndex + ')'),
        cls = ft.options.classes.sort,
        evt = ft.options.events.sort;

      ascending = (ascending === undefined) ? $th.hasClass(cls.sorted) :
        (ascending === 'toggle') ? !$th.hasClass(cls.sorted) : ascending;

      if (column.sort.ignore === true) return true;

      //raise a pre-sorting event so that we can cancel the sorting if needed
      var event = ft.raise(evt.sorting, { column: column, direction: ascending ? 'ASC' : 'DESC' });
      if (event && event.result === false) return;

      $table.data('sorted', column.index);

      $table.find('> thead > tr:last-child > th, > thead > tr:last-child > td').not($th).removeClass(cls.sorted + ' ' + cls.descending);

      if (ascending === undefined) {
        ascending = $th.hasClass(cls.sorted);
      }

      if (ascending) {
        $th.removeClass(cls.descending).addClass(cls.sorted);
        // Modified: [MTLADM-789] added sort ascending for aria readers 
        $th.attr('aria-sort', 'ascending');
      } else {
        $th.removeClass(cls.sorted).addClass(cls.descending);
        // Modified: [MTLADM-789] added sort descending for aria readers
        $th.attr('aria-sort', 'descending');
      }

      p.sort(ft, $tbody, column, ascending);

      ft.bindToggleSelectors();
      ft.raise(evt.sorted, { column: column, direction: ascending ? 'ASC' : 'DESC' });
    };

    p.rows = function (ft, tbody, column) {
      var rows = [];
      tbody.find('> tr').each(function () {
        var $row = $(this), $next = null;
        if ($row.hasClass(ft.options.classes.detail)) return true;
        if ($row.next().hasClass(ft.options.classes.detail)) {
          $next = $row.next().get(0);
        }
        var row = { 'row': $row, 'detail': $next };
        if (column !== undefined) {
          row.value = ft.parse(this.cells[column.sort.match], column);
        }
        rows.push(row);
        return true;
      }).detach();
      return rows;
    };

    p.sort = function (ft, tbody, column, ascending) {
      var rows = p.rows(ft, tbody, column);
      var sorter = ft.options.sorters[column.type] || ft.options.sorters.alpha;
      rows.sort(function (a, b) {
        if (ascending) {
          return sorter(a.value, b.value);
        } else {
          return sorter(b.value, a.value);
        }
      });
      for (var j = 0; j < rows.length; j++) {
        tbody.append(rows[j].row);
        if (rows[j].detail !== null) {
          tbody.append(rows[j].detail);
        }
      }
    };
  }

  w.footable.plugins.register(Sort, defaults);

})(jQuery, window);
define("footable_sort", ["jquery", "footable"], function () { });

/***
* @author : Julie Cardinal
*/


define('responsiveTable', [
  'jquery',
  'a11y/footnote',
  'footable_sort',
], function ($, makeFootnote) {



  /***********************************  FlightBoard  ****************************************/

  var eventEmitter;

  var TableReponsive = {
    init: function (context) {
      var _t = this;
      var $context = $(context);

      eventEmitter = ADM.eventEmitter;
      console.log("table context", context);

      $context.each(function (index, el) {
        new TableResponsiveInstance(el);
      });

      if ($('.teaser-wrapper').length) {
        setupFootnote($context);
      }
    }
  };

  function setupFootnote($context) {
    var $footnoteDescription = $('.teaser-wrapper .teaser-neutral-content > p');
    var $footnoteMentions = $context.find('.tableaux-stationnement-col');

    makeFootnote($footnoteDescription, $footnoteMentions);
  }

  function TableResponsiveInstance(el) {
    var $el = $(el),
      breakpoints = $el.data("responsivetables-breakpoint") || {
        phone: 400,
        phoneLarge: 401,
        tablet: 635
      },
      $ignoreClick = $el.find($el.data("responsivetables-ignore"));

    $ignoreClick.on("click", function (evt) {
      evt.preventDefault();
      evt.stopImmediatePropagation();
      return false;
    });


    $el.footable({
      breakpoints: breakpoints
    });


    $el.on("footable_row_detail_updated footable_resized", function (evt) {
      var $this = $(this);

      $this.find(".footable-row-detail-inner").each(function () {
        $(this).find(".footable-row-detail-row").removeClass("footable-row-detail-row-last");
        $(this).find(".footable-row-detail-row:last").addClass("footable-row-detail-row-last");
      });

    });

    $el.on("footable_row_collapsed footable_row_expanded", function (evt) {
      eventEmitter.emitEvent("domChanged", []);
    });


    $el.find(".dark th .footable-sort-indicator").addClass("icon");


  }




  return TableReponsive;
});



/***
* @author : Julie Cardinal
*
*/



define('equalize', [
  'jquery'

], function ($) {

  /***********************************  Parking  ****************************************/

  var SameDimension = {
    init: function (context) {
      var _t = this;

      $(context).each(function (index, el) {
        new SameDimensionInstance(el);
      });
    }
  };

  function SameDimensionInstance(el) {
    var $el = $(el),
      CONFIG = {
        $elements: $el.find(".equalize-cell")
      };


    function init() {
      createEvents();
      update();
    }

    function createEvents() {
      $(window).resize(function () {
        update();
      });
    }


    function update() {
      var numElements = CONFIG.$elements.length,
        width = (100 / numElements) + "%";

      CONFIG.$elements.css("width", width);

    }

    init();

  }


  return SameDimension;
});

/***
* @author : Julie Cardinal
*
* ***************  WARNING :YOU HAVE TO HANDLE in CSS the breakpoint to show the select or the buttonsgroup. **********************
*
*
* DOCUMENTATION :
*
* DEPENDENCIES:
* ButtonsGroup (uiTools/buttonsgroup.js)
* CustomSelect (uiTools/customSelect.js)
*
*
* USAGE :
*
* This plugin links buttonsgroup and customselect togheter, when one update, the other update with the same value. Was programmed to work with widgets/domFilter.js
* but it will works with other plugins if configured and programmed like the widgets/domFilter.js (with eventEmitter)
*
* Data-attribute:
*
* data-filters-receiverevent {default: null} : Pass the eventEmitter name that you want to listen event by eventEmitter
* data-filters-triggerevent  {default: null} : Pass the eventEmitter name that you want to trigger by eventEmitter
*
*
* Example Markdown:

* <div class="enhance filter tableaux-destinationarrivees-filters" data-enhance="filters" data-filters-receiverevent="boarddirectdestinations-filterselected" data-filters-triggerevent="boarddirectdestinations-filtersupdate" >
*   <div class="filters-buttonsgroup">
*        <div class="equalize enhance" data-enhance="equalize buttonsgroup" data-buttonsgroup-triggerevent="boarddirectdestinations-filterselected" data-buttonsgroup-inactiveclass="neutral" data-buttonsgroup-trigger=".btn-action">
*        <div class="equalize-row">
*        <a href="#" class="equalize-cell btn-primary btn-action btn-tabulation" data-domfilters-filtertype="All">Toutes les destinations</a>
*        <a href="#" class="equalize-cell btn-primary btn-action btn-tabulation neutral" data-domfilters-filtertype="Canada">Canada</a>
*        <a href="#" class="equalize-cell btn-primary btn-action btn-tabulation neutral" data-domfilters-filtertype="États-Unis">États-Unis</a>
*        <a href="#" class="equalize-cell btn-primary btn-action btn-tabulation neutral last" data-domfilters-filtertype="International">International</a>
*        </div>
*        </div>
*   </div>
*
*   <div class="filters-select">
*       <div>
*            <select class="enhance" data-enhance="customSelect" data-customselect-triggerevent="boarddirectdestinations-filterselected" data-theme="dark">
*            <option data-domfilters-filtertype="All">Toutes les destinations</option>
*            <option data-domfilters-filtertype="Canada">Canada</option>
*            <option data-domfilters-filtertype="États-Unis">États-Unis</option>
*            <option data-domfilters-filtertype="International">International</option>
*            </select>
*        </div>
*    </div>
* </div>

*/


define('uiTools/filters', [
  'jquery'
], function ($) {

  /***********************************  Parking  ****************************************/

  var eventEmitter;

  var Filters = {
    init: function (context) {
      var _t = this;
      eventEmitter = ADM.eventEmitter;

      $(context).each(function (index, el) {
        new FiltersInstance(el);
      });
    }
  };

  function FiltersInstance(el) {

    var $el = $(el),
      CONFIG = {
        triggerEvent: $el.data("filters-triggerevent") || undefined,
        receiverEvent: $el.data("filters-receiverevent") || undefined
      },
      $buttonsGroups = $el.find(".filters-buttonsgroup"),
      $select = $el.find(".filters-select select");



    function init() {
      createEvents();
    }

    function createEvents() {
      if (typeof CONFIG.receiverEvent != "undefined") {
        eventEmitter.addListener(CONFIG.receiverEvent, function (eventType, value) {
          switch (eventType) {
            case "buttonsgroup-updated":
            case "customselect-updated":
              var $el = $(value),
                filterType = $el.data("domfiltersFiltertype");

              updateFilterUI(eventType, filterType);
              break;

            case "domFilters-filterupdate":
              var filterType = value;
              updateFilterUI(eventType, filterType);
              break;
          }
        });
      }
    }



    function updateFilterUI(eventType, filterType) {

      if ("buttonsgroup-updated" == eventType || "domFilters-filterupdate" == eventType) updateSelect(filterType);
      if ("customselect-updated" == eventType || "domFilters-filterupdate" == eventType) updateButtonsGroup(filterType);
      if ("customselect-updated" == eventType || "buttonsgroup-updated" == eventType) eventEmitter.emitEvent(CONFIG.triggerEvent, ["filters", filterType]);

    }


    function updateButtonsGroup(value) {
      $buttonsGroups.find("[data-domfilters-filtertype='" + value + "']").trigger("update.buttonsgroup");
    }

    function updateSelect(value) {
      $select.find("option").removeAttr('selected');
      $select.find("[data-domfilters-filtertype='" + value + "']").attr('selected', 'selected');
      $select.trigger("update:customselect");
    }


    init();

  }


  return Filters;
});

define('uiTools/faq', [
  'jquery',
  'UTILS'
], function ($, Utils) {


  var FAQ = {
    init: function (context) {
      // wait while other plugins applied

      var $context = $(Utils.removeHighlightedCodeFromContext($(context)));

      $context.each(function () {

        if ($(this).hasClass("ui-checklist") && $(this).find("dd").length > 0 && $.trim($(this).find("dd").text()) !== "") {
          $(this).addClass("expendable");
        }
        var $dts = $(this).find("dt");
        var $dtsContent = $dts.html();
        $dts.empty();
        $dts.append('<button aria-expanded="false">' + $dtsContent + '</button>');

        $dts.on('click', function (event) {
          if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
            var $question = $(this);
            var $answer = $(this).next("dd");
            var $btn = $(this).find("button");

            if ($question.hasClass("ui-faq-open")) {
              $answer.slideUp();
              $question.removeClass("ui-faq-open");
              $btn.attr("aria-expanded", "false");
            } else {
              $answer.slideDown();
              $question.addClass("ui-faq-open");
              $btn.attr("aria-expanded", "true");
            }
          }
        });
      });
    }
  };

  return FAQ;
});

/***
* @author : Julie Cardinal
*/


define('genericResponsiveTable', [
  'jquery',
  'footable'
], function ($) {



  /***********************************  FlightBoard  ****************************************/

  var eventEmitter;

  var GenericResponsiveTable = {
    init: function (context) {
      var _t = this;

      eventEmitter = ADM.eventEmitter;

      $(context).each(function (index, el) {
        new GenericResponsiveTableInstance(el);
      });
    }
  };

  function GenericResponsiveTableInstance(el) {
    var $el = $(el),
      breakpoints = {
        "phone": 400,
        "tablet": 550
      };



    function init() {
      createHideAttrForBreakpoints();
      initFootable();
      initEvents();
    }

    function createHideAttrForBreakpoints() {

      var $tableCol = $el.find("thead tr th"),
        $cloneTable = $el.clone();

      $el.attr("data-sort", false);

      $tableCol.each(function (i, el) {
        var $this = $(el);
        if (i != 0 && i != 1) {
          $this.attr("data-hide", "phone, tablet");
        } else if (i == 1) {
          $this.attr("data-hide", "phone");
        }
      });


      hideColIfLargestThanBiggerBreakpoint();
    }

    function hideColIfLargestThanBiggerBreakpoint() {
      var wrapperWidth = breakpoints.tablet,
        $wrapper = $("<div style='width:" + wrapperWidth + "px; background:red;height:200px'></div>"),
        $tableCol = $el.find("thead tr th"),

        $cloneTable = $el.clone(),
        $cloneTableCol = $($cloneTable.find("thead tr th").get().reverse()),
        $cloneTableRow = $($cloneTable.find("tbody tr").get().reverse()),
        cloneTableWidth,
        numCols = $cloneTable.find("thead tr th").length - 1;


      $("body").append($wrapper);
      $wrapper.append($cloneTable);

      cloneTableWidth = $cloneTable.width();

      if (cloneTableWidth > wrapperWidth) {

        $cloneTableCol.each(function (i, el) {

          var $this = $(el),
            realIndex = numCols - i,
            $realCol = $tableCol.eq(realIndex);

          cloneTableWidth = $cloneTable.width();

          if (cloneTableWidth > wrapperWidth) {

            $this.css("display", "none");
            $realCol.attr("data-hide", "all");


            $cloneTableRow.each(function (j, el) {
              var $td = $($(this).find("td").get().reverse());
              $td.eq(i).css("display", "none");
            });

          } else {
            return false;
          }

        });
      }

      $wrapper.empty();
      $wrapper.remove();
    }


    function initEvents() {

      $el.on("footable_row_detail_updated footable_resized", function (evt) {
        var $this = $(this);

        $this.find(".footable-row-detail-inner").each(function () {
          $(this).find(".footable-row-detail-row").removeClass("footable-row-detail-row-last");
          $(this).find(".footable-row-detail-row:last").addClass("footable-row-detail-row-last");
        });

      });

      $el.on("footable_row_collapsed footable_row_expanded", function (evt) {
        eventEmitter.emitEvent("domChanged", []);
      });
    }

    function initFootable() {

      $el.footable({
        breakpoints: breakpoints
      });

      $el.find(".dark th .footable-sort-indicator").addClass("icon");
    }




    init();


  }




  return GenericResponsiveTable;
});



define('uiTools/mailto', [
  'jquery',
  'UTILS',
  'placeholder'
], function ($, Utils) {


  var Mailto = {
    init: function (context) {


      var $context = $(Utils.removeHighlightedCodeFromContext($(context)));

      $context.each(function () {

        var $this = $(this);
        $this.click(function (evt) {
          evt.preventDefault();

          var _this = $(this);
          var mailto = _this.attr("href");
          var subject = _this.find(".subject").text();
          var message = _this.find(".message").text();

          if (_this.hasClass("analytics_jobs_apply")) {
            dataLayer.push({
              'event': 'jobs_apply_' + Utils.getLang()
            });
          }
          if (_this.hasClass("analytics_jobs_spontanious")) {
            dataLayer.push({
              'event': 'jobs_spontanious_' + Utils.getLang(),
              'jobs_spontanious_categorie': _this.parent().find(".teaser-item-title:first h3").text()
            });
          }



          if (typeof mailto !== "undefined") {
            var query = mailto + "?";
            if (typeof subject !== "undefined") {
              query = query + "subject=" + subject + "&";
            }
            if (typeof message !== "undefined") {
              query = query + "body=" + message;
            }
            console.log(query);
            window.location.href = query;
          }
        });

      });
    }
  };

  return Mailto;
});
/**
* DropKick
*
* Highly customizable <select> lists
* https://github.com/JamieLottering/DropKick
*
* &copy; 2011 Jamie Lottering <http://github.com/JamieLottering>
*                        <http://twitter.com/JamieLottering>
* 
*/
(function ($, window, document) {

  var ie6 = false;

  // Help prevent flashes of unstyled content
  if ($.browser.msie && $.browser.version.substr(0, 1) < 7) {
    ie6 = true;
  } else {
    document.documentElement.className = document.documentElement.className + ' dk_fouc';
  }

  var
    // Public methods exposed to $.fn.dropkick()
    methods = {},

    // Cache every <select> element that gets dropkicked
    lists = [],

    // Convenience keys for keyboard navigation
    keyMap = {
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'enter': 13
    },

    // HTML template for the dropdowns
    dropdownTemplate = [
      '<div class="dk_container" id="dk_container_{{ id }}" tabindex="{{ tabindex }}">',
      '<a href="#"  class="dk_toggle">', // Modified mamzellejuu::
      // added href for keyboard navigation (necessary for the focus)
      '<span class="dk_label" data-dk-value="{{ value }}">{{ label }}</span>',
      '</a>',
      '<div class="dk_options">',
      '<ul class="dk_options_inner">',
      '</ul>',
      '</div>',
      '</div>'
    ].join(''),

    // HTML template for dropdown options
    optionTemplate = '<li class="{{ current }}"><a data-dk-dropdown-value="{{ value }}">{{ text }}</a></li>',

    // Some nice default values
    defaults = {
      startSpeed: 1000,  // I recommend a high value here, I feel it makes the changes less noticeable to the user
      theme: false,
      change: false
    },

    // Make sure we only bind keydown on the document once
    keysBound = false
    ;

  // Called by using $('foo').dropkick();
  methods.init = function (settings) {
    settings = $.extend({}, defaults, settings);

    return this.each(function () {
      var
        // The current <select> element
        $select = $(this),

        // Store a reference to the originally selected <option> element
        $original = $select.find(':selected').first(),

        // Save all of the <option> elements
        $options = $select.find('option'),

        // We store lots of great stuff using jQuery data
        data = $select.data('dropkick') || {},

        // This gets applied to the 'dk_container' element
        id = $select.attr('id') || $select.attr('name'),

        // This gets updated to be equal to the longest <option> element
        width = settings.width || $select.outerWidth(),

        // Check if we have a tabindex set or not
        tabindex = $select.attr('tabindex') ? $select.attr('tabindex') : '',

        // The completed dk_container element
        $dk = false,

        theme
        ;

      // Dont do anything if we've already setup dropkick on this element
      if (data.id) {
        return $select;
      } else {
        data.settings = settings;
        data.tabindex = tabindex;
        data.id = id;
        data.$original = $original;
        data.$select = $select;
        data.value = _notBlank($select.val()) || _notBlank($original.attr('value'));
        data.label = $original.text();
        data.options = $options;
      }

      // Build the dropdown HTML
      $dk = _build(dropdownTemplate, data);

      // Make the dropdown fixed width if desired
      $dk.find('.dk_toggle').css({
        'width': width + 'px'
      });

      // Hide the <select> list and place our new one in front of it
      $select.before($dk);

      // Update the reference to $dk
      $dk = $('#dk_container_' + id).fadeIn(settings.startSpeed);

      // Save the current theme
      theme = settings.theme ? settings.theme : 'default';
      $dk.addClass('dk_theme_' + theme);
      data.theme = theme;

      // Save the updated $dk reference into our data object
      data.$dk = $dk;

      // Save the dropkick data onto the <select> element
      $select.data('dropkick', data);

      // Do the same for the dropdown, but add a few helpers
      $dk.data('dropkick', data);

      lists[lists.length] = $select;

      // Focus events
      /*$dk.bind('focus.dropkick', function (e) {
        $dk.addClass('dk_focus');
      }).bind('blur.dropkick', function (e) {
        $dk.removeClass('dk_open dk_focus');
      });
  
      setTimeout(function () {
        $select.hide();
      }, 0);
    });*/


      // Scrolling problem in IE , without this,
      // it closes when you touch the scroll
      // workaround from :: http://goo.gl/S0jFo
      $dk.bind('focus.dropkick', function (e) {
        $dk.addClass('dk_focus');
      });

      $(document.body).bind('click.dropkick', function (e) {
        $dk.removeClass('dk_open dk_focus');
      });

      setTimeout(function () {
        $select.hide();
      }, 0);
    });

  };

  // Allows dynamic theme changes
  methods.theme = function (newTheme) {
    var
      $select = $(this),
      list = $select.data('dropkick'),
      $dk = list.$dk,
      oldtheme = 'dk_theme_' + list.theme
      ;

    $dk.removeClass(oldtheme).addClass('dk_theme_' + newTheme);

    list.theme = newTheme;
  };

  // Reset all <selects and dropdowns in our lists array
  methods.reset = function () {
    for (var i = 0, l = lists.length; i < l; i++) {
      var
        listData = lists[i].data('dropkick'),
        $dk = listData.$dk,
        $current = $dk.find('li').first()
        ;

      $dk.find('.dk_label').text(listData.label);
      $dk.find('.dk_options_inner').animate({ scrollTop: 0 }, 0);

      _setCurrent($current, $dk);
      _updateFields($current, $dk, true);
    }
  };

  // Expose the plugin
  $.fn.dropkick = function (method) {
    if (!ie6) {
      if (methods[method]) {
        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
      } else if (typeof method === 'object' || !method) {
        return methods.init.apply(this, arguments);
      }
    }
  };

  // private
  function _handleKeyBoardNav(e, $dk) {
    var
      code = e.keyCode,
      data = $dk.data('dropkick'),
      options = $dk.find('.dk_options'),
      open = $dk.hasClass('dk_open'),
      current = $dk.find('.dk_option_current'),
      toggle = $dk.find('.dk_toggle'), // Added by mamzellejuu
      first = options.find('li').first(),
      last = options.find('li').last(),
      next,
      prev
      ;

    switch (code) {
      case keyMap.enter:
        if (open) {
          _updateFields(current.find('a'), $dk);
          _closeDropdown($dk);
          e.preventDefault();
        } else {
          // Modified by mamzellejuu ::
          // Modified for keyboard navigation
          // Open the dropdown only if the user
          // if focused on the dropdown
          if ($dk.is(":focus")) {
            _openDropdown($dk);
            e.preventDefault();
          }
          // end modification
        }
        // e.preventDefault();
        break;

      case keyMap.up:
        prev = current.prev('li');
        if (open) {
          if (prev.length) {
            _setCurrent(prev, $dk);
          } else {
            _setCurrent(last, $dk);
          }
        } else {
          _openDropdown($dk);
        }
        e.preventDefault();
        break;

      case keyMap.down:
        if (open) {
          next = current.next('li').first();
          if (next.length) {
            _setCurrent(next, $dk);
          } else {
            _setCurrent(first, $dk);
          }
        } else {
          _openDropdown($dk);
        }
        e.preventDefault();
        break;

      default:
        break;
    }
  }

  // Update the <select> value, and the dropdown label
  function _updateFields(option, $dk, reset) {
    var value, label, data;

    value = option.attr('data-dk-dropdown-value');
    label = option.text();
    data = $dk.data('dropkick');

    $select = data.$select;
    $select.val(value);

    $dk.find('.dk_label').text(label);

    reset = reset || false;

    if (data.settings.change && !reset) {
      data.settings.change.call($select, value, label);
    }
  }

  // Set the currently selected option
  function _setCurrent($current, $dk) {
    $dk.find('.dk_option_current').removeClass('dk_option_current');
    $current.addClass('dk_option_current');

    _setScrollPos($dk, $current);
  }

  function _setScrollPos($dk, anchor) {
    var height = anchor.prevAll('li').outerHeight() * anchor.prevAll('li').length;
    $dk.find('.dk_options_inner').animate({ scrollTop: height + 'px' }, 0);
  }

  // Close a dropdown
  function _closeDropdown($dk) {
    $dk.removeClass('dk_open');
  }

  // Open a dropdown
  function _openDropdown($dk) {
    var data = $dk.data('dropkick');
    $dk.find('.dk_options').css({ top: $dk.find('.dk_toggle').outerHeight() - 1 });
    $dk.toggleClass('dk_open');

  }

  /**
   * Turn the dropdownTemplate into a jQuery object and fill in the variables.
   */
  function _build(tpl, view) {
    var
      // Template for the dropdown
      template = tpl,
      // Holder of the dropdowns options
      options = [],
      $dk
      ;

    template = template.replace('{{ id }}', view.id);
    template = template.replace('{{ label }}', view.label);
    template = template.replace('{{ tabindex }}', view.tabindex);
    template = template.replace('{{ value }}', view.value);

    if (view.options && view.options.length) {
      for (var i = 0, l = view.options.length; i < l; i++) {
        var
          $option = $(view.options[i]),
          current = 'dk_option_current',
          oTemplate = optionTemplate
          ;

        oTemplate = oTemplate.replace('{{ value }}', $option.val());
        oTemplate = oTemplate.replace('{{ current }}', (_notBlank($option.val()) === view.value) ? current : '');
        oTemplate = oTemplate.replace('{{ text }}', $option.text());

        options[options.length] = oTemplate;
      }
    }

    $dk = $(template);
    $dk.find('.dk_options_inner').html(options.join(''));

    return $dk;
  }

  function _notBlank(text) {
    return ($.trim(text).length > 0) ? text : false;
  }

  $(function () {

    // Handle click events on the dropdown toggler
    $('.dk_toggle').live('click', function (e) {
      var $dk = $(this).parents('.dk_container').first();

      _openDropdown($dk);

      if ("ontouchstart" in window) {
        $dk.addClass('dk_touch');
        $dk.find('.dk_options_inner').addClass('scrollable vertical');
      }

      e.preventDefault();
      return false;
    });

    // Handle click events on individual dropdown options
    $('.dk_options a').live(($.browser.msie ? 'mousedown' : 'click'), function (e) {
      var
        $option = $(this),
        $dk = $option.parents('.dk_container').first(),
        data = $dk.data('dropkick')
        ;

      _closeDropdown($dk);
      _updateFields($option, $dk);
      _setCurrent($option.parent(), $dk);

      e.preventDefault();
      return false;
    });

    // Setup keyboard nav
    $(document).bind('keydown.dk_nav', function (e) {
      var
        // Look for an open dropdown...
        $open = $('.dk_container.dk_open'),

        // Look for a focused dropdown
        $focused = $('.dk_container.dk_focus'),

        // Will be either $open, $focused, or null
        $dk = null
        ;

      // If we have an open dropdown, key events should get sent to that one
      if ($open.length) {
        $dk = $open;
      } else if ($focused.length && !$open.length) {
        // But if we have no open dropdowns, use the focused dropdown instead
        $dk = $focused;
      }

      if ($dk) {
        _handleKeyBoardNav(e, $dk);
      }
    });
  });
})(jQuery, window, document);
define("dropkick", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.dropkick;
  };
}(this)));

define('uiTools/customSelectDOM', [
  'jquery',

  'dropkick'

], function ($, i18n, Utils) {

  var CustomSelectDOM = {
    init: function (context) {
      var _t = this;

      $(context).each(function (index, el) {
        new CustomSelectDOMInstance(el);
      });
    }
  };

  function CustomSelectDOMInstance(el) {
    var $el = $(el),
      type = $el.data("customselectdom-type");


    console.log("ENHANCE");
    // TODO :: select the options when we change the value;

    function defaultChangeCallback(value, label) {
      $el.find("option").removeAttr("selected");
      $el.find("option[value='" + value + "']").attr("selected", "selected");
    }

    switch (type) {
      case "drupal":



        $el.dropkick({
          change: function (value, label) {
            defaultChangeCallback(value, label);

            $toggle.find(".icon").remove();
            $toggle.append("<span class='icon customselectdrupal-icon " + value + "'></span>");
            $toggle.find("span").css("vertical-align", "middle");
          }
        });

        var $toggle = $el.parent().find(".dk_container .dk_toggle"),
          $options = $el.parent().find(".dk_container .dk_options_inner li a"),
          defaultValue = $toggle.find(".dk_label").attr("data-dk-value");


        // Add Default icon in the toggle button
        $toggle.append("<span class='icon customselectdrupal-icon " + defaultValue + "'></span>");
        $toggle.find("span").css("vertical-align", "middle");


        // Add Icons in each options

        $options.each(function (i, el) {
          var $this = $(el),
            value = $this.attr("data-dk-dropdown-value");


          $this.contents().wrap('<span/>');
          $this.append("<span class='icon customselectdrupal-icon " + value + "'></span>");
          $this.find("span").css("vertical-align", "middle");
        });

        break;

      default:
        $el.dropkick({
          change: function (value, label) {
            defaultChangeCallback(value, label);
          }
        });
        break;
    }

  }


  return CustomSelectDOM;
});
/*!
* VERSION: beta 1.10.3
* DATE: 2013-09-02
* UPDATES AND DOCS AT: http://www.greensock.com
*
* @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
* This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
* Club GreenSock members, the software agreement that was issued with your membership.
* 
* @author: Jack Doyle, jack@greensock.com
*/
(window._gsQueue || (window._gsQueue = [])).push(function () { "use strict"; window._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) { var i, s, r, n, a = function () { t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio }, o = {}, l = a.prototype = new t("css"); l.constructor = a, a.version = "1.10.3", a.API = 2, a.defaultTransformPerspective = 0, l = "px", a.suffixMap = { top: l, right: l, bottom: l, left: l, width: l, height: l, fontSize: l, padding: l, margin: l, perspective: l }; var h, u, _, p, f, c, d = /(?:\d|\-\d|\.\d|\-\.\d)+/g, m = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, v = /[^\d\-\.]/g, y = /(?:\d|\-|\+|=|#|\.)*/g, T = /opacity *= *([^)]*)/, w = /opacity:([^;]*)/, x = /alpha\(opacity *=.+?\)/i, b = /^(rgb|hsl)/, P = /([A-Z])/g, S = /-([a-z])/gi, k = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, R = function (t, e) { return e.toUpperCase() }, C = /(?:Left|Right|Width)/i, O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, A = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, D = /,(?=[^\)]*(?:\(|$))/gi, M = Math.PI / 180, L = 180 / Math.PI, I = {}, X = document, N = X.createElement("div"), F = X.createElement("img"), E = a._internals = { _specialProps: o }, Y = navigator.userAgent, z = function () { var t, e = Y.indexOf("Android"), i = X.createElement("div"); return _ = -1 !== Y.indexOf("Safari") && -1 === Y.indexOf("Chrome") && (-1 === e || Number(Y.substr(e + 8, 1)) > 3), f = _ && 6 > Number(Y.substr(Y.indexOf("Version/") + 8, 1)), p = -1 !== Y.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Y), c = parseFloat(RegExp.$1), i.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", t = i.getElementsByTagName("a")[0], t ? /^0.55/.test(t.style.opacity) : !1 }(), U = function (t) { return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 }, B = function (t) { window.console && console.log(t) }, j = "", V = "", q = function (t, e) { e = e || N; var i, s, r = e.style; if (void 0 !== r[t]) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], s = 5; --s > -1 && void 0 === r[i[s] + t];); return s >= 0 ? (V = 3 === s ? "ms" : i[s], j = "-" + V.toLowerCase() + "-", V + t) : null }, W = X.defaultView ? X.defaultView.getComputedStyle : function () { }, Q = a.getStyle = function (t, e, i, s, r) { var n; return z || "opacity" !== e ? (!s && t.style[e] ? n = t.style[e] : (i = i || W(t, null)) ? (t = i.getPropertyValue(e.replace(P, "-$1").toLowerCase()), n = t || i.length ? t : i[e]) : t.currentStyle && (n = t.currentStyle[e]), null == r || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : r) : U(t) }, Z = function (t, e, i, s, r) { if ("px" === s || !s) return i; if ("auto" === s || !i) return 0; var n, a = C.test(e), o = t, l = N.style, h = 0 > i; return h && (i = -i), "%" === s && -1 !== e.indexOf("border") ? n = i / 100 * (a ? t.clientWidth : t.clientHeight) : (l.cssText = "border-style:solid;border-width:0;position:absolute;line-height:0;", "%" !== s && o.appendChild ? l[a ? "borderLeftWidth" : "borderTopWidth"] = i + s : (o = t.parentNode || X.body, l[a ? "width" : "height"] = i + s), o.appendChild(N), n = parseFloat(N[a ? "offsetWidth" : "offsetHeight"]), o.removeChild(N), 0 !== n || r || (n = Z(t, e, i, s, !0))), h ? -n : n }, H = function (t, e, i) { if ("absolute" !== Q(t, "position", i)) return 0; var s = "left" === e ? "Left" : "Top", r = Q(t, "margin" + s, i); return t["offset" + s] - (Z(t, e, parseFloat(r), r.replace(y, "")) || 0) }, $ = function (t, e) { var i, s, r = {}; if (e = e || W(t, null)) if (i = e.length) for (; --i > -1;)r[e[i].replace(S, R)] = e.getPropertyValue(e[i]); else for (i in e) r[i] = e[i]; else if (e = t.currentStyle || t.style) for (i in e) r[i.replace(S, R)] = e[i]; return z || (r.opacity = U(t)), s = be(t, e, !1), r.rotation = s.rotation * L, r.skewX = s.skewX * L, r.scaleX = s.scaleX, r.scaleY = s.scaleY, r.x = s.x, r.y = s.y, xe && (r.z = s.z, r.rotationX = s.rotationX * L, r.rotationY = s.rotationY * L, r.scaleZ = s.scaleZ), r.filters && delete r.filters, r }, G = function (t, e, i, s, r) { var n, a, o, l = {}, h = t.style; for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (l[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(v, "") ? n : 0 : H(t, a), void 0 !== h[a] && (o = new _e(h, a, h[a], o))); if (s) for (a in s) "className" !== a && (l[a] = s[a]); return { difs: l, firstMPT: o } }, K = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, J = ["marginLeft", "marginRight", "marginTop", "marginBottom"], te = function (t, e, i) { var s = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight), r = K[e], n = r.length; for (i = i || W(t, null); --n > -1;)s -= parseFloat(Q(t, "padding" + r[n], i, !0)) || 0, s -= parseFloat(Q(t, "border" + r[n] + "Width", i, !0)) || 0; return s }, ee = function (t, e) { (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0"); var i = t.split(" "), s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0], r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1]; return null == r ? r = "0" : "center" === r && (r = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(s.replace(v, "")), e.oy = parseFloat(r.replace(v, ""))), s + " " + r + (i.length > 2 ? " " + i[2] : "") }, ie = function (t, e) { return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) }, se = function (t, e) { return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * Number(t.substr(2)) + e : parseFloat(t) }, re = function (t, e, i, s) { var r, n, a, o, l = 1e-6; return null == t ? o = e : "number" == typeof t ? o = t * M : (r = 2 * Math.PI, n = t.split("_"), a = Number(n[0].replace(v, "")) * (-1 === t.indexOf("rad") ? M : 1) - ("=" === t.charAt(1) ? 0 : e), n.length && (s && (s[i] = e + a), -1 !== t.indexOf("short") && (a %= r, a !== a % (r / 2) && (a = 0 > a ? a + r : a - r)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * r) % r - (0 | a / r) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (0 | a / r) * r)), o = e + a), l > o && o > -l && (o = 0), o }, ne = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, ae = function (t, e, i) { return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5 }, oe = function (t) { var e, i, s, r, n, a; return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ne[t] ? ne[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), s = t.charAt(3), t = "#" + e + e + i + i + s + s), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(d), r = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = ae(r + 1 / 3, e, i), t[1] = ae(r, e, i), t[2] = ae(r - 1 / 3, e, i), t) : (t = t.match(d) || ne.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : ne.black }, le = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; for (l in ne) le += "|" + l + "\\b"; le = RegExp(le + ")", "gi"); var he = function (t, e, i, s) { if (null == t) return function (t) { return t }; var r, n = e ? (t.match(le) || [""])[0] : "", a = t.split(n).join("").match(g) || [], o = t.substr(0, t.indexOf(a[0])), l = ")" === t.charAt(t.length - 1) ? ")" : "", h = -1 !== t.indexOf(" ") ? " " : ",", u = a.length, _ = u > 0 ? a[0].replace(d, "") : ""; return u ? r = e ? function (t) { var e, p, f, c; if ("number" == typeof t) t += _; else if (s && D.test(t)) { for (c = t.replace(D, "|").split("|"), f = 0; c.length > f; f++)c[f] = r(c[f]); return c.join(",") } if (e = (t.match(le) || [n])[0], p = t.split(e).join("").match(g) || [], f = p.length, u > f--) for (; u > ++f;)p[f] = i ? p[0 | (f - 1) / 2] : a[f]; return o + p.join(h) + h + e + l + (-1 !== t.indexOf("inset") ? " inset" : "") } : function (t) { var e, n, p; if ("number" == typeof t) t += _; else if (s && D.test(t)) { for (n = t.replace(D, "|").split("|"), p = 0; n.length > p; p++)n[p] = r(n[p]); return n.join(",") } if (e = t.match(g) || [], p = e.length, u > p--) for (; u > ++p;)e[p] = i ? e[0 | (p - 1) / 2] : a[p]; return o + e.join(h) + l } : function (t) { return t } }, ue = function (t) { return t = t.split(","), function (e, i, s, r, n, a, o) { var l, h = (i + "").split(" "); for (o = {}, l = 0; 4 > l; l++)o[t[l]] = h[l] = h[l] || h[(l - 1) / 2 >> 0]; return r.parse(e, o, n, a) } }, _e = (E._setPluginRatio = function (t) { this.plugin.setRatio(t); for (var e, i, s, r, n = this.data, a = n.proxy, o = n.firstMPT, l = 1e-6; o;)e = a[o.v], o.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : l > e && e > -l && (e = 0), o.t[o.p] = e, o = o._next; if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t) for (o = n.firstMPT; o;) { if (i = o.t, i.type) { if (1 === i.type) { for (r = i.xs0 + i.s + i.xs1, s = 1; i.l > s; s++)r += i["xn" + s] + i["xs" + (s + 1)]; i.e = r } } else i.e = i.s + i.xs0; o = o._next } }, function (t, e, i, s, r) { this.t = t, this.p = e, this.v = i, this.r = r, s && (s._prev = this, this._next = s) }), pe = (E._parseToProxy = function (t, e, i, s, r, n) { var a, o, l, h, u, _ = s, p = {}, f = {}, c = i._transform, d = I; for (i._transform = null, I = e, s = u = i.parse(t, e, s, r), I = d, n && (i._transform = c, _ && (_._prev = null, _._prev && (_._prev._next = null))); s && s !== _;) { if (1 >= s.type && (o = s.p, f[o] = s.s + s.c, p[o] = s.s, n || (h = new _e(s, "s", o, h, s.r), s.c = 0), 1 === s.type)) for (a = s.l; --a > 0;)l = "xn" + a, o = s.p + "_" + l, f[o] = s.data[l], p[o] = s[l], n || (h = new _e(s, l, o, h, s.rxp[l])); s = s._next } return { proxy: p, end: f, firstMPT: h, pt: u } }, E.CSSPropTween = function (t, e, s, r, a, o, l, h, u, _, p) { this.t = t, this.p = e, this.s = s, this.c = r, this.n = l || e, t instanceof pe || n.push(this.n), this.r = h, this.type = o || 0, u && (this.pr = u, i = !0), this.b = void 0 === _ ? s : _, this.e = void 0 === p ? s + r : p, a && (this._next = a, a._prev = this) }), fe = a.parseComplex = function (t, e, i, s, r, n, a, o, l, u) { i = i || n || "", a = new pe(t, e, 0, 0, a, u ? 2 : 1, null, !1, o, i, s), s += ""; var _, p, f, c, g, v, y, T, w, x, P, S, k = i.split(", ").join(",").split(" "), R = s.split(", ").join(",").split(" "), C = k.length, O = h !== !1; for ((-1 !== s.indexOf(",") || -1 !== i.indexOf(",")) && (k = k.join(" ").replace(D, ", ").split(" "), R = R.join(" ").replace(D, ", ").split(" "), C = k.length), C !== R.length && (k = (n || "").split(" "), C = k.length), a.plugin = l, a.setRatio = u, _ = 0; C > _; _++)if (c = k[_], g = R[_], T = parseFloat(c), T || 0 === T) a.appendXtra("", T, ie(g, T), g.replace(m, ""), O && -1 !== g.indexOf("px"), !0); else if (r && ("#" === c.charAt(0) || ne[c] || b.test(c))) S = "," === g.charAt(g.length - 1) ? ")," : ")", c = oe(c), g = oe(g), w = c.length + g.length > 6, w && !z && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[_]).join("transparent")) : (z || (w = !1), a.appendXtra(w ? "rgba(" : "rgb(", c[0], g[0] - c[0], ",", !0, !0).appendXtra("", c[1], g[1] - c[1], ",", !0).appendXtra("", c[2], g[2] - c[2], w ? "," : S, !0), w && (c = 4 > c.length ? 1 : c[3], a.appendXtra("", c, (4 > g.length ? 1 : g[3]) - c, S, !1))); else if (v = c.match(d)) { if (y = g.match(m), !y || y.length !== v.length) return a; for (f = 0, p = 0; v.length > p; p++)P = v[p], x = c.indexOf(P, f), a.appendXtra(c.substr(f, x - f), Number(P), ie(y[p], P), "", O && "px" === c.substr(x + P.length, 2), 0 === p), f = x + P.length; a["xs" + a.l] += c.substr(f) } else a["xs" + a.l] += a.l ? " " + c : c; if (-1 !== s.indexOf("=") && a.data) { for (S = a.xs0 + a.data.s, _ = 1; a.l > _; _++)S += a["xs" + _] + a.data["xn" + _]; a.e = S + a["xs" + _] } return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a }, ce = 9; for (l = pe.prototype, l.l = l.pr = 0; --ce > 0;)l["xn" + ce] = 0, l["xs" + ce] = ""; l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function (t, e, i, s, r, n) { var a = this, o = a.l; return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = s || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new pe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = { s: e + i }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (s || ""), a) }; var de = function (t, e) { e = e || {}, this.p = e.prefix ? q(t) || t : t, o[t] = o[this.p] = this, this.format = e.formatter || he(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0 }, me = E._registerComplexSpecialProp = function (t, e, i) { "object" != typeof e && (e = { parser: i }); var s, r, n = t.split(","), a = e.defaultValue; for (i = i || [a], s = 0; n.length > s; s++)e.prefix = 0 === s && e.prefix, e.defaultValue = i[s] || a, r = new de(n[s], e) }, ge = function (t) { if (!o[t]) { var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin"; me(t, { parser: function (t, i, s, r, n, a, l) { var h = (window.GreenSockGlobals || window).com.greensock.plugins[e]; return h ? (h._cssRegister(), o[s].parse(t, i, s, r, n, a, l)) : (B("Error: " + e + " js file not loaded."), n) } }) } }; l = de.prototype, l.parseComplex = function (t, e, i, s, r, n) { var a, o, l, h, u, _, p = this.keyword; if (this.multi && (D.test(i) || D.test(e) ? (o = e.replace(D, "|").split("|"), l = i.replace(D, "|").split("|")) : p && (o = [e], l = [i])), l) { for (h = l.length > o.length ? l.length : o.length, a = 0; h > a; a++)e = o[a] = o[a] || this.dflt, i = l[a] = l[a] || this.dflt, p && (u = e.indexOf(p), _ = i.indexOf(p), u !== _ && (i = -1 === _ ? l : o, i[a] += " " + p)); e = o.join(", "), i = l.join(", ") } return fe(t, this.p, e, i, this.clrs, this.dflt, s, this.pr, r, n) }, l.parse = function (t, e, i, s, n, a) { return this.parseComplex(t.style, this.format(Q(t, this.p, r, !1, this.dflt)), this.format(e), n, a) }, a.registerSpecialProp = function (t, e, i) { me(t, { parser: function (t, s, r, n, a, o) { var l = new pe(t, r, 0, 0, a, 2, r, !1, i); return l.plugin = o, l.setRatio = e(t, s, n._tween, r), l }, priority: i }) }; var ve = "scaleX,scaleY,scaleZ,x,y,z,skewX,rotation,rotationX,rotationY,perspective".split(","), ye = q("transform"), Te = j + "transform", we = q("transformOrigin"), xe = null !== q("perspective"), be = function (t, e, i, s) { if (t._gsTransform && i && !s) return t._gsTransform; var r, n, o, l, h, u, _, p, f, c, d, m, g, v = i ? t._gsTransform || { skewY: 0 } : { skewY: 0 }, y = 0 > v.scaleX, T = 2e-5, w = 1e5, x = -Math.PI + 1e-4, b = Math.PI - 1e-4, P = xe ? parseFloat(Q(t, we, e, !1, "0 0 0").split(" ")[2]) || v.zOrigin || 0 : 0; for (ye ? r = Q(t, Te, e, !0) : t.currentStyle && (r = t.currentStyle.filter.match(O), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), v.x || 0, v.y || 0].join(",") : ""), n = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], o = n.length; --o > -1;)l = Number(n[o]), n[o] = (h = l - (l |= 0)) ? (0 | h * w + (0 > h ? -.5 : .5)) / w + l : l; if (16 === n.length) { var S = n[8], k = n[9], R = n[10], C = n[12], A = n[13], D = n[14]; if (v.zOrigin && (D = -v.zOrigin, C = S * D - n[12], A = k * D - n[13], D = R * D + v.zOrigin - n[14]), !i || s || null == v.rotationX) { var M, L, I, X, N, F, E, Y = n[0], z = n[1], U = n[2], B = n[3], j = n[4], V = n[5], q = n[6], W = n[7], Z = n[11], H = v.rotationX = Math.atan2(q, R), $ = x > H || H > b; H && (X = Math.cos(-H), N = Math.sin(-H), M = j * X + S * N, L = V * X + k * N, I = q * X + R * N, S = j * -N + S * X, k = V * -N + k * X, R = q * -N + R * X, Z = W * -N + Z * X, j = M, V = L, q = I), H = v.rotationY = Math.atan2(S, Y), H && (F = x > H || H > b, X = Math.cos(-H), N = Math.sin(-H), M = Y * X - S * N, L = z * X - k * N, I = U * X - R * N, k = z * N + k * X, R = U * N + R * X, Z = B * N + Z * X, Y = M, z = L, U = I), H = v.rotation = Math.atan2(z, V), H && (E = x > H || H > b, X = Math.cos(-H), N = Math.sin(-H), Y = Y * X + j * N, L = z * X + V * N, V = z * -N + V * X, q = U * -N + q * X, z = L), E && $ ? v.rotation = v.rotationX = 0 : E && F ? v.rotation = v.rotationY = 0 : F && $ && (v.rotationY = v.rotationX = 0), v.scaleX = (0 | Math.sqrt(Y * Y + z * z) * w + .5) / w, v.scaleY = (0 | Math.sqrt(V * V + k * k) * w + .5) / w, v.scaleZ = (0 | Math.sqrt(q * q + R * R) * w + .5) / w, v.skewX = 0, v.perspective = Z ? 1 / (0 > Z ? -Z : Z) : 0, v.x = C, v.y = A, v.z = D } } else if (!(xe && !s && n.length && v.x === n[4] && v.y === n[5] && (v.rotationX || v.rotationY) || void 0 !== v.x && "none" === Q(t, "display", e))) { var G = n.length >= 6, K = G ? n[0] : 1, J = n[1] || 0, te = n[2] || 0, ee = G ? n[3] : 1; v.x = n[4] || 0, v.y = n[5] || 0, u = Math.sqrt(K * K + J * J), _ = Math.sqrt(ee * ee + te * te), p = K || J ? Math.atan2(J, K) : v.rotation || 0, f = te || ee ? Math.atan2(te, ee) + p : v.skewX || 0, c = u - Math.abs(v.scaleX || 0), d = _ - Math.abs(v.scaleY || 0), Math.abs(f) > Math.PI / 2 && Math.abs(f) < 1.5 * Math.PI && (y ? (u *= -1, f += 0 >= p ? Math.PI : -Math.PI, p += 0 >= p ? Math.PI : -Math.PI) : (_ *= -1, f += 0 >= f ? Math.PI : -Math.PI)), m = (p - v.rotation) % Math.PI, g = (f - v.skewX) % Math.PI, (void 0 === v.skewX || c > T || -T > c || d > T || -T > d || m > x && b > m && false | m * w || g > x && b > g && false | g * w) && (v.scaleX = u, v.scaleY = _, v.rotation = p, v.skewX = f), xe && (v.rotationX = v.rotationY = v.z = 0, v.perspective = parseFloat(a.defaultTransformPerspective) || 0, v.scaleZ = 1) } v.zOrigin = P; for (o in v) T > v[o] && v[o] > -T && (v[o] = 0); return i && (t._gsTransform = v), v }, Pe = function (t) { var e, i, s = this.data, r = -s.rotation, n = r + s.skewX, a = 1e5, o = (0 | Math.cos(r) * s.scaleX * a) / a, l = (0 | Math.sin(r) * s.scaleX * a) / a, h = (0 | Math.sin(n) * -s.scaleY * a) / a, u = (0 | Math.cos(n) * s.scaleY * a) / a, _ = this.t.style, p = this.t.currentStyle; if (p) { i = l, l = -h, h = -i, e = p.filter, _.filter = ""; var f, d, m = this.t.offsetWidth, g = this.t.offsetHeight, v = "absolute" !== p.position, w = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + l + ", M21=" + h + ", M22=" + u, x = s.x, b = s.y; if (null != s.ox && (f = (s.oxp ? .01 * m * s.ox : s.ox) - m / 2, d = (s.oyp ? .01 * g * s.oy : s.oy) - g / 2, x += f - (f * o + d * l), b += d - (f * h + d * u)), v ? (f = m / 2, d = g / 2, w += ", Dx=" + (f - (f * o + d * l) + x) + ", Dy=" + (d - (f * h + d * u) + b) + ")") : w += ", sizingMethod='auto expand')", _.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(A, w) : w + " " + e, (0 === t || 1 === t) && 1 === o && 0 === l && 0 === h && 1 === u && (v && -1 === w.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf("gradient(" && e.indexOf("Alpha")) && _.removeAttribute("filter")), !v) { var P, S, k, R = 8 > c ? 1 : -1; for (f = s.ieOffsetX || 0, d = s.ieOffsetY || 0, s.ieOffsetX = Math.round((m - ((0 > o ? -o : o) * m + (0 > l ? -l : l) * g)) / 2 + x), s.ieOffsetY = Math.round((g - ((0 > u ? -u : u) * g + (0 > h ? -h : h) * m)) / 2 + b), ce = 0; 4 > ce; ce++)S = J[ce], P = p[S], i = -1 !== P.indexOf("px") ? parseFloat(P) : Z(this.t, S, parseFloat(P), P.replace(y, "")) || 0, k = i !== s[S] ? 2 > ce ? -s.ieOffsetX : -s.ieOffsetY : 2 > ce ? f - s.ieOffsetX : d - s.ieOffsetY, _[S] = (s[S] = Math.round(i - k * (0 === ce || 2 === ce ? 1 : R))) + "px" } } }, Se = function () { var t, e, i, s, r, n, a, o, l, h, u, _, f, c, d, m, g, v, y, T, w, x, b, P, S, k, R = this.data, C = this.t.style, O = R.rotation, A = R.scaleX, D = R.scaleY, M = R.scaleZ, L = R.perspective; if (p && (P = C.top ? "top" : C.bottom ? "bottom" : parseFloat(Q(this.t, "top", null, !1)) ? "bottom" : "top", T = Q(this.t, P, null, !1), S = parseFloat(T) || 0, k = T.substr((S + "").length) || "px", R._ffFix = !R._ffFix, C[P] = (R._ffFix ? S + .05 : S - .05) + k), O || R.skewX) v = Math.cos(O), y = Math.sin(O), t = v, r = y, R.skewX && (O -= R.skewX, v = Math.cos(O), y = Math.sin(O)), e = -y, n = v; else { if (!(R.rotationY || R.rotationX || 1 !== M || L)) return C[ye] = "translate3d(" + R.x + "px," + R.y + "px," + R.z + "px)" + (1 !== A || 1 !== D ? " scale(" + A + "," + D + ")" : ""), void 0; t = n = 1, e = r = 0 } u = 1, i = s = a = o = l = h = _ = f = c = 0, d = L ? -1 / L : 0, m = R.zOrigin, g = 1e5, O = R.rotationY, O && (v = Math.cos(O), y = Math.sin(O), l = u * -y, f = d * -y, i = t * y, a = r * y, u *= v, d *= v, t *= v, r *= v), O = R.rotationX, O && (v = Math.cos(O), y = Math.sin(O), T = e * v + i * y, w = n * v + a * y, x = h * v + u * y, b = c * v + d * y, i = e * -y + i * v, a = n * -y + a * v, u = h * -y + u * v, d = c * -y + d * v, e = T, n = w, h = x, c = b), 1 !== M && (i *= M, a *= M, u *= M, d *= M), 1 !== D && (e *= D, n *= D, h *= D, c *= D), 1 !== A && (t *= A, r *= A, l *= A, f *= A), m && (_ -= m, s = i * _, o = a * _, _ = u * _ + m), s = (T = (s += R.x) - (s |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + s : s, o = (T = (o += R.y) - (o |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + o : o, _ = (T = (_ += R.z) - (_ |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + _ : _, C[ye] = "matrix3d(" + [(0 | t * g) / g, (0 | r * g) / g, (0 | l * g) / g, (0 | f * g) / g, (0 | e * g) / g, (0 | n * g) / g, (0 | h * g) / g, (0 | c * g) / g, (0 | i * g) / g, (0 | a * g) / g, (0 | u * g) / g, (0 | d * g) / g, s, o, _, L ? 1 + -_ / L : 1].join(",") + ")" }, ke = function () { var t, e, i, s, r, n, a, o, l, h = this.data, u = this.t, _ = u.style; p && (t = _.top ? "top" : _.bottom ? "bottom" : parseFloat(Q(u, "top", null, !1)) ? "bottom" : "top", e = Q(u, t, null, !1), i = parseFloat(e) || 0, s = e.substr((i + "").length) || "px", h._ffFix = !h._ffFix, _[t] = (h._ffFix ? i + .05 : i - .05) + s), h.rotation || h.skewX ? (r = h.rotation, n = r - h.skewX, a = 1e5, o = h.scaleX * a, l = h.scaleY * a, _[ye] = "matrix(" + (0 | Math.cos(r) * o) / a + "," + (0 | Math.sin(r) * o) / a + "," + (0 | Math.sin(n) * -l) / a + "," + (0 | Math.cos(n) * l) / a + "," + h.x + "," + h.y + ")") : _[ye] = "matrix(" + h.scaleX + ",0,0," + h.scaleY + "," + h.x + "," + h.y + ")" }; me("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D", { parser: function (t, e, i, s, n, a, o) { if (s._transform) return n; var l, h, u, _, p, f, c, d = s._transform = be(t, r, !0, o.parseTransform), m = t.style, g = 1e-6, v = ve.length, y = o, T = {}; if ("string" == typeof y.transform && ye) u = m.cssText, m[ye] = y.transform, m.display = "block", l = be(t, null, !1), m.cssText = u; else if ("object" == typeof y) { if (l = { scaleX: se(null != y.scaleX ? y.scaleX : y.scale, d.scaleX), scaleY: se(null != y.scaleY ? y.scaleY : y.scale, d.scaleY), scaleZ: se(null != y.scaleZ ? y.scaleZ : y.scale, d.scaleZ), x: se(y.x, d.x), y: se(y.y, d.y), z: se(y.z, d.z), perspective: se(y.transformPerspective, d.perspective) }, c = y.directionalRotation, null != c) if ("object" == typeof c) for (u in c) y[u] = c[u]; else y.rotation = c; l.rotation = re("rotation" in y ? y.rotation : "shortRotation" in y ? y.shortRotation + "_short" : "rotationZ" in y ? y.rotationZ : d.rotation * L, d.rotation, "rotation", T), xe && (l.rotationX = re("rotationX" in y ? y.rotationX : "shortRotationX" in y ? y.shortRotationX + "_short" : d.rotationX * L || 0, d.rotationX, "rotationX", T), l.rotationY = re("rotationY" in y ? y.rotationY : "shortRotationY" in y ? y.shortRotationY + "_short" : d.rotationY * L || 0, d.rotationY, "rotationY", T)), l.skewX = null == y.skewX ? d.skewX : re(y.skewX, d.skewX), l.skewY = null == y.skewY ? d.skewY : re(y.skewY, d.skewY), (h = l.skewY - d.skewY) && (l.skewX += h, l.rotation += h) } for (null != y.force3D && (d.force3D = y.force3D, f = !0), p = d.force3D || d.z || d.rotationX || d.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, p || null == y.scale || (l.scaleZ = 1); --v > -1;)i = ve[v], _ = l[i] - d[i], (_ > g || -g > _ || null != I[i]) && (f = !0, n = new pe(d, i, d[i], _, n), i in T && (n.e = T[i]), n.xs0 = 0, n.plugin = a, s._overwriteProps.push(n.n)); return _ = y.transformOrigin, (_ || xe && p && d.zOrigin) && (ye ? (f = !0, i = we, _ = (_ || Q(t, i, r, !1, "50% 50%")) + "", n = new pe(m, i, 0, 0, n, -1, "transformOrigin"), n.b = m[i], n.plugin = a, xe ? (u = d.zOrigin, _ = _.split(" "), d.zOrigin = (_.length > 2 && (0 === u || "0px" !== _[2]) ? parseFloat(_[2]) : u) || 0, n.xs0 = n.e = m[i] = _[0] + " " + (_[1] || "50%") + " 0px", n = new pe(d, "zOrigin", 0, 0, n, -1, n.n), n.b = u, n.xs0 = n.e = d.zOrigin) : n.xs0 = n.e = m[i] = _) : ee(_ + "", d)), f && (s._transformType = p || 3 === this._transformType ? 3 : 2), n }, prefix: !0 }), me("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), me("borderRadius", { defaultValue: "0px", parser: function (t, e, i, n, a) { e = this.format(e); var o, l, h, u, _, p, f, c, d, m, g, v, y, T, w, x, b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], P = t.style; for (d = parseFloat(t.offsetWidth), m = parseFloat(t.offsetHeight), o = e.split(" "), l = 0; b.length > l; l++)this.p.indexOf("border") && (b[l] = q(b[l])), _ = u = Q(t, b[l], r, !1, "0px"), -1 !== _.indexOf(" ") && (u = _.split(" "), _ = u[0], u = u[1]), p = h = o[l], f = parseFloat(_), v = _.substr((f + "").length), y = "=" === p.charAt(1), y ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), g = p.substr((c + "").length - (0 > c ? 1 : 0)) || "") : (c = parseFloat(p), g = p.substr((c + "").length)), "" === g && (g = s[i] || v), g !== v && (T = Z(t, "borderLeft", f, v), w = Z(t, "borderTop", f, v), "%" === g ? (_ = 100 * (T / d) + "%", u = 100 * (w / m) + "%") : "em" === g ? (x = Z(t, "borderLeft", 1, "em"), _ = T / x + "em", u = w / x + "em") : (_ = T + "px", u = w + "px"), y && (p = parseFloat(_) + c + g, h = parseFloat(u) + c + g)), a = fe(P, b[l], _ + " " + u, p + " " + h, !1, "0px", a); return a }, prefix: !0, formatter: he("0px 0px 0px 0px", !1, !0) }), me("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, i, s, n, a) { var o, l, h, u, _, p, f = "background-position", d = r || W(t, null), m = this.format((d ? c ? d.getPropertyValue(f + "-x") + " " + d.getPropertyValue(f + "-y") : d.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), g = this.format(e); if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && (p = Q(t, "backgroundImage").replace(k, ""), p && "none" !== p)) { for (o = m.split(" "), l = g.split(" "), F.setAttribute("src", p), h = 2; --h > -1;)m = o[h], u = -1 !== m.indexOf("%"), u !== (-1 !== l[h].indexOf("%")) && (_ = 0 === h ? t.offsetWidth - F.width : t.offsetHeight - F.height, o[h] = u ? parseFloat(m) / 100 * _ + "px" : 100 * (parseFloat(m) / _) + "%"); m = o.join(" ") } return this.parseComplex(t.style, m, g, n, a) }, formatter: ee }), me("backgroundSize", { defaultValue: "0 0", formatter: ee }), me("perspective", { defaultValue: "0px", prefix: !0 }), me("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), me("transformStyle", { prefix: !0 }), me("backfaceVisibility", { prefix: !0 }), me("margin", { parser: ue("marginTop,marginRight,marginBottom,marginLeft") }), me("padding", { parser: ue("paddingTop,paddingRight,paddingBottom,paddingLeft") }), me("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, i, s, n, a) { var o, l, h; return 9 > c ? (l = t.currentStyle, h = 8 > c ? " " : ",", o = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")", e = this.format(e).split(",").join(h)) : (o = this.format(Q(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a) } }), me("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), me("autoRound,strictUnits", { parser: function (t, e, i, s, r) { return r } }), me("border", { defaultValue: "0px solid #000", parser: function (t, e, i, s, n, a) { return this.parseComplex(t.style, this.format(Q(t, "borderTopWidth", r, !1, "0px") + " " + Q(t, "borderTopStyle", r, !1, "solid") + " " + Q(t, "borderTopColor", r, !1, "#000")), this.format(e), n, a) }, color: !0, formatter: function (t) { var e = t.split(" "); return e[0] + " " + (e[1] || "solid") + " " + (t.match(le) || ["#000"])[0] } }), me("float,cssFloat,styleFloat", { parser: function (t, e, i, s, r) { var n = t.style, a = "cssFloat" in n ? "cssFloat" : "styleFloat"; return new pe(n, a, 0, 0, r, -1, i, !1, 0, n[a], e) } }); var Re = function (t) { var e, i = this.t, s = i.filter || Q(this.data, "filter"), r = 0 | this.s + this.c * t; 100 === r && (-1 === s.indexOf("atrix(") && -1 === s.indexOf("radient(") && -1 === s.indexOf("oader(") ? (i.removeAttribute("filter"), e = !Q(this.data, "filter")) : (i.filter = s.replace(x, ""), e = !0)), e || (this.xn1 && (i.filter = s = s || "alpha(opacity=" + r + ")"), -1 === s.indexOf("opacity") ? 0 === r && this.xn1 || (i.filter = s + " alpha(opacity=" + r + ")") : i.filter = s.replace(T, "opacity=" + r)) }; me("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, i, s, n, a) { var o = parseFloat(Q(t, "opacity", r, !1, "1")), l = t.style, h = "autoAlpha" === i; return e = parseFloat(e), h && 1 === o && "hidden" === Q(t, "visibility", r) && 0 !== e && (o = 0), z ? n = new pe(l, "opacity", o, e - o, n) : (n = new pe(l, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = h ? 1 : 0, l.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = Re), h && (n = new pe(l, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", s._overwriteProps.push(n.n), s._overwriteProps.push(i)), n } }); var Ce = function (t, e) { e && (t.removeProperty ? t.removeProperty(e.replace(P, "-$1").toLowerCase()) : t.removeAttribute(e)) }, Oe = function (t) { if (this.t._gsClassPT = this, 1 === t || 0 === t) { this.t.className = 0 === t ? this.b : this.e; for (var e = this.data, i = this.t.style; e;)e.v ? i[e.p] = e.v : Ce(i, e.p), e = e._next; 1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.className !== this.e && (this.t.className = this.e) }; me("className", { parser: function (t, e, s, n, a, o, l) { var h, u, _, p, f, c = t.className, d = t.style.cssText; if (a = n._classNamePT = new pe(t, s, 0, 0, a, 2), a.setRatio = Oe, a.pr = -11, i = !0, a.b = c, u = $(t, r), _ = t._gsClassPT) { for (p = {}, f = _.data; f;)p[f.p] = 1, f = f._next; _.setRatio(1) } return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : c.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), n._tween._duration && (t.className = a.e, h = G(t, u, $(t), l, p), t.className = c, a.data = h.firstMPT, t.style.cssText = d, a = a.xfirst = n.parse(t, h.difs, a, o)), a } }); var Ae = function (t) { if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration) { var e, i, s, r, n = this.t.style, a = o.transform.parse; if ("all" === this.e) n.cssText = "", r = !0; else for (e = this.e.split(","), s = e.length; --s > -1;)i = e[s], o[i] && (o[i].parse === a ? r = !0 : i = "transformOrigin" === i ? we : o[i].p), Ce(n, i); r && (Ce(n, ye), this.t._gsTransform && delete this.t._gsTransform) } }; for (me("clearProps", { parser: function (t, e, s, r, n) { return n = new pe(t, s, 0, 0, n, 2), n.setRatio = Ae, n.e = e, n.pr = -10, n.data = r._tween, i = !0, n } }), l = "bezier,throwProps,physicsProps,physics2D".split(","), ce = l.length; ce--;)ge(l[ce]); l = a.prototype, l._firstPT = null, l._onInitTween = function (t, e, o) { if (!t.nodeType) return !1; this._target = t, this._tween = o, this._vars = e, h = e.autoRound, i = !1, s = e.suffixMap || a.suffixMap, r = W(t, ""), n = this._overwriteProps; var l, p, c, d, m, g, v, y, T, x = t.style; if (u && "" === x.zIndex && (l = Q(t, "zIndex", r), ("auto" === l || "" === l) && (x.zIndex = 0)), "string" == typeof e && (d = x.cssText, l = $(t, r), x.cssText = d + ";" + e, l = G(t, l, $(t)).difs, !z && w.test(e) && (l.opacity = parseFloat(RegExp.$1)), e = l, x.cssText = d), this._firstPT = p = this.parse(t, e, null), this._transformType) { for (T = 3 === this._transformType, ye ? _ && (u = !0, "" === x.zIndex && (v = Q(t, "zIndex", r), ("auto" === v || "" === v) && (x.zIndex = 0)), f && (x.WebkitBackfaceVisibility = this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : x.zoom = 1, c = p; c && c._next;)c = c._next; y = new pe(t, "transform", 0, 0, null, 2), this._linkCSSP(y, null, c), y.setRatio = T && xe ? Se : ye ? ke : Pe, y.data = this._transform || be(t, r, !0), n.pop() } if (i) { for (; p;) { for (g = p._next, c = d; c && c.pr > p.pr;)c = c._next; (p._prev = c ? c._prev : m) ? p._prev._next = p : d = p, (p._next = c) ? c._prev = p : m = p, p = g } this._firstPT = d } return !0 }, l.parse = function (t, e, i, n) { var a, l, u, _, p, f, c, d, m, g, v = t.style; for (a in e) f = e[a], l = o[a], l ? i = l.parse(t, f, a, this, i, n, e) : (p = Q(t, a, r) + "", m = "string" == typeof f, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || m && b.test(f) ? (m || (f = oe(f), f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), i = fe(v, a, p, f, !0, "transparent", i, 0, n)) : !m || -1 === f.indexOf(" ") && -1 === f.indexOf(",") ? (u = parseFloat(p), c = u || 0 === u ? p.substr((u + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (u = te(t, a, r), c = "px") : "left" === a || "top" === a ? (u = H(t, a, r), c = "px") : (u = "opacity" !== a ? 0 : 1, c = "")), g = m && "=" === f.charAt(1), g ? (_ = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), _ *= parseFloat(f), d = f.replace(y, "")) : (_ = parseFloat(f), d = m ? f.substr((_ + "").length) || "" : ""), "" === d && (d = s[a] || c), f = _ || 0 === _ ? (g ? _ + u : _) + d : e[a], c !== d && "" !== d && (_ || 0 === _) && (u || 0 === u) && (u = Z(t, a, u, c), "%" === d ? (u /= Z(t, a, 100, "%") / 100, u > 100 && (u = 100), e.strictUnits !== !0 && (p = u + "%")) : "em" === d ? u /= Z(t, a, 1, "em") : (_ = Z(t, a, _, d), d = "px"), g && (_ || 0 === _) && (f = _ + u + d)), g && (_ += u), !u && 0 !== u || !_ && 0 !== _ ? void 0 !== v[a] && (f || "NaN" != f + "" && null != f) ? (i = new pe(v, a, _ || u || 0, 0, i, -1, a, !1, 0, p, f), i.xs0 = "none" !== f || "display" !== a && -1 === a.indexOf("Style") ? f : p) : B("invalid " + a + " tween value: " + e[a]) : (i = new pe(v, a, u, _ - u, i, 0, a, h !== !1 && ("px" === d || "zIndex" === a), 0, p, f), i.xs0 = d)) : i = fe(v, a, p, f, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n); return i }, l.setRatio = function (t) { var e, i, s, r = this._firstPT, n = 1e-6; if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; r;) { if (e = r.c * t + r.s, r.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : n > e && e > -n && (e = 0), r.type) if (1 === r.type) if (s = r.l, 2 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2; else if (3 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else { for (i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++)i += r["xn" + s] + r["xs" + (s + 1)]; r.t[r.p] = i } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t); else r.t[r.p] = e + r.xs0; r = r._next } else for (; r;)2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next; else for (; r;)2 !== r.type ? r.t[r.p] = r.e : r.setRatio(t), r = r._next }, l._enableTransforms = function (t) { this._transformType = t || 3 === this._transformType ? 3 : 2, this._transform = this._transform || be(this._target, r, !0) }, l._linkCSSP = function (t, e, i, s) { return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, s = !0), i ? i._next = t : s || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t }, l._kill = function (e) { var i, s, r, n = e; if (e.autoAlpha || e.alpha) { n = {}; for (s in e) n[s] = e[s]; n.opacity = 1, n.autoAlpha && (n.visibility = 1) } return e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), t.prototype._kill.call(this, n) }; var De = function (t, e, i) { var s, r, n, a; if (t.slice) for (r = t.length; --r > -1;)De(t[r], e, i); else for (s = t.childNodes, r = s.length; --r > -1;)n = s[r], a = n.type, n.style && (e.push($(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || De(n, e, i) }; return a.cascadeTo = function (t, i, s) { var r, n, a, o = e.to(t, i, s), l = [o], h = [], u = [], _ = [], p = e._internals.reservedProps; for (t = o._targets || o.target, De(t, h, _), o.render(i, !0), De(t, u), o.render(0, !0), o._enabled(!0), r = _.length; --r > -1;)if (n = G(_[r], h[r], u[r]), n.firstMPT) { n = n.difs; for (a in s) p[a] && (n[a] = s[a]); l.push(e.to(_[r], i, n)) } return l }, t.activate([a]), a }, !0) }), window._gsDefine && window._gsQueue.pop()();
define("cssPlugin", function () { });

/*!
* VERSION: beta 1.9.3
* DATE: 2013-04-02
* UPDATES AND DOCS AT: http://www.greensock.com
*
* @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
* This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
* Club GreenSock members, the software agreement that was issued with your membership.
* 
* @author: Jack Doyle, jack@greensock.com
**/
(window._gsQueue || (window._gsQueue = [])).push(function () { "use strict"; window._gsDefine("easing.Back", ["easing.Ease"], function (t) { var e, i, s, r = window.GreenSockGlobals || window, n = r.com.greensock, a = 2 * Math.PI, o = Math.PI / 2, h = n._class, l = function (e, i) { var s = h("easing." + e, function () { }, !0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, s }, _ = t.register || function () { }, u = function (t, e, i, s) { var r = h("easing." + t, { easeOut: new e, easeIn: new i, easeInOut: new s }, !0); return _(r, t), r }, c = function (t, e, i) { this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t) }, f = function (e, i) { var s = h("easing." + e, function (t) { this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1 }, !0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, r.config = function (t) { return new s(t) }, s }, p = u("Back", f("BackOut", function (t) { return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1 }), f("BackIn", function (t) { return t * t * ((this._p1 + 1) * t - this._p1) }), f("BackInOut", function (t) { return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2) })), m = h("easing.SlowMo", function (t, e, i) { e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0 }, !0), d = m.prototype = new t; return d.constructor = m, d.getRatio = function (t) { var e = t + (.5 - t) * this._p; return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e }, m.ease = new m(.7, .7), d.config = m.config = function (t, e, i) { return new m(t, e, i) }, e = h("easing.SteppedEase", function (t) { t = t || 1, this._p1 = 1 / t, this._p2 = t + 1 }, !0), d = e.prototype = new t, d.constructor = e, d.getRatio = function (t) { return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1 }, d.config = e.config = function (t) { return new e(t) }, i = h("easing.RoughEase", function (e) { e = e || {}; for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), f = u, p = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --f > -1;)i = p ? Math.random() : 1 / u * f, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), p ? s += Math.random() * r - .5 * r : f % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = { x: i, y: s }; for (l.sort(function (t, e) { return t.x - e.x }), o = new c(1, 1, null), f = u; --f > -1;)a = l[f], o = new c(a.x, a.y, o); this._prev = new c(0, 0, 0 !== o.t ? o : o.next) }, !0), d = i.prototype = new t, d.constructor = i, d.getRatio = function (t) { var e = this._prev; if (t > e.t) { for (; e.next && t >= e.t;)e = e.next; e = e.prev } else for (; e.prev && e.t >= t;)e = e.prev; return this._prev = e, e.v + (t - e.t) / e.gap * e.c }, d.config = function (t) { return new i(t) }, i.ease = new i, u("Bounce", l("BounceOut", function (t) { return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }), l("BounceIn", function (t) { return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375) }), l("BounceInOut", function (t) { var e = .5 > t; return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5 })), u("Circ", l("CircOut", function (t) { return Math.sqrt(1 - (t -= 1) * t) }), l("CircIn", function (t) { return -(Math.sqrt(1 - t * t) - 1) }), l("CircInOut", function (t) { return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) })), s = function (e, i, s) { var r = h("easing." + e, function (t, e) { this._p1 = t || 1, this._p2 = e || s, this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0) }, !0), n = r.prototype = new t; return n.constructor = r, n.getRatio = i, n.config = function (t, e) { return new r(t, e) }, r }, u("Elastic", s("ElasticOut", function (t) { return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * a / this._p2) + 1 }, .3), s("ElasticIn", function (t) { return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2)) }, .3), s("ElasticInOut", function (t) { return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) + 1 }, .45)), u("Expo", l("ExpoOut", function (t) { return 1 - Math.pow(2, -10 * t) }), l("ExpoIn", function (t) { return Math.pow(2, 10 * (t - 1)) - .001 }), l("ExpoInOut", function (t) { return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1))) })), u("Sine", l("SineOut", function (t) { return Math.sin(t * o) }), l("SineIn", function (t) { return -Math.cos(t * o) + 1 }), l("SineInOut", function (t) { return -.5 * (Math.cos(Math.PI * t) - 1) })), h("easing.EaseLookup", { find: function (e) { return t.map[e] } }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), p }, !0) }), window._gsDefine && window._gsQueue.pop()();
define("easepack", function () { });

/*!
* VERSION: beta 1.10.3
* DATE: 2013-09-02
* UPDATES AND DOCS AT: http://www.greensock.com
*
* @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
* This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
* Club GreenSock members, the software agreement that was issued with your membership.
* 
* @author: Jack Doyle, jack@greensock.com
*/
(function (t) { "use strict"; var e, i, s, n, r, a = t.GreenSockGlobals || t, o = function (t) { var e, i = t.split("."), s = a; for (e = 0; i.length > e; e++)s[i[e]] = s = s[i[e]] || {}; return s }, l = o("com.greensock"), _ = [].slice, h = function () { }, u = {}, m = function (e, i, s, n) { this.sc = u[e] ? u[e].sc : [], u[e] = this, this.gsClass = null, this.func = s; var r = []; this.check = function (l) { for (var _, h, f, p, c = i.length, d = c; --c > -1;)(_ = u[i[c]] || new m(i[c], [])).gsClass ? (r[c] = _.gsClass, d--) : l && _.sc.push(this); if (0 === d && s) for (h = ("com.greensock." + e).split("."), f = h.pop(), p = o(h.join("."))[f] = this.gsClass = s.apply(s, r), n && (a[f] = p, "function" == typeof define && define.amd ? define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + e.split(".").join("/"), [], function () { return p }) : "undefined" != typeof module && module.exports && (module.exports = p)), c = 0; this.sc.length > c; c++)this.sc[c].check() }, this.check(!0) }, f = t._gsDefine = function (t, e, i, s) { return new m(t, e, i, s) }, p = l._class = function (t, e, i) { return e = e || function () { }, f(t, [], function () { return e }, i), e }; f.globals = a; var c = [0, 0, 1, 1], d = [], v = p("easing.Ease", function (t, e, i, s) { this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? c.concat(e) : c }, !0), g = v.map = {}, T = v.register = function (t, e, i, s) { for (var n, r, a, o, _ = e.split(","), h = _.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --h > -1;)for (r = _[h], n = s ? p("easing." + r, null, !0) : l.easing[r] || {}, a = u.length; --a > -1;)o = u[a], g[r + "." + o] = g[o + r] = n[o] = t.getRatio ? t : t[o] || new t }; for (s = v.prototype, s._calcEnd = !1, s.getRatio = function (t) { if (this._func) return this._params[0] = t, this._func.apply(null, this._params); var e = this._type, i = this._power, s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t); return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2 }, e = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], i = e.length; --i > -1;)s = e[i] + ",Power" + i, T(new v(null, null, 1, i), s, "easeOut", !0), T(new v(null, null, 2, i), s, "easeIn" + (0 === i ? ",easeNone" : "")), T(new v(null, null, 3, i), s, "easeInOut"); g.linear = l.easing.Linear.easeIn, g.swing = l.easing.Quad.easeInOut; var w = p("events.EventDispatcher", function (t) { this._listeners = {}, this._eventTarget = t || this }); s = w.prototype, s.addEventListener = function (t, e, i, s, a) { a = a || 0; var o, l, _ = this._listeners[t], h = 0; for (null == _ && (this._listeners[t] = _ = []), l = _.length; --l > -1;)o = _[l], o.c === e && o.s === i ? _.splice(l, 1) : 0 === h && a > o.pr && (h = l + 1); _.splice(h, 0, { c: e, s: i, up: s, pr: a }), this !== n || r || n.wake() }, s.removeEventListener = function (t, e) { var i, s = this._listeners[t]; if (s) for (i = s.length; --i > -1;)if (s[i].c === e) return s.splice(i, 1), void 0 }, s.dispatchEvent = function (t) { var e, i, s, n = this._listeners[t]; if (n) for (e = n.length, i = this._eventTarget; --e > -1;)s = n[e], s.up ? s.c.call(s.s || i, { type: t, target: i }) : s.c.call(s.s || i) }; var P = t.requestAnimationFrame, y = t.cancelAnimationFrame, k = Date.now || function () { return (new Date).getTime() }, b = k(); for (e = ["ms", "moz", "webkit", "o"], i = e.length; --i > -1 && !P;)P = t[e[i] + "RequestAnimationFrame"], y = t[e[i] + "CancelAnimationFrame"] || t[e[i] + "CancelRequestAnimationFrame"]; p("Ticker", function (t, e) { var i, s, a, o, l, _ = this, u = k(), m = e !== !1 && P, f = function (t) { b = k(), _.time = (b - u) / 1e3; var e, n = _.time - l; (!i || n > 0 || t === !0) && (_.frame++, l += n + (n >= o ? .004 : o - n), e = !0), t !== !0 && (a = s(f)), e && _.dispatchEvent("tick") }; w.call(_), _.time = _.frame = 0, _.tick = function () { f(!0) }, _.sleep = function () { null != a && (m && y ? y(a) : clearTimeout(a), s = h, a = null, _ === n && (r = !1)) }, _.wake = function () { null !== a && _.sleep(), s = 0 === i ? h : m && P ? P : function (t) { return setTimeout(t, 0 | 1e3 * (l - _.time) + 1) }, _ === n && (r = !0), f(2) }, _.fps = function (t) { return arguments.length ? (i = t, o = 1 / (i || 60), l = this.time + o, _.wake(), void 0) : i }, _.useRAF = function (t) { return arguments.length ? (_.sleep(), m = t, _.fps(i), void 0) : m }, _.fps(t), setTimeout(function () { m && (!a || 5 > _.frame) && _.useRAF(!1) }, 1500) }), s = l.Ticker.prototype = new l.events.EventDispatcher, s.constructor = l.Ticker; var A = p("core.Animation", function (t, e) { if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, j) { r || n.wake(); var i = this.vars.useFrames ? F : j; i.add(this, i._time), this.vars.paused && this.paused(!0) } }); n = A.ticker = new l.Ticker, s = A.prototype, s._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1; var S = function () { k() - b > 2e3 && n.wake(), setTimeout(S, 2e3) }; S(), s.play = function (t, e) { return arguments.length && this.seek(t, e), this.reversed(!1).paused(!1) }, s.pause = function (t, e) { return arguments.length && this.seek(t, e), this.paused(!0) }, s.resume = function (t, e) { return arguments.length && this.seek(t, e), this.paused(!1) }, s.seek = function (t, e) { return this.totalTime(Number(t), e !== !1) }, s.restart = function (t, e) { return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0) }, s.reverse = function (t, e) { return arguments.length && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, s.render = function () { }, s.invalidate = function () { return this }, s._enabled = function (t, e) { return r || n.wake(), this._gc = !t, this._active = t && !this._paused && this._totalTime > 0 && this._totalTime < this._totalDuration, e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1 }, s._kill = function () { return this._enabled(!1, !1) }, s.kill = function (t, e) { return this._kill(t, e), this }, s._uncache = function (t) { for (var e = t ? this : this.timeline; e;)e._dirty = !0, e = e.timeline; return this }, s._swapSelfInParams = function (t) { for (var e = t.length, i = t.concat(); --e > -1;)"{self}" === t[e] && (i[e] = this); return i }, s.eventCallback = function (t, e, i, s) { if ("on" === (t || "").substr(0, 2)) { var n = this.vars; if (1 === arguments.length) return n[t]; null == e ? delete n[t] : (n[t] = e, n[t + "Params"] = i instanceof Array && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, n[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e) } return this }, s.delay = function (t) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay }, s.duration = function (t) { return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration) }, s.totalDuration = function (t) { return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration }, s.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time }, s.totalTime = function (t, e, i) { if (r || n.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var s = this._totalDuration, a = this._timeline; if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : a._time) - (this._reversed ? s - t : t) / this._timeScale, a._dirty || this._uncache(!1), a._timeline) for (; a._timeline;)a._timeline._time !== (a._startTime + a._totalTime) / a._timeScale && a.totalTime(a._totalTime, !0), a = a._timeline } this._gc && this._enabled(!0, !1), this._totalTime !== t && this.render(t, e, !1) } return this }, s.startTime = function (t) { return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime }, s.timeScale = function (t) { if (!arguments.length) return this._timeScale; if (t = t || 1e-6, this._timeline && this._timeline.smoothChildTiming) { var e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(); this._startTime = i - (i - this._startTime) * this._timeScale / t } return this._timeScale = t, this._uncache(!1) }, s.reversed = function (t) { return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._totalTime, !0)), this) : this._reversed }, s.paused = function (t) { if (!arguments.length) return this._paused; if (t != this._paused && this._timeline) { r || t || n.wake(); var e = this._timeline, i = e.rawTime(), s = i - this._pauseTime; !t && e.smoothChildTiming && (this._startTime += s, this._uncache(!1)), this._pauseTime = t ? i : null, this._paused = t, this._active = !t && this._totalTime > 0 && this._totalTime < this._totalDuration, t || 0 === s || 0 === this._duration || this.render(e.smoothChildTiming ? this._totalTime : (i - this._startTime) / this._timeScale, !0, !0) } return this._gc && !t && this._enabled(!0, !1), this }; var x = p("core.SimpleTimeline", function (t) { A.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0 }); s = x.prototype = new A, s.constructor = x, s.kill()._gc = !1, s._first = s._last = null, s._sortChildren = !1, s.add = s.insert = function (t, e) { var i, s; if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren) for (s = t._startTime; i && i._startTime > s;)i = i._prev; return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._timeline && this._uncache(!0), this }, s._remove = function (t, e) { return t.timeline === this && (e || t._enabled(!1, !0), t.timeline = null, t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), this._timeline && this._uncache(!0)), this }, s.render = function (t, e, i) { var s, n = this._first; for (this._totalTime = this._time = this._rawPrevTime = t; n;)s = n._next, (n._active || t >= n._startTime && !n._paused) && (n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s }, s.rawTime = function () { return r || n.wake(), this._totalTime }; var C = p("TweenLite", function (e, i, s) { if (A.call(this, i, s), this.render = C.prototype.render, null == e) throw "Cannot tween a null target."; this.target = e = "string" != typeof e ? e : C.selector(e) || e; var n, r, a, o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType), l = this.vars.overwrite; if (this._overwrite = l = null == l ? L[C.defaultOverwrite] : "number" == typeof l ? l >> 0 : L[l], (o || e instanceof Array) && "number" != typeof e[0]) for (this._targets = a = _.call(e, 0), this._propLookup = [], this._siblings = [], n = 0; a.length > n; n++)r = a[n], r ? "string" != typeof r ? r.length && r !== t && r[0] && (r[0] === t || r[0].nodeType && r[0].style && !r.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(_.call(r, 0))) : (this._siblings[n] = G(r, this, !1), 1 === l && this._siblings[n].length > 1 && Q(r, this, null, 1, this._siblings[n])) : (r = a[n--] = C.selector(r), "string" == typeof r && a.splice(n + 1, 1)) : a.splice(n--, 1); else this._propLookup = {}, this._siblings = G(e, this, !1), 1 === l && this._siblings.length > 1 && Q(e, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && this.render(-this._delay, !1, !0) }, !0), R = function (e) { return e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType) }, D = function (t, e) { var i, s = {}; for (i in t) U[i] || i in e && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!I[i] || I[i] && I[i]._autoCSS) || (s[i] = t[i], delete t[i]); t.css = s }; s = C.prototype = new A, s.constructor = C, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = !1, C.version = "1.10.3", C.defaultEase = s._ease = new v(null, null, 1, 1), C.defaultOverwrite = "auto", C.ticker = n, C.autoSleep = !0, C.selector = t.$ || t.jQuery || function (e) { return t.$ ? (C.selector = t.$, t.$(e)) : t.document ? t.document.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e }; var E = C._internals = {}, I = C._plugins = {}, O = C._tweenLookup = {}, N = 0, U = E.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1 }, L = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 }, F = A._rootFramesTimeline = new x, j = A._rootTimeline = new x; j._startTime = n.time, F._startTime = n.frame, j._active = F._active = !0, A._updateRoot = function () { if (j.render((n.time - j._startTime) * j._timeScale, !1, !1), F.render((n.frame - F._startTime) * F._timeScale, !1, !1), !(n.frame % 120)) { var t, e, i; for (i in O) { for (e = O[i].tweens, t = e.length; --t > -1;)e[t]._gc && e.splice(t, 1); 0 === e.length && delete O[i] } if (i = j._first, (!i || i._paused) && C.autoSleep && !F._first && 1 === n._listeners.tick.length) { for (; i && i._paused;)i = i._next; i || n.sleep() } } }, n.addEventListener("tick", A._updateRoot); var G = function (t, e, i) { var s, n, r = t._gsTweenID; if (O[r || (t._gsTweenID = r = "t" + N++)] || (O[r] = { target: t, tweens: [] }), e && (s = O[r].tweens, s[n = s.length] = e, i)) for (; --n > -1;)s[n] === e && s.splice(n, 1); return O[r].tweens }, Q = function (t, e, i, s, n) { var r, a, o, l; if (1 === s || s >= 4) { for (l = n.length, r = 0; l > r; r++)if ((o = n[r]) !== e) o._gc || o._enabled(!1, !1) && (a = !0); else if (5 === s) break; return a } var _, h = e._startTime + 1e-10, u = [], m = 0, f = 0 === e._duration; for (r = n.length; --r > -1;)(o = n[r]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (_ = _ || B(e, 0, f), 0 === B(o, _, f) && (u[m++] = o)) : h >= o._startTime && o._startTime + o.totalDuration() / o._timeScale + 1e-10 > h && ((f || !o._initted) && 2e-10 >= h - o._startTime || (u[m++] = o))); for (r = m; --r > -1;)o = u[r], 2 === s && o._kill(i, t) && (a = !0), (2 !== s || !o._firstPT && o._initted) && o._enabled(!1, !1) && (a = !0); return a }, B = function (t, e, i) { for (var s = t._timeline, n = s._timeScale, r = t._startTime, a = 1e-10; s._timeline;) { if (r += s._startTime, n *= s._timeScale, s._paused) return -100; s = s._timeline } return r /= n, r > e ? r - e : i && r === e || !t._initted && 2 * a > r - e ? a : (r += t.totalDuration() / t._timeScale / n) > e + a ? 0 : r - e - a }; s._init = function () { var t, e, i, s, n = this.vars, r = this._overwrittenProps, a = this._duration, o = n.immediateRender, l = n.ease; if (n.startAt) { if (this._startAt && this._startAt.render(-1, !0), n.startAt.overwrite = 0, n.startAt.immediateRender = !0, this._startAt = C.to(this.target, 0, n.startAt), o) if (this._time > 0) this._startAt = null; else if (0 !== a) return } else if (n.runBackwards && n.immediateRender && 0 !== a) if (this._startAt) this._startAt.render(-1, !0), this._startAt = null; else if (0 === this._time) { i = {}; for (s in n) U[s] && "autoCSS" !== s || (i[s] = n[s]); return i.overwrite = 0, this._startAt = C.to(this.target, 0, i), void 0 } if (this._ease = l ? l instanceof v ? n.easeParams instanceof Array ? l.config.apply(l, n.easeParams) : l : "function" == typeof l ? new v(l, n.easeParams) : g[l] || C.defaultEase : C.defaultEase, this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (t = this._targets.length; --t > -1;)this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], r ? r[t] : null) && (e = !0); else e = this._initProps(this.target, this._propLookup, this._siblings, r); if (e && C._onPluginEvent("_onInitAllProps", this), r && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), n.runBackwards) for (i = this._firstPT; i;)i.s += i.c, i.c = -i.c, i = i._next; this._onUpdate = n.onUpdate, this._initted = !0 }, s._initProps = function (e, i, s, n) { var r, a, o, l, _, h; if (null == e) return !1; this.vars.css || e.style && e !== t && e.nodeType && I.css && this.vars.autoCSS !== !1 && D(this.vars, e); for (r in this.vars) { if (h = this.vars[r], U[r]) h instanceof Array && -1 !== h.join("").indexOf("{self}") && (this.vars[r] = h = this._swapSelfInParams(h, this)); else if (I[r] && (l = new I[r])._onInitTween(e, this.vars[r], this)) { for (this._firstPT = _ = { _next: this._firstPT, t: l, p: "setRatio", s: 0, c: 1, f: !0, n: r, pg: !0, pr: l._priority }, a = l._overwriteProps.length; --a > -1;)i[l._overwriteProps[a]] = this._firstPT; (l._priority || l._onInitAllProps) && (o = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0) } else this._firstPT = i[r] = _ = { _next: this._firstPT, t: e, p: r, f: "function" == typeof e[r], n: r, pg: !1, pr: 0 }, _.s = _.f ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(e[r]), _.c = "string" == typeof h && "=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * Number(h.substr(2)) : Number(h) - _.s || 0; _ && _._next && (_._next._prev = _) } return n && this._kill(n, e) ? this._initProps(e, i, s, n) : this._overwrite > 1 && this._firstPT && s.length > 1 && Q(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, n)) : o }, s.render = function (t, e, i) { var s, n, r, a = this._time; if (t >= this._duration) this._totalTime = this._time = this._duration, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, n = "onComplete"), 0 === this._duration && ((0 === t || 0 > this._rawPrevTime) && this._rawPrevTime !== t && (i = !0, this._rawPrevTime > 0 && (n = "onReverseComplete", e && (t = -1))), this._rawPrevTime = t); else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === this._duration && this._rawPrevTime > 0) && (n = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === this._duration && (this._rawPrevTime >= 0 && (i = !0), this._rawPrevTime = t)) : this._initted || (i = !0); else if (this._totalTime = this._time = t, this._easeType) { var o = t / this._duration, l = this._easeType, _ = this._easePower; (1 === l || 3 === l && o >= .5) && (o = 1 - o), 3 === l && (o *= 2), 1 === _ ? o *= o : 2 === _ ? o *= o * o : 3 === _ ? o *= o * o * o : 4 === _ && (o *= o * o * o * o), this.ratio = 1 === l ? 1 - o : 2 === l ? o : .5 > t / this._duration ? o / 2 : 1 - o / 2 } else this.ratio = this._ease.getRatio(t / this._duration); if (this._time !== a || i) { if (!this._initted) { if (this._init(), !this._initted) return; this._time && !s ? this.ratio = this._ease.getRatio(this._time / this._duration) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === this._duration) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || d))), r = this._firstPT; r;)r.f ? r.t[r.p](r.c * this.ratio + r.s) : r.t[r.p] = r.c * this.ratio + r.s, r = r._next; this._onUpdate && (0 > t && this._startAt && this._startAt.render(t, e, i), e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || d)), n && (this._gc || (0 > t && this._startAt && !this._onUpdate && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[n] && this.vars[n].apply(this.vars[n + "Scope"] || this, this.vars[n + "Params"] || d))) } }, s._kill = function (t, e) { if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._enabled(!1, !1); e = "string" != typeof e ? e || this._targets || this.target : C.selector(e) || e; var i, s, n, r, a, o, l, _; if ((e instanceof Array || R(e)) && "number" != typeof e[0]) for (i = e.length; --i > -1;)this._kill(t, e[i]) && (o = !0); else { if (this._targets) { for (i = this._targets.length; --i > -1;)if (e === this._targets[i]) { a = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all"; break } } else { if (e !== this.target) return !1; a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all" } if (a) { l = t || a, _ = t !== s && "all" !== s && t !== a && (null == t || t._tempKill !== !0); for (n in l) (r = a[n]) && (r.pg && r.t._kill(l) && (o = !0), r.pg && 0 !== r.t._overwriteProps.length || (r._prev ? r._prev._next = r._next : r === this._firstPT && (this._firstPT = r._next), r._next && (r._next._prev = r._prev), r._next = r._prev = null), delete a[n]), _ && (s[n] = 1); !this._firstPT && this._initted && this._enabled(!1, !1) } } return o }, s.invalidate = function () { return this._notifyPluginsOfEnabled && C._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = !1, this._propLookup = this._targets ? {} : [], this }, s._enabled = function (t, e) { if (r || n.wake(), t && this._gc) { var i, s = this._targets; if (s) for (i = s.length; --i > -1;)this._siblings[i] = G(s[i], this, !0); else this._siblings = G(this.target, this, !0) } return A.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? C._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1 }, C.to = function (t, e, i) { return new C(t, e, i) }, C.from = function (t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new C(t, e, i) }, C.fromTo = function (t, e, i, s) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new C(t, e, s) }, C.delayedCall = function (t, e, i, s, n) { return new C(e, 0, { delay: t, onComplete: e, onCompleteParams: i, onCompleteScope: s, onReverseComplete: e, onReverseCompleteParams: i, onReverseCompleteScope: s, immediateRender: !1, useFrames: n, overwrite: 0 }) }, C.set = function (t, e) { return new C(t, 0, e) }, C.killTweensOf = C.killDelayedCallsTo = function (t, e) { for (var i = C.getTweensOf(t), s = i.length; --s > -1;)i[s]._kill(e, t) }, C.getTweensOf = function (t) { if (null == t) return []; t = "string" != typeof t ? t : C.selector(t) || t; var e, i, s, n; if ((t instanceof Array || R(t)) && "number" != typeof t[0]) { for (e = t.length, i = []; --e > -1;)i = i.concat(C.getTweensOf(t[e])); for (e = i.length; --e > -1;)for (n = i[e], s = e; --s > -1;)n === i[s] && i.splice(e, 1) } else for (i = G(t).concat(), e = i.length; --e > -1;)i[e]._gc && i.splice(e, 1); return i }; var q = p("plugins.TweenPlugin", function (t, e) { this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = q.prototype }, !0); if (s = q.prototype, q.version = "1.10.1", q.API = 2, s._firstPT = null, s._addTween = function (t, e, i, s, n, r) { var a, o; return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - i : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = { _next: this._firstPT, t: t, p: e, s: i, c: a, f: "function" == typeof t[e], n: n || e, r: r }, o._next && (o._next._prev = o), o) : void 0 }, s.setRatio = function (t) { for (var e, i = this._firstPT, s = 1e-6; i;)e = i.c * t + i.s, i.r ? e = 0 | e + (e > 0 ? .5 : -.5) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next }, s._kill = function (t) { var e, i = this._overwriteProps, s = this._firstPT; if (null != t[this._propName]) this._overwriteProps = []; else for (e = i.length; --e > -1;)null != t[i[e]] && i.splice(e, 1); for (; s;)null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next; return !1 }, s._roundProps = function (t, e) { for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next }, C._onPluginEvent = function (t, e) { var i, s, n, r, a, o = e._firstPT; if ("_onInitAllProps" === t) { for (; o;) { for (a = o._next, s = n; s && s.pr > o.pr;)s = s._next; (o._prev = s ? s._prev : r) ? o._prev._next = o : n = o, (o._next = s) ? s._prev = o : r = o, o = a } o = e._firstPT = n } for (; o;)o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next; return i }, q.activate = function (t) { for (var e = t.length; --e > -1;)t[e].API === q.API && (I[(new t[e])._propName] = t[e]); return !0 }, f.plugin = function (t) { if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition."; var e, i = t.propName, s = t.priority || 0, n = t.overwriteProps, r = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" }, a = p("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () { q.call(this, i, s), this._overwriteProps = n || [] }, t.global === !0), o = a.prototype = new q(i); o.constructor = a, a.API = t.API; for (e in r) "function" == typeof t[e] && (o[r[e]] = t[e]); return a.version = t.version, q.activate([a]), a }, e = t._gsQueue) { for (i = 0; e.length > i; i++)e[i](); for (s in u) u[s].func || t.console.log("GSAP encountered missing dependency: com.greensock." + s) } r = !1 })(window);
define("tweenlite", function () { });

/*!
* VERSION: 0.1.6
* DATE: 2013-02-13
* UPDATES AND DOCS AT: http://www.greensock.com/jquery-gsap-plugin/
*
* Requires TweenLite version 1.8.0 or higher and CSSPlugin.
*
* @license Copyright (c) 2013, GreenSock. All rights reserved.
* This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
* Club GreenSock members, the software agreement that was issued with your membership.
*
* @author: Jack Doyle, jack@greensock.com
*/
(function (t) { "use strict"; var e, i, s, r = t.fn.animate, n = t.fn.stop, a = !0, o = function (t, e) { "function" == typeof t && this.each(t), e() }, h = function (t, e, i, s, r) { r = "function" == typeof r ? r : null, e = "function" == typeof e ? e : null, (e || r) && (s[t] = r ? o : i.each, s[t + "Scope"] = i, s[t + "Params"] = r ? [e, r] : [e]) }, l = { overwrite: 1, delay: 1, useFrames: 1, runBackwards: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, autoCSS: 1 }, _ = function (t, e) { for (var i in l) l[i] && void 0 !== t[i] && (e[i] = t[i]) }, u = function (t) { return function (e) { return t.getRatio(e) } }, f = {}, c = function () { var r, n, a, o = window.GreenSockGlobals || window; if (e = o.TweenMax || o.TweenLite, e && (r = (e.version + ".0.0").split("."), n = !(Number(r[0]) > 0 && Number(r[1]) > 7), o = o.com.greensock, i = o.plugins.CSSPlugin, f = o.easing.Ease.map || {}), !e || !i || n) return e = null, !s && window.console && (window.console.log("The jquery.gsap.js plugin requires the TweenMax (or at least TweenLite and CSSPlugin) JavaScript file(s)." + (n ? " Version " + r.join(".") + " is too old." : "")), s = !0), void 0; if (t.easing) { for (a in f) t.easing[a] = u(f[a]); c = !1 } }; t.fn.animate = function (s, n, o, l) { if (s = s || {}, c && (c(), !e || !i)) return r.call(this, s, n, o, l); if (!a || s.skipGSAP === !0 || "object" == typeof n && "function" == typeof n.step || null != s.scrollTop || null != s.scrollLeft) return r.call(this, s, n, o, l); var u, p, m, d, g = t.speed(n, o, l), v = { ease: f[g.easing] || (g.easing === !1 ? f.linear : f.swing) }, T = this, y = "object" == typeof n ? n.specialEasing : null; for (p in s) { if (u = s[p], u instanceof Array && f[u[1]] && (y = y || {}, y[p] = u[1], u = u[0]), "toggle" === u || "hide" === u || "show" === u) return r.call(this, s, n, o, l); v[-1 === p.indexOf("-") ? p : t.camelCase(p)] = u } if (y) { d = []; for (p in y) u = d[d.length] = {}, _(v, u), u.ease = f[y[p]] || v.ease, -1 !== p.indexOf("-") && (p = t.camelCase(p)), u[p] = v[p]; 0 === d.length && (d = null) } return m = function (i) { if (d) for (var s = d.length; --s > -1;)e.to(T, t.fx.off ? 0 : g.duration / 1e3, d[s]); h("onComplete", g.old, T, v, i), e.to(T, t.fx.off ? 0 : g.duration / 1e3, v) }, g.queue !== !1 ? T.queue(g.queue, m) : m(), T }, t.fn.stop = function (t, i) { if (n.call(this, t, i), e) { if (i) for (var s, r = e.getTweensOf(this), a = r.length; --a > -1;)s = r[a].totalTime() / r[a].totalDuration(), s > 0 && 1 > s && r[a].seek(r[a].totalDuration()); e.killTweensOf(this) } return this }, t.gsap = { enabled: function (t) { a = t }, version: "0.1.6" } })(jQuery);
define("gsap", ["jquery", "cssPlugin", "easepack", "tweenlite"], function () { });

/***
* @author : Julie Cardinal
*/


define('uiTools/pagination', [
  'jquery',

  'gsap'
], function ($) {



  /***********************************  FlightBoard  ****************************************/


  var Pagination = {
    init: function (context) {
      var _t = this;

      $(context).each(function (index, el) {
        new PaginationInstance(el);
      });
    }
  };

  function PaginationInstance(el) {
    var $pager = $(el),
      $prev = $pager.find(".pagination-prev"),
      $next = $pager.find(".pagination-next"),
      $pageNumbers = $pager.find(".pagination-listnumber"),
      $allPages = $pager.find(".pagination-listnumber-ctn"),
      $allPagesNumber = $pager.find(".pagination-number"),
      selectIndex = $allPages.find(".pagination-number.active").index(),
      $numPages = $allPagesNumber.length - 1,
      $pageNumbersCtn = $pager.find(".pagination-listnumber"),
      $pageNumbersCtnWidth = $pageNumbersCtn.width(),
      $allPageNumbers = $pageNumbersCtn.find(".pagination-number"),
      $onePageNumber = $allPageNumbers.eq(0),
      buttonWidth = $onePageNumber.width(),
      $indexButtonActive = $pageNumbersCtn.find(".pagination-number.active").index(),
      numButtonsVisible = Math.floor($pager.find(".pagination-listnumber-ctn").width() / buttonWidth),
      maxDistance = $pageNumbersCtnWidth - (numButtonsVisible * buttonWidth);

    var isStandard = false;
    if (($pager.data('type') == 'standard')) {
      isStandard = true;
    }

    function init() {
      update();
      updatePagerController();
      movePage();
      createEvents();
    }

    function createEvents() {
      $(window).bind("resize", function () {
        // TODO :: Need to reposition the PageNumber Ctn when we resize
        update();

        movePage();
      });

      $prev.on("click", function (evt) {
        evt.preventDefault();
        if (!isStandard) {
          resetActiveButton();
          selectIndex--;
          if (selectIndex < 0) selectIndex = 0;
          activeButton();
          movePage();
          updatePagerController();
        } else {
          var url = $('a', $prev).attr('href');
          if (url != '#') {
            window.location.href = url;
          }
        }
      });

      $next.on("click", function (evt) {
        evt.preventDefault();

        if (!isStandard) {
          var isMaxDistance = getIsMaxDistance();

          if (!isMaxDistance) {
            resetActiveButton();

            var isMaxDistance = (($indexButtonActive * buttonWidth) < maxDistance) ? false : true;

            selectIndex++;
            activeButton();
            movePage();
            updatePagerController();
          }
        } else {
          var url = $('a', $next).attr('href');
          if (url != '#') {
            window.location.href = url;
          }
        }
      });
    }

    function getIsMaxDistance() {
      var $indexButtonActive = $pageNumbersCtn.find(".pagination-number.active").index(),
        numButtonsVisible = Math.floor($pager.find(".pagination-listnumber-ctn").width() / buttonWidth),
        maxDistance = $pageNumbersCtnWidth - (numButtonsVisible * buttonWidth),
        isMaxDistance = (($indexButtonActive * buttonWidth) < maxDistance) ? false : true;

      return isMaxDistance;
    }

    function resetActiveButton() {
      $allPagesNumber.eq(selectIndex).removeClass("active");
    }

    function activeButton() {
      $allPagesNumber.eq(selectIndex).addClass("active");
    }


    function update() {
      $prev.css("width", "");
      $next.css("width", "");
      $prev.find(".btn-primary").css("width", "");
      $next.find(".btn-primary").css("width", "");


      var pagerWidth = $pager.width(),
        prevWidth = $prev.width(),
        nextWidth = $next.width(),
        btnAvailSpace = pagerWidth - prevWidth - nextWidth;

      var remainingSpace = btnAvailSpace,
        haveHiddenButtons = false;


      $pager.find(".pagination-number").each(function (index, el) {
        var $el = $(el)
          , $elWidth = $(el).width();

        if ((remainingSpace - $elWidth) > 0) {
          remainingSpace -= $elWidth;
        } else {
          haveHiddenButtons = true;
          return;
        }
      });

      $allPages.css({ "width": btnAvailSpace - remainingSpace });


      remainingSpace--; // Workaround because the width isn't always right calculate (border 1px right caused by)

      $prev.find(".btn-primary").css("width", Math.floor(prevWidth + (remainingSpace / 2)));
      $next.find(".btn-primary").css("width", Math.floor(nextWidth + (remainingSpace / 2)));


      var _t = this;
      updatePagerController();
    }

    function updatePagerController() {

      var $indexButtonActive = $pageNumbersCtn.find(".pagination-number.active").index(),
        numButtonsVisible = Math.floor($pager.find(".pagination-listnumber-ctn").width() / buttonWidth),
        maxDistance = $pageNumbersCtnWidth - (numButtonsVisible * buttonWidth);

      $pageNumbersCtn.find(".pagination-number.active a").attr("aria-current", "page");

      //selectIndex
      if (!isStandard) {
        if (selectIndex <= 0) {
          $prev.find(".btn-primary").addClass("neutral");
        } else if (selectIndex > 0) {
          $prev.find(".btn-primary").removeClass("neutral");
        }

        var isMaxDistance = getIsMaxDistance();

        if (isMaxDistance) {
          $next.find(".btn-primary").addClass("neutral");
        } else {
          $next.find(".btn-primary").removeClass("neutral");
        }
      }
    }

    function movePage() {
      var $indexButtonActive = $pageNumbersCtn.find(".pagination-number.active").index(),
        numButtonsVisible = Math.floor($pager.find(".pagination-listnumber-ctn").width() / buttonWidth),
        maxDistance = $pageNumbersCtnWidth - (numButtonsVisible * buttonWidth);

      var distance = (($indexButtonActive * buttonWidth) < maxDistance) ? -($indexButtonActive * buttonWidth) : -(maxDistance);
      TweenLite.to($pageNumbersCtn, .5, { css: { marginLeft: distance || 0 } });
    }

    // TODO :: Update the Disable/enable buttons for the prev & next button;

    init();


  }

  return Pagination;
});




define('uiTools/news', [
  'jquery',
  'UTILS'
], function ($, Utils) {

  var eventEmitter;
  /***********************************  Parking  ****************************************/

  var News = {
    init: function (context) {
      var _t = this;

      $(context).each(function (index, el) {
        new NewsInstance(el);
      });
    }
  };

  function NewsInstance(el) {
    var $el = $(el),
      link = $el.data("news-links");

    $el.click(function (evt) {
      if (Utils.getPlatform() == "mobile") window.location = link;
    });
  }

  return News;
});

(function (a) {
  function w(a) {
    for (var c in a) if (void 0 !== j[a[c]]) return !0;
    return !1
  }

  function l(a, c) {
    var e = a.originalEvent, j = a.changedTouches;
    return j || e && e.changedTouches ? e ? e.changedTouches[0]["page" + c] : j[0]["page" + c] : a["page" + c]
  }

  function u(j, g, e) {
    var m = j;
    if ("object" === typeof g) return j.each(function () {
      this.id || (this.id = "mobiscroll" + ++fa);
      c[this.id] && c[this.id].destroy();
      new a.mobiscroll.classes[g.component || "Scroller"](this, g)
    });
    "string" === typeof g && j.each(function () {
      var a;
      if ((a = c[this.id]) && a[g]) if (a =
        a[g].apply(this, Array.prototype.slice.call(e, 1)), void 0 !== a) return m = a, !1
    });
    return m
  }

  function o(a) {
    if ("touchstart" == a.type) O[a.target] = !0; else if (O[a.target]) return delete O[a.target], !1;
    return !0
  }

  var fa = +new Date, O = {}, c = {}, g = a.extend, j = document.createElement("modernizr").style, E = w(["perspectiveProperty", "WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective"]), v = function () {
    var a = ["Webkit", "Moz", "O", "ms"], c;
    for (c in a) if (w([a[c] + "Transform"])) return "-" + a[c].toLowerCase() + "-";
    return ""
  }(),
    k = v.replace(/^\-/, "").replace(/\-$/, "").replace("moz", "Moz");
  a.fn.mobiscroll = function (c) {
    g(this, a.mobiscroll.components);
    return u(this, c, arguments)
  };
  a.mobiscroll = a.mobiscroll || {
    util: { prefix: v, jsPrefix: k, has3d: E, getCoord: l, testTouch: o }, presets: {}, themes: {}, i18n: {}, instances: c, classes: {}, components: {}, defaults: {}, userdef: {}, setDefaults: function (a) {
      g(this.userdef, a)
    }, presetShort: function (a, c) {
      this.components[a] = function (e) {
        return u(this, g(e, { component: c, preset: a }), arguments)
      }
    }
  };
  a.scroller = a.scroller ||
    a.mobiscroll;
  a.fn.scroller = a.fn.scroller || a.fn.mobiscroll
})(jQuery);
(function (a) {
  a.mobiscroll.i18n.fr = a.extend(a.mobiscroll.i18n.fr, {
    setText: "Termin\u00e9", cancelText: "Annuler", clearText: "Effacer", selectedText: "S\u00e9lectionn\u00e9", dateFormat: "dd/mm/yy", dateOrder: "ddmmyy", dayNames: "&#68;imanche,Lundi,Mardi,Mercredi,Jeudi,Vendredi,Samedi".split(","), dayNamesShort: "&#68;im.,Lun.,Mar.,Mer.,Jeu.,Ven.,Sam.".split(","), dayText: "Jour", monthText: "Mois", monthNames: "Janvier,F\u00e9vrier,Mars,Avril,Mai,Juin,Juillet,Ao\u00fbt,Septembre,Octobre,Novembre,D\u00e9cembre".split(","),
    monthNamesShort: "Janv.,F\u00e9vr.,Mars,Avril,Mai,Juin,Juil.,Ao\u00fbt,Sept.,Oct.,Nov.,D\u00e9c.".split(","), hourText: "Heures", minuteText: "Minutes", secText: "Secondes", timeFormat: "HH:ii", timeWheels: "HHii", yearText: "Ann\u00e9e", nowText: "Maintenant", pmText: "apr\u00e8s-midi", amText: "avant-midi", dateText: "Date", timeText: "Heure", calendarText: "Calendrier", closeText: "Fermer", fromText: "D\u00e9marrer", toText: "Fin", wholeText: "Entier", fractionText: "Fraction", unitText: "Unit\u00e9", labels: "Ans,Mois,Jours,Heures,Minutes,Secondes,".split(","),
    labelsShort: "Yrs,Mths,Days,Hrs,Mins,Secs,".split(","), startText: "D\u00e9marrer", stopText: "Arr\u00eater", resetText: "R\u00e9initialiser", lapText: "Lap", hideText: "Cachez"
  })
})(jQuery);
(function (a) {
  function w() {
    O = !0;
    setTimeout(function () {
      O = !1
    }, 300)
  }

  function l(a, c, e) {
    return Math.max(c, Math.min(a, e))
  }

  function u(c) {
    var e = { values: [], keys: [] };
    a.each(c, function (a, b) {
      e.keys.push(a);
      e.values.push(b)
    });
    return e
  }

  a.mobiscroll.classes.Scroller = function (E, P) {
    function h(a, f, c) {
      a.stopPropagation();
      a.preventDefault();
      if (!ea && !b(f) && !f.hasClass("dwa")) {
        ea = !0;
        var n = f.find(".dw-ul");
        y(n);
        clearInterval($);
        $ = setInterval(function () {
          c(n)
        }, p.delay);
        c(n)
      }
    }

    function b(b) {
      return a.isArray(p.readonly) ? (b = a(".dwwl",
        K).index(b), p.readonly[b]) : p.readonly
    }

    function B(b) {
      var f = '<div class="dw-bf">', b = Ja[b], b = b.values ? b : u(b), c = 1, n = b.labels || [], e = b.values, h = b.keys || e;
      a.each(e, function (a, b) {
        0 == c % 20 && (f += '</div><div class="dw-bf">');
        f += '<div role="option" aria-selected="false" class="dw-li dw-v" data-val="' + h[a] + '"' + (n[a] ? ' aria-label="' + n[a] + '"' : "") + ' style="height:' + aa + "px;line-height:" + aa + 'px;"><div class="dw-i">' + b + "</div></div>";
        c++
      });
      return f += "</div>"
    }

    function y(b) {
      ha = a(".dw-li", b).index(a(".dw-v", b).eq(0));
      U =
        a(".dw-li", b).index(a(".dw-v", b).eq(-1));
      ia = a(".dw-ul", K).index(b)
    }

    function I(a) {
      var b = p.headerText;
      return b ? "function" === typeof b ? b.call(ua, a) : b.replace(/\{value\}/i, a) : ""
    }

    function f() {
      q.temp = q.values ? q.values.slice(0) : p.parseValue(Q.val() || "", q);
      n()
    }

    function X(b) {
      var f = window.getComputedStyle ? getComputedStyle(b[0]) : b[0].style, c;
      C ? (a.each(["t", "webkitT", "MozT", "OT", "msT"], function (a, b) {
        if (void 0 !== f[b + "ransform"]) return c = f[b + "ransform"], !1
      }), c = c.split(")")[0].split(", "), b = c[13] || c[5]) : b = f.top.replace("px",
        "");
      return Math.round(oa - b / aa)
    }

    function L(a, b) {
      clearTimeout(ya[b]);
      delete ya[b];
      a.closest(".dwwl").removeClass("dwa")
    }

    function t(a, b, f, c, n) {
      var e = (oa - f) * aa, h = a[0].style;
      e == Ha[b] && ya[b] || (c && e != Ha[b] && R("onAnimStart", [K, b, c]), Ha[b] = e, h[k + "Transition"] = "all " + (c ? c.toFixed(3) : 0) + "s ease-out", C ? h[k + "Transform"] = "translate3d(0," + e + "px,0)" : h.top = e + "px", ya[b] && L(a, b), c && n && (a.closest(".dwwl").addClass("dwa"), ya[b] = setTimeout(function () {
        L(a, b)
      }, 1E3 * c)), pa[b] = f)
    }

    function M(b, f, c) {
      var b = a('.dw-li[data-val="' +
        b + '"]', f), f = a(".dw-li", f), n = f.index(b), e = f.length;
      if (!b.hasClass("dw-v")) {
        for (var h = b, A = 0, j = 0; 0 <= n - A && !h.hasClass("dw-v");)A++, h = f.eq(n - A);
        for (; n + j < e && !b.hasClass("dw-v");)j++, b = f.eq(n + j);
        (j < A && j && 2 !== c || !A || 0 > n - A || 1 == c) && b.hasClass("dw-v") ? n += j : (b = h, n -= A)
      }
      return { cell: b, v: n, val: b.hasClass("dw-v") ? b.attr("data-val") : null }
    }

    function ca(b, f, c, e, h) {
      !1 !== R("validate", [K, f, b, e]) && (a(".dw-ul", K).each(function (c) {
        var n = a(this), A = c == f || void 0 === f, j = M(q.temp[c], n, e), g = j.cell;
        if (!g.hasClass("dw-sel") || A) q.temp[c] =
          j.val, p.multiple || (a(".dw-sel", n).removeAttr("aria-selected"), g.attr("aria-selected", "true")), a(".dw-sel", n).removeClass("dw-sel"), g.addClass("dw-sel"), t(n, c, j.v, A ? b : 0.1, A ? h : !1)
      }), Y = p.formatResult(q.temp), q.live && n(c, c, 0, !0), a(".dwv", K).html(I(Y)), c && R("onChange", [Y]))
    }

    function R(b, f) {
      var c;
      f.push(q);
      a.each([D, va, za, P], function (a, n) {
        n && n[b] && (c = n[b].apply(ua, f))
      });
      return c
    }

    function V(b, f, c, n, e) {
      var f = l(f, ha, U), h = a(".dw-li", b).eq(f), A = void 0 === e ? f : e, j = void 0 !== e, g = ia, y = n ? f == A ? 0.1 : Math.abs((f - A) * p.timeUnit) :
        0;
      q.temp[g] = h.attr("data-val");
      t(b, g, f, y, j);
      setTimeout(function () {
        ca(y, g, !0, c, j)
      }, 10)
    }

    function W(a) {
      var b = pa[ia] + 1;
      V(a, b > U ? ha : b, 1, !0)
    }

    function ba(a) {
      var b = pa[ia] - 1;
      V(a, b < ha ? U : b, 2, !0)
    }

    function n(a, b, f, c, n) {
      Ka && !c && ca(f);
      Y = p.formatResult(q.temp);
      n || (q.values = q.temp.slice(0), q.val = Y);
      a && (Da && (Q.val(Y), b && (Z = !0, Q.change())), R("onValueFill", [Y, b]))
    }

    function A(a, b) {
      var f;
      qa.on(a, function () {
        clearTimeout(f);
        f = setTimeout(function () {
          (Ea && b || !b) && q.position(!b)
        }, 200)
      })
    }

    var oa, aa, Y, K, wa, ra, J, H, Aa, Ba, Ea, Ca, va,
      Ia, ea, Fa, ma, La, na, sa, T, ja, ha, U, ka, la, ia, $, xa, Z, Ga, qa, z, ga, da, q = this, ua = E, Q = a(ua), p = x({}, r, D), za = {}, ya = {}, pa = {}, Ha = {}, Ja = [], ta = [], Da = Q.is("input"), Ka = !1, Qa = function (f) {
        e(f) && !fa && !ea && !da && !b(this) && (f.preventDefault(), fa = !0, ma = "clickpick" != p.mode, la = a(".dw-ul", this), y(la), ja = (La = void 0 !== ya[ia]) ? X(la) : pa[ia], na = s(f, "Y"), sa = new Date, T = na, t(la, ia, ja, 0.001), ma && la.closest(".dwwl").addClass("dwa"), a(document).on(S, Na).on(G, Oa))
      }, Na = function (a) {
        ma && (a.preventDefault(), a.stopPropagation(), T = s(a, "Y"), t(la,
          ia, l(ja + (na - T) / aa, ha - 1, U + 1)));
        na !== T && (La = !0)
      }, Oa = function () {
        var b = new Date - sa, f = l(ja + (na - T) / aa, ha - 1, U + 1), c, n = la.offset().top;
        300 > b ? (b = (T - na) / b, c = b * b / p.speedUnit, 0 > T - na && (c = -c)) : c = T - na;
        b = Math.round(ja - c / aa);
        if (!c && !La) {
          var n = Math.floor((T - n) / aa), e = a(a(".dw-li", la)[n]);
          c = ma;
          !1 !== R("onValueTap", [e]) ? b = n : c = !0;
          c && (e.addClass("dw-hl"), setTimeout(function () {
            e.removeClass("dw-hl")
          }, 200))
        }
        ma && V(la, b, 0, !0, Math.round(f));
        fa = !1;
        la = null;
        a(document).off(S, Na).off(G, Oa)
      }, Ra = function (b) {
        da && da.removeClass("dwb-a");
        da = a(this);
        a(document).on(G, Pa);
        !da.hasClass("dwb-d") && !da.hasClass("dwb-nhl") && da.addClass("dwb-a");
        da.hasClass("dwwb") && e(b) && h(b, da.closest(".dwwl"), da.hasClass("dwwbp") ? W : ba)
      }, Pa = function () {
        ea && (clearInterval($), ea = !1);
        da && (da.removeClass("dwb-a"), da = null);
        a(document).off(G, Pa)
      }, Sa = function (b) {
        38 == b.keyCode ? h(b, a(this), ba) : 40 == b.keyCode && h(b, a(this), W)
      }, Ta = function () {
        ea && (clearInterval($), ea = !1)
      }, Ua = function (f) {
        if (!b(this)) {
          f.preventDefault();
          var f = f.originalEvent || f, f = f.wheelDelta ? f.wheelDelta /
            120 : f.detail ? -f.detail / 3 : 0, c = a(".dw-ul", this);
          y(c);
          V(c, Math.round(pa[ia] - f), 0 > f ? 1 : 2)
        }
      };
    q.position = function (b) {
      var f = wa.width(), c = qa[0].innerHeight || qa.innerHeight();
      if (!(J === f && H === c && b) && !Ga && !1 !== R("onPosition", [K, f, c]) && ka) {
        var n, e, h, A, j, g, y, t, L, m = 0, B = 0, b = qa.scrollLeft(), I = qa.scrollTop();
        A = a(".dwwr", K);
        var k = a(".dw", K), Da = {};
        j = void 0 === p.anchor ? Q : p.anchor;
        /modal|bubble/.test(p.display) && (a(".dwc", K).each(function () {
          n = a(this).outerWidth(!0);
          m += n;
          B = n > B ? n : B
        }), n = m > f ? B : m, A.width(n).css("white-space",
          m > f ? "" : "nowrap"));
        Aa = k.outerWidth();
        Ba = k.outerHeight(!0);
        Ea = Ba <= c && Aa <= f;
        q.scrollLock = Ea;
        "modal" == p.display ? (e = (f - Aa) / 2, h = I + (c - Ba) / 2) : "bubble" == p.display ? (L = !0, t = a(".dw-arrw-i", K), h = j.offset(), g = Math.abs(a(p.context).offset().top - h.top), y = Math.abs(a(p.context).offset().left - h.left), A = j.outerWidth(), j = j.outerHeight(), e = l(y - (k.outerWidth(!0) - A) / 2 - b, 3, f - Aa - 3), h = g - Ba, h < I || g > I + c ? (k.removeClass("dw-bubble-top").addClass("dw-bubble-bottom"), h = g + j) : k.removeClass("dw-bubble-bottom").addClass("dw-bubble-top"),
          t = t.outerWidth(), A = l(y + A / 2 - (e + (Aa - t) / 2) - b, 0, t), a(".dw-arr", K).css({ left: A })) : "top" == p.display ? h = I : "bottom" == p.display && (h = I + c - Ba);
        Da.top = 0 > h ? 0 : h;
        Da.left = e;
        k.css(Da);
        wa.height(0);
        e = Math.max(h + Ba, "body" == p.context ? a(document).height() : z.scrollHeight);
        wa.css({ height: e, left: b });
        if (L && (h + Ba > I + c || g > I + c)) Ga = !0, setTimeout(function () {
          Ga = false
        }, 300), qa.scrollTop(Math.min(h + Ba - c, e - c))
      }
      J = f;
      H = c
    };
    q.enable = function () {
      p.disabled = !1;
      Da && Q.prop("disabled", !1)
    };
    q.disable = function () {
      p.disabled = !0;
      Da && Q.prop("disabled",
        !0)
    };
    q.setValue = function (b, f, c, e, h) {
      q.temp = a.isArray(b) ? b.slice(0) : p.parseValue.call(ua, b + "", q);
      n(f, void 0 === h ? f : h, c, !1, e)
    };
    q.getValue = function () {
      return q.values
    };
    q.getValues = function () {
      var a = [], b;
      for (b in q._selectedValues) a.push(q._selectedValues[b]);
      return a
    };
    q.changeWheel = function (b, f, c) {
      if (K) {
        var n = 0, e = b.length;
        a.each(p.wheels, function (h, A) {
          a.each(A, function (h, A) {
            if (-1 < a.inArray(n, b) && (Ja[n] = A, a(".dw-ul", K).eq(n).html(B(n)), e--, !e)) return q.position(), ca(f, void 0, c), !1;
            n++
          });
          if (!e) return !1
        })
      }
    };
    q.isVisible = function () {
      return Ka
    };
    q.tap = function (a, b) {
      var f, c;
      if (p.tap) a.on("touchstart.dw mousedown.dw", function (a) {
        a.preventDefault();
        f = s(a, "X");
        c = s(a, "Y")
      }).on("touchend.dw", function (a) {
        20 > Math.abs(s(a, "X") - f) && 20 > Math.abs(s(a, "Y") - c) && b.call(this, a);
        w()
      });
      a.on("click.dw", function (a) {
        O || b.call(this, a);
        a.preventDefault()
      })
    };
    q.show = function (b) {
      var c, n = 0, e = "";
      if (!p.disabled && !Ka) {
        "top" == p.display && (Ca = "slidedown");
        "bottom" == p.display && (Ca = "slideup");
        f();
        R("onBeforeShow", []);
        Ca && !b && (e = "dw-" + Ca + " dw-in");
        var h = '<div role="dialog" class="' + p.theme + " dw-" + p.display + (v ? " dw" + v.replace(/\-$/, "") : "") + (Fa ? "" : " dw-nobtn") + '"><div class="dw-persp">' + (!ka ? '<div class="dw dwbg dwi">' : '<div class="dwo"></div><div class="dw dwbg ' + e + '"><div class="dw-arrw"><div class="dw-arrw-i"><div class="dw-arr"></div></div></div>') + '<div class="dwwr"><div aria-live="assertive" class="dwv' + (p.headerText ? "" : " dw-hidden") + '"></div><div class="dwcc">', j = a.isArray(p.minWidth), y = a.isArray(p.maxWidth), t = a.isArray(p.fixedWidth);
        a.each(p.wheels, function (b, f) {
          h += '<div class="dwc' + ("scroller" != p.mode ? " dwpm" : " dwsc") + (p.showLabel ? "" : " dwhl") + '"><div class="dwwc dwrc"><table cellpadding="0" cellspacing="0"><tr>';
          a.each(f, function (a, b) {
            Ja[n] = b;
            c = void 0 !== b.label ? b.label : a;
            h += '<td><div class="dwwl dwrc dwwl' + n + '">' + ("scroller" != p.mode ? '<a href="#" tabindex="-1" class="dwb-e dwwb dwwbp" style="height:' + aa + "px;line-height:" + aa + 'px;"><span>+</span></a><a href="#" tabindex="-1" class="dwb-e dwwb dwwbm" style="height:' + aa + "px;line-height:" +
              aa + 'px;"><span>&ndash;</span></a>' : "") + '<div class="dwl">' + c + '</div><div tabindex="0" aria-live="off" aria-label="' + c + '" role="listbox" class="dwww"><div class="dww" style="height:' + p.rows * aa + "px;" + (p.fixedWidth ? "width:" + (t ? p.fixedWidth[n] : p.fixedWidth) + "px;" : (p.minWidth ? "min-width:" + (j ? p.minWidth[n] : p.minWidth) + "px;" : "min-width:" + p.width + "px;") + (p.maxWidth ? "max-width:" + (y ? p.maxWidth[n] : p.maxWidth) + "px;" : "")) + '"><div class="dw-ul">';
            h += B(n);
            h += '</div><div class="dwwol"></div></div><div class="dwwo"></div></div><div class="dwwol"></div></div></td>';
            n++
          });
          h += "</tr></table></div></div>"
        });
        h += "</div>";
        ka && Fa && (h += '<div class="dwbc">', a.each(ga, function (a, b) {
          b = "string" === typeof b ? q.buttons[b] : b;
          h += "<span" + (p.btnWidth ? ' style="width:' + 100 / ga.length + '%"' : "") + ' class="dwbw ' + b.css + '"><a href="#" class="dwb dwb' + a + ' dwb-e" role="button">' + b.text + "</a></span>"
        }), h += "</div>");
        h += "</div></div></div></div>";
        K = a(h);
        wa = a(".dw-persp", K);
        ra = a(".dwo", K);
        Ka = !0;
        ca();
        R("onMarkupReady", [K]);
        ka ? (g.activeInstance = q, K.appendTo(p.context), Ca && !b && (K.addClass("dw-trans"),
          setTimeout(function () {
            K.removeClass("dw-trans").find(".dw").removeClass(e)
          }, 350))) : Q.is("div") ? Q.html(K) : K.insertAfter(Q);
        R("onMarkupInserted", [K]);
        if (ka) {
          a(window).on("keydown.dw", function (a) {
            a.keyCode == 13 ? q.select() : a.keyCode == 27 && q.cancel()
          });
          if (p.scrollLock) K.on("touchmove", function (a) {
            Ea && a.preventDefault()
          });
          a("input,select,button", z).each(function () {
            if (!this.disabled) {
              a(this).attr("autocomplete") && a(this).data("autocomplete", a(this).attr("autocomplete"));
              a(this).addClass("dwtd").prop("disabled",
                true).attr("autocomplete", "off")
            }
          });
          A("scroll.dw", !0)
        }
        q.position();
        A("orientationchange.dw resize.dw", !1);
        K.on("DOMMouseScroll mousewheel", ".dwwl", Ua).on("keydown", ".dwwl", Sa).on("keyup", ".dwwl", Ta).on("selectstart mousedown", m).on("click", ".dwb-e", m).on("keydown", ".dwb-e", function (b) {
          if (b.keyCode == 32) {
            b.preventDefault();
            b.stopPropagation();
            a(this).click()
          }
        });
        setTimeout(function () {
          a.each(ga, function (b, f) {
            q.tap(a(".dwb" + b, K), function (a) {
              f = typeof f === "string" ? q.buttons[f] : f;
              f.handler.call(this, a, q)
            })
          });
          p.closeOnOverlay && q.tap(ra, function () {
            q.cancel()
          });
          K.on(N, ".dwwl", Qa).on(N, ".dwb-e", Ra)
        }, 300);
        R("onShow", [K, Y])
      }
    };
    q.hide = function (b, f, n) {
      if (!Ka || !n && !1 === R("onClose", [Y, f])) return !1;
      a(".dwtd", z).each(function () {
        a(this).prop("disabled", !1).removeClass("dwtd");
        a(this).data("autocomplete") ? a(this).attr("autocomplete", a(this).data("autocomplete")) : a(this).removeAttr("autocomplete")
      });
      K && ((f = ka && Ca && !b) && K.addClass("dw-trans").find(".dw").addClass("dw-" + Ca + " dw-out"), b ? K.remove() : setTimeout(function () {
        K.remove();
        o && (c = !0, o.focus())
      }, f ? 350 : 1), qa.off(".dw"));
      delete g.activeInstance;
      Ha = {};
      Ka = !1
    };
    q.select = function () {
      !1 !== q.hide(!1, "set") && (n(!0, !0, 0, !0), R("onSelect", [q.val]))
    };
    q.attachShow = function (a, b) {
      ta.push(a);
      if ("inline" !== p.display) a.on((p.showOnFocus ? "focus.dw" : "") + (p.showOnTap ? " click.dw" : ""), function (f) {
        if (("focus" !== f.type || "focus" === f.type && !c) && !O) b && b(), o = a, q.show();
        setTimeout(function () {
          c = !1
        }, 300)
      })
    };
    q.cancel = function () {
      !1 !== q.hide(!1, "cancel") && R("onCancel", [q.val])
    };
    q.init = function (b) {
      va = g.themes[b.theme ||
        p.theme];
      Ia = g.i18n[b.lang || p.lang];
      x(P, b);
      R("onThemeLoad", [Ia, P]);
      x(p, Ia, va, D, P);
      p.buttons = p.buttons || ["set", "cancel"];
      p.headerText = void 0 === p.headerText ? "inline" !== p.display ? "{value}" : !1 : p.headerText;
      q.settings = p;
      Q.off(".dw");
      if (b = g.presets[p.preset]) za = b.call(ua, q), x(p, za, P);
      oa = Math.floor(p.rows / 2);
      aa = p.height;
      Ca = p.animate;
      ka = "inline" !== p.display;
      ga = p.buttons;
      qa = a("body" == p.context ? window : p.context);
      z = a(p.context)[0];
      p.setText || ga.splice(a.inArray("set", ga), 1);
      p.cancelText || ga.splice(a.inArray("cancel",
        ga), 1);
      p.button3 && ga.splice(a.inArray("set", ga) + 1, 0, { text: p.button3Text, handler: p.button3 });
      q.context = qa;
      q.live = !ka || -1 == a.inArray("set", ga);
      q.buttons.set = { text: p.setText, css: "dwb-s", handler: q.select };
      q.buttons.cancel = { text: q.live ? p.closeText : p.cancelText, css: "dwb-c", handler: q.cancel };
      q.buttons.clear = {
        text: p.clearText, css: "dwb-cl", handler: function () {
          q.trigger("onClear", [K]);
          Q.val("");
          q.live || q.hide(!1, "clear")
        }
      };
      Fa = 0 < ga.length;
      Ka && q.hide(!0, !1, !0);
      ka ? (f(), Da && (void 0 === xa && (xa = ua.readOnly), ua.readOnly = !0), q.attachShow(Q)) : q.show();
      if (Da) Q.on("change.dw", function () {
        Z || q.setValue(Q.val(), false, 0.2);
        Z = false
      })
    };
    q.option = function (a, b) {
      var f = {};
      "object" === typeof a ? f = a : f[a] = b;
      q.init(f)
    };
    q.destroy = function () {
      q.hide(!0, !1, !0);
      a.each(ta, function (a, b) {
        b.off(".dw")
      });
      a(window).off(".dwa");
      Da && (ua.readOnly = xa);
      delete j[ua.id];
      R("onDestroy", [])
    };
    q.getInst = function () {
      return q
    };
    q.getValidCell = M;
    q.trigger = R;
    j[ua.id] = q;
    q.values = null;
    q.val = null;
    q.temp = null;
    q.buttons = {};
    q._selectedValues = {};
    q.init(P)
  };
  var o, fa, O,
    c, g = a.mobiscroll, j = g.instances, E = g.util, v = E.prefix, k = E.jsPrefix, C = E.has3d, s = E.getCoord, e = E.testTouch, m = function (a) {
      a.preventDefault()
    }, x = a.extend, N = "touchstart mousedown", S = "touchmove mousemove", G = "touchend mouseup", D = g.userdef, r = x(g.defaults, {
      width: 70, height: 40, rows: 3, delay: 300, disabled: !1, readonly: !1, closeOnOverlay: !0, showOnFocus: !0, showOnTap: !0, showLabel: !0, wheels: [], theme: "", display: "modal", mode: "scroller", preset: "", lang: "en-US", context: "body", scrollLock: !0, tap: !0, btnWidth: !0, speedUnit: 0.0012,
      timeUnit: 0.1, formatResult: function (a) {
        return a.join(" ")
      }, parseValue: function (c, e) {
        var h = c.split(" "), b = [], j = 0, g;
        a.each(e.settings.wheels, function (c, f) {
          a.each(f, function (f, c) {
            c = c.values ? c : u(c);
            g = c.keys || c.values;
            -1 !== a.inArray(h[j], g) ? b.push(h[j]) : b.push(g[0]);
            j++
          })
        });
        return b
      }
    });
  g.i18n.en = g.i18n["en-US"] = { setText: "Set", selectedText: "Selected", closeText: "Close", cancelText: "Cancel", clearText: "Clear" };
  a(window).on("focus", function () {
    o && (c = !0)
  });
  a(document).on("mouseover mouseup mousedown click", function (a) {
    if (O) return a.stopPropagation(),
      a.preventDefault(), !1
  })
})(jQuery);
(function (a) {
  var w;
  a.mobiscroll.themes.wp = {
    minWidth: 70, height: 76, accent: "none", dateOrder: "mmMMddDDyy", headerText: !1, showLabel: !1, btnWidth: !1, onAnimStart: function (l, u, o) {
      a(".dwwl" + u, l).addClass("wpam");
      clearTimeout(w[u]);
      w[u] = setTimeout(function () {
        a(".dwwl" + u, l).removeClass("wpam")
      }, 1E3 * o + 100)
    }, onMarkupInserted: function (l, u) {
      var o, fa;
      w = {};
      a(".dw", l).addClass("wp-" + u.settings.accent);
      a(".dwwl", l).on("touchstart mousedown DOMMouseScroll mousewheel", ".dw-sel", function () {
        o = !0;
        fa = a(this).closest(".dwwl").hasClass("wpa");
        a(".dwwl", l).removeClass("wpa");
        a(this).closest(".dwwl").addClass("wpa")
      }).on("touchmove mousemove", function () {
        o = !1
      }).on("touchend mouseup", function () {
        o && fa && a(this).closest(".dwwl").removeClass("wpa")
      })
    }, onThemeLoad: function (a, u) {
      if (a && a.dateOrder && !u.dateOrder) {
        var o = a.dateOrder, o = o.match(/mm/i) ? o.replace(/mmMM|mm|MM/, "mmMM") : o.replace(/mM|m|M/, "mM"), o = o.match(/dd/i) ? o.replace(/ddDD|dd|DD/, "ddDD") : o.replace(/dD|d|D/, "dD");
        u.dateOrder = o
      }
    }
  };
  a.mobiscroll.themes["wp light"] = a.mobiscroll.themes.wp
})(jQuery);
(function (a) {
  var w = a.mobiscroll, l = w.util, u = l.has3d, o = l.jsPrefix, fa = l.getCoord, O = l.testTouch, c = "webkitTransitionEnd transitionend", g = { controls: ["calendar"], firstDay: 0, maxMonthWidth: 170, months: 1, preMonths: 1, highlight: !0, swipe: !0, liveSwipe: !0, divergentDayChange: !0, navigation: "yearMonth" };
  w.i18n.en = a.extend(w.i18n.en, { dateText: "Date", timeText: "Time", calendarText: "Calendar", prevMonthText: "Previous Month", nextMonthText: "Next Month", prevYearText: "Previous Year", nextYearText: "Next Year" });
  w.presets.calbase =
    function (j) {
      function l(b, f, c) {
        var n, e, h, A, g = {}, t = Q + ha;
        b && (b = j.convert(b), a.each(b, function (a, b) {
          n = b.d || b.start || b;
          e = n + "";
          if (b.start && b.end) for (A = new Date(b.start); A <= b.end;)h = (new Date(A.getFullYear(), A.getMonth(), A.getDate())).getTime(), g[h] = g[h] || [], g[h].push(b), A.setDate(A.getDate() + 1); else if (n.getTime) h = (new Date(n.getFullYear(), n.getMonth(), n.getDate())).getTime(), g[h] = g[h] || [], g[h].push(b); else if (e.match(/w/i)) {
            var j = z.firstDay, y = +e.replace("w", ""), p = 0, m = (new Date(f, c - Q - U, 1)).getDay();
            1 < j -
              m + 1 && (p = 7);
            for (B = 0; B < 5 * ja; B++)h = (new Date(f, c - Q - U, 7 * B + j - p - m + 1 + y)).getTime(), g[h] = g[h] || [], g[h].push(b)
          } else if (e = e.split("/"), e[1]) 11 <= c + t && (h = (new Date(f + 1, e[0] - 1, e[1])).getTime(), g[h] = g[h] || [], g[h].push(b)), 1 >= c - t && (h = (new Date(f - 1, e[0] - 1, e[1])).getTime(), g[h] = g[h] || [], g[h].push(b)), h = (new Date(f, e[0] - 1, e[1])).getTime(), g[h] = g[h] || [], g[h].push(b); else for (B = 0; B < ja; B++)h = (new Date(f, c - Q - U + B, e[0])).getTime(), g[h] = g[h] || [], g[h].push(b)
        }));
        return g
      }

      function v(a, b) {
        ea = l(z.invalid, a, b);
        j.onGenMonth(a,
          b)
      }

      function k(b, f) {
        var c, n, h, e, A, g, t, y, p, m, I, k = 1, L = 0;
        A = new Date(b, f, 1);
        var B = A.getFullYear(), q = A.getMonth(), J = j.getDate(!0), H = (new Date(B, q + 1, 0)).getDate(), r = (new Date(B, q, 1)).getDay(), u = (new Date(B, q, 0)).getDate() - r + 1, s = '<div class="dw-cal-table">', l = '<div class="dw-week-nr-c">';
        1 < z.firstDay - r + 1 && (L = 7);
        for (I = 0; 42 > I; I++)m = I + z.firstDay - L, c = new Date(B, q, m - r + 1), n = c.getFullYear(), h = c.getMonth(), e = c.getDate(), A = n + "-" + h + "-" + e, g = a.extend({
          valid: c < new Date(K.getFullYear(), K.getMonth(), K.getDate()) || c > wa ?
            !1 : void 0 === ea[c.getTime()], selected: J.getFullYear() === n && J.getMonth() === h && J.getDate() === e
        }, j.getDayProps(c, J)), t = g.valid, y = g.selected, n = g.cssClass, p = m < r || m >= H + r, Ga[A] = g, 0 == I % 7 && (s += (I ? "</div>" : "") + '<div class="dw-cal-row' + (z.highlight && 0 <= J - c && 6048E5 > J - c ? " dw-cal-week-hl" : "") + '">', ga && ("month" == ga && h !== q && I ? k = 1 == e ? 1 : 2 : "year" == ga && (k = c, k = new Date(k), k.setHours(0, 0, 0), k.setDate(k.getDate() + 4 - (k.getDay() || 7)), c = new Date(k.getFullYear(), 0, 1), k = Math.ceil(((k - c) / 864E5 + 1) / 7)), l += '<div class="dw-week-nr"><div class="dw-week-nr-i">' +
          k + "</div></div>", k++)), s += '<div role="button" tabindex="-1" class="dw-cal-day ' + (z.dayClass || "") + (y ? " dw-sel" : "") + (n ? " " + n : "") + (p ? " dw-cal-day-diff" : "") + (t ? " dw-cal-day-v dwb-e dwb-nhl" : " dw-cal-day-inv") + '" data-day="' + m % 7 + '" data-date="' + (m - r + 1) + '" data-full="' + A + '"' + (y ? ' aria-selected="true"' : "") + (t ? "" : ' aria-disabled="true"') + '><div class="dw-i ' + (y ? pa : "") + " " + (t ? z.validDayClass || "" : "") + '"><div class="dw-cal-day-fg">' + (m < r ? u + m : m >= H + r ? m - H - r + 1 : m - r + 1) + "</div>" + (g.markup || "") + '<div class="dw-cal-day-frame"></div></div></div>';
        return s + ("</div>" + l + "</div></div>")
      }

      function C(c, h) {
        for (b = 0; b < T; ++b)a(A[b]).text(n[(new Date(c, h - U + b)).getMonth()]), 1 < oa.length && a(oa[b]).text((new Date(c, h - U + b)).getFullYear());
        1 == oa.length && oa.text(c);
        new Date(c, h - U - 1, 1) < aa ? a(".dw-cal-prev-m", f).addClass(ta).attr("aria-disabled", "true") : a(".dw-cal-prev-m", f).removeClass(ta).removeAttr("aria-disabled");
        new Date(c, h + T - U, 1) > Y ? a(".dw-cal-next-m", f).addClass(ta).attr("aria-disabled", "true") : a(".dw-cal-next-m", f).removeClass(ta).removeAttr("aria-disabled");
        (new Date(c, h, 1)).getFullYear() <= aa.getFullYear() ? a(".dw-cal-prev-y", f).addClass(ta).attr("aria-disabled", "true") : a(".dw-cal-prev-y", f).removeClass(ta).removeAttr("aria-disabled");
        (new Date(c, h, 1)).getFullYear() >= Y.getFullYear() ? a(".dw-cal-next-y", f).addClass(ta).attr("aria-disabled", "true") : a(".dw-cal-next-y", f).removeClass(ta).removeAttr("aria-disabled")
      }

      function s(b) {
        if (Z.calendar && "calendar" === ma) {
          var c, n, h = new Date(J, H), e = Math.abs(12 * (b.getFullYear() - J) + b.getMonth() - H);
          j.needsSlide && e && (J = b.getFullYear(),
            H = b.getMonth(), b > h ? (n = e > Q - U + T - 1, H -= n ? 0 : e - Q, c = "next") : b < h && (n = e > Q + U, H += n ? 0 : e - Q, c = "prev"), m.call(this, J, H, c, Math.min(e, Q), n, !0));
          j.trigger("onDayHighlight", [b]);
          z.highlight && (a(".dw-cal .dw-sel .dw-i", f).removeClass(pa), a(".dw-cal .dw-sel", f).removeClass("dw-sel").removeAttr("aria-selected"), a(".dw-cal-week-hl", f).removeClass("dw-cal-week-hl"), a('.dw-cal .dw-cal-day[data-full="' + b.getFullYear() + "-" + b.getMonth() + "-" + b.getDate() + '"]', f).addClass("dw-sel").attr("aria-selected", "true").parent().addClass("dw-cal-week-hl"),
            a(".dw-cal .dw-sel .dw-i", f).addClass(pa));
          j.needsSlide = !0
        }
      }

      function e(a, f, c, n) {
        n || v(a, f);
        for (b = 0; b < ja; b++)$[b].html(k(a, f - U - Q + b));
        j.needsRefresh = !1
      }

      function m(c, n, h, e, A, g, t) {
        c && xa.push({ y: c, m: n, dir: h, slideNr: e, load: A, active: g, callback: t });
        if (!na) {
          var y = xa.shift(), c = y.y, n = y.m, h = "next" == y.dir, e = y.slideNr, A = y.load, g = y.active, t = y.callback || qa, y = new Date(c, n, 1), c = y.getFullYear(), n = y.getMonth();
          na = !0;
          j.changing = !0;
          j.trigger("onMonthChange", [c, n]);
          v(c, n);
          if (A) for (b = 0; b < T; b++)$[h ? ja - T + b : b].html(k(c, n - U +
            b));
          g && ia.addClass("dw-cal-slide-a");
          C(c, n);
          setTimeout(function () {
            N(h ? R - M * e : R + M * e, 200, function () {
              var g;
              ia.removeClass("dw-cal-slide-a");
              if (h) {
                g = $.splice(0, e);
                for (b = 0; b < e; b++)$.push(g[b]), w($[$.length - 1], +$[$.length - 2].data("curr") + 100)
              } else {
                g = $.splice(ja - e, e);
                for (b = e - 1; 0 <= b; b--)$.unshift(g[b]), w($[0], +$[1].data("curr") - 100)
              }
              for (b = 0; b < e; b++)$[h ? ja - e + b : b].html(k(c, n - U - Q + b + (h ? ja - e : 0))), A && $[h ? b : ja - e + b].html(k(c, n - U - Q + b + (h ? 0 : ja - e)));
              for (b = 0; b < T; b++)$[Q + b].addClass("dw-cal-slide-a");
              na = !1;
              xa.length ? setTimeout(function () {
                m()
              },
                10) : (J = c, H = n, j.changing = !1, ga && ba.html(a(".dw-week-nr-c", $[Q]).html()), a(".dw-cal-day", f).attr("tabindex", -1), a(".dw-cal-slide-a .dw-cal-day", f).attr("tabindex", 0), j.needsRefresh && G(), j.trigger("onMonthLoaded", [c, n]), t())
            })
          }, 10)
        }
      }

      function x() {
        var b = a(this), c = j.live, f = j.getDate(!0), n = b.attr("data-full"), h = n.split("-"), h = new Date(h[0], h[1], h[2]), e = b.hasClass("dw-sel");
        if ((ka || !b.hasClass("dw-cal-day-diff")) && !1 !== j.trigger("onDayChange", [a.extend(Ga[n], { date: h, cell: this, selected: e })])) j.needsSlide = !1, j.setDate(new Date(h.getFullYear(), h.getMonth(), h.getDate(), f.getHours(), f.getMinutes(), f.getSeconds()), c, 0.2, !c, !0), z.divergentDayChange && (sa = !0, h < new Date(J, H - U, 1) ? r() : h > new Date(J, H - U + T, 0) && D(), sa = !1)
      }

      function N(a, b, f) {
        a = Math.max(R - M * Q, Math.min(a, R + M * Q));
        t[0].style[o + "Transition"] = "all " + (b || 0) + "ms";
        if (u) {
          if (f) if (ca == a) f(); else t.on(c, function () {
            t.off(c);
            f()
          });
          t[0].style[o + "Transform"] = "translate3d(" + a + "px,0,0)"
        } else f && setTimeout(f, b), t[0].style.left = a + "px";
        b && (R = a);
        ca = a
      }

      function w(a, b) {
        a.data("curr",
          b);
        u ? a[0].style[o + "Transform"] = "translate3d(" + b + "%,0,0)" : a[0].style.left = b + "%"
      }

      function G() {
        j.isVisible() && Z.calendar && e(J, H)
      }

      function D() {
        sa && new Date(J, H + T - U, 1) <= Y && m(J, ++H, "next", 1, !1, !0, D)
      }

      function r() {
        sa && new Date(J, H - U - 1, 1) >= aa && m(J, --H, "prev", 1, !1, !0, r)
      }

      function F(a) {
        sa && new Date(J, H, 1) <= new Date(Y.getFullYear() - 1, Y.getMonth() - ha, 1) ? m(++J, H, "next", Q, !0, !0, function () {
          F(a)
        }) : sa && !a.hasClass("dwb-d") && m(Y.getFullYear(), Y.getMonth() - ha, "next", Q, !0, !0)
      }

      function P(a) {
        sa && new Date(J, H, 1) >= new Date(aa.getFullYear() +
          1, aa.getMonth() + U, 1) ? m(--J, H, "prev", Q, !0, !0, function () {
            P(a)
          }) : sa && !a.hasClass("dwb-d") && m(aa.getFullYear(), aa.getMonth() + U, "prev", Q, !0, !0)
      }

      var h, b, B, y, I, f, X, L, t, M, ca, R, V, W, ba, n, A, oa, aa, Y, K, wa, ra, J, H, Aa, Ba, Ea, Ca, va, Ia, ea, Fa, ma, La, na, sa, T, ja, ha, U, ka, la = this, ia = [], $ = [], xa = [], Z = {}, Ga = {}, qa = function () {
      };
      y = a.extend({}, j.settings);
      var z = a.extend(j.settings, g, y), ga = z.weekCounter, da = "liquid" == (z.layout || (/top|bottom/.test(z.display) ? "liquid" : "")) && "bubble" !== z.display, q = "modal" == z.display, ua = da ? null : z.calendarWidth,
        Q = z.preMonths, p = "yearMonth" == z.navigation;
      y = z.controls.join(",");
      var za = (!0 === z.tabs || !1 !== z.tabs && da) && 1 < z.controls.length, ya = !za && void 0 === z.tabs && !da && 1 < z.controls.length, pa = z.activeClass || "", Ha = "dw-sel " + (z.activeTabClass || ""), Ja = z.activeTabInnerClass || "", ta = "dwb-d " + (z.disabledClass || "");
      y.match(/calendar/) && (Z.calendar = 1);
      y.match(/date/) && (Z.date = 1);
      y.match(/time/) && (Z.time = 1);
      Z.calendar && Z.date && (za = !0, ya = !1);
      z.preset = (Z.date || Z.calendar ? "date" : "") + (Z.time ? "time" : "");
      if ("inline" == z.display) a(this).closest('[data-role="page"]').on("pageshow",
        function () {
          j.position()
        });
      j.changing = !1;
      j.needsRefresh = !1;
      j.needsSlide = !0;
      j.getDayProps = qa;
      j.onGenMonth = qa;
      j.prepareObj = l;
      j.refresh = function () {
        j.changing ? j.needsRefresh = true : G()
      };
      y = a.mobiscroll.presets.datetime.call(this, j);
      va = y.validate;
      a.extend(y, {
        onMarkupReady: function (c) {
          var g, y, k = "", q = z.dateOrder.search(/m/i), l = z.dateOrder.search(/y/i);
          f = c;
          X = z.display == "inline" ? a(this).is("div") ? a(this) : a(this).parent() : j.context;
          ra = j.getDate(true);
          J = ra.getFullYear();
          H = ra.getMonth();
          ca = R = 0;
          W = true;
          n = z.monthNames;
          ma = "calendar";
          if (z.minDate) {
            aa = new Date(z.minDate.getFullYear(), z.minDate.getMonth(), 1);
            K = z.minDate
          } else K = aa = new Date(z.startYear, 0, 1);
          if (z.maxDate) {
            Y = new Date(z.maxDate.getFullYear(), z.maxDate.getMonth(), 1);
            wa = z.maxDate
          } else wa = Y = new Date(z.endYear, 11, 31, 23, 59, 59);
          c.addClass("dw-calendar" + (u ? "" : " dw-cal-no3d"));
          I = a(".dw", c);
          Fa = a(".dwcc", c);
          Z.date ? Z.date = a(".dwc", f).eq(0) : Z.calendar && a(".dwc", f).eq(0).addClass("dwc-hh");
          if (Z.time) Z.time = a(".dwc", f).eq(1);
          if (Z.calendar) {
            T = z.months == "auto" ? Math.max(1,
              Math.min(3, Math.floor((ua || X.width()) / 280))) : z.months;
            ja = T + 2 * Q;
            ha = Math.floor(T / 2);
            U = Math.round(T / 2) - 1;
            ka = z.showDivergentDays === void 0 ? T < 2 : z.showDivergentDays;
            y = '<div class="dw-cal-btnw"><div class="dw-cal-prev dw-cal-prev-m dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt">' + z.prevMonthText + "</a></div>";
            for (b = 0; b < T; ++b)y = y + ((!p && l < q ? '<span aria-live="assertive" class="dw-cal-year"></span>&nbsp;' : "") + '<div class="dw-cal-btnw-m" style="width: ' + 100 / T + '%"><span aria-live="assertive" class="dw-cal-month"></span>' +
              (!p && l > q ? '&nbsp;<span aria-live="assertive" class="dw-cal-year"></span>' : "") + "</div>");
            y = y + ('<div class="dw-cal-next dw-cal-next-m dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt">' + z.nextMonthText + "</a></div></div>");
            p && (k = '<div class="dw-cal-btnw"><div class="dw-cal-prev dw-cal-prev-y dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt">' + z.prevYearText + '</a></div><span aria-live="assertive" class="dw-cal-year"></span><div class="dw-cal-next dw-cal-next-y dw-cal-btn dwb dwb-e"><a href="#" role="button" class="dw-cal-btn-txt">' +
              z.nextYearText + "</a></div></div>");
            V = '<div class="dwc dw-cal-c"><div class="dw-cal ' + (T > 1 ? " dw-cal-multi " : "") + (ga ? " dw-weeks " : "") + (ka ? "" : " dw-hide-diff ") + (z.calendarClass || "") + '"><div class="dw-cal-header"><div class="dw-cal-btnc ' + (p ? "dw-cal-btnc-ym" : "dw-cal-btnc-m") + '">' + (l < q || T > 1 ? k + y : y + k) + '</div><div class="dw-cal-days-c">';
            for (B = 0; B < T; ++B) {
              V = V + ('<div class="dw-cal-days" style="width: ' + 100 / T + '%"><table cellpadding="0" cellspacing="0"><tr>');
              for (b = 0; b < 7; b++)V = V + ("<th>" + z.dayNamesShort[(b + z.firstDay) %
                7] + "</th>");
              V = V + "</tr></table></div>"
            }
            V = V + ('</div></div><div class="dw-cal-anim-c ' + (z.calendarClass || "") + '"><div class="dw-week-nrs-c ' + (z.weekNrClass || "") + '"><div class="dw-week-nrs"></div></div><div class="dw-cal-anim">');
            for (b = 0; b < T + 2 * Q; b++)V = V + '<div class="dw-cal-slide"></div>';
            V = V + "</div></div></div></div>";
            Z.calendar = a(V)
          }
          a.each(z.controls, function (b, c) {
            Z[c] = a('<div class="dw-cal-pnl" id="' + (la.id + "_dw_pnl_" + b) + '"></div>').append(a('<div class="dw-cal-pnl-i"></div>').append(Z[c])).appendTo(Fa)
          });
          g = '<div class="dw-cal-tabs"><ul role="tablist">';
          a.each(z.controls, function (a, b) {
            Z[b] && (g = g + ('<li role="tab" aria-controls="' + (la.id + "_dw_pnl_" + a) + '" class="dw-cal-tab ' + (a ? "" : Ha) + '" data-control="' + b + '"><a href="#" class="dwb-e dwb-nhl dw-i ' + (!a ? Ja : "") + '">' + z[b + "Text"] + "</a></li>"))
          });
          g = g + "</ul></div>";
          Fa.before(g);
          L = a(".dw-cal-anim-c", f);
          t = a(".dw-cal-anim", f);
          if (Z.calendar) {
            ia = a(".dw-cal-slide", f).each(function (b, c) {
              $.push(a(c))
            });
            ia.slice(Q, Q + T).addClass("dw-cal-slide-a");
            for (b = 0; b < ja; b++)w($[b],
              100 * (b - Q));
            e(J, H);
            ba = a(".dw-week-nrs", f).html(a(".dw-week-nr-c", $[Q]).html())
          }
          A = a(".dw-cal-month", f);
          oa = a(".dw-cal-year", f);
          setTimeout(function () {
            j.tap(L, function (b) {
              b = a(b.target);
              if (!na && !Ia) {
                for (; !b.hasClass("dw-cal-day") && !b.hasClass("dw-cal-row");)b = b.parent();
                b.hasClass("dw-cal-day-v") && x.call(b[0])
              }
            });
            a(".dw-cal-btn", f).on("touchstart mousedown", function (b) {
              var c = a(this);
              b.preventDefault();
              if (O(b) && !c.hasClass("dwb-d")) {
                sa = true;
                c.hasClass("dw-cal-prev-m") ? r() : c.hasClass("dw-cal-next-m") ? D() :
                  c.hasClass("dw-cal-prev-y") ? P(c) : c.hasClass("dw-cal-next-y") && F(c);
                a(document).on("mouseup.dwbtn", function () {
                  a(document).off(".dwbtn");
                  sa = false
                })
              }
            }).on("touchend", function () {
              sa = false
            });
            a(".dw-cal-tab", f).on("touchstart click", function (b) {
              var c = a(this);
              if (O(b) && !c.hasClass("dw-sel")) {
                ma = c.attr("data-control");
                a(".dw-cal-pnl", f).addClass("dw-cal-pnl-h");
                a(".dw-cal-tab", f).removeClass(Ha).removeAttr("aria-selected").find(".dw-i").removeClass(Ja);
                c.addClass(Ha).attr("aria-selected", "true").find(".dw-i").addClass(Ja);
                Z[ma].removeClass("dw-cal-pnl-h");
                if (ma === "calendar") {
                  h = j.getDate(true);
                  (h.getFullYear() !== ra.getFullYear() || h.getMonth() !== ra.getMonth() || h.getDate() !== ra.getDate()) && s(h)
                } else {
                  ra = j.getDate(true);
                  j.setDate(ra, false, 0, true)
                }
              }
            })
          }, 300);
          da ? c.addClass("dw-cal-liq") : a(".dw-cal", f).width(ua || 280 * T);
          z.calendarHeight && a(".dw-cal-anim-c", f).height(z.calendarHeight);
          if (z.swipe) {
            var v, E, C, o, G, ea, va, pa, za = z.liveSwipe, ya = window.requestAnimationFrame || function (a) {
              a()
            }, xa = window.cancelAnimationFrame || qa, ta = function (a) {
              if (!pa && !na) {
                La = true;
                Ia = false;
                pa = true;
                C = new Date;
                R = ca;
                Aa = fa(a, "X");
                Ba = fa(a, "Y")
              }
            }, Ga = function () {
              G = pa = false;
              if (va) {
                va = false;
                xa(v);
                E = false;
                o = new Date - C;
                ea = o < 300 && Math.abs(Ea - Aa) > 50 ? Ea - Aa < 0 ? -Q : Q : Math.round((ca - R) / M);
                ea > 0 && new Date(J, H - ea - U, 2) >= aa ? m(J, H - ea, "prev", ea) : ea < 0 && new Date(J, H - ea + T - U - 1, 2) <= Y ? m(J, H - ea, "next", -ea) : za && N(R, 200)
              }
            }, Ma = function (a) {
              na && a.preventDefault();
              if (pa) {
                Ea = fa(a, "X");
                Ca = fa(a, "Y");
                if (!va && !G) if (Math.abs(Ea - Aa) > 10) Ia = va = true; else if (!j.scrollLock && Math.abs(Ca - Ba) > 10) Ia = G = true;
                va && a.preventDefault();
                if (va && za && !E) {
                  E = true;
                  v = ya(Va)
                }
              }
            }, Va = function () {
              N(R + Ea - Aa);
              E = false
            };
            L.on("touchstart", ta).on("touchmove", Ma).on("touchend touchcancel", Ga).on("mousedown", function (b) {
              if (!La) {
                ta(b);
                a(document).on("mousemove.dwsw", Ma).on("mouseup.dwsw", function () {
                  Ga();
                  a(document).off("dwsw")
                })
              }
              La = false
            })
          }
        }, onShow: function () {
          C(J, H);
          j.trigger("onMonthLoaded", [J, H])
        }, onPosition: function (c, h, e) {
          var g, y, m = 0, k = 0, B = 0;
          if (da && q) {
            L.height("");
            Fa.height("")
          }
          if (za && W || ya || da) {
            a(".dw-cal-pnl", f).removeClass("dw-cal-pnl-h");
            da &&
              t.width("");
            a.each(Z, function (a, b) {
              g = b.width();
              m = Math.max(m, g);
              k = Math.max(k, b.height());
              B = B + g
            });
            if (za || ya && B > X.width()) {
              y = true;
              ma = a(".dw-cal-tabs .dw-sel", f).attr("data-control");
              I.addClass("dw-cal-tabbed")
            } else {
              ma = "calendar";
              k = m = "";
              I.removeClass("dw-cal-tabbed")
            }
          }
          if (da && q) {
            y && Fa.height(Z.calendar.height());
            c = I.outerHeight();
            e >= c && L.height(e - c + L.height());
            k = Math.max(k, Z.calendar.height())
          }
          y && Fa.css({ width: da ? "" : m, height: k });
          e = M;
          (M = Math.round(Math.round(L.width() || 0) / T)) && t.width(M);
          if (da && !W && e) {
            e = R /
              e;
            R = e * M;
            N(R, 0)
          }
          if (p) {
            n = z.maxMonthWidth > a(".dw-cal-btnw-m", f).width() ? z.monthNamesShort : z.monthNames;
            for (b = 0; b < T; ++b)a(A[b]).text(n[(new Date(J, H - U + b)).getMonth()])
          }
          if (y) {
            a(".dw-cal-pnl", f).addClass("dw-cal-pnl-h");
            Z[ma].removeClass("dw-cal-pnl-h")
          }
          j.trigger("onCalResize", []);
          W = false
        }, onClose: function () {
          $ = [];
          ma = null
        }, validate: function (a, b) {
          va.call(this, a, b);
          j.trigger("onSetDate", []);
          s(j.getDate(true))
        }
      });
      return y
    }
})(jQuery);
(function (a) {
  var w = a.mobiscroll, l = w.util, u = l.getCoord, o = l.has3d, fa = l.jsPrefix, O = { firstSelectDay: 0, eventText: "event", eventsText: "events" };
  w.presetShort("calendar");
  w.presets.calendar = function (c) {
    function g(b) {
      if (b) {
        if (I[b]) return I[b];
        var c = a('<div style="background-color:' + b + ';"></div>').appendTo("body"), f = (window.getComputedStyle ? getComputedStyle(c[0]) : c[0].style).backgroundColor.replace(/rgb|rgba|\(|\)|\s/g, "").split(","), f = 130 < 0.299 * f[0] + 0.587 * f[1] + 0.114 * f[2] ? "#000" : "#fff";
        c.remove();
        return I[b] =
          f
      }
    }

    function j(b, f) {
      var y = x[b.getTime()];
      if (y) {
        var j, t;
        t = a(".dw-cal-c", s).height();
        var I = f.height(), B = f.width(), l = f.offset().top - a(".dw-cal-c", s).offset().top, J = 2 > f.closest(".dw-cal-row").index(), H = '<ul class="dw-cal-event-list">';
        F = 0;
        h = !1;
        m = f;
        f.addClass(X).find(".dw-i").addClass(L);
        a.each(y, function (a, b) {
          j = b.color;
          g(j);
          H += '<li class="dw-cal-event"><div class="dw-cal-event-color" style="' + (j ? "background:" + j + ";" : "") + '"></div>' + b.text + "</li>"
        });
        H += "</ul>";
        S.html(H);
        c.trigger("onEventBubbleShow", [m, e]);
        t = e.addClass("dw-cal-events-t").css({ top: J ? l + I : "0", bottom: J ? "0" : t - l }).addClass("dw-cal-events-v").height();
        r = t - S.height();
        e.css(J ? "bottom" : "top", "auto").removeClass("dw-cal-events-t");
        w.css("max-height", t);
        k(0);
        J ? e.addClass("dw-cal-events-b") : e.removeClass("dw-cal-events-b");
        a(".dw-cal-events-arr", e).css("left", f.offset().left - e.offset().left + B / 2);
        c.tap(a(".dw-cal-event", S), function (f) {
          h || c.trigger("onEventSelect", [f, y[a(this).index()], b])
        });
        G = !0
      }
    }

    function l() {
      e && e.removeClass("dw-cal-events-v");
      m && m.removeClass(X).find(".dw-i").removeClass(L);
      G = !1
    }

    function v() {
      W && l();
      c.changing ? c.needRefresh = !0 : c.refresh()
    }

    function k(a) {
      o ? S[0].style[fa + "Transform"] = "translateY(" + a + "px)" : S.css("top", a)
    }

    var C, s, e, m, x, w, S, G, D, r, F, P, h, b, B, y, I = {};
    P = a.extend({}, c.settings);
    var f = a.extend(c.settings, O, P), X = "dw-sel dw-cal-day-ev", L = f.activeClass || "", t = f.multiSelect || "week" == f.selectType, M = f.markedDisplay, ca = !0 === f.events || !0 === f.markedText, R = 0, V = [], W = a.isArray(f.events), ba = W ? a.extend(!0, [], f.events) : [];
    P = a.mobiscroll.presets.calbase.call(this,
      c);
    C = a.extend({}, P);
    if (f.selectedValues) for (i = 0; i < f.selectedValues.length; i++)d = f.selectedValues[i], c._selectedValues[d] = d;
    W && a.each(ba, function (a, b) {
      b._id = R++
    });
    c.onGenMonth = function (a, b) {
      x = c.prepareObj(ba, a, b);
      D = c.prepareObj(f.marked, a, b)
    };
    c.getDayProps = function (a) {
      var b = new Date, h = a.getTime(), a = t ? void 0 !== c._selectedValues[a] : W ? h === b.setHours(0, 0, 0, 0) : void 0, e = D[h] ? D[h][0] : !1, j = x[h] ? x[h][0] : !1, b = e || j, h = e.text || (ca && j ? x[h].length + " " + (1 < x[h].length ? f.eventsText : f.eventText) : 0), e = b.color, j = ca && h ?
        g(e) : "";
      return { marked: b, selected: a, cssClass: W && a ? "dw-cal-day-hl" : "", markup: ca && h ? '<div class="dw-cal-day-txt-c"><div class="dw-cal-day-txt ' + (f.eventTextClass || "") + '" title="' + h + '"' + (e ? ' style="background:' + e + ";color:" + j + ';text-shadow:none;"' : "") + ">" + h + "</div></div>" : b ? '<div class="dw-cal-day-m"' + (e ? ' style="background-color:' + e + ";border-color:" + e + " " + e + ' transparent transparent"' : "") + "></div>" : "" }
    };
    c.addValue = function (a) {
      c._selectedValues[a] = a;
      v()
    };
    c.removeValue = function (a) {
      delete c._selectedValues[a];
      v()
    };
    c.setValues = function (a) {
      var b = 0;
      c._selectedValues = {};
      for (b; b < a.length; b++)c._selectedValues[a[b]] = a[b];
      v()
    };
    W && (c.addEvent = function (b) {
      var c = [], b = a.extend(!0, [], a.isArray(b) ? b : [b]);
      a.each(b, function (a, b) {
        b._id = R++;
        ba.push(b);
        c.push(b._id)
      });
      v();
      return c
    }, c.removeEvent = function (b) {
      b = a.isArray(b) ? b : [b];
      a.each(b, function (b, c) {
        a.each(ba, function (a, b) {
          if (b._id === c) return ba.splice(a, 1), !1
        })
      });
      v()
    }, c.getEvents = function () {
      return ba
    }, c.setEvents = function (b) {
      var c = [];
      ba = a.extend(!0, [], b);
      a.each(ba, function (a, b) {
        b._id = R++;
        c.push(b._id)
      });
      v();
      return c
    });
    a.extend(P, {
      highlight: !t && !W, divergentDayChange: !t && !W, buttons: W ? ["cancel"] : f.buttons, onClear: function () {
        if (t) {
          c._selectedValues = {};
          c.refresh()
        }
      }, onBeforeShow: function () {
        if (W) {
          c.getDate(true);
          f.headerText = false
        }
        if (f.counter && t) f.headerText = function () {
          var b = 0, h = f.selectType == "week" ? 7 : 1;
          a.each(c._selectedValues, function () {
            b++
          });
          return b / h + " " + f.selectedText
        }
      }, onMarkupReady: function (n) {
        C.onMarkupReady.call(this, n);
        s = n;
        if (t) {
          a(".dwv", n).attr("aria-live", "off");
          V = a.extend({}, c._selectedValues)
        }
        ca && a(".dw-cal", n).addClass("dw-cal-ev");
        M && a(".dw-cal", n).addClass("dw-cal-m-" + M);
        if (W) {
          n.addClass("dw-cal-em");
          e = a('<div class="dw-cal-events ' + (f.eventBubbleClass || "") + '"><div class="dw-cal-events-arr"></div><div class="dw-cal-events-i"><div class="dw-cal-events-sc"></div></div></div>').appendTo(a(".dw-cal-c", n));
          w = a(".dw-cal-events-i", e);
          S = a(".dw-cal-events-sc", e);
          e.on("touchstart mousedown", function (c) {
            if (r < 0) {
              B = c.type === "touchstart";
              h = false;
              b = F;
              startY = u(c, "Y");
              endY = u(c, "Y");
              a(document).on(B ? "touchmove.dwsc" : "mousemove.dwsc", function (a) {
                a.preventDefault();
                endY = u(a, "Y");
                F = Math.min(0, Math.max(b + endY - startY, r));
                k(F);
                Math.abs(endY - startY) > 5 && (h = true)
              }).on(B ? "touchend.dwsc" : "mouseup.dwsc", function () {
                a(document).off(".dwsc")
              })
            }
          });
          c.tap(e, function () {
            h || l()
          })
        }
      }, onMonthChange: function () {
        W && l()
      }, onMonthLoaded: function () {
        if (y) {
          j(y.d, a('.dw-cal-day-v[data-full="' + y.full + '"]:not(.dw-cal-day-diff)', s));
          y = false
        }
      }, onDayChange: function (b) {
        var h = b.date, e = a(b.cell), b = b.selected;
        if (W) {
          l();
          e.hasClass("dw-cal-day-ev") || setTimeout(function () {
            c.changing ? y = { d: h, full: e.attr("data-full") } : j(h, e)
          }, 10)
        } else if (t) if (f.selectType == "week") {
          var g, m, k = h.getDay() - f.firstSelectDay, k = k < 0 ? 7 + k : k;
          if (!f.multiSelect) c._selectedValues = {};
          for (g = 0; g < 7; g++) {
            m = new Date(h.getFullYear(), h.getMonth(), h.getDate() - k + g);
            b ? delete c._selectedValues[m] : c._selectedValues[m] = m
          }
          v()
        } else {
          g = a('.dw-cal .dw-cal-day[data-full="' + e.attr("data-full") + '"]', s);
          if (b) {
            g.removeClass("dw-sel").removeAttr("aria-selected").find(".dw-i").removeClass(L);
            delete c._selectedValues[h]
          } else {
            g.addClass("dw-sel").attr("aria-selected", "true").find(".dw-i").addClass(L);
            c._selectedValues[h] = h
          }
        }
        if (!W && !f.multiSelect && f.closeOnSelect && f.display !== "inline") {
          c.setDate(h);
          c.select();
          return false
        }
      }, onCalResize: function () {
        G && a(".dw-cal-events-arr", e).css("left", m.offset().left - e.offset().left + m.width() / 2)
      }, onCancel: function () {
        if (!c.live && t) c._selectedValues = a.extend({}, V)
      }
    });
    return P
  }
})(jQuery);
(function (a) {
  var w = a.mobiscroll, l = new Date, u = { startYear: l.getFullYear() - 100, endYear: l.getFullYear() + 1, shortYearCutoff: "+10", showNow: !1, stepHour: 1, stepMinute: 1, stepSecond: 1, separator: " ", ampmText: "&nbsp;" }, o = function (l) {
    function O(a, c, f) {
      return void 0 !== h[c] ? +a[h[c]] : void 0 !== f ? f : M[b[c]] ? M[b[c]]() : b[c](M)
    }

    function c(a, b, c, f) {
      a.push({ values: c, keys: b, label: f })
    }

    function g(a, b) {
      return Math.floor(a / b) * b
    }

    function j(a) {
      var b = O(a, "h", 0);
      return new Date(O(a, "y"), O(a, "m"), O(a, "d", 1), O(a, "a", 0) ? b + 12 : b, O(a, "i",
        0), O(a, "s", 0))
    }

    function E(b, c) {
      return a(".dw-li", b).index(a('.dw-li[data-val="' + c + '"]', b))
    }

    var v = a(this), k = {}, o;
    if (v.is("input")) {
      switch (v.attr("type")) {
        case "date":
          o = "yy-mm-dd";
          break;
        case "datetime":
          o = "yy-mm-ddTHH:ii:ssZ";
          break;
        case "datetime-local":
          o = "yy-mm-ddTHH:ii:ss";
          break;
        case "month":
          o = "yy-mm";
          k.dateOrder = "mmyy";
          break;
        case "time":
          o = "HH:ii:ss"
      }
      var s = v.attr("min"), v = v.attr("max");
      s && (k.minDate = w.parseDate(o, s));
      v && (k.maxDate = w.parseDate(o, v))
    }
    var e, m, x, N, S, G, D, s = a.extend({}, l.settings), r = a.extend(l.settings,
      u, k, s), F = 0, v = [], P = [], h = {}, b = {
        y: "getFullYear", m: "getMonth", d: "getDate", h: function (a) {
          a = a.getHours();
          a = L && 12 <= a ? a - 12 : a;
          return g(a, ca)
        }, i: function (a) {
          return g(a.getMinutes(), R)
        }, s: function (a) {
          return g(a.getSeconds(), V)
        }, a: function (a) {
          return X && 11 < a.getHours() ? 1 : 0
        }
      }, B = r.preset, y = r.dateOrder, I = r.timeWheels, f = y.match(/D/), X = I.match(/a/i), L = I.match(/h/), t = "datetime" == B ? r.dateFormat + r.separator + r.timeFormat : "time" == B ? r.timeFormat : r.dateFormat, M = new Date, ca = r.stepHour, R = r.stepMinute, V = r.stepSecond, W = r.minDate ||
        new Date(r.startYear, 0, 1), ba = r.maxDate || new Date(r.endYear, 11, 31, 23, 59, 59);
    o = o || t;
    if (B.match(/date/i)) {
      a.each(["y", "m", "d"], function (a, b) {
        e = y.search(RegExp(b, "i"));
        -1 < e && P.push({ o: e, v: b })
      });
      P.sort(function (a, b) {
        return a.o > b.o ? 1 : -1
      });
      a.each(P, function (a, b) {
        h[b.v] = a
      });
      s = [];
      for (k = 0; 3 > k; k++)if (k == h.y) {
        F++;
        x = [];
        m = [];
        N = W.getFullYear();
        S = ba.getFullYear();
        for (e = N; e <= S; e++)m.push(e), x.push(y.match(/yy/i) ? e : (e + "").substr(2, 2));
        c(s, m, x, r.yearText)
      } else if (k == h.m) {
        F++;
        x = [];
        m = [];
        for (e = 0; 12 > e; e++)N = y.replace(/[dy]/gi,
          "").replace(/mm/, 9 > e ? "0" + (e + 1) : e + 1).replace(/m/, e + 1), m.push(e), x.push(N.match(/MM/) ? N.replace(/MM/, '<span class="dw-mon">' + r.monthNames[e] + "</span>") : N.replace(/M/, '<span class="dw-mon">' + r.monthNamesShort[e] + "</span>"));
        c(s, m, x, r.monthText)
      } else if (k == h.d) {
        F++;
        x = [];
        m = [];
        for (e = 1; 32 > e; e++)m.push(e), x.push(y.match(/dd/i) && 10 > e ? "0" + e : e);
        c(s, m, x, r.dayText)
      }
      v.push(s)
    }
    if (B.match(/time/i)) {
      D = !0;
      P = [];
      a.each(["h", "i", "s", "a"], function (a, b) {
        a = I.search(RegExp(b, "i"));
        -1 < a && P.push({ o: a, v: b })
      });
      P.sort(function (a, b) {
        return a.o > b.o ? 1 : -1
      });
      a.each(P, function (a, b) {
        h[b.v] = F + a
      });
      s = [];
      for (k = F; k < F + 4; k++)if (k == h.h) {
        F++;
        x = [];
        m = [];
        for (e = 0; e < (L ? 12 : 24); e += ca)m.push(e), x.push(L && 0 == e ? 12 : I.match(/hh/i) && 10 > e ? "0" + e : e);
        c(s, m, x, r.hourText)
      } else if (k == h.i) {
        F++;
        x = [];
        m = [];
        for (e = 0; 60 > e; e += R)m.push(e), x.push(I.match(/ii/) && 10 > e ? "0" + e : e);
        c(s, m, x, r.minuteText)
      } else if (k == h.s) {
        F++;
        x = [];
        m = [];
        for (e = 0; 60 > e; e += V)m.push(e), x.push(I.match(/ss/) && 10 > e ? "0" + e : e);
        c(s, m, x, r.secText)
      } else k == h.a && (F++, m = I.match(/A/), c(s, [0, 1], m ? [r.amText.toUpperCase(),
      r.pmText.toUpperCase()] : [r.amText, r.pmText], r.ampmText));
      v.push(s)
    }
    l.setDate = function (a, c, f, e, g) {
      for (var j in h) l.temp[h[j]] = a[b[j]] ? a[b[j]]() : b[j](a);
      l.setValue(l.temp, c, f, e, g)
    };
    l.getDate = function (a) {
      return j(a ? l.temp : l.values)
    };
    l.convert = function (b) {
      var c = b;
      a.isArray(b) || (c = [], a.each(b, function (b, f) {
        a.each(f, function (a, f) {
          "daysOfWeek" === b && (f.d ? f.d = "w" + f.d : f = "w" + f);
          c.push(f)
        })
      }));
      return c
    };
    l.format = t;
    l.buttons.now = {
      text: r.nowText, css: "dwb-n", handler: function () {
        l.setDate(new Date, !1, 0.3, !0, !0)
      }
    };
    r.showNow && r.buttons.splice(a.inArray("set", r.buttons) + 1, 0, "now");
    G = r.invalid ? l.convert(r.invalid) : !1;
    return {
      wheels: v, headerText: r.headerText ? function () {
        return w.formatDate(t, j(l.temp), r)
      } : !1, formatResult: function (a) {
        return w.formatDate(o, j(a), r)
      }, parseValue: function (a) {
        var a = w.parseDate(o, a, r), c, f = [];
        for (c in h) f[h[c]] = a[b[c]] ? a[b[c]]() : b[c](a);
        return f
      }, validate: function (c, e, j, t) {
        var m = l.temp, k = { y: W.getFullYear(), m: 0, d: 1, h: 0, i: 0, s: 0, a: 0 }, I = {
          y: ba.getFullYear(), m: 11, d: 31, h: g(L ? 11 : 23, ca), i: g(59, R),
          s: g(59, V), a: 1
        }, B = { h: ca, i: R, s: V, a: 1 }, J = O(m, "y"), H = O(m, "m"), s = !0, u = !0;
        a.each("y,m,d,a,h,i,s".split(","), function (e, g) {
          if (h[g] !== void 0) {
            var j = k[g], B = I[g], L = 31, q = O(m, g), v = a(".dw-ul", c).eq(h[g]);
            if (g == "d") {
              B = L = 32 - (new Date(J, H, 32)).getDate();
              f && a(".dw-li", v).each(function () {
                var b = a(this), c = b.data("val"), f = (new Date(J, H, c)).getDay(), c = y.replace(/[my]/gi, "").replace(/dd/, c < 10 ? "0" + c : c).replace(/d/, c);
                a(".dw-i", b).html(c.match(/DD/) ? c.replace(/DD/, '<span class="dw-day">' + r.dayNames[f] + "</span>") : c.replace(/D/,
                  '<span class="dw-day">' + r.dayNamesShort[f] + "</span>"))
              })
            }
            s && W && (j = W[b[g]] ? W[b[g]]() : b[g](W));
            u && ba && (B = ba[b[g]] ? ba[b[g]]() : b[g](ba));
            if (g != "y") {
              var o = E(v, j), p = E(v, B);
              a(".dw-li", v).removeClass("dw-v").slice(o, p + 1).addClass("dw-v");
              g == "d" && a(".dw-li", v).removeClass("dw-h").slice(L).addClass("dw-h")
            }
            q < j && (q = j);
            q > B && (q = B);
            s && (s = q == j);
            u && (u = q == B);
            if (G && g == "d") {
              for (var x, B = (new Date(J, H, 1)).getDay(), o = [], j = 0; j < G.length; j++) {
                p = G[j];
                x = p + "";
                if (!p.start) if (p.getTime) p.getFullYear() == J && p.getMonth() == H && o.push(p.getDate() -
                  1); else if (x.match(/w/i)) {
                    x = +x.replace("w", "");
                    for (p = x - B; p < L; p = p + 7)p >= 0 && o.push(p)
                  } else {
                  x = x.split("/");
                  x[1] ? x[0] - 1 == H && o.push(x[1] - 1) : o.push(x[0] - 1)
                }
              }
              a.each(o, function (b, c) {
                a(".dw-li", v).eq(c).removeClass("dw-v")
              });
              q = l.getValidCell(q, v, t).val
            }
            m[h[g]] = q
          }
        });
        if (D && G) {
          var v, o, x, P, X, w, M, C, F, N, T, S, ha, U, ka, la, ia = {}, $ = O(m, "d"), xa = new Date(J, H, $), Z = ["a", "h", "i", "s"];
          a.each(G, function (a, b) {
            if (b.start && (b.apply = !1, v = b.d, o = v + "", P = o.split("/"), v && (v.getTime && J == v.getFullYear() && H == v.getMonth() && $ == v.getDate() ||
              !o.match(/w/i) && (P[1] && $ == P[1] && H == P[0] - 1 || !P[1] && $ == P[0]) || o.match(/w/i) && xa.getDay() == +o.replace("w", "")))) b.apply = !0, ia[xa] = !0
          });
          a.each(G, function (b, f) {
            if (f.start && (f.apply || !f.d && !ia[xa])) {
              X = f.start.split(":");
              w = f.end.split(":");
              for (M = 0; 3 > M; M++)void 0 === X[M] && (X[M] = 0), void 0 === w[M] && (w[M] = 59), X[M] = +X[M], w[M] = +w[M];
              X.unshift(11 < X[0] ? 1 : 0);
              w.unshift(11 < w[0] ? 1 : 0);
              L && (12 <= X[1] && (X[1] -= 12), 12 <= w[1] && (w[1] -= 12));
              ha = S = !0;
              a.each(Z, function (b, f) {
                if (h[f] !== void 0) {
                  x = O(m, f);
                  N = la = ka = 0;
                  T = void 0;
                  U = a(".dw-ul",
                    c).eq(h[f]);
                  for (M = b + 1; M < 4; M++) {
                    X[M] > 0 && (ka = B[f]);
                    w[M] < I[Z[M]] && (la = B[f])
                  }
                  C = g(X[b] + ka, B[f]);
                  F = g(w[b] - la, B[f]);
                  S && (N = C < 0 ? 0 : C > I[f] ? a(".dw-li", U).length : E(U, C) + 0);
                  ha && (T = F < 0 ? 0 : F > I[f] ? a(".dw-li", U).length : E(U, F) + 1);
                  (S || ha) && a(".dw-li", U).slice(N, T).removeClass("dw-v");
                  x = l.getValidCell(x, U, t).val;
                  S = S && x == g(X[b], B[f]);
                  ha = ha && x == g(w[b], B[f]);
                  m[h[f]] = x
                }
              })
            }
          })
        }
      }
    }
  };
  w.i18n.en = a.extend(w.i18n.en, {
    dateFormat: "mm/dd/yy", dateOrder: "mmddy", timeWheels: "hhiiA", timeFormat: "hh:ii A", monthNames: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthNamesShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), dayNames: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), dayNamesShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","), monthText: "Month", dayText: "Day", yearText: "Year", hourText: "Hours", minuteText: "Minutes", secText: "Seconds", amText: "am", pmText: "pm", nowText: "Now"
  });
  a.each(["date", "time", "datetime"], function (a, l) {
    w.presets[l] = o;
    w.presetShort(l)
  });
  w.formatDate = function (l, o, c) {
    if (!o) return null;
    var c = a.extend({},
      u, c), g = function (a) {
        for (var c = 0; v + 1 < l.length && l.charAt(v + 1) == a;)c++, v++;
        return c
      }, j = function (a, c, j) {
        c = "" + c;
        if (g(a)) for (; c.length < j;)c = "0" + c;
        return c
      }, w = function (a, c, j, k) {
        return g(a) ? k[c] : j[c]
      }, v, k = "", C = !1;
    for (v = 0; v < l.length; v++)if (C) "'" == l.charAt(v) && !g("'") ? C = !1 : k += l.charAt(v); else switch (l.charAt(v)) {
      case "d":
        k += j("d", o.getDate(), 2);
        break;
      case "D":
        k += w("D", o.getDay(), c.dayNamesShort, c.dayNames);
        break;
      case "o":
        k += j("o", (o.getTime() - (new Date(o.getFullYear(), 0, 0)).getTime()) / 864E5, 3);
        break;
      case "m":
        k +=
          j("m", o.getMonth() + 1, 2);
        break;
      case "M":
        k += w("M", o.getMonth(), c.monthNamesShort, c.monthNames);
        break;
      case "y":
        k += g("y") ? o.getFullYear() : (10 > o.getYear() % 100 ? "0" : "") + o.getYear() % 100;
        break;
      case "h":
        var s = o.getHours(), k = k + j("h", 12 < s ? s - 12 : 0 == s ? 12 : s, 2);
        break;
      case "H":
        k += j("H", o.getHours(), 2);
        break;
      case "i":
        k += j("i", o.getMinutes(), 2);
        break;
      case "s":
        k += j("s", o.getSeconds(), 2);
        break;
      case "a":
        k += 11 < o.getHours() ? c.pmText : c.amText;
        break;
      case "A":
        k += 11 < o.getHours() ? c.pmText.toUpperCase() : c.amText.toUpperCase();
        break;
      case "'":
        g("'") ? k += "'" : C = !0;
        break;
      default:
        k += l.charAt(v)
    }
    return k
  };
  w.parseDate = function (l, o, c) {
    var g = a.extend({}, u, c), c = g.defaultValue || new Date;
    if (!l || !o) return c;
    var o = "object" == typeof o ? o.toString() : o + "", j = g.shortYearCutoff, w = c.getFullYear(), v = c.getMonth() + 1, k = c.getDate(), C = -1, s = c.getHours(), e = c.getMinutes(), m = 0, x = -1, N = !1, S = function (a) {
      (a = F + 1 < l.length && l.charAt(F + 1) == a) && F++;
      return a
    }, G = function (a) {
      S(a);
      a = o.substr(r).match(RegExp("^\\d{1," + ("@" == a ? 14 : "!" == a ? 20 : "y" == a ? 4 : "o" == a ? 3 : 2) + "}"));
      if (!a) return 0;
      r += a[0].length;
      return parseInt(a[0], 10)
    }, D = function (a, c, b) {
      a = S(a) ? b : c;
      for (c = 0; c < a.length; c++)if (o.substr(r, a[c].length).toLowerCase() == a[c].toLowerCase()) return r += a[c].length, c + 1;
      return 0
    }, r = 0, F;
    for (F = 0; F < l.length; F++)if (N) "'" == l.charAt(F) && !S("'") ? N = !1 : r++; else switch (l.charAt(F)) {
      case "d":
        k = G("d");
        break;
      case "D":
        D("D", g.dayNamesShort, g.dayNames);
        break;
      case "o":
        C = G("o");
        break;
      case "m":
        v = G("m");
        break;
      case "M":
        v = D("M", g.monthNamesShort, g.monthNames);
        break;
      case "y":
        w = G("y");
        break;
      case "H":
        s =
          G("H");
        break;
      case "h":
        s = G("h");
        break;
      case "i":
        e = G("i");
        break;
      case "s":
        m = G("s");
        break;
      case "a":
        x = D("a", [g.amText, g.pmText], [g.amText, g.pmText]) - 1;
        break;
      case "A":
        x = D("A", [g.amText, g.pmText], [g.amText, g.pmText]) - 1;
        break;
      case "'":
        S("'") ? r++ : N = !0;
        break;
      default:
        r++
    }
    100 > w && (w += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (w <= ("string" != typeof j ? j : (new Date).getFullYear() % 100 + parseInt(j, 10)) ? 0 : -100));
    if (-1 < C) {
      v = 1;
      k = C;
      do {
        g = 32 - (new Date(w, v - 1, 32)).getDate();
        if (k <= g) break;
        v++;
        k -= g
      } while (1)
    }
    s = new Date(w,
      v - 1, k, -1 == x ? s : x && 12 > s ? s + 12 : !x && 12 == s ? 0 : s, e, m);
    return s.getFullYear() != w || s.getMonth() + 1 != v || s.getDate() != k ? c : s
  }
})(jQuery);
(function (a) {
  var w = a.mobiscroll, l = { invalid: [], showInput: !0, inputClass: "" }, u = function (o) {
    function u(b, c, h, e) {
      for (var f = 0; f < c;) {
        var g = a(".dwwl" + f, b), j = w(e, f, h);
        a.each(j, function (b, c) {
          a('.dw-li[data-val="' + c + '"]', g).removeClass("dw-v")
        });
        f++
      }
    }

    function w(a, c, h) {
      for (var e = 0, f, g = []; e < c;) {
        var j = a[e];
        for (f in h) if (h[f].key == j) {
          h = h[f].children;
          break
        }
        e++
      }
      for (e = 0; e < h.length;)h[e].invalid && g.push(h[e].key), e++;
      return g
    }

    function c(a, c) {
      for (var h = []; a;)h[--a] = !0;
      h[c] = !1;
      return h
    }

    function g(a, c, h) {
      var e = 0, f, g, k =
        [], t = D;
      if (c) for (f = 0; f < c; f++)k[f] = [
        {}
      ];
      for (; e < a.length;) {
        f = k;
        for (var c = e, l = t, m = { keys: [], values: [], label: r[e] }, o = 0; o < l.length;)m.values.push(l[o].value), m.keys.push(l[o].key), o++;
        f[c] = [m];
        f = 0;
        for (c = void 0; f < t.length && void 0 === c;) {
          if (t[f].key == a[e] && (void 0 !== h && e <= h || void 0 === h)) c = f;
          f++
        }
        if (void 0 !== c && t[c].children) e++, t = t[c].children; else if ((g = j(t)) && g.children) e++, t = g.children; else break
      }
      return k
    }

    function j(a, c) {
      if (!a) return !1;
      for (var h = 0, e; h < a.length;)if (!(e = a[h++]).invalid) return c ? h - 1 : e;
      return !1
    }

    function E(b, c) {
      a(".dwc", b).css("display", "").slice(c).hide()
    }

    function v(a, c) {
      var h = [], e = D, f = 0, g = !1, k, t;
      if (void 0 !== a[f] && f <= c) {
        g = 0;
        k = a[f];
        for (t = void 0; g < e.length && void 0 === t;)e[g].key == a[f] && !e[g].invalid && (t = g), g++
      } else t = j(e, !0), k = e[t].key;
      g = void 0 !== t ? e[t].children : !1;
      for (h[f] = k; g;) {
        e = e[t].children;
        f++;
        if (void 0 !== a[f] && f <= c) {
          g = 0;
          k = a[f];
          for (t = void 0; g < e.length && void 0 === t;)e[g].key == a[f] && !e[g].invalid && (t = g), g++
        } else t = j(e, !0), t = !1 === t ? void 0 : t, k = e[t].key;
        g = void 0 !== t && j(e[t].children) ? e[t].children :
          !1;
        h[f] = k
      }
      return { lvl: f + 1, nVector: h }
    }

    function k(b) {
      var c = [];
      N = N > S++ ? N : S;
      b.children("li").each(function (b) {
        var e = a(this), f = e.clone();
        f.children("ul,ol").remove();
        var f = f.html().replace(/^\s\s*/, "").replace(/\s\s*$/, ""), h = e.data("invalid") ? !0 : !1, b = { key: e.data("val") || b, value: f, invalid: h, children: null }, e = e.children("ul,ol");
        e.length && (b.children = k(e));
        c.push(b)
      });
      S--;
      return c
    }

    var C = a.extend({}, o.settings), s = a.extend(o.settings, l, C), e = a(this), m, x, C = this.id + "_dummy", N = 0, S = 0, G = {}, D = s.wheelArray || k(e), r =
      function (a) {
        var c = [], e;
        for (e = 0; e < a; e++)c[e] = s.labels && s.labels[e] ? s.labels[e] : e;
        return c
      }(N), F = [], P = function (a) {
        var c = [], e;
        e = !0;
        for (var h = 0; e;)e = j(a), c[h++] = e.key, (e = e.children) && (a = e);
        return c
      }(D), h = g(P, N);
    a("#" + C).remove();
    s.showInput && (m = a('<input type="text" id="' + C + '" value="" class="' + s.inputClass + '" readonly />').insertBefore(e), s.anchor = m, o.attachShow(m));
    s.wheelArray || e.hide().closest(".ui-field-contain").trigger("create");
    return {
      width: 50, wheels: h, headerText: !1, parseValue: function (a) {
        return a ?
          a.split(" ") : s.defaultValue || P
      }, onBeforeShow: function () {
        var a = o.temp;
        F = a.slice(0);
        s.wheels = g(a, N, N);
        x = true
      }, onValueFill: function (a, c) {
        m && m.val(a);
        c && e.change()
      }, onShow: function (b) {
        a(".dwwl", b).on("mousedown touchstart", function () {
          clearTimeout(G[a(".dwwl", b).index(this)])
        })
      }, onDestroy: function () {
        m && m.remove();
        e.show()
      }, validate: function (a, e, h) {
        var j = [], f = o.temp, k = (e || 0) + 1, l;
        if (e !== void 0 && F[e] != f[e] || e === void 0 && !x) {
          s.wheels = g(f, null, e);
          l = v(f, e);
          if (e !== void 0) o.temp = l.nVector.slice(0);
          for (; k < l.lvl;)j.push(k++);
          if (j.length) {
            s.readonly = c(N, e);
            clearTimeout(G[e]);
            G[e] = setTimeout(function () {
              x = true;
              E(a, l.lvl);
              F = o.temp.slice(0);
              o.changeWheel(j, e === void 0 ? h : 0, e !== void 0);
              s.readonly = false
            }, e === void 0 ? 0 : h * 1E3);
            return false
          }
          u(a, l.lvl, D, o.temp)
        } else {
          l = v(f, f.length);
          u(a, l.lvl, D, f);
          E(a, l.lvl)
        }
        x = false
      }
    }
  };
  a.each(["list", "image", "treelist"], function (a, l) {
    w.presets[l] = u;
    w.presetShort(l)
  })
})(jQuery);
(function (a) {
  var w = { inputClass: "", invalid: [], rtl: !1, showInput: !0, group: !1, groupLabel: "Groups" };
  a.mobiscroll.presetShort("select");
  a.mobiscroll.presets.select = function (l) {
    function u() {
      var e, b = 0, j = [], k = [], l = [
        []
      ];
      c.group ? (c.rtl && (b = 1), a("optgroup", g).each(function (b) {
        j.push(a(this).attr("label"));
        k.push(b)
      }), l[b] = [
        { values: j, keys: k, label: c.groupLabel }
      ], e = v, b += c.rtl ? -1 : 1) : e = g;
      j = [];
      k = [];
      a("option", e).each(function () {
        var b = a(this).attr("value");
        j.push(a(this).text());
        k.push(b);
        a(this).prop("disabled") &&
          x.push(b)
      });
      l[b] = [
        { values: j, keys: k, label: m }
      ];
      return l
    }

    function o(a, b, c) {
      var e = [];
      if (j) {
        var a = [], k = 0;
        for (k in l._selectedValues) a.push(S[k]), e.push(k);
        F.val(a.join(", "))
      } else F.val(a), e = b ? l.values[D] : null;
      b && (g.val(e), c && (s = !0, g.change()))
    }

    function fa(a) {
      if (j && a.hasClass("dw-v") && a.closest(".dw").find(".dw-ul").index(a.closest(".dw-ul")) == D) {
        var b = a.attr("data-val");
        a.hasClass("dw-msel") ? (a.removeClass("dw-msel").removeAttr("aria-selected"), delete l._selectedValues[b]) : (a.addClass("dw-msel").attr("aria-selected",
          "true"), l._selectedValues[b] = b);
        l.live && o(b, !0, !0);
        return !1
      }
    }

    var O = a.extend({}, l.settings), c = a.extend(l.settings, w, O), g = a(this), j = g.prop("multiple"), O = this.id + "_dummy", E = j ? g.val() ? g.val()[0] : a("option", g).attr("value") : g.val(), v = g.find('option[value="' + E + '"]').parent(), k = v.index() + "", C = k, s;
    a('label[for="' + this.id + '"]').attr("for", O);
    var e = a('label[for="' + O + '"]'), m = void 0 !== c.label ? c.label : e.length ? e.text() : g.attr("name"), x = [], N = [], S = {}, G, D, r, F, P = c.readonly;
    c.group && !a("optgroup", g).length && (c.group = !1);
    c.invalid.length || (c.invalid = x);
    c.group ? c.rtl ? (G = 1, D = 0) : (G = 0, D = 1) : (G = -1, D = 0);
    a("#" + O).remove();
    F = a('<input type="text" id="' + O + '" class="' + c.inputClass + '" readonly />');
    c.showInput && F.insertBefore(g);
    a("option", g).each(function () {
      S[a(this).attr("value")] = a(this).text()
    });
    l.attachShow(F);
    O = g.val() || [];
    e = 0;
    for (e; e < O.length; e++)l._selectedValues[O[e]] = O[e];
    o(S[E]);
    g.off(".dwsel").on("change.dwsel", function () {
      s || l.setValue(j ? g.val() || [] : [g.val()], true);
      s = false
    }).addClass("dw-hsel").attr("tabindex",
      -1).closest(".ui-field-contain").trigger("create");
    l._setValue || (l._setValue = l.setValue);
    l.setValue = function (e, b, m, r, s) {
      var f = a.isArray(e) ? e[0] : e;
      E = f !== void 0 ? f : a("option", g).attr("value");
      if (j) {
        l._selectedValues = {};
        f = 0;
        for (f; f < e.length; f++)l._selectedValues[e[f]] = e[f]
      }
      if (c.group) {
        v = g.find('option[value="' + E + '"]').parent();
        C = v.index();
        e = c.rtl ? [E, v.index()] : [v.index(), E];
        if (C !== k) {
          c.wheels = u();
          l.changeWheel([D]);
          k = C + ""
        }
      } else e = [E];
      l._setValue(e, b, m, r, s);
      if (b) {
        b = j ? true : E !== g.val();
        o(S[E], b, s)
      }
    };
    l.getValue =
      function (a) {
        return (a ? l.temp : l.values)[D]
      };
    return {
      width: 50, wheels: void 0, headerText: !1, multiple: j, anchor: F, formatResult: function (a) {
        return S[a[D]]
      }, parseValue: function () {
        var e = g.val() || [], b = 0;
        if (j) {
          l._selectedValues = {};
          for (b; b < e.length; b++)l._selectedValues[e[b]] = e[b]
        }
        E = j ? g.val() ? g.val()[0] : a("option", g).attr("value") : g.val();
        v = g.find('option[value="' + E + '"]').parent();
        C = v.index();
        k = C + "";
        return c.group && c.rtl ? [E, C] : c.group ? [C, E] : [E]
      }, validate: function (e, b, m) {
        if (b === void 0 && j) {
          var o = l._selectedValues,
            s = 0;
          a(".dwwl" + D + " .dw-li", e).removeClass("dw-msel").removeAttr("aria-selected");
          for (s in o) a(".dwwl" + D + ' .dw-li[data-val="' + o[s] + '"]', e).addClass("dw-msel").attr("aria-selected", "true")
        }
        if (b === G) {
          C = l.temp[G];
          if (C !== k) {
            v = g.find("optgroup").eq(C);
            C = v.index();
            E = (E = v.find("option").eq(0).val()) || g.val();
            c.wheels = u();
            if (c.group) {
              l.temp = c.rtl ? [E, C] : [C, E];
              c.readonly = [c.rtl, !c.rtl];
              clearTimeout(r);
              r = setTimeout(function () {
                l.changeWheel([D], void 0, true);
                c.readonly = P;
                k = C + ""
              }, m * 1E3);
              return false
            }
          } else c.readonly =
            P
        } else E = l.temp[D];
        var f = a(".dw-ul", e).eq(D);
        a.each(c.invalid, function (b, c) {
          a('.dw-li[data-val="' + c + '"]', f).removeClass("dw-v")
        })
      }, onBeforeShow: function () {
        if (j && c.counter) c.headerText = function () {
          var e = 0;
          a.each(l._selectedValues, function () {
            e++
          });
          return e + " " + c.selectedText
        };
        c.wheels = u();
        if (c.group) l.temp = c.rtl ? [E, v.index()] : [v.index(), E]
      }, onClear: function (c) {
        l._selectedValues = {};
        F.val("");
        a(".dwwl" + D + " .dw-li", c).removeClass("dw-msel").removeAttr("aria-selected")
      }, onMarkupReady: function (c) {
        c.addClass("dw-select");
        a(".dwwl" + G, c).on("mousedown touchstart", function () {
          clearTimeout(r)
        });
        if (j) {
          c.addClass("dwms");
          a(".dwwl", c).eq(D).addClass("dwwms").attr("aria-multiselectable", "true");
          a(".dwwl", c).on("keydown", function (b) {
            if (b.keyCode == 32) {
              b.preventDefault();
              b.stopPropagation();
              fa(a(".dw-sel", this))
            }
          });
          N = a.extend({}, l._selectedValues)
        }
      }, onValueTap: fa, onSelect: function (a) {
        o(a, true, true);
        if (c.group) l.values = null
      }, onCancel: function () {
        if (c.group) l.values = null;
        if (!l.live && j) l._selectedValues = a.extend({}, N)
      }, onChange: function (a) {
        if (l.live && !j) {
          F.val(a);
          s = true;
          g.val(l.temp[D]).change()
        }
      }, onDestroy: function () {
        F.remove();
        g.removeClass("dw-hsel").removeAttr("tabindex")
      }
    }
  }
})(jQuery);
(function (a) {
  var w = a.mobiscroll, l = { controls: ["start", "reset"], autostart: !1, step: 1, useShortLabels: !1 };
  w.i18n.en = a.extend(w.i18n.en, { labels: "Years,Months,Days,Hours,Minutes,Seconds,".split(","), labelsShort: "Yrs,Mths,Days,Hrs,Mins,Secs,".split(","), startText: "Start", stopText: "Stop", resetText: "Reset", lapText: "Lap", hideText: "Hide" });
  w.presetShort("timer");
  w.presets.timer = function (u) {
    function o(a) {
      return new Date(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate(), a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(),
        a.getUTCMilliseconds())
    }

    function w(b) {
      var c = {};
      if (K && t[A].index > t.days.index) {
        var e, f, h, g;
        e = new Date;
        var j = x ? e : Y;
        e = x ? Y : e;
        e = o(e);
        j = o(j);
        c.years = j.getFullYear() - e.getFullYear();
        c.months = j.getMonth() - e.getMonth();
        c.days = j.getDate() - e.getDate();
        c.hours = j.getHours() - e.getHours();
        c.minutes = j.getMinutes() - e.getMinutes();
        c.seconds = j.getSeconds() - e.getSeconds();
        c.fract = (j.getMilliseconds() - e.getMilliseconds()) / 10;
        for (e = L.length; 0 < e; e--)f = L[e - 1], h = t[f], g = L[a.inArray(f, L) - 1], t[g] && 0 > c[f] && (c[g]--, c[f] += "months" ==
          g ? 32 - (new Date(j.getFullYear(), j.getMonth(), 32)).getDate() : h.until + 1);
        "months" == A && (c.months += 12 * c.years, delete c.years)
      } else a(L).each(function (a, e) {
        t[e].index <= t[A].index && (c[e] = Math.floor(b / t[e].limit), b -= c[e] * t[e].limit)
      });
      return c
    }

    function O(c, e) {
      var f = 1, g = t[c], k = g.wheel, l = g.prefix, m = t[L[a.inArray(c, L) - 1]];
      h = 0;
      b = g.until;
      c == A && (h = Math.max(0, e[c] - 50), b = h + 100, S = h + 5, G = b - 5);
      if (g.index <= t[A].index && (!m || m.limit > n)) {
        M[c] || ra[0].push(k);
        M[c] = 1;
        k.keys = [];
        k.values = [];
        k.label = g.label;
        n >= g.limit && (f = Math.max(Math.round(n /
          g.limit), 1), v = f * g.limit);
        for (j = h; j <= b; j += f)k.keys.push(j), k.values.push((l || "") + (10 > j ? "0" : "") + j + '<span class="dwtlbl">' + g.label + "</span>")
      }
    }

    function c(b) {
      var c = [], e, f = w(b);
      a(L).each(function (a, b) {
        M[b] && (e = Math.max(Math.round(n / t[b].limit), 1), c.push(Math.round(f[b] / e) * e))
      });
      return c
    }

    function g(a) {
      K ? (e = Y - new Date, 0 > e ? (e *= -1, x = !0) : x = !1, m = 0, ba = !0) : (void 0 !== Y ? (ba = !1, e = 1E3 * Y, x = "down" !== f.countDirection) : (e = 0, ba = x = "down" !== f.countDirection), a && (m = 0))
    }

    var j, E, v, k, C, s, e, m, x, N, S, G, D, r, F, P, h, b, B, y;
    a(this);
    var I = a.extend({}, u.settings), f = a.extend(u.settings, l, I), X = f.useShortLabels ? f.labelsShort : f.labels, L = "years,months,days,hours,minutes,seconds,fract".split(","), t = {
      years: { index: 6, until: 10, limit: 31536E6, label: X[0], wheel: {} }, months: { index: 5, until: 11, limit: 2592E6, label: X[1], wheel: {} }, days: { index: 4, until: 31, limit: 864E5, label: X[2], wheel: {} }, hours: { index: 3, until: 23, limit: 36E5, label: X[3], wheel: {} }, minutes: { index: 2, until: 59, limit: 6E4, label: X[4], wheel: {} }, seconds: { index: 1, until: 59, limit: 1E3, label: X[5], wheel: {} },
      fract: { index: 0, until: 99, limit: 10, label: X[6], prefix: ".", wheel: {} }
    }, M = {}, ca = [], R = 0, V = !1, W = !0, ba = !1, n = Math.max(10, 1E3 * f.step), A = f.maxWheel, oa = f.locked || K, aa = (a.isArray(f.controls) ? f.controls : []).join(","), Y = f.targetTime, K = Y && void 0 !== Y.getTime, wa = "jqm" == f.theme, ra = [
      []
    ];
    u.start = function () {
      W && u.reset();
      if (!V && (g(), ba || !(m >= e))) V = !0, W = !1, C = new Date, k = m, f.readonly = !0, u.setValue(c(x ? m : e - m), !0, 0.1), E = setInterval(function () {
        m = new Date - C + k;
        u.setValue(c(x ? m : e - m), !0, 0.1);
        !ba && m + v >= e && (clearInterval(E), setTimeout(function () {
          u.stop();
          m = e;
          u.setValue(c(x ? m : 0), !0, 0.1);
          u.trigger("onFinish", [e]);
          W = !0
        }, e - m))
      }, v), a(".dwwr", N).addClass("dw-running dw-locked"), a(".dw-timer-st", N).attr("title", f.stopText).find(".dwb-txt").text(f.stopText), u.trigger("onStart", [])
    };
    u.stop = function () {
      V && (V = !1, clearInterval(E), m = new Date - C + k, a(".dwwr", N).removeClass("dw-running"), a(".dw-timer-st", N).attr("title", f.startText).find(".dwb-txt").text(f.startText), u.trigger("onStop", [m]))
    };
    u.reset = function () {
      u.stop();
      m = 0;
      ca = [];
      R = 0;
      u.setValue(c(x ? 0 : e), !0, 0.1);
      u.settings.readonly =
        oa;
      W = !0;
      oa || a(".dwwr", N).removeClass("dw-locked");
      u.trigger("onReset", [])
    };
    u.lap = function () {
      V && (s = new Date - C + k, D = s - R, R = s, ca.push(s), u.trigger("lap", [s, D, ca]))
    };
    u.getTime = function () {
      return e
    };
    u.setTime = function (a) {
      Y = a / 1E3;
      e = a
    };
    u.getEllapsedTime = function () {
      return V ? new Date - C + k : 0
    };
    u.setEllapsedTime = function (a) {
      W || (k = m = a, C = new Date, u.setValue(c(x ? m : e - m), !0, 0.1))
    };
    g(!0);
    !A && !e && (A = "minutes");
    A || a(L).each(function (a, b) {
      if (!A && e >= t[b].limit) return A = b, !1
    });
    P = w(e);
    a(L).each(function (a, b) {
      O(b, P)
    });
    v = Math.max(87,
      v);
    f.autostart && setTimeout(function () {
      u.start()
    }, 0);
    return {
      wheels: ra, headerText: !1, readonly: oa, parseValue: function () {
        return c(x ? 0 : e)
      }, formatResult: function (b) {
        var c = "", e = 0;
        a(L).each(function (a, f) {
          "fract" != f && M[f] && (c += b[e] + ("seconds" == f && M.fract ? "." + b[e + 1] : "") + " " + X[a] + " ", e++)
        });
        return c
      }, validate: function (c, f, j) {
        var k, l, n = 0, c = !1;
        W && void 0 !== f && (Y = 0, a(L).each(function (a, b) {
          M[b] && (Y += t[b].limit * u.temp[n], n++)
        }), Y /= 1E3, g(!0));
        if (W && 0 === f) c = !0, k = w(e); else if (!r && (u.temp[0] < S || u.temp[0] > G)) k = w(x ? m : e -
          m), c = !0;
        if (c && (O(A, k), B !== h || y !== b)) l = u.temp[0], F = setTimeout(function () {
          B = h;
          y = b;
          r = true;
          u.temp[0] = l;
          u.changeWheel([0], void 0, f !== void 0)
        }, 1E3 * j);
        r = !1
      }, onBeforeShow: function () {
        f.mode = "scroller";
        f.showLabel = !0
      }, onMarkupReady: function (b) {
        var c = 0;
        N = b;
        b.addClass("dw-timer");
        V ? a(".dwwr", b).addClass("dw-running") : a(".dwwr", b).removeClass("dw-running");
        oa && a(".dwwr", N).addClass("dw-locked");
        a(".dwbc", b).remove();
        a(".dwwl0", b).on("mousedown touchstart", function () {
          clearTimeout(F)
        });
        a(L).each(function (e, f) {
          M[f] &&
            (a(".dwwl" + c, b).addClass("dwwl-" + f), c++)
        });
        var e = aa.match(/start/), h = aa.match(/reset/) && !K, g = aa.match(/lap/) && !K, j = "inline" !== f.display;
        if (e || h || g || j) a(".dwwr", b).addClass("dw-timer-btns").append('<div class="dwbc">' + (e ? '<span class="dwbw dwbgr dwbgrf' + (!h && !g ? " dwbgrl" : "") + '"><a href="#" role="button" class="dwb-e dwb dw-timer-st"' + (wa ? ' data-role="button" data-icon="arrow-r" data-iconpos="notext"' : "") + ' title="' + (V ? f.stopText : f.startText) + '"><span class="dwb-i"><span class="dwb-txt">' + (V ? f.stopText :
          f.startText) + "</span></span></a></span>" : "") + (h ? '<span class="dwbw dwbgr' + (!e ? " dwbgrf" : "") + (!g ? " dwbgrl" : "") + '"><a href="#" role="button" class="dwb-e dwb dw-timer-r"' + (wa ? ' data-role="button" data-icon="delete" data-iconpos="notext"' : "") + ' title="' + f.resetText + '"><span class="dwb-i"><span class="dwb-txt">' + f.resetText + "</span></span></a></span>" : "") + (g ? '<span class="dwbw dwbgr dwbgrl' + (!e && !h ? " dwbgrf" : "") + '"><a href="#" role="button" class="dwb-e dwb dw-timer-l"' + (wa ? ' data-role="button" data-icon="refresh" data-iconpos="notext"' :
            "") + ' title="' + f.lapText + '"><span class="dwb-i"><span class="dwb-txt">' + f.lapText + "</span></span></a></span>" : "") + (j ? '<span class="dwbw dwtcl"><a href="#" role="button" class="dwb-e dwb dw-timer-cl"' + (wa ? ' data-role="button" data-mini="true"' : "") + ">" + f.hideText + "</a></span>" : "") + "</div>"), u.tap(a(".dw-timer-st", b), function () {
              V ? u.stop() : u.start()
            }), u.tap(a(".dw-timer-r", b), function () {
              u.reset()
            }), u.tap(a(".dw-timer-l", b), function () {
              u.lap()
            }), u.tap(a(".dw-timer-cl", b), function () {
              u.hide()
            })
      }, onMarkupInserted: function (b) {
        a(".dwwr",
          b).css("min-width", a(".dwbc", b).width())
      }, onDestroy: function () {
        clearInterval(E)
      }
    }
  }
})(jQuery);
(function (a) {
  var w = a.mobiscroll, l = { wheelOrder: "hhiiss", useShortLabels: !1, minTime: 0, maxTime: Infinity };
  w.i18n.en = a.extend(w.i18n.en, { labels: "Years,Months,Days,Hours,Minutes,Seconds".split(","), labelsShort: "Yrs,Mths,Days,Hrs,Mins,Secs".split(",") });
  w.presetShort("timespan");
  w.presets.timespan = function (u) {
    function o(b) {
      var c = {};
      a(P).each(function (a, e) {
        c[e] = y[e] ? Math.floor(b / h[e].limit) : 0;
        b -= c[e] * h[e].limit
      });
      return c
    }

    function w(a, b) {
      var f = !1, g = B[y[a] - 1] || 1, j = h[a], k = j.wheel, l = j.prefix;
      e = 0;
      m = j.until;
      a ==
        I && (e = Math.max(S[a], b[a] - 50 * g), m = Math.min(G[a], e + 100 * g), E = e + 5 * g, v = m - 5 * g);
      k.keys = [];
      k.values = [];
      k.label = j.label;
      F.match(RegExp(j.re + j.re, "i")) && (f = !0);
      for (c = e; c <= m; c += g)k.keys.push(c), k.values.push((l || "") + (10 > c && f ? "0" : "") + c + '<span class="dwtlbl">' + j.label + "</span>")
    }

    function O(c) {
      var e = 0;
      a.each(b, function (a, b) {
        isNaN(+c[0]) || (e += h[b.v].limit * c[a])
      });
      return e
    }

    var c, g, j, E, v, k, C, s, e, m, x, N, S, G;
    a(this);
    var D = a.extend({}, u.settings), r = a.extend(u.settings, l, D), F = r.wheelOrder, D = r.useShortLabels ? r.labelsShort :
      r.labels, P = "years,months,days,hours,minutes,seconds".split(","), h = { years: { index: 6, until: 10, limit: 31536E6, label: D[0], re: "y", wheel: {} }, months: { index: 5, until: 11, limit: 2592E6, label: D[1], re: "m", wheel: {} }, days: { index: 4, until: 31, limit: 864E5, label: D[2], re: "d", wheel: {} }, hours: { index: 3, until: 23, limit: 36E5, label: D[3], re: "h", wheel: {} }, minutes: { index: 2, until: 59, limit: 6E4, label: D[4], re: "i", wheel: {} }, seconds: { index: 1, until: 59, limit: 1E3, label: D[5], re: "s", wheel: {} } }, b = [], B = r.steps || [], y = {}, I = "seconds", f = 0, X = [
        []
      ];
    j = 0;
    s = o(j);
    S = o(r.minTime);
    G = o(r.maxTime);
    a(P).each(function (a, c) {
      g = F.search(RegExp(h[c].re, "i"));
      -1 < g && (b.push({ o: g, v: c }), h[c].index > h[I].index && (I = c))
    });
    b.sort(function (a, b) {
      return a.o > b.o ? 1 : -1
    });
    a.each(b, function (a, b) {
      b.v == I && (f = a);
      y[b.v] = a + 1;
      X[0].push(h[b.v].wheel);
      w(b.v, s)
    });
    return {
      wheels: X, parseValue: function (c) {
        var e = [];
        c ? (a(r.labels).each(function (a, b) {
          c = c.replace(b, "")
        }), a(r.labelsShort).each(function (a, b) {
          c = c.replace(b, "")
        }), e = c.replace(/\s+/g, " ").split(" ")) : r.defaultValue && (s = o(r.defaultValue),
          a.each(b, function (a, b) {
            e.push(s[b.v])
          }));
        a(e).each(function (a, b) {
          e[a] = Math.floor(b / (B[a] || 1)) * (B[a] || 1)
        });
        return e
      }, formatResult: function (c) {
        var e = "";
        a(b).each(function (a, b) {
          e += c[a] + " " + h[b.v].label + " "
        });
        return e
      }, validate: function (b, c, g) {
        var h, l;
        j = O(u.temp);
        h = o(j);
        if (c === f || !k && (u.temp[f] < E || u.temp[f] > v)) if (w(I, h), x !== e || N !== m) l = u.temp[f], C = setTimeout(function () {
          x = e;
          N = m;
          k = !0;
          u.temp[f] = l;
          u.changeWheel([f], void 0, void 0 !== c)
        }, 1E3 * g);
        var r = !1, s = !1;
        a(P).each(function (c, e) {
          if (void 0 !== y[e]) {
            var f = a(".dw-ul",
              b).eq(y[e] - 1), g = a(".dw-li", f).index(a('.dw-li[data-val="' + G[e] + '"]', f)), j = a(".dw-li", f).index(a('.dw-li[data-val="' + S[e] + '"]', f));
            a(".dw-li", f).addClass("dw-v");
            r && a(".dw-li", f).slice(g + 1).removeClass("dw-v");
            s && a(".dw-li", f).slice(0, j).removeClass("dw-v");
            r = h[e] == G[e];
            s = h[e] == S[e];
            if (!r && !s) return !1
          }
        });
        k = !1
      }, onBeforeShow: function () {
        r.mode = "scroller";
        r.showLabel = !0;
        j = O(u.temp);
        s = o(j);
        S = o(r.minTime);
        G = o(r.maxTime);
        w(I, s)
      }, onMarkupReady: function (b) {
        b.addClass("dw-timespan");
        a(".dwwl" + f, b).on("mousedown touchstart",
          function () {
            clearTimeout(C)
          })
      }
    }
  }
})(jQuery);

define("mobiscroll", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.mobiscroll;
  };
}(this)));

define('i18n/mobiscroll', [
  'jquery',
  'UTILS',
  'mobiscroll'
], function ($, Utils, mobiscroll) {

  var lang = Utils.getLang(),
    i18n = ADM.i18n.mobiscroll;

  var mobiscrolli18n = {
    label: {
      setText: i18n.setText,
      cancelText: i18n.cancelText,
      clearText: i18n.clearText,
      selectedText: i18n.selectedText,
      // Datetime component
      dateFormat: i18n.dateFormat,
      dateOrder: i18n.dateOrder,
      dayNames: i18n.dayNames,
      dayNamesShort: i18n.dayNamesShort,
      dayText: i18n.dayText,
      hourText: i18n.hourText,
      minuteText: i18n.minuteText,
      monthNames: i18n.monthNames,
      monthNamesShort: i18n.monthNamesShort,
      monthText: i18n.monthText,
      secText: i18n.secText,
      timeFormat: i18n.timeFormat,
      timeWheels: i18n.timeWheels,
      yearText: i18n.yearText,
      nowText: i18n.nowText,
      dateText: i18n.dateText,
      timeText: i18n.timeText,
      calendarText: i18n.calendarText,
      // Time / Timespan component
      labels: i18n.labels,
      labelsShort: i18n.labelsShort
    },


    // CUSTOM FORMAT ( DON'T PUT IT IN DRUPAL, DON'T CHANGE THE FORMAT )
    fr: {
      format: {
        dateFormated: "YYYY/MM/DD",
        dateFormat: 'yy-mm-dd',
        timeFormat: "HH'h'ii", // The 'h' is written this manner to escape the character in mobiscroll
        timeWheels: 'HHii'
      }
    },
    en: {
      format: {
        dateFormated: "YYYY/MM/DD",
        dateFormat: 'yy-mm-dd',
        timeFormat: 'HH:ii',
        timeWheels: 'HHii'
      }
    },
    // PUBLIC METHOD
    getDateFormated: function () {
      var _t = this;

      return _t[lang].format.dateFormated;
    },
    getDateFormat: function () {
      var _t = this;

      return _t[lang].format.dateFormat;
    },
    getTimeFormat: function () {
      var _t = this;

      return _t[lang].format.timeFormat;
    },
    getTimeWheels: function () {
      var _t = this;
      return _t[lang].format.timeWheels;
    }
  };

  $.mobiscroll.i18n[lang] = $.extend($.mobiscroll.i18n[lang], mobiscrolli18n.label);

  return mobiscrolli18n;

});
define('mobi/config', [
  'UTILS',
  'i18n/mobiscroll'
], function (Utils, Mobiscrolli18n) {


  var Config = {
    getDefaultDisplay: function () {
      return 'bubble';
    },
    getCalDefaultDisplay: function () {
      if (Utils.isMobile.any()) {
        return 'bottom';
      } else {
        return 'bubble'
      }
    },
    getTheme: function () {
      return 'wp light';
    },
    getHourPickerDefaultOptions: function () {
      var _t = this;
      return {
        scrollLock: true,
        lang: Utils.getLang(),
        mode: 'scroller',
        buttons: ['cancel', 'set'],
        setText: ADM.i18n.mobiscroll.setText,
        cancelText: ADM.i18n.mobiscroll.cancelText,
        headerText: false,
        accent: 'none',
        display: _t.getDefaultDisplay(),
        theme: 'android-ics light',
        dateFormat: Mobiscrolli18n.getDateFormat(),
        timeFormat: Mobiscrolli18n.getTimeFormat(),
        timeWheels: Mobiscrolli18n.getTimeWheels()
      }
    },
    getCalendarDefaultOptions: function () {
      var _t = this;
      return {
        scrollLock: true,
        lang: Utils.getLang(),
        mode: 'scroller',
        theme: _t.getTheme(),
        accent: 'none',
        display: _t.getCalDefaultDisplay(),
        controls: ['calendar'],
        buttons: ['cancel', 'set'],
        setText: ADM.i18n.mobiscroll.setText,
        cancelText: ADM.i18n.mobiscroll.cancelText,
        closeOnSelect: true,
        dateFormat: Mobiscrolli18n.getDateFormat()
      }
    }
  };

  return Config;
});

//! moment.js
//! version : 2.4.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

//***************************** CUSTOM VERSION TO GET MORE PRECISION FOR TIME AGO ************************************** /
// Git Repo with the modification :: https://github.com/mamzellejuu/moment/commits/develop


(function (a) {
  function b(a, b) { return function (c) { return i(a.call(this, c), b) } } function c(a, b) { return function (c) { return this.lang().ordinal(a.call(this, c), b) } } function d() { } function e(a) { u(a), g(this, a) } function f(a) { var b = o(a), c = b.year || 0, d = b.month || 0, e = b.week || 0, f = b.day || 0, g = b.hour || 0, h = b.minute || 0, i = b.second || 0, j = b.millisecond || 0; this._milliseconds = +j + 1e3 * i + 6e4 * h + 36e5 * g, this._days = +f + 7 * e, this._months = +d + 12 * c, this._data = {}, this._bubble() } function g(a, b) { for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]); return b.hasOwnProperty("toString") && (a.toString = b.toString), b.hasOwnProperty("valueOf") && (a.valueOf = b.valueOf), a } function h(a) { return 0 > a ? Math.ceil(a) : Math.floor(a) } function i(a, b) { for (var c = a + ""; c.length < b;)c = "0" + c; return c } function j(a, b, c, d) { var e, f, g = b._milliseconds, h = b._days, i = b._months; g && a._d.setTime(+a._d + g * c), (h || i) && (e = a.minute(), f = a.hour()), h && a.date(a.date() + h * c), i && a.month(a.month() + i * c), g && !d && bb.updateOffset(a), (h || i) && (a.minute(e), a.hour(f)) } function k(a) { return "[object Array]" === Object.prototype.toString.call(a) } function l(a) { return "[object Date]" === Object.prototype.toString.call(a) || a instanceof Date } function m(a, b, c) { var d, e = Math.min(a.length, b.length), f = Math.abs(a.length - b.length), g = 0; for (d = 0; e > d; d++)(c && a[d] !== b[d] || !c && q(a[d]) !== q(b[d])) && g++; return g + f } function n(a) { if (a) { var b = a.toLowerCase().replace(/(.)s$/, "$1"); a = Kb[a] || Lb[b] || b } return a } function o(a) { var b, c, d = {}; for (c in a) a.hasOwnProperty(c) && (b = n(c), b && (d[b] = a[c])); return d } function p(b) { var c, d; if (0 === b.indexOf("week")) c = 7, d = "day"; else { if (0 !== b.indexOf("month")) return; c = 12, d = "month" } bb[b] = function (e, f) { var g, h, i = bb.fn._lang[b], j = []; if ("number" == typeof e && (f = e, e = a), h = function (a) { var b = bb().utc().set(d, a); return i.call(bb.fn._lang, b, e || "") }, null != f) return h(f); for (g = 0; c > g; g++)j.push(h(g)); return j } } function q(a) { var b = +a, c = 0; return 0 !== b && isFinite(b) && (c = b >= 0 ? Math.floor(b) : Math.ceil(b)), c } function r(a, b) { return new Date(Date.UTC(a, b + 1, 0)).getUTCDate() } function s(a) { return t(a) ? 366 : 365 } function t(a) { return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0 } function u(a) { var b; a._a && -2 === a._pf.overflow && (b = a._a[gb] < 0 || a._a[gb] > 11 ? gb : a._a[hb] < 1 || a._a[hb] > r(a._a[fb], a._a[gb]) ? hb : a._a[ib] < 0 || a._a[ib] > 23 ? ib : a._a[jb] < 0 || a._a[jb] > 59 ? jb : a._a[kb] < 0 || a._a[kb] > 59 ? kb : a._a[lb] < 0 || a._a[lb] > 999 ? lb : -1, a._pf._overflowDayOfYear && (fb > b || b > hb) && (b = hb), a._pf.overflow = b) } function v(a) { a._pf = { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1 } } function w(a) { return null == a._isValid && (a._isValid = !isNaN(a._d.getTime()) && a._pf.overflow < 0 && !a._pf.empty && !a._pf.invalidMonth && !a._pf.nullInput && !a._pf.invalidFormat && !a._pf.userInvalidated, a._strict && (a._isValid = a._isValid && 0 === a._pf.charsLeftOver && 0 === a._pf.unusedTokens.length)), a._isValid } function x(a) { return a ? a.toLowerCase().replace("_", "-") : a } function y(a, b) { return b.abbr = a, mb[a] || (mb[a] = new d), mb[a].set(b), mb[a] } function z(a) { delete mb[a] } function A(a) { var b, c, d, e, f = 0, g = function (a) { if (!mb[a] && nb) try { require("./lang/" + a) } catch (b) { } return mb[a] }; if (!a) return bb.fn._lang; if (!k(a)) { if (c = g(a)) return c; a = [a] } for (; f < a.length;) { for (e = x(a[f]).split("-"), b = e.length, d = x(a[f + 1]), d = d ? d.split("-") : null; b > 0;) { if (c = g(e.slice(0, b).join("-"))) return c; if (d && d.length >= b && m(e, d, !0) >= b - 1) break; b-- } f++ } return bb.fn._lang } function B(a) { return a.match(/\[[\s\S]/) ? a.replace(/^\[|\]$/g, "") : a.replace(/\\/g, "") } function C(a) { var b, c, d = a.match(rb); for (b = 0, c = d.length; c > b; b++)d[b] = Pb[d[b]] ? Pb[d[b]] : B(d[b]); return function (e) { var f = ""; for (b = 0; c > b; b++)f += d[b] instanceof Function ? d[b].call(e, a) : d[b]; return f } } function D(a, b) { return a.isValid() ? (b = E(b, a.lang()), Mb[b] || (Mb[b] = C(b)), Mb[b](a)) : a.lang().invalidDate() } function E(a, b) { function c(a) { return b.longDateFormat(a) || a } var d = 5; for (sb.lastIndex = 0; d >= 0 && sb.test(a);)a = a.replace(sb, c), sb.lastIndex = 0, d -= 1; return a } function F(a, b) { var c; switch (a) { case "DDDD": return vb; case "YYYY": case "GGGG": case "gggg": return wb; case "YYYYY": case "GGGGG": case "ggggg": return xb; case "S": case "SS": case "SSS": case "DDD": return ub; case "MMM": case "MMMM": case "dd": case "ddd": case "dddd": return zb; case "a": case "A": return A(b._l)._meridiemParse; case "X": return Cb; case "Z": case "ZZ": return Ab; case "T": return Bb; case "SSSS": return yb; case "MM": case "DD": case "YY": case "GG": case "gg": case "HH": case "hh": case "mm": case "ss": case "M": case "D": case "d": case "H": case "h": case "m": case "s": case "w": case "ww": case "W": case "WW": case "e": case "E": return tb; default: return c = new RegExp(N(M(a.replace("\\", "")), "i")) } } function G(a) { var b = (Ab.exec(a) || [])[0], c = (b + "").match(Hb) || ["-", 0, 0], d = +(60 * c[1]) + q(c[2]); return "+" === c[0] ? -d : d } function H(a, b, c) { var d, e = c._a; switch (a) { case "M": case "MM": null != b && (e[gb] = q(b) - 1); break; case "MMM": case "MMMM": d = A(c._l).monthsParse(b), null != d ? e[gb] = d : c._pf.invalidMonth = b; break; case "D": case "DD": null != b && (e[hb] = q(b)); break; case "DDD": case "DDDD": null != b && (c._dayOfYear = q(b)); break; case "YY": e[fb] = q(b) + (q(b) > 68 ? 1900 : 2e3); break; case "YYYY": case "YYYYY": e[fb] = q(b); break; case "a": case "A": c._isPm = A(c._l).isPM(b); break; case "H": case "HH": case "h": case "hh": e[ib] = q(b); break; case "m": case "mm": e[jb] = q(b); break; case "s": case "ss": e[kb] = q(b); break; case "S": case "SS": case "SSS": case "SSSS": e[lb] = q(1e3 * ("0." + b)); break; case "X": c._d = new Date(1e3 * parseFloat(b)); break; case "Z": case "ZZ": c._useUTC = !0, c._tzm = G(b); break; case "w": case "ww": case "W": case "WW": case "d": case "dd": case "ddd": case "dddd": case "e": case "E": a = a.substr(0, 1); case "gg": case "gggg": case "GG": case "GGGG": case "GGGGG": a = a.substr(0, 2), b && (c._w = c._w || {}, c._w[a] = b) } } function I(a) { var b, c, d, e, f, g, h, i, j, k, l = []; if (!a._d) { for (d = K(a), a._w && null == a._a[hb] && null == a._a[gb] && (f = function (b) { return b ? b.length < 3 ? parseInt(b, 10) > 68 ? "19" + b : "20" + b : b : null == a._a[fb] ? bb().weekYear() : a._a[fb] }, g = a._w, null != g.GG || null != g.W || null != g.E ? h = X(f(g.GG), g.W || 1, g.E, 4, 1) : (i = A(a._l), j = null != g.d ? T(g.d, i) : null != g.e ? parseInt(g.e, 10) + i._week.dow : 0, k = parseInt(g.w, 10) || 1, null != g.d && j < i._week.dow && k++, h = X(f(g.gg), k, j, i._week.doy, i._week.dow)), a._a[fb] = h.year, a._dayOfYear = h.dayOfYear), a._dayOfYear && (e = null == a._a[fb] ? d[fb] : a._a[fb], a._dayOfYear > s(e) && (a._pf._overflowDayOfYear = !0), c = S(e, 0, a._dayOfYear), a._a[gb] = c.getUTCMonth(), a._a[hb] = c.getUTCDate()), b = 0; 3 > b && null == a._a[b]; ++b)a._a[b] = l[b] = d[b]; for (; 7 > b; b++)a._a[b] = l[b] = null == a._a[b] ? 2 === b ? 1 : 0 : a._a[b]; l[ib] += q((a._tzm || 0) / 60), l[jb] += q((a._tzm || 0) % 60), a._d = (a._useUTC ? S : R).apply(null, l) } } function J(a) { var b; a._d || (b = o(a._i), a._a = [b.year, b.month, b.day, b.hour, b.minute, b.second, b.millisecond], I(a)) } function K(a) { var b = new Date; return a._useUTC ? [b.getUTCFullYear(), b.getUTCMonth(), b.getUTCDate()] : [b.getFullYear(), b.getMonth(), b.getDate()] } function L(a) { a._a = [], a._pf.empty = !0; var b, c, d, e, f, g = A(a._l), h = "" + a._i, i = h.length, j = 0; for (d = E(a._f, g).match(rb) || [], b = 0; b < d.length; b++)e = d[b], c = (F(e, a).exec(h) || [])[0], c && (f = h.substr(0, h.indexOf(c)), f.length > 0 && a._pf.unusedInput.push(f), h = h.slice(h.indexOf(c) + c.length), j += c.length), Pb[e] ? (c ? a._pf.empty = !1 : a._pf.unusedTokens.push(e), H(e, c, a)) : a._strict && !c && a._pf.unusedTokens.push(e); a._pf.charsLeftOver = i - j, h.length > 0 && a._pf.unusedInput.push(h), a._isPm && a._a[ib] < 12 && (a._a[ib] += 12), a._isPm === !1 && 12 === a._a[ib] && (a._a[ib] = 0), I(a), u(a) } function M(a) { return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (a, b, c, d, e) { return b || c || d || e }) } function N(a) { return a.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") } function O(a) { var b, c, d, e, f; if (0 === a._f.length) return a._pf.invalidFormat = !0, a._d = new Date(0 / 0), void 0; for (e = 0; e < a._f.length; e++)f = 0, b = g({}, a), v(b), b._f = a._f[e], L(b), w(b) && (f += b._pf.charsLeftOver, f += 10 * b._pf.unusedTokens.length, b._pf.score = f, (null == d || d > f) && (d = f, c = b)); g(a, c || b) } function P(a) { var b, c = a._i, d = Db.exec(c); if (d) { for (a._pf.iso = !0, b = 4; b > 0; b--)if (d[b]) { a._f = Fb[b - 1] + (d[6] || " "); break } for (b = 0; 4 > b; b++)if (Gb[b][1].exec(c)) { a._f += Gb[b][0]; break } Ab.exec(c) && (a._f += "Z"), L(a) } else a._d = new Date(c) } function Q(b) { var c = b._i, d = ob.exec(c); c === a ? b._d = new Date : d ? b._d = new Date(+d[1]) : "string" == typeof c ? P(b) : k(c) ? (b._a = c.slice(0), I(b)) : l(c) ? b._d = new Date(+c) : "object" == typeof c ? J(b) : b._d = new Date(c) } function R(a, b, c, d, e, f, g) { var h = new Date(a, b, c, d, e, f, g); return 1970 > a && h.setFullYear(a), h } function S(a) { var b = new Date(Date.UTC.apply(null, arguments)); return 1970 > a && b.setUTCFullYear(a), b } function T(a, b) { if ("string" == typeof a) if (isNaN(a)) { if (a = b.weekdaysParse(a), "number" != typeof a) return null } else a = parseInt(a, 10); return a } function U(a, b, c, d, e) { return e.relativeTime(b || 1, !!c, a, d) } function V(a, b, c) { var d = eb(Math.abs(a) / 1e3), e = eb(d / 60), f = eb(e / 60), g = eb(f / 24), h = eb(g / 365), i = 60 > d && ["s", d] || 1 === e && ["m"] || 60 > e && ["mm", e] || 1 === f && ["h"] || 24 > f && ["hh", f] || 1 === g && ["d"] || 25 >= g && ["dd", g] || 45 >= g && ["M"] || 345 > g && ["MM", eb(g / 30)] || 1 === h && ["y"] || ["yy", h]; return i[2] = b, i[3] = a > 0, i[4] = c, U.apply({}, i) } function W(a, b, c) { var d, e = c - b, f = c - a.day(); return f > e && (f -= 7), e - 7 > f && (f += 7), d = bb(a).add("d", f), { week: Math.ceil(d.dayOfYear() / 7), year: d.year() } } function X(a, b, c, d, e) { var f, g, h = new Date(Date.UTC(a, 0)).getUTCDay(); return c = null != c ? c : e, f = e - h + (h > d ? 7 : 0), g = 7 * (b - 1) + (c - e) + f + 1, { year: g > 0 ? a : a - 1, dayOfYear: g > 0 ? g : s(a - 1) + g } } function Y(a) { var b = a._i, c = a._f; return "undefined" == typeof a._pf && v(a), null === b ? bb.invalid({ nullInput: !0 }) : ("string" == typeof b && (a._i = b = A().preparse(b)), bb.isMoment(b) ? (a = g({}, b), a._d = new Date(+b._d)) : c ? k(c) ? O(a) : L(a) : Q(a), new e(a)) } function Z(a, b) { bb.fn[a] = bb.fn[a + "s"] = function (a) { var c = this._isUTC ? "UTC" : ""; return null != a ? (this._d["set" + c + b](a), bb.updateOffset(this), this) : this._d["get" + c + b]() } } function $(a) { bb.duration.fn[a] = function () { return this._data[a] } } function _(a, b) { bb.duration.fn["as" + a] = function () { return +this / b } } function ab(a) { var b = !1, c = bb; "undefined" == typeof ender && (this.moment = a ? function () { return !b && console && console.warn && (b = !0, console.warn("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.")), c.apply(null, arguments) } : bb) } for (var bb, cb, db = "2.4.0", eb = Math.floor, fb = 0, gb = 1, hb = 2, ib = 3, jb = 4, kb = 5, lb = 6, mb = {}, nb = "undefined" != typeof module && module.exports && "undefined" != typeof require, ob = /^\/?Date\((\-?\d+)/i, pb = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, qb = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, rb = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g, sb = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, tb = /\d\d?/, ub = /\d{1,3}/, vb = /\d{3}/, wb = /\d{1,4}/, xb = /[+\-]?\d{1,6}/, yb = /\d+/, zb = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, Ab = /Z|[\+\-]\d\d:?\d\d/i, Bb = /T/i, Cb = /[\+\-]?\d+(\.\d{1,3})?/, Db = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d:?\d\d|Z)?)?$/, Eb = "YYYY-MM-DDTHH:mm:ssZ", Fb = ["YYYY-MM-DD", "GGGG-[W]WW", "GGGG-[W]WW-E", "YYYY-DDD"], Gb = [["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d{1,3}/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]], Hb = /([\+\-]|\d\d)/gi, Ib = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), Jb = { Milliseconds: 1, Seconds: 1e3, Minutes: 6e4, Hours: 36e5, Days: 864e5, Months: 2592e6, Years: 31536e6 }, Kb = { ms: "millisecond", s: "second", m: "minute", h: "hour", d: "day", D: "date", w: "week", W: "isoWeek", M: "month", y: "year", DDD: "dayOfYear", e: "weekday", E: "isoWeekday", gg: "weekYear", GG: "isoWeekYear" }, Lb = { dayofyear: "dayOfYear", isoweekday: "isoWeekday", isoweek: "isoWeek", weekyear: "weekYear", isoweekyear: "isoWeekYear" }, Mb = {}, Nb = "DDD w W M D d".split(" "), Ob = "M D H h m s w W".split(" "), Pb = { M: function () { return this.month() + 1 }, MMM: function (a) { return this.lang().monthsShort(this, a) }, MMMM: function (a) { return this.lang().months(this, a) }, D: function () { return this.date() }, DDD: function () { return this.dayOfYear() }, d: function () { return this.day() }, dd: function (a) { return this.lang().weekdaysMin(this, a) }, ddd: function (a) { return this.lang().weekdaysShort(this, a) }, dddd: function (a) { return this.lang().weekdays(this, a) }, w: function () { return this.week() }, W: function () { return this.isoWeek() }, YY: function () { return i(this.year() % 100, 2) }, YYYY: function () { return i(this.year(), 4) }, YYYYY: function () { return i(this.year(), 5) }, gg: function () { return i(this.weekYear() % 100, 2) }, gggg: function () { return this.weekYear() }, ggggg: function () { return i(this.weekYear(), 5) }, GG: function () { return i(this.isoWeekYear() % 100, 2) }, GGGG: function () { return this.isoWeekYear() }, GGGGG: function () { return i(this.isoWeekYear(), 5) }, e: function () { return this.weekday() }, E: function () { return this.isoWeekday() }, a: function () { return this.lang().meridiem(this.hours(), this.minutes(), !0) }, A: function () { return this.lang().meridiem(this.hours(), this.minutes(), !1) }, H: function () { return this.hours() }, h: function () { return this.hours() % 12 || 12 }, m: function () { return this.minutes() }, s: function () { return this.seconds() }, S: function () { return q(this.milliseconds() / 100) }, SS: function () { return i(q(this.milliseconds() / 10), 2) }, SSS: function () { return i(this.milliseconds(), 3) }, SSSS: function () { return i(this.milliseconds(), 3) }, Z: function () { var a = -this.zone(), b = "+"; return 0 > a && (a = -a, b = "-"), b + i(q(a / 60), 2) + ":" + i(q(a) % 60, 2) }, ZZ: function () { var a = -this.zone(), b = "+"; return 0 > a && (a = -a, b = "-"), b + i(q(10 * a / 6), 4) }, z: function () { return this.zoneAbbr() }, zz: function () { return this.zoneName() }, X: function () { return this.unix() } }, Qb = ["months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin"]; Nb.length;)cb = Nb.pop(), Pb[cb + "o"] = c(Pb[cb], cb); for (; Ob.length;)cb = Ob.pop(), Pb[cb + cb] = b(Pb[cb], 2); for (Pb.DDDD = b(Pb.DDD, 3), g(d.prototype, { set: function (a) { var b, c; for (c in a) b = a[c], "function" == typeof b ? this[c] = b : this["_" + c] = b }, _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), months: function (a) { return this._months[a.month()] }, _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), monthsShort: function (a) { return this._monthsShort[a.month()] }, monthsParse: function (a) { var b, c, d; for (this._monthsParse || (this._monthsParse = []), b = 0; 12 > b; b++)if (this._monthsParse[b] || (c = bb.utc([2e3, b]), d = "^" + this.months(c, "") + "|^" + this.monthsShort(c, ""), this._monthsParse[b] = new RegExp(d.replace(".", ""), "i")), this._monthsParse[b].test(a)) return b }, _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdays: function (a) { return this._weekdays[a.day()] }, _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysShort: function (a) { return this._weekdaysShort[a.day()] }, _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), weekdaysMin: function (a) { return this._weekdaysMin[a.day()] }, weekdaysParse: function (a) { var b, c, d; for (this._weekdaysParse || (this._weekdaysParse = []), b = 0; 7 > b; b++)if (this._weekdaysParse[b] || (c = bb([2e3, 1]).day(b), d = "^" + this.weekdays(c, "") + "|^" + this.weekdaysShort(c, "") + "|^" + this.weekdaysMin(c, ""), this._weekdaysParse[b] = new RegExp(d.replace(".", ""), "i")), this._weekdaysParse[b].test(a)) return b }, _longDateFormat: { LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D YYYY", LLL: "MMMM D YYYY LT", LLLL: "dddd, MMMM D YYYY LT" }, longDateFormat: function (a) { var b = this._longDateFormat[a]; return !b && this._longDateFormat[a.toUpperCase()] && (b = this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (a) { return a.slice(1) }), this._longDateFormat[a] = b), b }, isPM: function (a) { return "p" === (a + "").toLowerCase().charAt(0) }, _meridiemParse: /[ap]\.?m?\.?/i, meridiem: function (a, b, c) { return a > 11 ? c ? "pm" : "PM" : c ? "am" : "AM" }, _calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, calendar: function (a, b) { var c = this._calendar[a]; return "function" == typeof c ? c.apply(b) : c }, _relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, relativeTime: function (a, b, c, d) { var e = this._relativeTime[c]; return "function" == typeof e ? e(a, b, c, d) : e.replace(/%d/i, a) }, pastFuture: function (a, b) { var c = this._relativeTime[a > 0 ? "future" : "past"]; return "function" == typeof c ? c(b) : c.replace(/%s/i, b) }, ordinal: function (a) { return this._ordinal.replace("%d", a) }, _ordinal: "%d", preparse: function (a) { return a }, postformat: function (a) { return a }, week: function (a) { return W(a, this._week.dow, this._week.doy).week }, _week: { dow: 0, doy: 6 }, _invalidDate: "Invalid date", invalidDate: function () { return this._invalidDate } }), bb = function (b, c, d, e) { return "boolean" == typeof d && (e = d, d = a), Y({ _i: b, _f: c, _l: d, _strict: e, _isUTC: !1 }) }, bb.utc = function (b, c, d, e) { var f; return "boolean" == typeof d && (e = d, d = a), f = Y({ _useUTC: !0, _isUTC: !0, _l: d, _i: b, _f: c, _strict: e }).utc() }, bb.unix = function (a) { return bb(1e3 * a) }, bb.duration = function (a, b) { var c, d, e, g = a, h = null; return bb.isDuration(a) ? g = { ms: a._milliseconds, d: a._days, M: a._months } : "number" == typeof a ? (g = {}, b ? g[b] = a : g.milliseconds = a) : (h = pb.exec(a)) ? (c = "-" === h[1] ? -1 : 1, g = { y: 0, d: q(h[hb]) * c, h: q(h[ib]) * c, m: q(h[jb]) * c, s: q(h[kb]) * c, ms: q(h[lb]) * c }) : (h = qb.exec(a)) && (c = "-" === h[1] ? -1 : 1, e = function (a) { var b = a && parseFloat(a.replace(",", ".")); return (isNaN(b) ? 0 : b) * c }, g = { y: e(h[2]), M: e(h[3]), d: e(h[4]), h: e(h[5]), m: e(h[6]), s: e(h[7]), w: e(h[8]) }), d = new f(g), bb.isDuration(a) && a.hasOwnProperty("_lang") && (d._lang = a._lang), d }, bb.version = db, bb.defaultFormat = Eb, bb.updateOffset = function () { }, bb.lang = function (a, b) { var c; return a ? (b ? y(x(a), b) : null === b ? (z(a), a = "en") : mb[a] || A(a), c = bb.duration.fn._lang = bb.fn._lang = A(a), c._abbr) : bb.fn._lang._abbr }, bb.langData = function (a) { return a && a._lang && a._lang._abbr && (a = a._lang._abbr), A(a) }, bb.isMoment = function (a) { return a instanceof e }, bb.isDuration = function (a) { return a instanceof f }, cb = Qb.length - 1; cb >= 0; --cb)p(Qb[cb]); for (bb.normalizeUnits = function (a) { return n(a) }, bb.invalid = function (a) { var b = bb.utc(0 / 0); return null != a ? g(b._pf, a) : b._pf.userInvalidated = !0, b }, bb.parseZone = function (a) { return bb(a).parseZone() }, g(bb.fn = e.prototype, { clone: function () { return bb(this) }, valueOf: function () { return +this._d + 6e4 * (this._offset || 0) }, unix: function () { return Math.floor(+this / 1e3) }, toString: function () { return this.clone().lang("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ") }, toDate: function () { return this._offset ? new Date(+this) : this._d }, toISOString: function () { return D(bb(this).utc(), "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") }, toArray: function () { var a = this; return [a.year(), a.month(), a.date(), a.hours(), a.minutes(), a.seconds(), a.milliseconds()] }, isValid: function () { return w(this) }, isDSTShifted: function () { return this._a ? this.isValid() && m(this._a, (this._isUTC ? bb.utc(this._a) : bb(this._a)).toArray()) > 0 : !1 }, parsingFlags: function () { return g({}, this._pf) }, invalidAt: function () { return this._pf.overflow }, utc: function () { return this.zone(0) }, local: function () { return this.zone(0), this._isUTC = !1, this }, format: function (a) { var b = D(this, a || bb.defaultFormat); return this.lang().postformat(b) }, add: function (a, b) { var c; return c = "string" == typeof a ? bb.duration(+b, a) : bb.duration(a, b), j(this, c, 1), this }, subtract: function (a, b) { var c; return c = "string" == typeof a ? bb.duration(+b, a) : bb.duration(a, b), j(this, c, -1), this }, diff: function (a, b, c) { var d, e, f = this._isUTC ? bb(a).zone(this._offset || 0) : bb(a).local(), g = 6e4 * (this.zone() - f.zone()); return b = n(b), "year" === b || "month" === b ? (d = 432e5 * (this.daysInMonth() + f.daysInMonth()), e = 12 * (this.year() - f.year()) + (this.month() - f.month()), e += (this - bb(this).startOf("month") - (f - bb(f).startOf("month"))) / d, e -= 6e4 * (this.zone() - bb(this).startOf("month").zone() - (f.zone() - bb(f).startOf("month").zone())) / d, "year" === b && (e /= 12)) : (d = this - f, e = "second" === b ? d / 1e3 : "minute" === b ? d / 6e4 : "hour" === b ? d / 36e5 : "day" === b ? (d - g) / 864e5 : "week" === b ? (d - g) / 6048e5 : d), c ? e : h(e) }, from: function (a, b) { return bb.duration(this.diff(a)).lang(this.lang()._abbr).humanize(!b) }, fromNow: function (a) { return this.from(bb(), a) }, calendar: function () { var a = this.diff(bb().zone(this.zone()).startOf("day"), "days", !0), b = -6 > a ? "sameElse" : -1 > a ? "lastWeek" : 0 > a ? "lastDay" : 1 > a ? "sameDay" : 2 > a ? "nextDay" : 7 > a ? "nextWeek" : "sameElse"; return this.format(this.lang().calendar(b, this)) }, isLeapYear: function () { return t(this.year()) }, isDST: function () { return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone() }, day: function (a) { var b = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return null != a ? (a = T(a, this.lang()), this.add({ d: a - b })) : b }, month: function (a) { var b, c = this._isUTC ? "UTC" : ""; return null != a ? "string" == typeof a && (a = this.lang().monthsParse(a), "number" != typeof a) ? this : (b = this.date(), this.date(1), this._d["set" + c + "Month"](a), this.date(Math.min(b, this.daysInMonth())), bb.updateOffset(this), this) : this._d["get" + c + "Month"]() }, startOf: function (a) { switch (a = n(a)) { case "year": this.month(0); case "month": this.date(1); case "week": case "isoWeek": case "day": this.hours(0); case "hour": this.minutes(0); case "minute": this.seconds(0); case "second": this.milliseconds(0) }return "week" === a ? this.weekday(0) : "isoWeek" === a && this.isoWeekday(1), this }, endOf: function (a) { return a = n(a), this.startOf(a).add("isoWeek" === a ? "week" : a, 1).subtract("ms", 1) }, isAfter: function (a, b) { return b = "undefined" != typeof b ? b : "millisecond", +this.clone().startOf(b) > +bb(a).startOf(b) }, isBefore: function (a, b) { return b = "undefined" != typeof b ? b : "millisecond", +this.clone().startOf(b) < +bb(a).startOf(b) }, isSame: function (a, b) { return b = "undefined" != typeof b ? b : "millisecond", +this.clone().startOf(b) === +bb(a).startOf(b) }, min: function (a) { return a = bb.apply(null, arguments), this > a ? this : a }, max: function (a) { return a = bb.apply(null, arguments), a > this ? this : a }, zone: function (a) { var b = this._offset || 0; return null == a ? this._isUTC ? b : this._d.getTimezoneOffset() : ("string" == typeof a && (a = G(a)), Math.abs(a) < 16 && (a = 60 * a), this._offset = a, this._isUTC = !0, b !== a && j(this, bb.duration(b - a, "m"), 1, !0), this) }, zoneAbbr: function () { return this._isUTC ? "UTC" : "" }, zoneName: function () { return this._isUTC ? "Coordinated Universal Time" : "" }, parseZone: function () { return "string" == typeof this._i && this.zone(this._i), this }, hasAlignedHourOffset: function (a) { return a = a ? bb(a).zone() : 0, (this.zone() - a) % 60 === 0 }, daysInMonth: function () { return r(this.year(), this.month()) }, dayOfYear: function (a) { var b = eb((bb(this).startOf("day") - bb(this).startOf("year")) / 864e5) + 1; return null == a ? b : this.add("d", a - b) }, weekYear: function (a) { var b = W(this, this.lang()._week.dow, this.lang()._week.doy).year; return null == a ? b : this.add("y", a - b) }, isoWeekYear: function (a) { var b = W(this, 1, 4).year; return null == a ? b : this.add("y", a - b) }, week: function (a) { var b = this.lang().week(this); return null == a ? b : this.add("d", 7 * (a - b)) }, isoWeek: function (a) { var b = W(this, 1, 4).week; return null == a ? b : this.add("d", 7 * (a - b)) }, weekday: function (a) { var b = (this.day() + 7 - this.lang()._week.dow) % 7; return null == a ? b : this.add("d", a - b) }, isoWeekday: function (a) { return null == a ? this.day() || 7 : this.day(this.day() % 7 ? a : a - 7) }, get: function (a) { return a = n(a), this[a]() }, set: function (a, b) { return a = n(a), "function" == typeof this[a] && this[a](b), this }, lang: function (b) { return b === a ? this._lang : (this._lang = A(b), this) } }), cb = 0; cb < Ib.length; cb++)Z(Ib[cb].toLowerCase().replace(/s$/, ""), Ib[cb]); Z("year", "FullYear"), bb.fn.days = bb.fn.day, bb.fn.months = bb.fn.month, bb.fn.weeks = bb.fn.week, bb.fn.isoWeeks = bb.fn.isoWeek, bb.fn.toJSON = bb.fn.toISOString, g(bb.duration.fn = f.prototype, { _bubble: function () { var a, b, c, d, e = this._milliseconds, f = this._days, g = this._months, i = this._data; i.milliseconds = e % 1e3, a = h(e / 1e3), i.seconds = a % 60, b = h(a / 60), i.minutes = b % 60, c = h(b / 60), i.hours = c % 24, f += h(c / 24), i.days = f % 30, g += h(f / 30), i.months = g % 12, d = h(g / 12), i.years = d }, weeks: function () { return h(this.days() / 7) }, valueOf: function () { return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * q(this._months / 12) }, humanize: function (a) { var b = +this, c = V(b, !a, this.lang()); return a && (c = this.lang().pastFuture(b, c)), this.lang().postformat(c) }, add: function (a, b) { var c = bb.duration(a, b); return this._milliseconds += c._milliseconds, this._days += c._days, this._months += c._months, this._bubble(), this }, subtract: function (a, b) { var c = bb.duration(a, b); return this._milliseconds -= c._milliseconds, this._days -= c._days, this._months -= c._months, this._bubble(), this }, get: function (a) { return a = n(a), this[a.toLowerCase() + "s"]() }, as: function (a) { return a = n(a), this["as" + a.charAt(0).toUpperCase() + a.slice(1) + "s"]() }, lang: bb.fn.lang, toIsoString: function () { var a = Math.abs(this.years()), b = Math.abs(this.months()), c = Math.abs(this.days()), d = Math.abs(this.hours()), e = Math.abs(this.minutes()), f = Math.abs(this.seconds() + this.milliseconds() / 1e3); return this.asSeconds() ? (this.asSeconds() < 0 ? "-" : "") + "P" + (a ? a + "Y" : "") + (b ? b + "M" : "") + (c ? c + "D" : "") + (d || e || f ? "T" : "") + (d ? d + "H" : "") + (e ? e + "M" : "") + (f ? f + "S" : "") : "P0D" } }); for (cb in Jb) Jb.hasOwnProperty(cb) && (_(cb, Jb[cb]), $(cb.toLowerCase())); _("Weeks", 6048e5), bb.duration.fn.asMonths = function () { return (+this - 31536e6 * this.years()) / 2592e6 + 12 * this.years() }, bb.lang("en", { ordinal: function (a) { var b = a % 10, c = 1 === q(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c } }), function (a) { a(bb) }(function (a) { return a.lang("ar-ma", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 6, doy: 12 } }) }), function (a) { a(bb) }(function (a) { return a.lang("ar", { months: "يناير/ كانون الثاني_فبراير/ شباط_مارس/ آذار_أبريل/ نيسان_مايو/ أيار_يونيو/ حزيران_يوليو/ تموز_أغسطس/ آب_سبتمبر/ أيلول_أكتوبر/ تشرين الأول_نوفمبر/ تشرين الثاني_ديسمبر/ كانون الأول".split("_"), monthsShort: "يناير/ كانون الثاني_فبراير/ شباط_مارس/ آذار_أبريل/ نيسان_مايو/ أيار_يونيو/ حزيران_يوليو/ تموز_أغسطس/ آب_سبتمبر/ أيلول_أكتوبر/ تشرين الأول_نوفمبر/ تشرين الثاني_ديسمبر/ كانون الأول".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 6, doy: 12 } }) }), function (a) { a(bb) }(function (a) { return a.lang("bg", { months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"), monthsShort: "янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"), weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"), weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "H:mm", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Днес в] LT", nextDay: "[Утре в] LT", nextWeek: "dddd [в] LT", lastDay: "[Вчера в] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: case 6: return "[В изминалата] dddd [в] LT"; case 1: case 2: case 4: case 5: return "[В изминалия] dddd [в] LT" } }, sameElse: "L" }, relativeTime: { future: "след %s", past: "преди %s", s: "няколко секунди", m: "минута", mm: "%d минути", h: "час", hh: "%d часа", d: "ден", dd: "%d дни", M: "месец", MM: "%d месеца", y: "година", yy: "%d години" }, ordinal: function (a) { var b = a % 10, c = a % 100; return 0 === a ? a + "-ев" : 0 === c ? a + "-ен" : c > 10 && 20 > c ? a + "-ти" : 1 === b ? a + "-ви" : 2 === b ? a + "-ри" : 7 === b || 8 === b ? a + "-ми" : a + "-ти" }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (b) { function c(a, b, c) { var d = { mm: "munutenn", MM: "miz", dd: "devezh" }; return a + " " + f(d[c], a) } function d(a) { switch (e(a)) { case 1: case 3: case 4: case 5: case 9: return a + " bloaz"; default: return a + " vloaz" } } function e(a) { return a > 9 ? e(a % 10) : a } function f(a, b) { return 2 === b ? g(a) : a } function g(b) { var c = { m: "v", b: "v", d: "z" }; return c[b.charAt(0)] === a ? b : c[b.charAt(0)] + b.substring(1) } return b.lang("br", { months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"), monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"), weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"), weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"), weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"), longDateFormat: { LT: "h[e]mm A", L: "DD/MM/YYYY", LL: "D [a viz] MMMM YYYY", LLL: "D [a viz] MMMM YYYY LT", LLLL: "dddd, D [a viz] MMMM YYYY LT" }, calendar: { sameDay: "[Hiziv da] LT", nextDay: "[Warc'hoazh da] LT", nextWeek: "dddd [da] LT", lastDay: "[Dec'h da] LT", lastWeek: "dddd [paset da] LT", sameElse: "L" }, relativeTime: { future: "a-benn %s", past: "%s 'zo", s: "un nebeud segondennoù", m: "ur vunutenn", mm: c, h: "un eur", hh: "%d eur", d: "un devezh", dd: c, M: "ur miz", MM: c, y: "ur bloaz", yy: d }, ordinal: function (a) { var b = 1 === a ? "añ" : "vet"; return a + b }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = a + " "; switch (c) { case "m": return b ? "jedna minuta" : "jedne minute"; case "mm": return d += 1 === a ? "minuta" : 2 === a || 3 === a || 4 === a ? "minute" : "minuta"; case "h": return b ? "jedan sat" : "jednog sata"; case "hh": return d += 1 === a ? "sat" : 2 === a || 3 === a || 4 === a ? "sata" : "sati"; case "dd": return d += 1 === a ? "dan" : "dana"; case "MM": return d += 1 === a ? "mjesec" : 2 === a || 3 === a || 4 === a ? "mjeseca" : "mjeseci"; case "yy": return d += 1 === a ? "godina" : 2 === a || 3 === a || 4 === a ? "godine" : "godina" } } return a.lang("bs", { months: "januar_februar_mart_april_maj_juni_juli_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"), weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), longDateFormat: { LT: "H:mm", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd, D. MMMM YYYY LT" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () { switch (this.day()) { case 0: return "[u] [nedjelju] [u] LT"; case 3: return "[u] [srijedu] [u] LT"; case 6: return "[u] [subotu] [u] LT"; case 1: case 2: case 4: case 5: return "[u] dddd [u] LT" } }, lastDay: "[jučer u] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: return "[prošlu] dddd [u] LT"; case 6: return "[prošle] [subote] [u] LT"; case 1: case 2: case 4: case 5: return "[prošli] dddd [u] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", m: b, mm: b, h: b, hh: b, d: "dan", dd: b, M: "mjesec", MM: b, y: "godinu", yy: b }, ordinal: "%d.", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("ca", { months: "Gener_Febrer_Març_Abril_Maig_Juny_Juliol_Agost_Setembre_Octubre_Novembre_Desembre".split("_"), monthsShort: "Gen._Febr._Mar._Abr._Mai._Jun._Jul._Ag._Set._Oct._Nov._Des.".split("_"), weekdays: "Diumenge_Dilluns_Dimarts_Dimecres_Dijous_Divendres_Dissabte".split("_"), weekdaysShort: "Dg._Dl._Dt._Dc._Dj._Dv._Ds.".split("_"), weekdaysMin: "Dg_Dl_Dt_Dc_Dj_Dv_Ds".split("_"), longDateFormat: { LT: "H:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: function () { return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, nextDay: function () { return "[demà a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, nextWeek: function () { return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, lastDay: function () { return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, lastWeek: function () { return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, sameElse: "L" }, relativeTime: { future: "en %s", past: "fa %s", s: "uns segons", m: "un minut", mm: "%d minuts", h: "una hora", hh: "%d hores", d: "un dia", dd: "%d dies", M: "un mes", MM: "%d mesos", y: "un any", yy: "%d anys" }, ordinal: "%dº", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) {
    function b(a) { return a > 1 && 5 > a && 1 !== ~~(a / 10) } function c(a, c, d, e) {
      var f = a + " "; switch (d) {
        case "s": return c || e ? "pár vteřin" : "pár vteřinami";
        case "m": return c ? "minuta" : e ? "minutu" : "minutou"; case "mm": return c || e ? f + (b(a) ? "minuty" : "minut") : f + "minutami"; break; case "h": return c ? "hodina" : e ? "hodinu" : "hodinou"; case "hh": return c || e ? f + (b(a) ? "hodiny" : "hodin") : f + "hodinami"; break; case "d": return c || e ? "den" : "dnem"; case "dd": return c || e ? f + (b(a) ? "dny" : "dní") : f + "dny"; break; case "M": return c || e ? "měsíc" : "měsícem"; case "MM": return c || e ? f + (b(a) ? "měsíce" : "měsíců") : f + "měsíci"; break; case "y": return c || e ? "rok" : "rokem"; case "yy": return c || e ? f + (b(a) ? "roky" : "let") : f + "lety"
      }
    } var d = "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"), e = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"); return a.lang("cs", { months: d, monthsShort: e, monthsParse: function (a, b) { var c, d = []; for (c = 0; 12 > c; c++)d[c] = new RegExp("^" + a[c] + "$|^" + b[c] + "$", "i"); return d }(d, e), weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"), weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"), weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"), longDateFormat: { LT: "H:mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd D. MMMM YYYY LT" }, calendar: { sameDay: "[dnes v] LT", nextDay: "[zítra v] LT", nextWeek: function () { switch (this.day()) { case 0: return "[v neděli v] LT"; case 1: case 2: return "[v] dddd [v] LT"; case 3: return "[ve středu v] LT"; case 4: return "[ve čtvrtek v] LT"; case 5: return "[v pátek v] LT"; case 6: return "[v sobotu v] LT" } }, lastDay: "[včera v] LT", lastWeek: function () { switch (this.day()) { case 0: return "[minulou neděli v] LT"; case 1: case 2: return "[minulé] dddd [v] LT"; case 3: return "[minulou středu v] LT"; case 4: case 5: return "[minulý] dddd [v] LT"; case 6: return "[minulou sobotu v] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "před %s", s: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, ordinal: "%d.", week: { dow: 1, doy: 4 } })
  }), function (a) { a(bb) }(function (a) { return a.lang("cv", { months: "кăрлач_нарăс_пуш_ака_май_çĕртме_утă_çурла_авăн_юпа_чӳк_раштав".split("_"), monthsShort: "кăр_нар_пуш_ака_май_çĕр_утă_çур_ав_юпа_чӳк_раш".split("_"), weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кĕçнерникун_эрнекун_шăматкун".split("_"), weekdaysShort: "выр_тун_ытл_юн_кĕç_эрн_шăм".split("_"), weekdaysMin: "вр_тн_ыт_юн_кç_эр_шм".split("_"), longDateFormat: { LT: "HH:mm", L: "DD-MM-YYYY", LL: "YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ]", LLL: "YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT", LLLL: "dddd, YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT" }, calendar: { sameDay: "[Паян] LT [сехетре]", nextDay: "[Ыран] LT [сехетре]", lastDay: "[Ĕнер] LT [сехетре]", nextWeek: "[Çитес] dddd LT [сехетре]", lastWeek: "[Иртнĕ] dddd LT [сехетре]", sameElse: "L" }, relativeTime: { future: function (a) { var b = /сехет$/i.exec(a) ? "рен" : /çул$/i.exec(a) ? "тан" : "ран"; return a + b }, past: "%s каялла", s: "пĕр-ик çеккунт", m: "пĕр минут", mm: "%d минут", h: "пĕр сехет", hh: "%d сехет", d: "пĕр кун", dd: "%d кун", M: "пĕр уйăх", MM: "%d уйăх", y: "пĕр çул", yy: "%d çул" }, ordinal: "%d-мĕш", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("cy", { months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"), monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"), weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"), weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"), weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Heddiw am] LT", nextDay: "[Yfory am] LT", nextWeek: "dddd [am] LT", lastDay: "[Ddoe am] LT", lastWeek: "dddd [diwethaf am] LT", sameElse: "L" }, relativeTime: { future: "mewn %s", past: "%s yn &#244;l", s: "ychydig eiliadau", m: "munud", mm: "%d munud", h: "awr", hh: "%d awr", d: "diwrnod", dd: "%d diwrnod", M: "mis", MM: "%d mis", y: "blwyddyn", yy: "%d flynedd" }, ordinal: function (a) { var b = a, c = "", d = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"]; return b > 20 ? c = 40 === b || 50 === b || 60 === b || 80 === b || 100 === b ? "fed" : "ain" : b > 0 && (c = d[b]), a + c }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("da", { months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D. MMMM, YYYY LT" }, calendar: { sameDay: "[I dag kl.] LT", nextDay: "[I morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[I går kl.] LT", lastWeek: "[sidste] dddd [kl] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "få sekunder", m: "et minut", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dage", M: "en måned", MM: "%d måneder", y: "et år", yy: "%d år" }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [a + " Tage", a + " Tagen"], M: ["ein Monat", "einem Monat"], MM: [a + " Monate", a + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [a + " Jahre", a + " Jahren"] }; return b ? d[c][0] : d[c][1] } return a.lang("de", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), longDateFormat: { LT: "H:mm [Uhr]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd, D. MMMM YYYY LT" }, calendar: { sameDay: "[Heute um] LT", sameElse: "L", nextDay: "[Morgen um] LT", nextWeek: "dddd [um] LT", lastDay: "[Gestern um] LT", lastWeek: "[letzten] dddd [um] LT" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", m: b, mm: "%d Minuten", h: b, hh: "%d Stunden", d: b, dd: b, M: b, MM: b, y: b, yy: b }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("el", { monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"), monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"), months: function (a, b) { return /D/.test(b.substring(0, b.indexOf("MMMM"))) ? this._monthsGenitiveEl[a.month()] : this._monthsNominativeEl[a.month()] }, monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"), weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"), weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"), weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"), meridiem: function (a, b, c) { return a > 11 ? c ? "μμ" : "ΜΜ" : c ? "πμ" : "ΠΜ" }, longDateFormat: { LT: "h:mm A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendarEl: { sameDay: "[Σήμερα {}] LT", nextDay: "[Αύριο {}] LT", nextWeek: "dddd [{}] LT", lastDay: "[Χθες {}] LT", lastWeek: "[την προηγούμενη] dddd [{}] LT", sameElse: "L" }, calendar: function (a, b) { var c = this._calendarEl[a], d = b && b.hours(); return c.replace("{}", d % 12 === 1 ? "στη" : "στις") }, relativeTime: { future: "σε %s", past: "%s πριν", s: "δευτερόλεπτα", m: "ένα λεπτό", mm: "%d λεπτά", h: "μία ώρα", hh: "%d ώρες", d: "μία μέρα", dd: "%d μέρες", M: "ένας μήνας", MM: "%d μήνες", y: "ένας χρόνος", yy: "%d χρόνια" }, ordinal: function (a) { return a + "η" }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("en-au", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("en-ca", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", L: "YYYY-MM-DD", LL: "D MMMM, YYYY", LLL: "D MMMM, YYYY LT", LLLL: "dddd, D MMMM, YYYY LT" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c } }) }), function (a) { a(bb) }(function (a) { return a.lang("en-gb", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("eo", { months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec".split("_"), weekdays: "Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato".split("_"), weekdaysShort: "Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab".split("_"), weekdaysMin: "Di_Lu_Ma_Me_Ĵa_Ve_Sa".split("_"), longDateFormat: { LT: "HH:mm", L: "YYYY-MM-DD", LL: "D[-an de] MMMM, YYYY", LLL: "D[-an de] MMMM, YYYY LT", LLLL: "dddd, [la] D[-an de] MMMM, YYYY LT" }, meridiem: function (a, b, c) { return a > 11 ? c ? "p.t.m." : "P.T.M." : c ? "a.t.m." : "A.T.M." }, calendar: { sameDay: "[Hodiaŭ je] LT", nextDay: "[Morgaŭ je] LT", nextWeek: "dddd [je] LT", lastDay: "[Hieraŭ je] LT", lastWeek: "[pasinta] dddd [je] LT", sameElse: "L" }, relativeTime: { future: "je %s", past: "antaŭ %s", s: "sekundoj", m: "minuto", mm: "%d minutoj", h: "horo", hh: "%d horoj", d: "tago", dd: "%d tagoj", M: "monato", MM: "%d monatoj", y: "jaro", yy: "%d jaroj" }, ordinal: "%da", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("es", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "Do_Lu_Ma_Mi_Ju_Vi_Sá".split("_"), longDateFormat: { LT: "H:mm", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY LT", LLLL: "dddd, D [de] MMMM [de] YYYY LT" }, calendar: { sameDay: function () { return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, nextDay: function () { return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, nextWeek: function () { return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, lastDay: function () { return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, lastWeek: function () { return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, ordinal: "%dº", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c, d) { return d || b ? "paari sekundi" : "paar sekundit" } return a.lang("et", { months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"), monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"), weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"), weekdaysShort: "P_E_T_K_N_R_L".split("_"), weekdaysMin: "P_E_T_K_N_R_L".split("_"), longDateFormat: { LT: "H:mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd, D. MMMM YYYY LT" }, calendar: { sameDay: "[Täna,] LT", nextDay: "[Homme,] LT", nextWeek: "[Järgmine] dddd LT", lastDay: "[Eile,] LT", lastWeek: "[Eelmine] dddd LT", sameElse: "L" }, relativeTime: { future: "%s pärast", past: "%s tagasi", s: b, m: "minut", mm: "%d minutit", h: "tund", hh: "%d tundi", d: "päev", dd: "%d päeva", M: "kuu", MM: "%d kuud", y: "aasta", yy: "%d aastat" }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("eu", { months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"), monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"), weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"), weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"), weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"), longDateFormat: { LT: "HH:mm", L: "YYYY-MM-DD", LL: "YYYY[ko] MMMM[ren] D[a]", LLL: "YYYY[ko] MMMM[ren] D[a] LT", LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] LT", l: "YYYY-M-D", ll: "YYYY[ko] MMM D[a]", lll: "YYYY[ko] MMM D[a] LT", llll: "ddd, YYYY[ko] MMM D[a] LT" }, calendar: { sameDay: "[gaur] LT[etan]", nextDay: "[bihar] LT[etan]", nextWeek: "dddd LT[etan]", lastDay: "[atzo] LT[etan]", lastWeek: "[aurreko] dddd LT[etan]", sameElse: "L" }, relativeTime: { future: "%s barru", past: "duela %s", s: "segundo batzuk", m: "minutu bat", mm: "%d minutu", h: "ordu bat", hh: "%d ordu", d: "egun bat", dd: "%d egun", M: "hilabete bat", MM: "%d hilabete", y: "urte bat", yy: "%d urte" }, ordinal: "%d.", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { var b = { 1: "۱", 2: "۲", 3: "۳", 4: "۴", 5: "۵", 6: "۶", 7: "۷", 8: "۸", 9: "۹", 0: "۰" }, c = { "۱": "1", "۲": "2", "۳": "3", "۴": "4", "۵": "5", "۶": "6", "۷": "7", "۸": "8", "۹": "9", "۰": "0" }; return a.lang("fa", { months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, meridiem: function (a) { return 12 > a ? "قبل از ظهر" : "بعد از ظهر" }, calendar: { sameDay: "[امروز ساعت] LT", nextDay: "[فردا ساعت] LT", nextWeek: "dddd [ساعت] LT", lastDay: "[دیروز ساعت] LT", lastWeek: "dddd [پیش] [ساعت] LT", sameElse: "L" }, relativeTime: { future: "در %s", past: "%s پیش", s: "چندین ثانیه", m: "یک دقیقه", mm: "%d دقیقه", h: "یک ساعت", hh: "%d ساعت", d: "یک روز", dd: "%d روز", M: "یک ماه", MM: "%d ماه", y: "یک سال", yy: "%d سال" }, preparse: function (a) { return a.replace(/[۰-۹]/g, function (a) { return c[a] }).replace(/،/g, ",") }, postformat: function (a) { return a.replace(/\d/g, function (a) { return b[a] }).replace(/,/g, "،") }, ordinal: "%dم", week: { dow: 6, doy: 12 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, d, e) { var f = ""; switch (d) { case "s": return e ? "muutaman sekunnin" : "muutama sekunti"; case "m": return e ? "minuutin" : "minuutti"; case "mm": f = e ? "minuutin" : "minuuttia"; break; case "h": return e ? "tunnin" : "tunti"; case "hh": f = e ? "tunnin" : "tuntia"; break; case "d": return e ? "päivän" : "päivä"; case "dd": f = e ? "päivän" : "päivää"; break; case "M": return e ? "kuukauden" : "kuukausi"; case "MM": f = e ? "kuukauden" : "kuukautta"; break; case "y": return e ? "vuoden" : "vuosi"; case "yy": f = e ? "vuoden" : "vuotta" }return f = c(a, e) + " " + f } function c(a, b) { return 10 > a ? b ? e[a] : d[a] : a } var d = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "), e = ["nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", d[7], d[8], d[9]]; return a.lang("fi", { months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"), monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"), weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"), weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"), weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"), longDateFormat: { LT: "HH.mm", L: "DD.MM.YYYY", LL: "Do MMMM[ta] YYYY", LLL: "Do MMMM[ta] YYYY, [klo] LT", LLLL: "dddd, Do MMMM[ta] YYYY, [klo] LT", l: "D.M.YYYY", ll: "Do MMM YYYY", lll: "Do MMM YYYY, [klo] LT", llll: "ddd, Do MMM YYYY, [klo] LT" }, calendar: { sameDay: "[tänään] [klo] LT", nextDay: "[huomenna] [klo] LT", nextWeek: "dddd [klo] LT", lastDay: "[eilen] [klo] LT", lastWeek: "[viime] dddd[na] [klo] LT", sameElse: "L" }, relativeTime: { future: "%s päästä", past: "%s sitten", s: b, m: b, mm: b, h: b, hh: b, d: b, dd: b, M: b, MM: b, y: b, yy: b }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("fo", { months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"), weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"), weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D. MMMM, YYYY LT" }, calendar: { sameDay: "[Í dag kl.] LT", nextDay: "[Í morgin kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[Í gjár kl.] LT", lastWeek: "[síðstu] dddd [kl] LT", sameElse: "L" }, relativeTime: { future: "um %s", past: "%s síðani", s: "fá sekund", m: "ein minutt", mm: "%d minuttir", h: "ein tími", hh: "%d tímar", d: "ein dagur", dd: "%d dagar", M: "ein mánaði", MM: "%d mánaðir", y: "eitt ár", yy: "%d ár" }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("fr-ca", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"), longDateFormat: { LT: "HH:mm", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[Aujourd'hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, ordinal: function (a) { return a + (1 === a ? "er" : "") } }) }), function (a) { a(bb) }(function (a) { return a.lang("fr", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[Aujourd'hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, ordinal: function (a) { return a + (1 === a ? "er" : "") }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("gl", { months: "Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro".split("_"), monthsShort: "Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.".split("_"), weekdays: "Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado".split("_"), weekdaysShort: "Dom._Lun._Mar._Mér._Xov._Ven._Sáb.".split("_"), weekdaysMin: "Do_Lu_Ma_Mé_Xo_Ve_Sá".split("_"), longDateFormat: { LT: "H:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: function () { return "[hoxe " + (1 !== this.hours() ? "ás" : "á") + "] LT" }, nextDay: function () { return "[mañá " + (1 !== this.hours() ? "ás" : "á") + "] LT" }, nextWeek: function () { return "dddd [" + (1 !== this.hours() ? "ás" : "a") + "] LT" }, lastDay: function () { return "[onte " + (1 !== this.hours() ? "á" : "a") + "] LT" }, lastWeek: function () { return "[o] dddd [pasado " + (1 !== this.hours() ? "ás" : "a") + "] LT" }, sameElse: "L" }, relativeTime: { future: function (a) { return "uns segundos" === a ? "nuns segundos" : "en " + a }, past: "hai %s", s: "uns segundos", m: "un minuto", mm: "%d minutos", h: "unha hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un ano", yy: "%d anos" }, ordinal: "%dº", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("he", { months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"), monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"), weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"), weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"), weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D [ב]MMMM YYYY", LLL: "D [ב]MMMM YYYY LT", LLLL: "dddd, D [ב]MMMM YYYY LT", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY LT", llll: "ddd, D MMM YYYY LT" }, calendar: { sameDay: "[היום ב־]LT", nextDay: "[מחר ב־]LT", nextWeek: "dddd [בשעה] LT", lastDay: "[אתמול ב־]LT", lastWeek: "[ביום] dddd [האחרון בשעה] LT", sameElse: "L" }, relativeTime: { future: "בעוד %s", past: "לפני %s", s: "מספר שניות", m: "דקה", mm: "%d דקות", h: "שעה", hh: function (a) { return 2 === a ? "שעתיים" : a + " שעות" }, d: "יום", dd: function (a) { return 2 === a ? "יומיים" : a + " ימים" }, M: "חודש", MM: function (a) { return 2 === a ? "חודשיים" : a + " חודשים" }, y: "שנה", yy: function (a) { return 2 === a ? "שנתיים" : a + " שנים" } } }) }), function (a) { a(bb) }(function (a) { var b = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, c = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }; return a.lang("hi", { months: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"), monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"), weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, LT", LLLL: "dddd, D MMMM YYYY, LT" }, calendar: { sameDay: "[आज] LT", nextDay: "[कल] LT", nextWeek: "dddd, LT", lastDay: "[कल] LT", lastWeek: "[पिछले] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s में", past: "%s पहले", s: "कुछ ही क्षण", m: "एक मिनट", mm: "%d मिनट", h: "एक घंटा", hh: "%d घंटे", d: "एक दिन", dd: "%d दिन", M: "एक महीने", MM: "%d महीने", y: "एक वर्ष", yy: "%d वर्ष" }, preparse: function (a) { return a.replace(/[१२३४५६७८९०]/g, function (a) { return c[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return b[a] }) }, meridiem: function (a) { return 4 > a ? "रात" : 10 > a ? "सुबह" : 17 > a ? "दोपहर" : 20 > a ? "शाम" : "रात" }, week: { dow: 0, doy: 6 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = a + " "; switch (c) { case "m": return b ? "jedna minuta" : "jedne minute"; case "mm": return d += 1 === a ? "minuta" : 2 === a || 3 === a || 4 === a ? "minute" : "minuta"; case "h": return b ? "jedan sat" : "jednog sata"; case "hh": return d += 1 === a ? "sat" : 2 === a || 3 === a || 4 === a ? "sata" : "sati"; case "dd": return d += 1 === a ? "dan" : "dana"; case "MM": return d += 1 === a ? "mjesec" : 2 === a || 3 === a || 4 === a ? "mjeseca" : "mjeseci"; case "yy": return d += 1 === a ? "godina" : 2 === a || 3 === a || 4 === a ? "godine" : "godina" } } return a.lang("hr", { months: "sječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_"), monthsShort: "sje._vel._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"), weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), longDateFormat: { LT: "H:mm", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd, D. MMMM YYYY LT" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () { switch (this.day()) { case 0: return "[u] [nedjelju] [u] LT"; case 3: return "[u] [srijedu] [u] LT"; case 6: return "[u] [subotu] [u] LT"; case 1: case 2: case 4: case 5: return "[u] dddd [u] LT" } }, lastDay: "[jučer u] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: return "[prošlu] dddd [u] LT"; case 6: return "[prošle] [subote] [u] LT"; case 1: case 2: case 4: case 5: return "[prošli] dddd [u] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", m: b, mm: b, h: b, hh: b, d: "dan", dd: b, M: "mjesec", MM: b, y: "godinu", yy: b }, ordinal: "%d.", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c, d) { var e = a; switch (c) { case "s": return d || b ? "néhány másodperc" : "néhány másodperce"; case "m": return "egy" + (d || b ? " perc" : " perce"); case "mm": return e + (d || b ? " perc" : " perce"); case "h": return "egy" + (d || b ? " óra" : " órája"); case "hh": return e + (d || b ? " óra" : " órája"); case "d": return "egy" + (d || b ? " nap" : " napja"); case "dd": return e + (d || b ? " nap" : " napja"); case "M": return "egy" + (d || b ? " hónap" : " hónapja"); case "MM": return e + (d || b ? " hónap" : " hónapja"); case "y": return "egy" + (d || b ? " év" : " éve"); case "yy": return e + (d || b ? " év" : " éve") }return "" } function c(a) { return (a ? "" : "[múlt] ") + "[" + d[this.day()] + "] LT[-kor]" } var d = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" "); return a.lang("hu", { months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"), monthsShort: "jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec".split("_"), weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"), weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"), weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"), longDateFormat: { LT: "H:mm", L: "YYYY.MM.DD.", LL: "YYYY. MMMM D.", LLL: "YYYY. MMMM D., LT", LLLL: "YYYY. MMMM D., dddd LT" }, calendar: { sameDay: "[ma] LT[-kor]", nextDay: "[holnap] LT[-kor]", nextWeek: function () { return c.call(this, !0) }, lastDay: "[tegnap] LT[-kor]", lastWeek: function () { return c.call(this, !1) }, sameElse: "L" }, relativeTime: { future: "%s múlva", past: "%s", s: b, m: b, mm: b, h: b, hh: b, d: b, dd: b, M: b, MM: b, y: b, yy: b }, ordinal: "%d.", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("id", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"), weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"), weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] LT", LLLL: "dddd, D MMMM YYYY [pukul] LT" }, meridiem: function (a) { return 11 > a ? "pagi" : 15 > a ? "siang" : 19 > a ? "sore" : "malam" }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Besok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kemarin pukul] LT", lastWeek: "dddd [lalu pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lalu", s: "beberapa detik", m: "semenit", mm: "%d menit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { function b(a) { return a % 100 === 11 ? !0 : a % 10 === 1 ? !1 : !0 } function c(a, c, d, e) { var f = a + " "; switch (d) { case "s": return c || e ? "nokkrar sekúndur" : "nokkrum sekúndum"; case "m": return c ? "mínúta" : "mínútu"; case "mm": return b(a) ? f + (c || e ? "mínútur" : "mínútum") : c ? f + "mínúta" : f + "mínútu"; case "hh": return b(a) ? f + (c || e ? "klukkustundir" : "klukkustundum") : f + "klukkustund"; case "d": return c ? "dagur" : e ? "dag" : "degi"; case "dd": return b(a) ? c ? f + "dagar" : f + (e ? "daga" : "dögum") : c ? f + "dagur" : f + (e ? "dag" : "degi"); case "M": return c ? "mánuður" : e ? "mánuð" : "mánuði"; case "MM": return b(a) ? c ? f + "mánuðir" : f + (e ? "mánuði" : "mánuðum") : c ? f + "mánuður" : f + (e ? "mánuð" : "mánuði"); case "y": return c || e ? "ár" : "ári"; case "yy": return b(a) ? f + (c || e ? "ár" : "árum") : f + (c || e ? "ár" : "ári") } } return a.lang("is", { months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"), monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"), weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"), weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"), weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"), longDateFormat: { LT: "H:mm", L: "DD/MM/YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] LT", LLLL: "dddd, D. MMMM YYYY [kl.] LT" }, calendar: { sameDay: "[í dag kl.] LT", nextDay: "[á morgun kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[í gær kl.] LT", lastWeek: "[síðasta] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "eftir %s", past: "fyrir %s síðan", s: c, m: c, mm: c, h: "klukkustund", hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("it", { months: "Gennaio_Febbraio_Marzo_Aprile_Maggio_Giugno_Luglio_Agosto_Settembre_Ottobre_Novembre_Dicembre".split("_"), monthsShort: "Gen_Feb_Mar_Apr_Mag_Giu_Lug_Ago_Set_Ott_Nov_Dic".split("_"), weekdays: "Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato".split("_"), weekdaysShort: "Dom_Lun_Mar_Mer_Gio_Ven_Sab".split("_"), weekdaysMin: "D_L_Ma_Me_G_V_S".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Oggi alle] LT", nextDay: "[Domani alle] LT", nextWeek: "dddd [alle] LT", lastDay: "[Ieri alle] LT", lastWeek: "[lo scorso] dddd [alle] LT", sameElse: "L" }, relativeTime: { future: function (a) { return (/^[0-9].+$/.test(a) ? "tra" : "in") + " " + a }, past: "%s fa", s: "secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, ordinal: "%dº", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("ja", { months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"), weekdaysShort: "日_月_火_水_木_金_土".split("_"), weekdaysMin: "日_月_火_水_木_金_土".split("_"), longDateFormat: { LT: "Ah時m分", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日LT", LLLL: "YYYY年M月D日LT dddd" }, meridiem: function (a) { return 12 > a ? "午前" : "午後" }, calendar: { sameDay: "[今日] LT", nextDay: "[明日] LT", nextWeek: "[来週]dddd LT", lastDay: "[昨日] LT", lastWeek: "[前週]dddd LT", sameElse: "L" }, relativeTime: { future: "%s後", past: "%s前", s: "数秒", m: "1分", mm: "%d分", h: "1時間", hh: "%d時間", d: "1日", dd: "%d日", M: "1ヶ月", MM: "%dヶ月", y: "1年", yy: "%d年" } }) }), function (a) { a(bb) }(function (a) {
    function b(a, b) { var c = { nominative: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"), accusative: "იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს".split("_") }, d = /D[oD] *MMMM?/.test(b) ? "accusative" : "nominative"; return c[d][a.month()] } function c(a, b) {
      var c = { nominative: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"), accusative: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_") }, d = /(წინა|შემდეგ)/.test(b) ? "accusative" : "nominative";
      return c[d][a.day()]
    } return a.lang("ka", { months: b, monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"), weekdays: c, weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"), weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"), longDateFormat: { LT: "h:mm A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[დღეს] LT[-ზე]", nextDay: "[ხვალ] LT[-ზე]", lastDay: "[გუშინ] LT[-ზე]", nextWeek: "[შემდეგ] dddd LT[-ზე]", lastWeek: "[წინა] dddd LT-ზე", sameElse: "L" }, relativeTime: { future: function (a) { return /(წამი|წუთი|საათი|წელი)/.test(a) ? a.replace(/ი$/, "ში") : a + "ში" }, past: function (a) { return /(წამი|წუთი|საათი|დღე|თვე)/.test(a) ? a.replace(/(ი|ე)$/, "ის წინ") : /წელი/.test(a) ? a.replace(/წელი$/, "წლის წინ") : void 0 }, s: "რამდენიმე წამი", m: "წუთი", mm: "%d წუთი", h: "საათი", hh: "%d საათი", d: "დღე", dd: "%d დღე", M: "თვე", MM: "%d თვე", y: "წელი", yy: "%d წელი" }, ordinal: function (a) { return 0 === a ? a : 1 === a ? a + "-ლი" : 20 > a || 100 >= a && a % 20 === 0 || a % 100 === 0 ? "მე-" + a : a + "-ე" }, week: { dow: 1, doy: 7 } })
  }), function (a) { a(bb) }(function (a) { return a.lang("ko", { months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"), weekdaysShort: "일_월_화_수_목_금_토".split("_"), weekdaysMin: "일_월_화_수_목_금_토".split("_"), longDateFormat: { LT: "A h시 mm분", L: "YYYY.MM.DD", LL: "YYYY년 MMMM D일", LLL: "YYYY년 MMMM D일 LT", LLLL: "YYYY년 MMMM D일 dddd LT" }, meridiem: function (a) { return 12 > a ? "오전" : "오후" }, calendar: { sameDay: "오늘 LT", nextDay: "내일 LT", nextWeek: "dddd LT", lastDay: "어제 LT", lastWeek: "지난주 dddd LT", sameElse: "L" }, relativeTime: { future: "%s 후", past: "%s 전", s: "몇초", ss: "%d초", m: "일분", mm: "%d분", h: "한시간", hh: "%d시간", d: "하루", dd: "%d일", M: "한달", MM: "%d달", y: "일년", yy: "%d년" }, ordinal: "%d일" }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = { m: ["eng Minutt", "enger Minutt"], h: ["eng Stonn", "enger Stonn"], d: ["een Dag", "engem Dag"], dd: [a + " Deeg", a + " Deeg"], M: ["ee Mount", "engem Mount"], MM: [a + " Méint", a + " Méint"], y: ["ee Joer", "engem Joer"], yy: [a + " Joer", a + " Joer"] }; return b ? d[c][0] : d[c][1] } function c(a) { var b = a.substr(0, a.indexOf(" ")); return g(b) ? "a " + a : "an " + a } function d(a) { var b = a.substr(0, a.indexOf(" ")); return g(b) ? "viru " + a : "virun " + a } function e() { var a = this.format("d"); return f(a) ? "[Leschte] dddd [um] LT" : "[Leschten] dddd [um] LT" } function f(a) { switch (a = parseInt(a)) { case 0: case 1: case 3: case 5: case 6: return !0; default: return !1 } } function g(a) { if (a = parseInt(a), isNaN(a)) return !1; if (0 > a) return !0; if (10 > a) return a >= 4 && 7 >= a ? !0 : !1; if (100 > a) { var b = a % 10, c = a / 10; return 0 === b ? g(c) : g(b) } if (1e4 > a) { for (; a >= 10;)a /= 10; return g(a) } return a /= 1e3, g(a) } return a.lang("lb", { months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"), weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"), longDateFormat: { LT: "H:mm [Auer]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd, D. MMMM YYYY LT" }, calendar: { sameDay: "[Haut um] LT", sameElse: "L", nextDay: "[Muer um] LT", nextWeek: "dddd [um] LT", lastDay: "[Gëschter um] LT", lastWeek: e }, relativeTime: { future: c, past: d, s: "e puer Sekonnen", m: b, mm: "%d Minutten", h: b, hh: "%d Stonnen", d: b, dd: b, M: b, MM: b, y: b, yy: b }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c, d) { return b ? "kelios sekundės" : d ? "kelių sekundžių" : "kelias sekundes" } function c(a, b, c, d) { return b ? e(c)[0] : d ? e(c)[1] : e(c)[2] } function d(a) { return a % 10 === 0 || a > 10 && 20 > a } function e(a) { return h[a].split("_") } function f(a, b, f, g) { var h = a + " "; return 1 === a ? h + c(a, b, f[0], g) : b ? h + (d(a) ? e(f)[1] : e(f)[0]) : g ? h + e(f)[1] : h + (d(a) ? e(f)[1] : e(f)[2]) } function g(a, b) { var c = -1 === b.indexOf("dddd LT"), d = i[a.weekday()]; return c ? d : d.substring(0, d.length - 2) + "į" } var h = { m: "minutė_minutės_minutę", mm: "minutės_minučių_minutes", h: "valanda_valandos_valandą", hh: "valandos_valandų_valandas", d: "diena_dienos_dieną", dd: "dienos_dienų_dienas", M: "mėnuo_mėnesio_mėnesį", MM: "mėnesiai_mėnesių_mėnesius", y: "metai_metų_metus", yy: "metai_metų_metus" }, i = "pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis_sekmadienis".split("_"); return a.lang("lt", { months: "sausio_vasario_kovo_balandžio_gegužės_biržėlio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"), monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"), weekdays: g, weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"), weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"), longDateFormat: { LT: "HH:mm", L: "YYYY-MM-DD", LL: "YYYY [m.] MMMM D [d.]", LLL: "YYYY [m.] MMMM D [d.], LT [val.]", LLLL: "YYYY [m.] MMMM D [d.], dddd, LT [val.]", l: "YYYY-MM-DD", ll: "YYYY [m.] MMMM D [d.]", lll: "YYYY [m.] MMMM D [d.], LT [val.]", llll: "YYYY [m.] MMMM D [d.], ddd, LT [val.]" }, calendar: { sameDay: "[Šiandien] LT", nextDay: "[Rytoj] LT", nextWeek: "dddd LT", lastDay: "[Vakar] LT", lastWeek: "[Praėjusį] dddd LT", sameElse: "L" }, relativeTime: { future: "po %s", past: "prieš %s", s: b, m: c, mm: f, h: c, hh: f, d: c, dd: f, M: c, MM: f, y: c, yy: f }, ordinal: function (a) { return a + "-oji" }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = a.split("_"); return c ? b % 10 === 1 && 11 !== b ? d[2] : d[3] : b % 10 === 1 && 11 !== b ? d[0] : d[1] } function c(a, c, e) { return a + " " + b(d[e], a, c) } var d = { mm: "minūti_minūtes_minūte_minūtes", hh: "stundu_stundas_stunda_stundas", dd: "dienu_dienas_diena_dienas", MM: "mēnesi_mēnešus_mēnesis_mēneši", yy: "gadu_gadus_gads_gadi" }; return a.lang("lv", { months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"), monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"), weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"), weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"), longDateFormat: { LT: "HH:mm", L: "DD.MM.YYYY", LL: "YYYY. [gada] D. MMMM", LLL: "YYYY. [gada] D. MMMM, LT", LLLL: "YYYY. [gada] D. MMMM, dddd, LT" }, calendar: { sameDay: "[Šodien pulksten] LT", nextDay: "[Rīt pulksten] LT", nextWeek: "dddd [pulksten] LT", lastDay: "[Vakar pulksten] LT", lastWeek: "[Pagājušā] dddd [pulksten] LT", sameElse: "L" }, relativeTime: { future: "%s vēlāk", past: "%s agrāk", s: "dažas sekundes", m: "minūti", mm: c, h: "stundu", hh: c, d: "dienu", dd: c, M: "mēnesi", MM: c, y: "gadu", yy: c }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("ml", { months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"), monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"), weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"), weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"), weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"), longDateFormat: { LT: "A h:mm -നു", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, LT", LLLL: "dddd, D MMMM YYYY, LT" }, calendar: { sameDay: "[ഇന്ന്] LT", nextDay: "[നാളെ] LT", nextWeek: "dddd, LT", lastDay: "[ഇന്നലെ] LT", lastWeek: "[കഴിഞ്ഞ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s കഴിഞ്ഞ്", past: "%s മുൻപ്", s: "അൽപ നിമിഷങ്ങൾ", m: "ഒരു മിനിറ്റ്", mm: "%d മിനിറ്റ്", h: "ഒരു മണിക്കൂർ", hh: "%d മണിക്കൂർ", d: "ഒരു ദിവസം", dd: "%d ദിവസം", M: "ഒരു മാസം", MM: "%d മാസം", y: "ഒരു വർഷം", yy: "%d വർഷം" }, meridiem: function (a) { return 4 > a ? "രാത്രി" : 12 > a ? "രാവിലെ" : 17 > a ? "ഉച്ച കഴിഞ്ഞ്" : 20 > a ? "വൈകുന്നേരം" : "രാത്രി" } }) }), function (a) { a(bb) }(function (a) { var b = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, c = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }; return a.lang("mr", { months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"), monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"), weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm वाजता", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, LT", LLLL: "dddd, D MMMM YYYY, LT" }, calendar: { sameDay: "[आज] LT", nextDay: "[उद्या] LT", nextWeek: "dddd, LT", lastDay: "[काल] LT", lastWeek: "[मागील] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s नंतर", past: "%s पूर्वी", s: "सेकंद", m: "एक मिनिट", mm: "%d मिनिटे", h: "एक तास", hh: "%d तास", d: "एक दिवस", dd: "%d दिवस", M: "एक महिना", MM: "%d महिने", y: "एक वर्ष", yy: "%d वर्षे" }, preparse: function (a) { return a.replace(/[१२३४५६७८९०]/g, function (a) { return c[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return b[a] }) }, meridiem: function (a) { return 4 > a ? "रात्री" : 10 > a ? "सकाळी" : 17 > a ? "दुपारी" : 20 > a ? "सायंकाळी" : "रात्री" }, week: { dow: 0, doy: 6 } }) }), function (a) { a(bb) }(function (a) { return a.lang("ms-my", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] LT", LLLL: "dddd, D MMMM YYYY [pukul] LT" }, meridiem: function (a) { return 11 > a ? "pagi" : 15 > a ? "tengahari" : 19 > a ? "petang" : "malam" }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("nb", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.".split("_"), weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), longDateFormat: { LT: "H.mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] LT", LLLL: "dddd D. MMMM YYYY [kl.] LT" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[forrige] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "for %s siden", s: "noen sekunder", m: "ett minutt", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dager", M: "en måned", MM: "%d måneder", y: "ett år", yy: "%d år" }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { var b = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, c = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }; return a.lang("ne", { months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"), monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"), weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"), weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"), weekdaysMin: "आइ._सो._मङ्_बु._बि._शु._श.".split("_"), longDateFormat: { LT: "Aको h:mm बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, LT", LLLL: "dddd, D MMMM YYYY, LT" }, preparse: function (a) { return a.replace(/[१२३४५६७८९०]/g, function (a) { return c[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return b[a] }) }, meridiem: function (a) { return 3 > a ? "राती" : 10 > a ? "बिहान" : 15 > a ? "दिउँसो" : 18 > a ? "बेलुका" : 20 > a ? "साँझ" : "राती" }, calendar: { sameDay: "[आज] LT", nextDay: "[भोली] LT", nextWeek: "[आउँदो] dddd[,] LT", lastDay: "[हिजो] LT", lastWeek: "[गएको] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%sमा", past: "%s अगाडी", s: "केही समय", m: "एक मिनेट", mm: "%d मिनेट", h: "एक घण्टा", hh: "%d घण्टा", d: "एक दिन", dd: "%d दिन", M: "एक महिना", MM: "%d महिना", y: "एक बर्ष", yy: "%d बर्ष" }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { var b = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), c = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"); return a.lang("nl", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function (a, d) { return /-MMM-/.test(d) ? c[a.month()] : b[a.month()] }, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"), longDateFormat: { LT: "HH:mm", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, ordinal: function (a) { return a + (1 === a || 8 === a || a >= 20 ? "ste" : "de") }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("nn", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"), weekdaysShort: "sun_mån_tys_ons_tor_fre_lau".split("_"), weekdaysMin: "su_må_ty_on_to_fr_lø".split("_"), longDateFormat: { LT: "HH:mm", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[I dag klokka] LT", nextDay: "[I morgon klokka] LT", nextWeek: "dddd [klokka] LT", lastDay: "[I går klokka] LT", lastWeek: "[Føregående] dddd [klokka] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "for %s siden", s: "noen sekund", m: "ett minutt", mm: "%d minutt", h: "en time", hh: "%d timar", d: "en dag", dd: "%d dagar", M: "en månad", MM: "%d månader", y: "ett år", yy: "%d år" }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a) { return 5 > a % 10 && a % 10 > 1 && 1 !== ~~(a / 10) } function c(a, c, d) { var e = a + " "; switch (d) { case "m": return c ? "minuta" : "minutę"; case "mm": return e + (b(a) ? "minuty" : "minut"); case "h": return c ? "godzina" : "godzinę"; case "hh": return e + (b(a) ? "godziny" : "godzin"); case "MM": return e + (b(a) ? "miesiące" : "miesięcy"); case "yy": return e + (b(a) ? "lata" : "lat") } } var d = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"), e = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"); return a.lang("pl", { months: function (a, b) { return /D MMMM/.test(b) ? e[a.month()] : d[a.month()] }, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"), weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"), weekdaysShort: "nie_pon_wt_śr_czw_pt_sb".split("_"), weekdaysMin: "N_Pn_Wt_Śr_Cz_Pt_So".split("_"), longDateFormat: { LT: "HH:mm", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Dziś o] LT", nextDay: "[Jutro o] LT", nextWeek: "[W] dddd [o] LT", lastDay: "[Wczoraj o] LT", lastWeek: function () { switch (this.day()) { case 0: return "[W zeszłą niedzielę o] LT"; case 3: return "[W zeszłą środę o] LT"; case 6: return "[W zeszłą sobotę o] LT"; default: return "[W zeszły] dddd [o] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", m: c, mm: c, h: c, hh: c, d: "1 dzień", dd: "%d dni", M: "miesiąc", MM: c, y: "rok", yy: c }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("pt-br", { months: "Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"), weekdaysMin: "Dom_2ª_3ª_4ª_5ª_6ª_Sáb".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY LT", LLLL: "dddd, D [de] MMMM [de] YYYY LT" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function () { return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT" }, sameElse: "L" }, relativeTime: { future: "em %s", past: "%s atrás", s: "segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, ordinal: "%dº" }) }), function (a) { a(bb) }(function (a) { return a.lang("pt", { months: "Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"), weekdaysMin: "Dom_2ª_3ª_4ª_5ª_6ª_Sáb".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY LT", LLLL: "dddd, D [de] MMMM [de] YYYY LT" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function () { return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT" }, sameElse: "L" }, relativeTime: { future: "em %s", past: "%s atrás", s: "segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, ordinal: "%dº", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = { mm: "minute", hh: "ore", dd: "zile", MM: "luni", yy: "ani" }, e = " "; return (a % 100 >= 20 || a >= 100 && a % 100 === 0) && (e = " de "), a + e + d[c] } return a.lang("ro", { months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"), monthsShort: "ian_feb_mar_apr_mai_iun_iul_aug_sep_oct_noi_dec".split("_"), weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"), weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"), weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"), longDateFormat: { LT: "H:mm", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[azi la] LT", nextDay: "[mâine la] LT", nextWeek: "dddd [la] LT", lastDay: "[ieri la] LT", lastWeek: "[fosta] dddd [la] LT", sameElse: "L" }, relativeTime: { future: "peste %s", past: "%s în urmă", s: "câteva secunde", m: "un minut", mm: b, h: "o oră", hh: b, d: "o zi", dd: b, M: "o lună", MM: b, y: "un an", yy: b }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { function b(a, b) { var c = a.split("_"); return b % 10 === 1 && b % 100 !== 11 ? c[0] : b % 10 >= 2 && 4 >= b % 10 && (10 > b % 100 || b % 100 >= 20) ? c[1] : c[2] } function c(a, c, d) { var e = { mm: "минута_минуты_минут", hh: "час_часа_часов", dd: "день_дня_дней", MM: "месяц_месяца_месяцев", yy: "год_года_лет" }; return "m" === d ? c ? "минута" : "минуту" : a + " " + b(e[d], +a) } function d(a, b) { var c = { nominative: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"), accusative: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_") }, d = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(b) ? "accusative" : "nominative"; return c[d][a.month()] } function e(a, b) { var c = { nominative: "янв_фев_мар_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"), accusative: "янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек".split("_") }, d = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(b) ? "accusative" : "nominative"; return c[d][a.month()] } function f(a, b) { var c = { nominative: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"), accusative: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_") }, d = /\[ ?[Вв] ?(?:прошлую|следующую)? ?\] ?dddd/.test(b) ? "accusative" : "nominative"; return c[d][a.day()] } return a.lang("ru", { months: d, monthsShort: e, weekdays: f, weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"), monthsParse: [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i], longDateFormat: { LT: "HH:mm", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., LT", LLLL: "dddd, D MMMM YYYY г., LT" }, calendar: { sameDay: "[Сегодня в] LT", nextDay: "[Завтра в] LT", lastDay: "[Вчера в] LT", nextWeek: function () { return 2 === this.day() ? "[Во] dddd [в] LT" : "[В] dddd [в] LT" }, lastWeek: function () { switch (this.day()) { case 0: return "[В прошлое] dddd [в] LT"; case 1: case 2: case 4: return "[В прошлый] dddd [в] LT"; case 3: case 5: case 6: return "[В прошлую] dddd [в] LT" } }, sameElse: "L" }, relativeTime: { future: "через %s", past: "%s назад", s: "несколько секунд", m: c, mm: c, h: "час", hh: c, d: "день", dd: c, M: "месяц", MM: c, y: "год", yy: c }, meridiem: function (a) { return 4 > a ? "ночи" : 12 > a ? "утра" : 17 > a ? "дня" : "вечера" }, ordinal: function (a, b) { switch (b) { case "M": case "d": case "DDD": return a + "-й"; case "D": return a + "-го"; case "w": case "W": return a + "-я"; default: return a } }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { function b(a) { return a > 1 && 5 > a } function c(a, c, d, e) { var f = a + " "; switch (d) { case "s": return c || e ? "pár sekúnd" : "pár sekundami"; case "m": return c ? "minúta" : e ? "minútu" : "minútou"; case "mm": return c || e ? f + (b(a) ? "minúty" : "minút") : f + "minútami"; break; case "h": return c ? "hodina" : e ? "hodinu" : "hodinou"; case "hh": return c || e ? f + (b(a) ? "hodiny" : "hodín") : f + "hodinami"; break; case "d": return c || e ? "deň" : "dňom"; case "dd": return c || e ? f + (b(a) ? "dni" : "dní") : f + "dňami"; break; case "M": return c || e ? "mesiac" : "mesiacom"; case "MM": return c || e ? f + (b(a) ? "mesiace" : "mesiacov") : f + "mesiacmi"; break; case "y": return c || e ? "rok" : "rokom"; case "yy": return c || e ? f + (b(a) ? "roky" : "rokov") : f + "rokmi" } } var d = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"), e = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_"); return a.lang("sk", { months: d, monthsShort: e, monthsParse: function (a, b) { var c, d = []; for (c = 0; 12 > c; c++)d[c] = new RegExp("^" + a[c] + "$|^" + b[c] + "$", "i"); return d }(d, e), weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"), weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"), weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"), longDateFormat: { LT: "H:mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd D. MMMM YYYY LT" }, calendar: { sameDay: "[dnes o] LT", nextDay: "[zajtra o] LT", nextWeek: function () { switch (this.day()) { case 0: return "[v nedeľu o] LT"; case 1: case 2: return "[v] dddd [o] LT"; case 3: return "[v stredu o] LT"; case 4: return "[vo štvrtok o] LT"; case 5: return "[v piatok o] LT"; case 6: return "[v sobotu o] LT" } }, lastDay: "[včera o] LT", lastWeek: function () { switch (this.day()) { case 0: return "[minulú nedeľu o] LT"; case 1: case 2: return "[minulý] dddd [o] LT"; case 3: return "[minulú stredu o] LT"; case 4: case 5: return "[minulý] dddd [o] LT"; case 6: return "[minulú sobotu o] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pred %s", s: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { function b(a, b, c) { var d = a + " "; switch (c) { case "m": return b ? "ena minuta" : "eno minuto"; case "mm": return d += 1 === a ? "minuta" : 2 === a ? "minuti" : 3 === a || 4 === a ? "minute" : "minut"; case "h": return b ? "ena ura" : "eno uro"; case "hh": return d += 1 === a ? "ura" : 2 === a ? "uri" : 3 === a || 4 === a ? "ure" : "ur"; case "dd": return d += 1 === a ? "dan" : "dni"; case "MM": return d += 1 === a ? "mesec" : 2 === a ? "meseca" : 3 === a || 4 === a ? "mesece" : "mesecev"; case "yy": return d += 1 === a ? "leto" : 2 === a ? "leti" : 3 === a || 4 === a ? "leta" : "let" } } return a.lang("sl", { months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"), weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"), weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"), weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"), longDateFormat: { LT: "H:mm", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY LT", LLLL: "dddd, D. MMMM YYYY LT" }, calendar: { sameDay: "[danes ob] LT", nextDay: "[jutri ob] LT", nextWeek: function () { switch (this.day()) { case 0: return "[v] [nedeljo] [ob] LT"; case 3: return "[v] [sredo] [ob] LT"; case 6: return "[v] [soboto] [ob] LT"; case 1: case 2: case 4: case 5: return "[v] dddd [ob] LT" } }, lastDay: "[včeraj ob] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: case 6: return "[prejšnja] dddd [ob] LT"; case 1: case 2: case 4: case 5: return "[prejšnji] dddd [ob] LT" } }, sameElse: "L" }, relativeTime: { future: "čez %s", past: "%s nazaj", s: "nekaj sekund", m: b, mm: b, h: b, hh: b, d: "en dan", dd: b, M: "en mesec", MM: b, y: "eno leto", yy: b }, ordinal: "%d.", week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("sq", { months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"), monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"), weekdays: "E Diel_E Hënë_E Marte_E Mërkure_E Enjte_E Premte_E Shtunë".split("_"), weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"), weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[Sot në] LT", nextDay: "[Neser në] LT", nextWeek: "dddd [në] LT", lastDay: "[Dje në] LT", lastWeek: "dddd [e kaluar në] LT", sameElse: "L" }, relativeTime: { future: "në %s", past: "%s me parë", s: "disa sekonda", m: "një minut", mm: "%d minuta", h: "një orë", hh: "%d orë", d: "një ditë", dd: "%d ditë", M: "një muaj", MM: "%d muaj", y: "një vit", yy: "%d vite" }, ordinal: "%d.", week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("sv", { months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"), weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"), weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"), longDateFormat: { LT: "HH:mm", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[Idag] LT", nextDay: "[Imorgon] LT", lastDay: "[Igår] LT", nextWeek: "dddd LT", lastWeek: "[Förra] dddd[en] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "för %s sedan", s: "några sekunder", m: "en minut", mm: "%d minuter", h: "en timme", hh: "%d timmar", d: "en dag", dd: "%d dagar", M: "en månad", MM: "%d månader", y: "ett år", yy: "%d år" }, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "e" : 1 === b ? "a" : 2 === b ? "a" : 3 === b ? "e" : "e"; return a + c }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("th", { months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"), monthsShort: "มกรา_กุมภา_มีนา_เมษา_พฤษภา_มิถุนา_กรกฎา_สิงหา_กันยา_ตุลา_พฤศจิกา_ธันวา".split("_"), weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"), weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"), weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"), longDateFormat: { LT: "H นาฬิกา m นาที", L: "YYYY/MM/DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY เวลา LT", LLLL: "วันddddที่ D MMMM YYYY เวลา LT" }, meridiem: function (a) { return 12 > a ? "ก่อนเที่ยง" : "หลังเที่ยง" }, calendar: { sameDay: "[วันนี้ เวลา] LT", nextDay: "[พรุ่งนี้ เวลา] LT", nextWeek: "dddd[หน้า เวลา] LT", lastDay: "[เมื่อวานนี้ เวลา] LT", lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT", sameElse: "L" }, relativeTime: { future: "อีก %s", past: "%sที่แล้ว", s: "ไม่กี่วินาที", m: "1 นาที", mm: "%d นาที", h: "1 ชั่วโมง", hh: "%d ชั่วโมง", d: "1 วัน", dd: "%d วัน", M: "1 เดือน", MM: "%d เดือน", y: "1 ปี", yy: "%d ปี" } }) }), function (a) { a(bb) }(function (a) { return a.lang("tl-ph", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY LT", LLLL: "dddd, MMMM DD, YYYY LT" }, calendar: { sameDay: "[Ngayon sa] LT", nextDay: "[Bukas sa] LT", nextWeek: "dddd [sa] LT", lastDay: "[Kahapon sa] LT", lastWeek: "dddd [huling linggo] LT", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, ordinal: function (a) { return a }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { var b = { 1: "'inci", 5: "'inci", 8: "'inci", 70: "'inci", 80: "'inci", 2: "'nci", 7: "'nci", 20: "'nci", 50: "'nci", 3: "'üncü", 4: "'üncü", 100: "'üncü", 6: "'ncı", 9: "'uncu", 10: "'uncu", 30: "'uncu", 60: "'ıncı", 90: "'ıncı" }; return a.lang("tr", { months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"), monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"), weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pts_Sal_Çar_Per_Cum_Cts".split("_"), weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"), longDateFormat: { LT: "HH:mm", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd, D MMMM YYYY LT" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[yarın saat] LT", nextWeek: "[haftaya] dddd [saat] LT", lastDay: "[dün] LT", lastWeek: "[geçen hafta] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s önce", s: "birkaç saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", M: "bir ay", MM: "%d ay", y: "bir yıl", yy: "%d yıl" }, ordinal: function (a) { if (0 === a) return a + "'ıncı"; var c = a % 10, d = a % 100 - c, e = a >= 100 ? 100 : null; return a + (b[c] || b[d] || b[e]) }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("tzm-la", { months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[asdkh g] LT", nextDay: "[aska g] LT", nextWeek: "dddd [g] LT", lastDay: "[assant g] LT", lastWeek: "dddd [g] LT", sameElse: "L" }, relativeTime: { future: "dadkh s yan %s", past: "yan %s", s: "imik", m: "minuḍ", mm: "%d minuḍ", h: "saɛa", hh: "%d tassaɛin", d: "ass", dd: "%d ossan", M: "ayowr", MM: "%d iyyirn", y: "asgas", yy: "%d isgasn" }, week: { dow: 6, doy: 12 } }) }), function (a) { a(bb) }(function (a) { return a.lang("tzm", { months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "dddd D MMMM YYYY LT" }, calendar: { sameDay: "[ⴰⵙⴷⵅ ⴴ] LT", nextDay: "[ⴰⵙⴽⴰ ⴴ] LT", nextWeek: "dddd [ⴴ] LT", lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT", lastWeek: "dddd [ⴴ] LT", sameElse: "L" }, relativeTime: { future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s", past: "ⵢⴰⵏ %s", s: "ⵉⵎⵉⴽ", m: "ⵎⵉⵏⵓⴺ", mm: "%d ⵎⵉⵏⵓⴺ", h: "ⵙⴰⵄⴰ", hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ", d: "ⴰⵙⵙ", dd: "%d oⵙⵙⴰⵏ", M: "ⴰⵢoⵓⵔ", MM: "%d ⵉⵢⵢⵉⵔⵏ", y: "ⴰⵙⴳⴰⵙ", yy: "%d ⵉⵙⴳⴰⵙⵏ" }, week: { dow: 6, doy: 12 } }) }), function (a) { a(bb) }(function (a) {
    function b(a, b) { var c = a.split("_"); return b % 10 === 1 && b % 100 !== 11 ? c[0] : b % 10 >= 2 && 4 >= b % 10 && (10 > b % 100 || b % 100 >= 20) ? c[1] : c[2] } function c(a, c, d) { var e = { mm: "хвилина_хвилини_хвилин", hh: "година_години_годин", dd: "день_дні_днів", MM: "місяць_місяці_місяців", yy: "рік_роки_років" }; return "m" === d ? c ? "хвилина" : "хвилину" : "h" === d ? c ? "година" : "годину" : a + " " + b(e[d], +a) } function d(a, b) {
      var c = { nominative: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_"), accusative: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_") }, d = /D[oD]? *MMMM?/.test(b) ? "accusative" : "nominative";
      return c[d][a.month()]
    } function e(a, b) { var c = { nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"), accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"), genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_") }, d = /(\[[ВвУу]\]) ?dddd/.test(b) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(b) ? "genitive" : "nominative"; return c[d][a.day()] } function f(a) { return function () { return a + "о" + (11 === this.hours() ? "б" : "") + "] LT" } } return a.lang("uk", { months: d, monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"), weekdays: e, weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", L: "DD.MM.YYYY", LL: "D MMMM YYYY р.", LLL: "D MMMM YYYY р., LT", LLLL: "dddd, D MMMM YYYY р., LT" }, calendar: { sameDay: f("[Сьогодні "), nextDay: f("[Завтра "), lastDay: f("[Вчора "), nextWeek: f("[У] dddd ["), lastWeek: function () { switch (this.day()) { case 0: case 3: case 5: case 6: return f("[Минулої] dddd [").call(this); case 1: case 2: case 4: return f("[Минулого] dddd [").call(this) } }, sameElse: "L" }, relativeTime: { future: "за %s", past: "%s тому", s: "декілька секунд", m: c, mm: c, h: "годину", hh: c, d: "день", dd: c, M: "місяць", MM: c, y: "рік", yy: c }, meridiem: function (a) { return 4 > a ? "ночі" : 12 > a ? "ранку" : 17 > a ? "дня" : "вечора" }, ordinal: function (a, b) { switch (b) { case "M": case "d": case "DDD": case "w": case "W": return a + "-й"; case "D": return a + "-го"; default: return a } }, week: { dow: 1, doy: 7 } })
  }), function (a) { a(bb) }(function (a) { return a.lang("uz", { months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"), monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"), weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"), weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"), weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY LT", LLLL: "D MMMM YYYY, dddd LT" }, calendar: { sameDay: "[Бугун соат] LT [да]", nextDay: "[Эртага] LT [да]", nextWeek: "dddd [куни соат] LT [да]", lastDay: "[Кеча соат] LT [да]", lastWeek: "[Утган] dddd [куни соат] LT [да]", sameElse: "L" }, relativeTime: { future: "Якин %s ичида", past: "Бир неча %s олдин", s: "фурсат", m: "бир дакика", mm: "%d дакика", h: "бир соат", hh: "%d соат", d: "бир кун", dd: "%d кун", M: "бир ой", MM: "%d ой", y: "бир йил", yy: "%d йил" }, week: { dow: 1, doy: 7 } }) }), function (a) { a(bb) }(function (a) { return a.lang("vn", { months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"), monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"), weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"), weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"), longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM [năm] YYYY", LLL: "D MMMM [năm] YYYY LT", LLLL: "dddd, D MMMM [năm] YYYY LT", l: "DD/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY LT", llll: "ddd, D MMM YYYY LT" }, calendar: { sameDay: "[Hôm nay lúc] LT", nextDay: "[Ngày mai lúc] LT", nextWeek: "dddd [tuần tới lúc] LT", lastDay: "[Hôm qua lúc] LT", lastWeek: "dddd [tuần rồi lúc] LT", sameElse: "L" }, relativeTime: { future: "%s tới", past: "%s trước", s: "vài giây", m: "một phút", mm: "%d phút", h: "một giờ", hh: "%d giờ", d: "một ngày", dd: "%d ngày", M: "một tháng", MM: "%d tháng", y: "một năm", yy: "%d năm" }, ordinal: function (a) { return a }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("zh-cn", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "Ah点mm", L: "YYYY年MMMD日", LL: "YYYY年MMMD日", LLL: "YYYY年MMMD日LT", LLLL: "YYYY年MMMD日ddddLT", l: "YYYY年MMMD日", ll: "YYYY年MMMD日", lll: "YYYY年MMMD日LT", llll: "YYYY年MMMD日ddddLT" }, meridiem: function (a, b) { var c = 100 * a + b; return 600 > c ? "凌晨" : 900 > c ? "早上" : 1130 > c ? "上午" : 1230 > c ? "中午" : 1800 > c ? "下午" : "晚上" }, calendar: { sameDay: function () { return 0 === this.minutes() ? "[今天]Ah[点整]" : "[今天]LT" }, nextDay: function () { return 0 === this.minutes() ? "[明天]Ah[点整]" : "[明天]LT" }, lastDay: function () { return 0 === this.minutes() ? "[昨天]Ah[点整]" : "[昨天]LT" }, nextWeek: function () { var b, c; return b = a().startOf("week"), c = this.unix() - b.unix() >= 604800 ? "[下]" : "[本]", 0 === this.minutes() ? c + "dddAh点整" : c + "dddAh点mm" }, lastWeek: function () { var b, c; return b = a().startOf("week"), c = this.unix() < b.unix() ? "[上]" : "[本]", 0 === this.minutes() ? c + "dddAh点整" : c + "dddAh点mm" }, sameElse: "L" }, ordinal: function (a, b) { switch (b) { case "d": case "D": case "DDD": return a + "日"; case "M": return a + "月"; case "w": case "W": return a + "周"; default: return a } }, relativeTime: { future: "%s内", past: "%s前", s: "几秒", m: "1分钟", mm: "%d分钟", h: "1小时", hh: "%d小时", d: "1天", dd: "%d天", M: "1个月", MM: "%d个月", y: "1年", yy: "%d年" }, week: { dow: 1, doy: 4 } }) }), function (a) { a(bb) }(function (a) { return a.lang("zh-tw", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "Ah點mm", L: "YYYY年MMMD日", LL: "YYYY年MMMD日", LLL: "YYYY年MMMD日LT", LLLL: "YYYY年MMMD日ddddLT", l: "YYYY年MMMD日", ll: "YYYY年MMMD日", lll: "YYYY年MMMD日LT", llll: "YYYY年MMMD日ddddLT" }, meridiem: function (a, b) { var c = 100 * a + b; return 900 > c ? "早上" : 1130 > c ? "上午" : 1230 > c ? "中午" : 1800 > c ? "下午" : "晚上" }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" }, ordinal: function (a, b) { switch (b) { case "d": case "D": case "DDD": return a + "日"; case "M": return a + "月"; case "w": case "W": return a + "週"; default: return a } }, relativeTime: { future: "%s內", past: "%s前", s: "幾秒", m: "一分鐘", mm: "%d分鐘", h: "一小時", hh: "%d小時", d: "一天", dd: "%d天", M: "一個月", MM: "%d個月", y: "一年", yy: "%d年" } }) }), bb.lang("en"), nb ? (module.exports = bb, ab(!0)) : "function" == typeof define && define.amd ? define("moment", ['require', 'exports', 'module'], function (b, c, d) { return d.config().noGlobal !== !0 && ab(d.config().noGlobal === a), bb }) : ab()
}).call(this);
/**
* DateUtils
* @author: Julie Cardinal
* @dependencies: momentjs
*
* Utilities created to help to works with date created with momentjs (//momentjs.com/)
*
*/

define('UTILS_DATE', ["jquery", "moment"], function ($, moment) {

  /******************************************* INITIALIZE **************************************/

  function DateUtils() {
    var formatedTimezone = "-0400";

    if ($("body").data("timezone") == "-5") {
      formatedTimezone = "-0500";
    }

    var gmt = formatedTimezone,
      currentDate = moment().zone(gmt);

    return {
      areSameDate: function (d1, d2) {

        var value = moment(1397102160 * 1000).zone('-0400').format('YYYY-MM-DD HH:mm');
        var value2 = moment(1397102460 * 1000).zone('-0400').format('YYYY-MM-DD HH:mm');

        return d1.get('year') == d2.get('year') && d1.get('month') == d2.get('month') && d1.get('date') == d2.get('date');
      },
      isBeforeOrSameDate: function (d1, d2) {
        //return d1.get('year') >= d2.get('year') && d1.get('month') >= d2.get('month') && d1.get('date') >= d2.get('date');
        if (d1.get('year') > d2.get('year') || (d1.get('year') == d2.get('year') && d1.get('month') > d2.get('month'))) {
          return true;
        } else if (d1.get('year') == d2.get('year') && d1.get('month') == d2.get('month') && d1.get('date') >= d2.get('date')) {
          return true;
        } else {
          return false;
        }
      },
      isAfterOrSameDate: function (d1, d2) {
        //return d1.get('year') <= d2.get('year') && d1.get('month') <= d2.get('month') && d1.get('date') <= d2.get('date');
        if (d1.get('year') < d2.get('year') || (d1.get('year') == d2.get('year') && d1.get('month') < d2.get('month'))) {
          return true;
        } else if (d1.get('year') == d2.get('year') && d1.get('month') == d2.get('month') && d1.get('date') <= d2.get('date')) {
          return true;
        } else {
          return false;
        }
      },
      getTimezone: function () {
        return gmt;
      },
      currentDateServer: function () {
        return currentDate;
      },
      now: function () {
        var m = moment(new Date().getTime()).zone(gmt).hour(0).minute(0).second(0);

        return m;
      },
      tomorrow: function () {
        var m = moment(new Date().getTime()).add('d', 1).zone(gmt).hour(0).minute(0).second(0);

        return m;
      },
      getHours: function () {

      },
      nowTimestamp: function () {
        return new Date().getTime();
      },
      convertTimestampToDate: function (timestamp) {
        return moment(timestamp * 1000).zone(gmt)
      },
      timestampToHtml5Datetime: function (timestamps) {
        return this.convertTimestampToDate(timestamps).format('YYYY-MM-DDTHH:mm');
      },
      ceilHoursOnThirtyStep: function (d) {
        /* Check if d minutes must be ceil */
        var m = d.minutes()
          , d = moment(d);

        if (m && m != 30) {
          /* Get number of minutes to add */
          var add = (m < 30) ? 30 - m : 60 - m;
          d = moment(d).add('minutes', add);
        }

        return d;
      },
      getDayAndMonthName: function (d1) {
        if (moment().lang()._abbr == "en") {
          return moment(d1).format('MMMM Do');
        } else {
          return moment(d1).format('Do MMMM');
        }

      }
    }
  }


  return new DateUtils();

});
define('uiTools/collapse-css', [
  'jquery'
], function ($) {

  /* Collapse elements */
  var Module = function ($el, opts) {
    var defaultOpts = {
      parent: {
        css: 'commerce-zone-collapse'
      },
      stateOpen: {
        css: 'collapse-open'
      },
      contentSelector: 'ul:first',
      autoclose: true
    };

    this.opts = $.extend({}, defaultOpts, opts);
    this.elt = $($el);
    this.container = $('.collapse-content', this.elt);
    this.height = this.getHeight();
    this.btn = $('a:first', this.elt);
    this.collapsed = false;
    this.visibleState = false;

    return this.init();
  };

  $.extend(Module.prototype, {
    init: function () {
      var self = this
        , o = self.opts
        , oCss = o.stateOpen.css
        , pCss = o.parent.css;

      this.btn.bind('click', function (evt) {
        evt.preventDefault();
        /* Force getHeight for dynamic content injection */
        self.height = self.getHeight();

        this.blur();

        var fn = 'close';
        if (!self.collapsed) {
          fn = 'open';
        }

        self[fn]();
        return false;
      });

      this.container.on('transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd', function (evt) {
        if (!self.container.height()) {
          self.elt.removeClass(oCss);
        }
      });

      if (o.autoclose) {
        $('body').on('click', function (evt) {
          if (self.visibleState && self.collapsed) {
            var $target = $(evt.target);
            if (!$target.parents('.' + pCss + ':first').length) {
              self.close();
            }
          }
        });
      }

      return this;
    },

    open: function () {
      var css = this.opts.stateOpen.css;
      this.collapsed = true;
      this.elt.addClass(css);
      this.container.height(this.height);
      return this;
    },

    close: function (force) {
      var css = this.opts.stateOpen.css;
      this.collapsed = false;
      if (force) {
        /* Resize page breakpoint */
        this.elt.removeClass(css);
      }

      this.container.height(0);
      return this;
    },

    refresh: function () {
      this.height = this.getHeight();
      return this;
    },

    getHeight: function () {
      var selector = this.opts.contentSelector;
      return this.container.children(selector).innerHeight();
    }
  });

  return Module;
});
// jQuery Mask Plugin v1.14.15
// github.com/igorescobar/jQuery-Mask-Plugin
var $jscomp = { scope: {}, findInternal: function (a, l, d) { a instanceof String && (a = String(a)); for (var p = a.length, h = 0; h < p; h++) { var b = a[h]; if (l.call(d, b, h, a)) return { i: h, v: b } } return { i: -1, v: void 0 } } }; $jscomp.defineProperty = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, l, d) { if (d.get || d.set) throw new TypeError("ES3 does not support getters and setters."); a != Array.prototype && a != Object.prototype && (a[l] = d.value) };
$jscomp.getGlobal = function (a) { return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a }; $jscomp.global = $jscomp.getGlobal(this); $jscomp.polyfill = function (a, l, d, p) { if (l) { d = $jscomp.global; a = a.split("."); for (p = 0; p < a.length - 1; p++) { var h = a[p]; h in d || (d[h] = {}); d = d[h] } a = a[a.length - 1]; p = d[a]; l = l(p); l != p && null != l && $jscomp.defineProperty(d, a, { configurable: !0, writable: !0, value: l }) } };
$jscomp.polyfill("Array.prototype.find", function (a) { return a ? a : function (a, d) { return $jscomp.findInternal(this, a, d).v } }, "es6-impl", "es3");
(function (a, l, d) { "function" === typeof define && define.amd ? define('mask', ["jquery"], a) : "object" === typeof exports ? module.exports = a(require("jquery")) : a(l || d) })(function (a) {
  var l = function (b, e, f) {
    var c = {
      invalid: [], getCaret: function () { try { var a, r = 0, g = b.get(0), e = document.selection, f = g.selectionStart; if (e && -1 === navigator.appVersion.indexOf("MSIE 10")) a = e.createRange(), a.moveStart("character", -c.val().length), r = a.text.length; else if (f || "0" === f) r = f; return r } catch (C) { } }, setCaret: function (a) {
        try {
          if (b.is(":focus")) {
            var c,
            g = b.get(0); g.setSelectionRange ? g.setSelectionRange(a, a) : (c = g.createTextRange(), c.collapse(!0), c.moveEnd("character", a), c.moveStart("character", a), c.select())
          }
        } catch (B) { }
      }, events: function () {
        b.on("keydown.mask", function (a) { b.data("mask-keycode", a.keyCode || a.which); b.data("mask-previus-value", b.val()); b.data("mask-previus-caret-pos", c.getCaret()); c.maskDigitPosMapOld = c.maskDigitPosMap }).on(a.jMaskGlobals.useInput ? "input.mask" : "keyup.mask", c.behaviour).on("paste.mask drop.mask", function () {
          setTimeout(function () { b.keydown().keyup() },
            100)
        }).on("change.mask", function () { b.data("changed", !0) }).on("blur.mask", function () { d === c.val() || b.data("changed") || b.trigger("change"); b.data("changed", !1) }).on("blur.mask", function () { d = c.val() }).on("focus.mask", function (b) { !0 === f.selectOnFocus && a(b.target).select() }).on("focusout.mask", function () { f.clearIfNotMatch && !h.test(c.val()) && c.val("") })
      }, getRegexMask: function () {
        for (var a = [], b, c, f, n, d = 0; d < e.length; d++)(b = m.translation[e.charAt(d)]) ? (c = b.pattern.toString().replace(/.{1}$|^.{1}/g, ""), f = b.optional,
          (b = b.recursive) ? (a.push(e.charAt(d)), n = { digit: e.charAt(d), pattern: c }) : a.push(f || b ? c + "?" : c)) : a.push(e.charAt(d).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")); a = a.join(""); n && (a = a.replace(new RegExp("(" + n.digit + "(.*" + n.digit + ")?)"), "($1)?").replace(new RegExp(n.digit, "g"), n.pattern)); return new RegExp(a)
      }, destroyEvents: function () { b.off("input keydown keyup paste drop blur focusout ".split(" ").join(".mask ")) }, val: function (a) {
        var c = b.is("input") ? "val" : "text"; if (0 < arguments.length) {
          if (b[c]() !== a) b[c](a);
          c = b
        } else c = b[c](); return c
      }, calculateCaretPosition: function () {
        var a = b.data("mask-previus-value") || "", e = c.getMasked(), g = c.getCaret(); if (a !== e) {
          var f = b.data("mask-previus-caret-pos") || 0, e = e.length, d = a.length, m = a = 0, h = 0, l = 0, k; for (k = g; k < e && c.maskDigitPosMap[k]; k++)m++; for (k = g - 1; 0 <= k && c.maskDigitPosMap[k]; k--)a++; for (k = g - 1; 0 <= k; k--)c.maskDigitPosMap[k] && h++; for (k = f - 1; 0 <= k; k--)c.maskDigitPosMapOld[k] && l++; g > d ? g = 10 * e : f >= g && f !== d ? c.maskDigitPosMapOld[g] || (f = g, g = g - (l - h) - a, c.maskDigitPosMap[g] && (g = f)) : g > f &&
            (g = g + (h - l) + m)
        } return g
      }, behaviour: function (f) { f = f || window.event; c.invalid = []; var e = b.data("mask-keycode"); if (-1 === a.inArray(e, m.byPassKeys)) { var e = c.getMasked(), g = c.getCaret(); setTimeout(function () { c.setCaret(c.calculateCaretPosition()) }, a.jMaskGlobals.keyStrokeCompensation); c.val(e); c.setCaret(g); return c.callbacks(f) } }, getMasked: function (a, b) {
        var g = [], d = void 0 === b ? c.val() : b + "", n = 0, h = e.length, q = 0, l = d.length, k = 1, r = "push", p = -1, t = 0, y = [], v, z; f.reverse ? (r = "unshift", k = -1, v = 0, n = h - 1, q = l - 1, z = function () {
          return -1 <
            n && -1 < q
        }) : (v = h - 1, z = function () { return n < h && q < l }); for (var A; z();) { var x = e.charAt(n), w = d.charAt(q), u = m.translation[x]; if (u) w.match(u.pattern) ? (g[r](w), u.recursive && (-1 === p ? p = n : n === v && n !== p && (n = p - k), v === p && (n -= k)), n += k) : w === A ? (t--, A = void 0) : u.optional ? (n += k, q -= k) : u.fallback ? (g[r](u.fallback), n += k, q -= k) : c.invalid.push({ p: q, v: w, e: u.pattern }), q += k; else { if (!a) g[r](x); w === x ? (y.push(q), q += k) : (A = x, y.push(q + t), t++); n += k } } d = e.charAt(v); h !== l + 1 || m.translation[d] || g.push(d); g = g.join(""); c.mapMaskdigitPositions(g,
          y, l); return g
      }, mapMaskdigitPositions: function (a, b, e) { a = f.reverse ? a.length - e : 0; c.maskDigitPosMap = {}; for (e = 0; e < b.length; e++)c.maskDigitPosMap[b[e] + a] = 1 }, callbacks: function (a) { var h = c.val(), g = h !== d, m = [h, a, b, f], q = function (a, b, c) { "function" === typeof f[a] && b && f[a].apply(this, c) }; q("onChange", !0 === g, m); q("onKeyPress", !0 === g, m); q("onComplete", h.length === e.length, m); q("onInvalid", 0 < c.invalid.length, [h, a, b, c.invalid, f]) }
    }; b = a(b); var m = this, d = c.val(), h; e = "function" === typeof e ? e(c.val(), void 0, b, f) : e; m.mask =
      e; m.options = f; m.remove = function () { var a = c.getCaret(); m.options.placeholder && b.removeAttr("placeholder"); b.data("mask-maxlength") && b.removeAttr("maxlength"); c.destroyEvents(); c.val(m.getCleanVal()); c.setCaret(a); return b }; m.getCleanVal = function () { return c.getMasked(!0) }; m.getMaskedVal = function (a) { return c.getMasked(!1, a) }; m.init = function (d) {
        d = d || !1; f = f || {}; m.clearIfNotMatch = a.jMaskGlobals.clearIfNotMatch; m.byPassKeys = a.jMaskGlobals.byPassKeys; m.translation = a.extend({}, a.jMaskGlobals.translation, f.translation);
        m = a.extend(!0, {}, m, f); h = c.getRegexMask(); if (d) c.events(), c.val(c.getMasked()); else { f.placeholder && b.attr("placeholder", f.placeholder); b.data("mask") && b.attr("autocomplete", "off"); d = 0; for (var l = !0; d < e.length; d++) { var g = m.translation[e.charAt(d)]; if (g && g.recursive) { l = !1; break } } l && b.attr("maxlength", e.length).data("mask-maxlength", !0); c.destroyEvents(); c.events(); d = c.getCaret(); c.val(c.getMasked()); c.setCaret(d) }
      }; m.init(!b.is("input"))
  }; a.maskWatchers = {}; var d = function () {
    var b = a(this), e = {}, f = b.attr("data-mask");
    b.attr("data-mask-reverse") && (e.reverse = !0); b.attr("data-mask-clearifnotmatch") && (e.clearIfNotMatch = !0); "true" === b.attr("data-mask-selectonfocus") && (e.selectOnFocus = !0); if (p(b, f, e)) return b.data("mask", new l(this, f, e))
  }, p = function (b, e, f) { f = f || {}; var c = a(b).data("mask"), d = JSON.stringify; b = a(b).val() || a(b).text(); try { return "function" === typeof e && (e = e(b)), "object" !== typeof c || d(c.options) !== d(f) || c.mask !== e } catch (t) { } }, h = function (a) {
    var b = document.createElement("div"), d; a = "on" + a; d = a in b; d || (b.setAttribute(a,
      "return;"), d = "function" === typeof b[a]); return d
  }; a.fn.mask = function (b, d) { d = d || {}; var e = this.selector, c = a.jMaskGlobals, h = c.watchInterval, c = d.watchInputs || c.watchInputs, t = function () { if (p(this, b, d)) return a(this).data("mask", new l(this, b, d)) }; a(this).each(t); e && "" !== e && c && (clearInterval(a.maskWatchers[e]), a.maskWatchers[e] = setInterval(function () { a(document).find(e).each(t) }, h)); return this }; a.fn.masked = function (a) { return this.data("mask").getMaskedVal(a) }; a.fn.unmask = function () {
    clearInterval(a.maskWatchers[this.selector]);
    delete a.maskWatchers[this.selector]; return this.each(function () { var b = a(this).data("mask"); b && b.remove().removeData("mask") })
  }; a.fn.cleanVal = function () { return this.data("mask").getCleanVal() }; a.applyDataMask = function (b) { b = b || a.jMaskGlobals.maskElements; (b instanceof a ? b : a(b)).filter(a.jMaskGlobals.dataMaskAttr).each(d) }; h = {
    maskElements: "input,td,span,div", dataMaskAttr: "*[data-mask]", dataMask: !0, watchInterval: 300, watchInputs: !0, keyStrokeCompensation: 10, useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) &&
      h("input"), watchDataMask: !1, byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91], translation: { 0: { pattern: /\d/ }, 9: { pattern: /\d/, optional: !0 }, "#": { pattern: /\d/, recursive: !0 }, A: { pattern: /[a-zA-Z0-9]/ }, S: { pattern: /[a-zA-Z]/ } }
  }; a.jMaskGlobals = a.jMaskGlobals || {}; h = a.jMaskGlobals = a.extend(!0, {}, h, a.jMaskGlobals); h.dataMask && a.applyDataMask(); setInterval(function () { a.jMaskGlobals.watchDataMask && a.applyDataMask() }, h.watchInterval)
}, window.jQuery, window.Zepto);


define('uiTools/formHelpers', [
  'jquery',
  'UTILS',
  'mobiscroll',
  'mobi/config',
  'UTILS_DATE',
  'moment',
  'uiTools/collapse-css',
  'mask'
], function ($, Utils, mobiscroll, MobiConfig, DateUtils, moment, Collapse) {

  var FormHelpers = (function () {
    /* Pseudo Placeholder text */
    var _PlaceHolder = function ($c, opts) {
      var defaultOpts = {
        selectors: {
          text: 'alternatePlaceHolder',
          focus: 'focus',
          field: 'input[type=text]'
        }
      };

      /* Instance Options */
      this.opts = $.extend({}, defaultOpts, opts);

      var s = this.opts.selectors;
      /* HTML Elements */
      this.wrapper = $c;
      this.container = $('.' + s.text, this.wrapper);
      this.text = this.container.text();
      this.field = $(s.field + ':first', this.wrapper);

      return this.init();
    };

    $.extend(_PlaceHolder.prototype, {
      init: function () {

        var self = this
          , f = self.field
          , w = self.wrapper
          , s = self.opts.selectors;

        f.bind('focus', function () {
          w.addClass(s.focus);
        }).bind('blur', function () {
          w.removeClass(s.focus);
        }).bind('keyup', function () {
          self.refresh();
        });

        self.container.bind('click', function () {
          if (f.length) {
            f[0].focus();
          }
        });

        return this.refresh();
      },

      refresh: function () {
        var val = this.field.val()
          , p = (!val.length) ? 'block' : 'none';

        this.container.css({ display: p });
        return this;
      }
    });

    var _PhoneFormat = function ($c, opts) {

      var defaultOpts = {
        'pattern': '(000) 000-0000'
      };

      /* Instance Options */
      this.opts = $.extend({}, defaultOpts, opts);
      this.field = $($c);
      return this.init();
    };

    $.extend(_PhoneFormat.prototype, {
      init: function () {

        if (this.field.length) {

          var self = this,
            f = self.field;

          $(f).mask(this.opts.pattern);

          f.bind('blur', function () {
            self.clear();
            return;
          });
        }

        return this.clear();
      },

      clear: function () {
        var f = this.field
          , val = f.val()
          , regExp = /\d/i;

        if (!regExp.test(val)) {
          f.val('');
        }

        return this;
      }
    });


    return {
      PhoneFormat: function ($f, opts) {
        return new _PhoneFormat($f, opts);
      }
    }
  })();

  var opts = {
    selectors: {
      phoneFormatter: 'data-helper="phone-formatter"'
    }

  };

  var mobiScrollOpts = {
    onClose: function (valueText, inst) {
      console.log(inst);
    }
  };

  $.extend(mobiScrollOpts, MobiConfig.getCalendarDefaultOptions());

  var ModuleFormHelpers = {
    init: function (context) {

      /* Format */
      $('input[' + opts.selectors.phoneFormatter + ']', $(context)).each(function (i, elt) {
        FormHelpers.PhoneFormat($(elt), {});
      });

      /* Collapse optionnal fields */
      (function () {
        var $root = $('.form-collapse', $(context))
          , opts = {
            parent: { css: 'form-collapse' },
            contentSelector: 'div:first',
            autoclose: false
          };
        $root.each(function () {
          new Collapse($(this), opts);
        });

      })();

      /* Date picker */
      (function () {
        var $root = $('label.date-picker', $(context));
        $root.each(function (i, label) {
          var $input = $('input[readonly="readonly"]', label);
          $input.mobiscroll().calendar(mobiScrollOpts);
        });
      })();

      /* Error msg */
      (function () {
        var $errors = $('.error', $(context));

        $errors.each(function (i, c) {
          var $c = $(c)
            , $msg = $('.msg', $c)
            , $input = $('textarea, input[type="text"]', $c)
            , active = true;

          if ($c.length && $input.length) {
            $input.bind('focus', function () {
              if (!active) return;
              $msg.css({ display: 'block' });
            }).bind('blur', function () {
              $msg.css({ display: 'none' });
            }).bind('change', function () {
              active = false;
              $c.removeClass('error');
              $msg.css({ display: 'none' });

              if ($input.is('textarea')) {
                var rel = $c.data('related');
                $('#' + rel).removeClass('error');
              }
            });
          }
        });

        //Focus on first error
        if ($errors.length) {
          $t = $('input[type=text]', $errors);

          if ($t.length) {
            $t.first().focus();
            console.log("focus", $t.first());
          }
        }
      })();


      var optsDate = {
        now: moment(DateUtils.currentDateServer()).toDate(),
        maxDate: moment(DateUtils.currentDateServer()).toDate()
      };

      $.extend(optsDate, MobiConfig.getCalendarDefaultOptions());



      $('label.date-picker input').mobiscroll().calendar(optsDate);

      $('label.hours-picker input').mobiscroll().time(MobiConfig.getHourPickerDefaultOptions());



    }
  }


  return ModuleFormHelpers;
});
define('uiTools/toggle', [
  'jquery',
], function ($) {
  var Toggle = {
    init: function (context) {

      $(context).each(function (index) {

        $(this).on("click", function () {
          var idToOpen = $(this).data('toggle-id');
          var elementToToggle = $("[data-to-toggle-id=" + idToOpen + "]");

          if (elementToToggle.attr("data-is-open") === "false") {
            elementToToggle.attr('data-is-open', "true");
          } else {
            elementToToggle.attr('data-is-open', "false");
          }
        });
      });

    }
  };

  return Toggle;
});

define('uiTools/tools', [
  'jquery',
  'uiTools/retinaImages',
  'uiTools/tooltips',
  'uiTools/customSelect',
  'uiTools/placeholder',
  'buttonGroup',
  'uiTools/modals',
  'responsiveTable',
  'equalize',
  'uiTools/filters',
  'uiTools/faq',
  'genericResponsiveTable',
  'uiTools/mailto',
  'uiTools/customSelectDOM',
  'uiTools/pagination',
  'uiTools/news',
  'uiTools/formHelpers',
  'uiTools/toggle'

], function ($, RetinaImages, Tooltips, CustomSelect, Placeholder, BoutonsGroup, Modals, ResponsiveTable, Equalize, Filters, FAQ, GenericReponsiveTable, Mailto, CustomSelectDOM, Pagination, News, FormHelpers, Toggle) {

  var uiTools = {
    retinaImages: function (context) {
      RetinaImages.init(context);
    },
    tooltips: function (context) {
      Tooltips.init(context);
    },
    customSelect: function (context) {
      CustomSelect.init(context);
    },
    placeholder: function (context) {
      Placeholder.init(context);
    },
    buttonsGroup: function (context) {
      BoutonsGroup.init(context);
    },
    modals: function (context) {
      Modals.init(context);
    },
    responsiveTable: function (context) {
      ResponsiveTable.init(context);
    },
    equalize: function (context) {
      Equalize.init(context);
    },
    filters: function (context) {
      Filters.init(context);
    },
    faq: function (context) {
      FAQ.init(context);
    },
    genericReponsiveTable: function (context) {
      GenericReponsiveTable.init(context);
    },
    mailto: function (context) {
      Mailto.init(context);
    },
    customSelectDOM: function (context) {
      CustomSelectDOM.init(context);
    },
    pagination: function (context) {
      Pagination.init(context);
    },
    newsItem: function (context) {
      News.init(context);
    },
    formHelpers: function (context) {
      FormHelpers.init(context);
    },
    toggle: function (context) {
      Toggle.init(context);
    }
  };

  return uiTools;
});

define('UTILS_TIME', [], function () {

  var TimeConverter = {
    format: {
      day: 86400000,
      hour: 3600000,
      minute: 60000,
      second: 1000
    },
    getMilisecondsToSeconds: function (seconds) {
      return seconds * this.format.second;
    },
    getMilisecondsToMinutes: function (minutes) {
      return minutes * this.format.minute;
    },
    getMilisecondsToHours: function (hours) {
      return hours * this.format.hour;
    },
    getMilisecondsToDay: function (days) {
      return days * this.format.day;
    },
    getMilisecondsToType: function (type, time) {
      switch (type) {
        case "second":
          return this.getMilisecondsToSeconds(time);
          break

        case "minute":
          return this.getMilisecondsToMinutes(time);
          break

        case "hour":
          return this.getMilisecondsToHours(time);
          break

        case "day":
          return this.getMilisecondsToDay(time);
          break
      }
    }
  };

  return TimeConverter;
});
define('UTILS_UPDATER', [
  'jquery',
  'UTILS_TIME'
], function ($, Time) {


  /*************************************** INITIALIZATION *******************************************/

  var Updater = {
    create: function (scope) {
      return new UpdaterInstance(scope);
    }
  };

  /************************************* Updater Instance *****************************************/
  function UpdaterInstance(s) {

    var scope = s,
      timeInterval,
      interval,
      callback;

    function update() {
      if (callback) {
        if (scope) callback.apply(scope);
        else callback();
      }
    }

    return {
      init: function (time, cb) {
        timeInterval = time;
        callback = cb;
      },
      setCallback: function (cb) {
        callback = cb;
      },
      getTimeInterval: function () {
        return callback;
      },
      setTimeInterval: function (time) {
        timeInterval = time;
      },
      start: function () {
        interval = setInterval(function () {
          update();
        }, timeInterval);
      },
      startOnce: function () {
        interval = setTimeout(function () {
          update();
        }, timeInterval);
      },
      reset: function () {
        clearInterval(interval);
        this.start();
      },
      stop: function () {
        clearInterval(interval);
      },
      stopOnce: function () {
        clearTimeout(interval);
      }
    };
  }


  return Updater;
});
define('dataprovider', [
  'jquery',
  'settings',
  'UTILS',
  'UTILS_PRELOADER',
  'UTILS_UPDATER'
], function ($, Settings, Utils, DataProviderPreloader, Updater) {

  var RESTAPI = {
    // PRODUCTION
    arrivals: Settings.webServicePath.flight,
    departures: Settings.webServicePath.flight,
    delay: Settings.webServicePath.waitingtime,
    parkingOccupancy: Settings.webServicePath.parkingOccupancy,
    taxiWaitingTime: Settings.webServicePath.taxiWaitingTime,
    autocomplete: {
      arrival: Settings.webServicePath.autocomplete.arrival,
      departure: Settings.webServicePath.autocomplete.departure
    }
  };

  var DataProvider = {
    setTimeout: 3000,
    restTimeOut: 10000,
    begin: function (loader, myInterval) {
      if (loader && myInterval) {
        myInterval.init(this.setTimeout, function () {
          loader.show();
        });

        myInterval.startOnce();
      }
    },
    end: function (url, loader, myInterval) {
      if (loader && myInterval) {
        myInterval.stopOnce();
        loader.remove();
      }
      if (typeof window.QUnit !== 'undefined') {
        test("AJAX Test :", function () {
          console.log("AJAX Test '" + url + "': Success");
          ok(true, "Success");
        });
      }
    },
    error: function (url, jqXHR, textStatus, errorThrown, loader, myInterval) {
      if (loader && myInterval) {
        myInterval.stopOnce();
        loader.remove();
        if (typeof window.QUnit !== 'undefined') {
          test("AJAX Test :", function () {
            console.log("AJAX Test '" + url + "': Fail");
            ok(false, "Fail");
          });
        }
      }
    },
    arrivals: function (options, callback) {
      var _t = this,
        loader = new DataProviderPreloader(options.loader),
        url = RESTAPI.arrivals,
        myInterval = Updater.create(this);

      _t.begin(loader, myInterval);
      $.ajax({
        type: 'GET',
        url: url,
        data: options.ajaxOpts,
        dataType: 'json',
        success: function (data, textStatus, jqXHR) {
          _t.end(url, loader, myInterval);
          callback(data);
        },
        timeout: this.restTimeOut,
        error: function (jqXHR, textStatus, errorThrown) {

          switch (jqXHR.status) {
            case 503:
              _t.end(url, loader, myInterval);
              callback(JSON.parse(jqXHR.responseText));
              break;

            default:
              _t.error(url, jqXHR, textStatus, errorThrown, loader, myInterval);
              break;
          }
        }
      });
    },

    departures: function (options, callback) {
      var _t = this,
        loader = new DataProviderPreloader(options.loader),
        url = RESTAPI.departures,
        myInterval = Updater.create(this);

      _t.begin(loader, myInterval);

      $.ajax({
        type: 'GET',
        url: url,
        data: options.ajaxOpts,
        dataType: 'json',
        success: function (data, textStatus, jqXHR) {
          _t.end(url, loader, myInterval);
          callback(data);
        },
        timeout: this.restTimeOut,
        error: function (jqXHR, textStatus, errorThrown) {
          switch (jqXHR.status) {
            case 503:
              _t.end(url, loader, myInterval);
              callback(JSON.parse(jqXHR.responseText));
              break;

            default:
              _t.error(url, jqXHR, textStatus, errorThrown, loader, myInterval);
              break;
          }
        }
      });
    },
    delays: function (options, callback) {
      var _t = this,
        url = RESTAPI.delay;
      _t.begin();
      $.ajax({
        type: 'GET',
        url: url,
        data: options,
        dataType: 'json',
        success: function (data, textStatus, jqXHR) {
          _t.end(url);
          callback(200, data);
        },
        timeout: this.restTimeOut,
        error: function (url, jqXHR, textStatus, errorThrown) {
          _t.error(jqXHR, textStatus, errorThrown);
          callback(jqXHR.status, null);
        }
      });
    },
    parkingOccupancy: function (options, callback) {
      var _t = this,
        url = RESTAPI.parkingOccupancy;
      _t.begin();
      $.ajax({
        type: 'GET',
        url: url,
        data: options,
        dataType: 'json',
        success: function (data, textStatus, jqXHR) {
          _t.end(url);
          callback(200, data);
        },
        timeout: this.restTimeOut,
        error: function (url, jqXHR, textStatus, errorThrown) {
          _t.error(jqXHR, textStatus, errorThrown);
          callback(jqXHR.status, null);
        }
      });
    },
    taxiWaitingTime: function (options, callback) {
      var _t = this,
        url = RESTAPI.taxiWaitingTime;
      _t.begin();
      $.ajax({
        type: 'GET',
        url: url,
        data: options,
        dataType: 'json',
        success: function (data, textStatus, jqXHR) {
          _t.end(url);
          callback(200, data);
        },
        timeout: this.restTimeOut,
        error: function (url, jqXHR, textStatus, errorThrown) {
          _t.error(jqXHR, textStatus, errorThrown);
          callback(jqXHR.status, null);
        }
      });
    },
    autocomplete: function (options, callback) {
      var _t = this,
        loader = new DataProviderPreloader(options.loader),
        myInterval = Updater.create(this);

      _t.begin(loader, myInterval);

      var apiurl = "";

      switch (options.type) {
        case "arrival":
          apiurl = RESTAPI.autocomplete.arrival;
          break;
        case "departure":
          apiurl = RESTAPI.autocomplete.departure;
          break;
      }

      if (options.ajaxOpts === undefined) {
        options.ajaxOpts = {};
      }
      options.ajaxOpts.cachebreaker = Math.floor((Math.random() * 10000) + 1);

      var url = apiurl;
      $.ajax({
        type: 'GET',
        url: url,
        data: options.ajaxOpts,
        dataType: 'json',
        success: function (data, textStatus, jqXHR) {
          _t.end(url, loader, myInterval);
          callback(data);
        },
        timeout: this.restTimeOut,
        error: function (jqXHR, textStatus, errorThrown) {
          _t.error(url, jqXHR, textStatus, errorThrown, loader, myInterval);
        }
      });
    }
  };

  return DataProvider;
});
define('data/delays', [], function () {

  function Delays(data) {

    var json = {};

    // TBD
    function parseData(data) {
      var parsedData = data;
      return parsedData;
    }

    function UndefinedFrench(timeString) {
      return isNA(timeString) && isFrench() ? 'N/D' : timeString;
    }

    function isNA(timeString) {
      return typeof timeString === "string" && (timeString.indexOf("N/A") !== -1 || timeString.indexOf("N/D") !== -1);
    }

    function isFrench() {
      return (window.location.href.indexOf("temps") !== -1) ||
        (window.location.href.indexOf("acces") !== -1 && window.location.href.indexOf("access") === -1);
    }

    function isGreaterThenInString(timeString) {
      return typeof timeString === "string" && timeString.indexOf(">") !== -1;
    }
    function buildTimeClass(timeString) {
      return "<span class='time'>" + timeString + "</span>";
    }

    // TBD
    function reorganize(data) {
      const min = data.delays.arrival.min;
      const max = data.delays.arrival.max;
      let time = buildTimeClass(data.delays.arrival.min + " - " + data.delays.arrival.max) + " " + data.delays.arrival.maxMinute;
      if ((min === max) && !isNA(max) && !isGreaterThenInString(max)) {
        time = isFrench() ?
          "Environ " + buildTimeClass(data.delays.arrival.max) + " minutes" :
          buildTimeClass(data.delays.arrival.max) + " minutes approximately";
      } else if (min === max && isGreaterThenInString(max)) {
        time = buildTimeClass(data.delays.arrival.max) + " minutes";
      }
      else if (min === max && isNA(max)) {
        time = buildTimeClass(UndefinedFrench(data.delays.arrival.max));
      }
      if (isNA(data.delays.arrival.min) || isNA(data.delays.arrival.max)) {
        time = buildTimeClass(UndefinedFrench("N/A"));
      }
      json.departure = {
        intl: UndefinedFrench(data.delays.departure.intl),
        intlMinute: data.delays.departure.intlMinute ? UndefinedFrench(data.delays.departure.intlMinute) : "",
        us: UndefinedFrench(data.delays.departure.us),
        usMinute: data.delays.departure.usMinute ? UndefinedFrench(data.delays.departure.usMinute) : ""
      };

      json.arrival = {
        time: time,
        message: data.delays.arrival.message,
        minute: data.delays.arrival.maxMinute ? data.delays.arrival.maxMinute : ""
      };
      console.log(json);
    }

    reorganize(data.data);

    return json;
  }

  return Delays;
});

define('i18n_general', [], function () {

  var i18n = ADM.i18n.general;

  ADM.i18n.general = {
    "searchForFlight": Drupal.t("Search for flights ..."),
    "trackBySms": Drupal.t("Track by SMS"),
    "enProvenanceDe": Drupal.t("From", {}, { 'context': 'flightboard' }),
    "heureArrivee": Drupal.t("Arrival time"),
    "Statut": Drupal.t("Status"),
    "Porte": Drupal.t("Gate"),
    "Phone": Drupal.t("Phone :"),
    "SansFrais": Drupal.t("Toll free :"),
    "Website": Drupal.t("Website "),
    "ADestinationDe": Drupal.t("To", {}, { 'context': 'flightboard' }),
    "HeureDeDepart": Drupal.t("Departure time"),
    "Vol": Drupal.t("Flight"),
    "ErrorAjaxFilter": Drupal.t("Sorry, a system error prevents us from displaying the list of commerces that you've requested.."),
    "ErrorAjaxFilterLink": Drupal.t("Try refreshing the page later."),
    "ErrorAjaxGlobal": Drupal.t("Failure of the last attempt. The service is temporarily unavailable."),
    "RequestImages": Drupal.t("Ask the selected images"),
    "SelectAImage": Drupal.t("Please select an image"),
    "currently": Drupal.t("currently", {}, { 'context': 'flightboard' }),
    "selHours": Drupal.t("Time"),
    "HomeNewsMobile": Drupal.t("Press releases, public notices and other communications"),
    "HomeNews": Drupal.t("See all"),
    "RefreshData": Drupal.t("Refresh flight information"),
    "previous": Drupal.t("Previous"),
    "next": Drupal.t("Next"),
    "play": Drupal.t("Play"),
    "pause": Drupal.t("Pause"),
    "search": Drupal.t("Search"),
    "priorityLow": Drupal.t("Low occupancy"),
    "priorityMedium": Drupal.t("Average occupancy"),
    "priorityHigh": Drupal.t("High occupancy"),
    "toggleFlightDetail": Drupal.t("Toggle the flight detail"),
    "noRevisionFlight": Drupal.t('No revision for this flight.'),
    "compagny": Drupal.t('Compagny'),
    "doorNumber": Drupal.t('Door number'),
  };

  var Generali18n = {
    "searchForFlight": i18n.searchForFlight,
    "trackBySms": i18n.trackBySms,
    "enProvenanceDe": i18n.enProvenanceDe,
    "heureArrivee": i18n.heureArrivee,
    "Statut": i18n.Statut,
    "Porte": i18n.Porte,
    "Phone": i18n.Phone,
    "SansFrais": i18n.SansFrais,
    "Website": i18n.Website,
    "ADestinationDe": i18n.ADestinationDe,
    "HeureDeDepart": i18n.HeureDeDepart,
    "Vol": i18n.Vol,
    "ErrorAjaxFilter": i18n.ErrorAjaxFilter,
    "ErrorAjaxFilterLink": i18n.ErrorAjaxFilterLink,
    "ErrorAjaxGlobal": i18n.ErrorAjaxGlobal,
    "RequestImages": i18n.RequestImages,
    "SelectAImage": i18n.SelectAImage,
    "currently": i18n.currently,
    "selHours": i18n.selHours,
    "HomeNewsMobile": i18n.HomeNewsMobile,
    "HomeNews": i18n.HomeNews,
    "RefreshData": i18n.RefreshData,
    "previous": i18n.previous,
    "next": i18n.next,
    "play": i18n.play,
    "pause": i18n.pause,
    "search": i18n.search,
    "priorityLow": i18n.priorityLow,
    "priorityMedium": i18n.priorityMedium,
    "priorityHigh": i18n.priorityHigh,
    "toggleFlightDetail": i18n.toggleFlightDetail,
    "noRevisionFlight": i18n.noRevisionFlight,
    "compagny": i18n.compagny,
    "doorNumber": i18n.doorNumber,
  };

  return Generali18n;
});

/*! JsRender v1.0.0-beta: http://github.com/BorisMoore/jsrender and http://jsviews.com/jsviews */
/*
* Optimized version of jQuery Templates, for rendering to string.
* Does not require jQuery, or HTML DOM
* Integrates with JsViews (http://jsviews.com/jsviews)
* Copyright 2013, Boris Moore
* Released under the MIT License.
*/

(function (global, jQuery, undefined) {
  // global is the this object, which is window when running in the usual browser environment.
  "use strict";

  if (jQuery && jQuery.views || global.jsviews) { return; } // JsRender is already loaded

  //========================== Top-level vars ==========================

  var versionNumber = "v1.0.0-beta",

    $, jsvStoreName, rTag, rTmplString,// nodeJsModule,

    //TODO	tmplFnsCache = {},
    delimOpenChar0 = "{", delimOpenChar1 = "{", delimCloseChar0 = "}", delimCloseChar1 = "}", linkChar = "^",

    rPath = /^(?:null|true|false|\d[\d.]*|([\w$]+|\.|~([\w$]+)|#(view|([\w$]+))?)([\w$.^]*?)(?:[.[^]([\w$]+)\]?)?)$/g,
    //                                     object     helper    view  viewProperty pathTokens      leafToken

    rParams = /(\()(?=\s*\()|(?:([([])\s*)?(?:([#~]?[\w$.^]+)?\s*((\+\+|--)|\+|-|&&|\|\||===|!==|==|!=|<=|>=|[<>%*!:?\/]|(=))\s*|([#~]?[\w$.^]+)([([])?)|(,\s*)|(\(?)\\?(?:(')|("))|(?:\s*(([)\]])(?=\s*\.|\s*\^)|[)\]])([([]?))|(\s+)/g,
    //          lftPrn0        lftPrn                  path    operator err                                                eq          path2       prn    comma   lftPrn2   apos quot      rtPrn rtPrnDot                        prn2      space
    // (left paren? followed by (path? followed by operator) or (path followed by left paren?)) or comma or apos or quot or right paren or space

    rNewLine = /\s*\n/g,
    rUnescapeQuotes = /\\(['"])/g,
    rEscapeQuotes = /['"\\]/g, // Escape quotes and \ character
    rBuildHash = /\x08(~)?([^\x08]+)\x08/g,
    rTestElseIf = /^if\s/,
    rFirstElem = /<(\w+)[>\s]/,
    rAttrEncode = /[\x00`><"'&]/g, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings
    rHtmlEncode = rAttrEncode,
    autoTmplName = 0,
    viewId = 0,
    charEntities = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\x00": "&#0;",
      "'": "&#39;",
      '"': "&#34;",
      "`": "&#96;"
    },
    tmplAttr = "data-jsv-tmpl",

    $render = {},
    jsvStores = {
      template: {
        compile: compileTmpl
      },
      tag: {
        compile: compileTag
      },
      helper: {},
      converter: {}
    },

    // jsviews object ($.views if jQuery is loaded)
    $views = {
      jsviews: versionNumber,
      render: $render,
      settings: {
        delimiters: $viewsDelimiters,
        debugMode: true,
        tryCatch: true
      },
      sub: {
        // subscription, e.g. JsViews integration
        View: View,
        Error: JsViewsError,
        tmplFn: tmplFn,
        parse: parseParams,
        extend: $extend,
        error: error,
        syntaxError: syntaxError
      },
      _cnvt: convertVal,
      _tag: renderTag,

      _err: function (e) {
        // Place a breakpoint here to intercept template rendering errors
        return $viewsSettings.debugMode ? ("Error: " + (e.message || e)) + ". " : '';
      }
    };

  function JsViewsError(message, object) {
    // Error exception type for JsViews/JsRender
    // Override of $.views.sub.Error is possible
    if (object && object.onError) {
      if (object.onError(message) === false) {
        return;
      }
    }
    this.name = "JsRender Error";
    this.message = message || "JsRender error";
  }

  function $extend(target, source) {
    var name;
    target = target || {};
    for (name in source) {
      target[name] = source[name];
    }
    return target;
  }

  (JsViewsError.prototype = new Error()).constructor = JsViewsError;

  //========================== Top-level functions ==========================

  //===================
  // jsviews.delimiters
  //===================
  function $viewsDelimiters(openChars, closeChars, link) {
    // Set the tag opening and closing delimiters and 'link' character. Default is "{{", "}}" and "^"
    // openChars, closeChars: opening and closing strings, each with two characters

    if (!$viewsSub.rTag || arguments.length) {
      delimOpenChar0 = openChars ? openChars.charAt(0) : delimOpenChar0; // Escape the characters - since they could be regex special characters
      delimOpenChar1 = openChars ? openChars.charAt(1) : delimOpenChar1;
      delimCloseChar0 = closeChars ? closeChars.charAt(0) : delimCloseChar0;
      delimCloseChar1 = closeChars ? closeChars.charAt(1) : delimCloseChar1;
      linkChar = link || linkChar;
      openChars = "\\" + delimOpenChar0 + "(\\" + linkChar + ")?\\" + delimOpenChar1;  // Default is "{^{"
      closeChars = "\\" + delimCloseChar0 + "\\" + delimCloseChar1;                   // Default is "}}"
      // Build regex with new delimiters
      //          tag    (followed by / space or })   or cvtr+colon or html or code
      rTag = "(?:(?:(\\w+(?=[\\/\\s\\" + delimCloseChar0 + "]))|(?:(\\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\\*)))"
        + "\\s*((?:[^\\" + delimCloseChar0 + "]|\\" + delimCloseChar0 + "(?!\\" + delimCloseChar1 + "))*?)";

      // make rTag available to JsViews (or other components) for parsing binding expressions
      $viewsSub.rTag = rTag + ")";

      rTag = new RegExp(openChars + rTag + "(\\/)?|(?:\\/(\\w+)))" + closeChars, "g");

      // Default:    bind           tag       converter colon html     comment            code      params            slash   closeBlock
      //           /{(\^)?{(?:(?:(\w+(?=[\/\s}]))|(?:(\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\*)))\s*((?:[^}]|}(?!}))*?)(\/)?|(?:\/(\w+)))}}/g

      rTmplString = new RegExp("<.*>|([^\\\\]|^)[{}]|" + openChars + ".*" + closeChars);
      // rTmplString looks for html tags or { or } char not preceded by \\, or JsRender tags {{xxx}}. Each of these strings are considered
      // NOT to be jQuery selectors
    }
    return [delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, linkChar];
  }

  //=========
  // View.get
  //=========

  function getView(inner, type) { //view.get(inner, type)
    if (!type) {
      // view.get(type)
      type = inner;
      inner = undefined;
    }

    var views, i, l, found,
      view = this,
      root = !type || type === "root";
    // If type is undefined, returns root view (view under top view).

    if (inner) {
      // Go through views - this one, and all nested ones, depth-first - and return first one with given type.
      found = view.type === type ? view : undefined;
      if (!found) {
        views = view.views;
        if (view._.useKey) {
          for (i in views) {
            if (found = views[i].get(inner, type)) {
              break;
            }
          }
        } else for (i = 0, l = views.length; !found && i < l; i++) {
          found = views[i].get(inner, type);
        }
      }
    } else if (root) {
      // Find root view. (view whose parent is top view)
      while (view.parent.parent) {
        found = view = view.parent;
      }
    } else while (view && !found) {
      // Go through views - this one, and all parent ones - and return first one with given type.
      found = view.type === type ? view : undefined;
      view = view.parent;
    }
    return found;
  }

  function getIndex() {
    var view = this.get("item");
    return view ? view.index : undefined;
  }

  getIndex.depends = function () {
    return [this.get("item"), "index"];
  };

  //==========
  // View.hlp
  //==========

  function getHelper(helper) {
    // Helper method called as view.hlp(key) from compiled template, for helper functions or template parameters ~foo
    var wrapped,
      view = this,
      res = (view.ctx || {})[helper];

    res = res === undefined ? view.getRsc("helpers", helper) : res;

    if (res) {
      if (typeof res === "function") {
        wrapped = function () {
          // If it is of type function, we will wrap it so it gets called with view as 'this' context.
          // If the helper ~foo() was in a data-link expression, the view will have a 'temporary' linkCtx property too.
          // However note that helper functions on deeper paths will not have access to view and tagCtx.
          // For example, ~util.foo() will have the ~util object as 'this' pointer
          return res.apply(view, arguments);
        };
        $extend(wrapped, res);
      }
    }
    return wrapped || res;
  }

  //==============
  // jsviews._cnvt
  //==============

  function convertVal(converter, view, tagCtx) {
    // self is template object or linkCtx object
    var tmplConverter, tag, value,
      boundTagCtx = +tagCtx === tagCtx && tagCtx, // if value is an integer, then it is the key for the boundTagCtx
      linkCtx = view.linkCtx;

    if (boundTagCtx) {
      // Call compiled function which returns the tagCtxs for current data
      tagCtx = (boundTagCtx = view.tmpl.bnds[boundTagCtx - 1])(view.data, view, $views);
    }

    value = tagCtx.args[0];

    if (converter || boundTagCtx) {
      tag = linkCtx && linkCtx.tag || {
        _: {
          inline: !linkCtx
        },
        tagName: converter + ":",
        flow: true,
        _is: "tag"
      };

      tag._.bnd = boundTagCtx;

      if (linkCtx) {
        linkCtx.tag = tag;
        tag.linkCtx = linkCtx;
        tagCtx.ctx = extendCtx(tagCtx.ctx, linkCtx.view.ctx);
      }
      tag.tagCtx = tagCtx;
      tagCtx.view = view;

      tag.ctx = tagCtx.ctx || {};
      delete tagCtx.ctx;
      // Provide this tag on view, for addBindingMarkers on bound tags to add the tag to view._.bnds, associated with the tag id,
      view._.tag = tag;

      converter = converter !== "true" && converter; // If there is a convertBack but no convert, converter will be "true"

      if (converter && ((tmplConverter = view.getRsc("converters", converter)) || error("Unknown converter: {{" + converter + ":"))) {
        // A call to {{cnvt: ... }} or {^{cnvt: ... }} or data-link="{cnvt: ... }"
        tag.depends = tmplConverter.depends;
        value = tmplConverter.apply(tag, tagCtx.args);
      }
      // Call onRender (used by JsViews if present, to add binding annotations around rendered content)
      value = boundTagCtx && view._.onRender
        ? view._.onRender(value, view, boundTagCtx)
        : value;
      view._.tag = undefined;
    }
    return value;
  }

  //=============
  // jsviews._tag
  //=============

  function getResource(resourceType, itemName) {
    var res,
      view = this,
      store = $views[resourceType];

    res = store && store[itemName];
    while ((res === undefined) && view) {
      store = view.tmpl[resourceType];
      res = store && store[itemName];
      view = view.parent;
    }
    return res;
  }

  function renderTag(tagName, parentView, tmpl, tagCtxs) {
    // Called from within compiled template function, to render a template tag
    // Returns the rendered tag

    var render, tag, tags, attr, parentTag, i, l, itemRet, tagCtx, tagCtxCtx, content, boundTagFn, tagDef, callInit,
      ret = "",
      boundTagKey = +tagCtxs === tagCtxs && tagCtxs, // if tagCtxs is an integer, then it is the boundTagKey
      linkCtx = parentView.linkCtx || 0,
      ctx = parentView.ctx,
      parentTmpl = tmpl || parentView.tmpl,
      parentView_ = parentView._;

    if (tagName._is === "tag") {
      tag = tagName;
      tagName = tag.tagName;
    }

    // Provide tagCtx, linkCtx and ctx access from tag
    if (boundTagKey) {
      // if tagCtxs is an integer, we are data binding
      // Call compiled function which returns the tagCtxs for current data
      tagCtxs = (boundTagFn = parentTmpl.bnds[boundTagKey - 1])(parentView.data, parentView, $views);
    }

    l = tagCtxs.length;
    tag = tag || linkCtx.tag;
    for (i = 0; i < l; i++) {
      tagCtx = tagCtxs[i];

      // Set the tmpl property to the content of the block tag, unless set as an override property on the tag
      content = tagCtx.tmpl;
      content = tagCtx.content = content && parentTmpl.tmpls[content - 1];
      tmpl = tagCtx.props.tmpl;
      if (!i && (!tmpl || !tag)) {
        tagDef = parentView.getRsc("tags", tagName) || error("Unknown tag: {{" + tagName + "}}");
      }
      tmpl = tmpl || (tag ? tag._def : tagDef).template || content;
      tmpl = "" + tmpl === tmpl // if a string
        ? parentView.getRsc("templates", tmpl) || $templates(tmpl)
        : tmpl;

      $extend(tagCtx, {
        tmpl: tmpl,
        render: renderContent,
        index: i,
        view: parentView,
        ctx: extendCtx(tagCtx.ctx, ctx) // Extend parentView.ctx
      }); // Extend parentView.ctx

      if (!tag) {
        // This will only be hit for initial tagCtx (not for {{else}}) - if the tag instance does not exist yet
        // Instantiate tag if it does not yet exist
        if (tagDef._ctr) {
          // If the tag has not already been instantiated, we will create a new instance.
          // ~tag will access the tag, even within the rendering of the template content of this tag.
          // From child/descendant tags, can access using ~tag.parent, or ~parentTags.tagName
          //	TODO provide error handling owned by the tag - using tag.onError
          //				try {
          tag = new tagDef._ctr();
          callInit = !!tag.init;
          //				}
          //				catch(e) {
          //					tagDef.onError(e);
          //				}
          // Set attr on linkCtx to ensure outputting to the correct target attribute.
          tag.attr = tag.attr || tagDef.attr || undefined;
          // Setting either linkCtx.attr or this.attr in the init() allows per-instance choice of target attrib.
        } else {
          // This is a simple tag declared as a function, or with init set to false. We won't instantiate a specific tag constructor - just a standard instance object.
          tag = {
            // tag instance object if no init constructor
            render: tagDef.render
          };
        }
        tag._ = {
          inline: !linkCtx
        };
        if (linkCtx) {
          // Set attr on linkCtx to ensure outputting to the correct target attribute.
          linkCtx.attr = tag.attr = linkCtx.attr || tag.attr;
          linkCtx.tag = tag;
          tag.linkCtx = linkCtx;
        }
        if (tag._.bnd = boundTagFn || linkCtx) {
          // Bound if {^{tag...}} or data-link="{tag...}"
          tag._.arrVws = {};
        }
        tag.tagName = tagName;
        tag.parent = parentTag = ctx && ctx.tag;
        tag._is = "tag";
        tag._def = tagDef;
        // Provide this tag on view, for addBindingMarkers on bound tags to add the tag to view._.bnds, associated with the tag id,
      }
      parentView_.tag = tag;
      tagCtx.tag = tag;
      tag.tagCtxs = tagCtxs;
      if (!tag.flow) {
        tagCtxCtx = tagCtx.ctx = tagCtx.ctx || {};

        // tags hash: tag.ctx.tags, merged with parentView.ctx.tags,
        tags = tag.parents = tagCtxCtx.parentTags = ctx && extendCtx(tagCtxCtx.parentTags, ctx.parentTags) || {};
        if (parentTag) {
          tags[parentTag.tagName] = parentTag;
        }
        tagCtxCtx.tag = tag;
      }
    }
    tag.rendering = {}; // Provide object for state during render calls to tag and elses. (Used by {{if}} and {{for}}...)
    for (i = 0; i < l; i++) {
      tagCtx = tag.tagCtx = tagCtxs[i];
      tag.ctx = tagCtx.ctx;

      if (!i && callInit) {
        tag.init(tagCtx, linkCtx, tag.ctx);
        callInit = undefined;
      }

      if (render = tag.render) {
        itemRet = render.apply(tag, tagCtx.args);
      }
      ret += itemRet !== undefined
        ? itemRet   // Return result of render function unless it is undefined, in which case return rendered template
        : tagCtx.tmpl
          // render template/content on the current data item
          ? tagCtx.render()
          : ""; // No return value from render, and no template/content defined, so return ""
    }
    delete tag.rendering;

    tag.tagCtx = tag.tagCtxs[0];
    tag.ctx = tag.tagCtx.ctx;

    if (tag._.inline && (attr = tag.attr) && attr !== "html") {
      ret = attr === "text"
        ? $converters.html(ret)
        : "";
    }
    return boundTagKey && parentView._.onRender
      // Call onRender (used by JsViews if present, to add binding annotations around rendered content)
      ? parentView._.onRender(ret, parentView, boundTagKey)
      : ret;
  }

  //=================
  // View constructor
  //=================

  function View(context, type, parentView, data, template, key, contentTmpl, onRender) {
    // Constructor for view object in view hierarchy. (Augmented by JsViews if JsViews is loaded)
    var views, parentView_, tag,
      isArray = type === "array",
      self_ = {
        key: 0,
        useKey: isArray ? 0 : 1,
        id: "" + viewId++,
        onRender: onRender,
        bnds: {}
      },
      self = {
        data: data,
        tmpl: template,
        content: contentTmpl,
        views: isArray ? [] : {},
        parent: parentView,
        ctx: context,
        type: type,
        // If the data is an array, this is an 'array view' with a views array for each child 'item view'
        // If the data is not an array, this is an 'item view' with a views 'map' object for any child nested views
        // ._.useKey is non zero if is not an 'array view' (owning a data array). Uuse this as next key for adding to child views map
        get: getView,
        getIndex: getIndex,
        getRsc: getResource,
        hlp: getHelper,
        _: self_,
        _is: "view"
      };
    if (parentView) {
      views = parentView.views;
      parentView_ = parentView._;
      if (parentView_.useKey) {
        // Parent is an 'item view'. Add this view to its views object
        // self._key = is the key in the parent view map
        views[self_.key = "_" + parentView_.useKey++] = self;
        tag = parentView_.tag;
        self_.bnd = isArray && (!tag || !!tag._.bnd && tag); // For array views that are data bound for collection change events, set the
        // view._.bnd property to true for top-level link() or data-link="{for}", or to the tag instance for a data- bound tag, e.g. {^{for ...}}
      } else {
        // Parent is an 'array view'. Add this view to its views array
        views.splice(
          // self._.key = self.index - the index in the parent view array
          self_.key = self.index =
          key !== undefined
            ? key
            : views.length,
          0, self);
      }
      // If no context was passed in, use parent context
      // If context was passed in, it should have been merged already with parent context
      self.ctx = context || parentView.ctx;
    }
    return self;
  }

  //=============
  // Registration
  //=============

  function compileChildResources(parentTmpl) {
    var storeName, resources, resourceName, settings, compile;
    for (storeName in jsvStores) {
      settings = jsvStores[storeName];
      if ((compile = settings.compile) && (resources = parentTmpl[storeName + "s"])) {
        for (resourceName in resources) {
          // compile child resource declarations (templates, tags, converters or helpers)
          resources[resourceName] = compile(resourceName, resources[resourceName], parentTmpl, storeName, settings);
        }
      }
    }
  }

  function compileTag(name, tagDef, parentTmpl) {
    var init, tmpl;
    if (typeof tagDef === "function") {
      // Simple tag declared as function. No presenter instantation.
      tagDef = {
        depends: tagDef.depends,
        render: tagDef
      };
    } else {
      // Tag declared as object, used as the prototype for tag instantiation (control/presenter)
      if (tmpl = tagDef.template) {
        tagDef.template = "" + tmpl === tmpl ? ($templates[tmpl] || $templates(tmpl)) : tmpl;
      }
      if (tagDef.init !== false) {
        init = tagDef._ctr = function (tagCtx) { };
        (init.prototype = tagDef).constructor = init;
      }
    }
    if (parentTmpl) {
      tagDef._parentTmpl = parentTmpl;
    }
    //TODO	tagDef.onError = function(e) {
    //			var error;
    //			if (error = this.prototype.onError) {
    //				error.call(this, e);
    //			} else {
    //				throw e;
    //			}
    //		}
    return tagDef;
  }

  function compileTmpl(name, tmpl, parentTmpl, storeName, storeSettings, options) {
    // tmpl is either a template object, a selector for a template script block, the name of a compiled template, or a template object

    //==== nested functions ====
    function tmplOrMarkupFromStr(value) {
      // If value is of type string - treat as selector, or name of compiled template
      // Return the template object, if already compiled, or the markup string

      if (("" + value === value) || value.nodeType > 0) {
        try {
          elem = value.nodeType > 0
            ? value
            : !rTmplString.test(value)
            // If value is a string and does not contain HTML or tag content, then test as selector
            && jQuery && jQuery(global.document).find(value)[0];
          // If selector is valid and returns at least one element, get first element
          // If invalid, jQuery will throw. We will stay with the original string.
        } catch (e) { }

        if (elem) {
          // Generally this is a script element.
          // However we allow it to be any element, so you can for example take the content of a div,
          // use it as a template, and replace it by the same content rendered against data.
          // e.g. for linking the content of a div to a container, and using the initial content as template:
          // $.link("#content", model, {tmpl: "#content"});

          value = elem.getAttribute(tmplAttr);
          name = name || value;
          value = $templates[value];
          if (!value) {
            // Not already compiled and cached, so compile and cache the name
            // Create a name for compiled template if none provided
            name = name || "_" + autoTmplName++;
            elem.setAttribute(tmplAttr, name);
            // Use tmpl as options
            value = $templates[name] = compileTmpl(name, elem.innerHTML, parentTmpl, storeName, storeSettings, options);
          }
        }
        return value;
      }
      // If value is not a string, return undefined
    }

    var tmplOrMarkup, elem;

    //==== Compile the template ====
    tmpl = tmpl || "";
    tmplOrMarkup = tmplOrMarkupFromStr(tmpl);

    // If options, then this was already compiled from a (script) element template declaration.
    // If not, then if tmpl is a template object, use it for options
    options = options || (tmpl.markup ? tmpl : {});
    options.tmplName = name;
    if (parentTmpl) {
      options._parentTmpl = parentTmpl;
    }
    // If tmpl is not a markup string or a selector string, then it must be a template object
    // In that case, get it from the markup property of the object
    if (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = tmplOrMarkupFromStr(tmpl.markup))) {
      if (tmplOrMarkup.fn && (tmplOrMarkup.debug !== tmpl.debug || tmplOrMarkup.allowCode !== tmpl.allowCode)) {
        // if the string references a compiled template object, but the debug or allowCode props are different, need to recompile
        tmplOrMarkup = tmplOrMarkup.markup;
      }
    }
    if (tmplOrMarkup !== undefined) {
      if (name && !parentTmpl) {
        $render[name] = function () {
          return tmpl.render.apply(tmpl, arguments);
        };
      }
      if (tmplOrMarkup.fn || tmpl.fn) {
        // tmpl is already compiled, so use it, or if different name is provided, clone it
        if (tmplOrMarkup.fn) {
          if (name && name !== tmplOrMarkup.tmplName) {
            tmpl = extendCtx(options, tmplOrMarkup);
          } else {
            tmpl = tmplOrMarkup;
          }
        }
      } else {
        // tmplOrMarkup is a markup string, not a compiled template
        // Create template object
        tmpl = TmplObject(tmplOrMarkup, options);
        // Compile to AST and then to compiled function
        tmplFn(tmplOrMarkup, tmpl);
      }
      compileChildResources(options);
      return tmpl;
    }
  }
  //==== /end of function compile ====

  function TmplObject(markup, options) {
    // Template object constructor
    var htmlTag,
      wrapMap = $viewsSettings.wrapMap || {},
      tmpl = $extend(
        {
          markup: markup,
          tmpls: [],
          links: {}, // Compiled functions for link expressions
          tags: {}, // Compiled functions for bound tag expressions
          bnds: [],
          _is: "template",
          render: renderContent
        },
        options
      );

    if (!options.htmlTag) {
      // Set tmpl.tag to the top-level HTML tag used in the template, if any...
      htmlTag = rFirstElem.exec(markup);
      tmpl.htmlTag = htmlTag ? htmlTag[1].toLowerCase() : "";
    }
    htmlTag = wrapMap[tmpl.htmlTag];
    if (htmlTag && htmlTag !== wrapMap.div) {
      // When using JsViews, we trim templates which are inserted into HTML contexts where text nodes are not rendered (i.e. not 'Phrasing Content').
      tmpl.markup = $.trim(tmpl.markup);
      tmpl._elCnt = true; // element content model (no rendered text nodes), not phrasing content model
    }

    return tmpl;
  }

  function registerStore(storeName, storeSettings) {

    function theStore(name, item, parentTmpl) {
      // The store is also the function used to add items to the store. e.g. $.templates, or $.views.tags

      // For store of name 'thing', Call as:
      //    $.views.things(items[, parentTmpl]),
      // or $.views.things(name, item[, parentTmpl])

      var onStore, compile, itemName, thisStore;

      if (name && "" + name !== name && !name.nodeType && !name.markup) {
        // Call to $.views.things(items[, parentTmpl]),

        // Adding items to the store
        // If name is a map, then item is parentTmpl. Iterate over map and call store for key.
        for (itemName in name) {
          theStore(itemName, name[itemName], item);
        }
        return $views;
      }
      // Adding a single unnamed item to the store
      if (item === undefined) {
        item = name;
        name = undefined;
      }
      if (name && "" + name !== name) { // name must be a string
        parentTmpl = item;
        item = name;
        name = undefined;
      }
      thisStore = parentTmpl ? parentTmpl[storeNames] = parentTmpl[storeNames] || {} : theStore;
      compile = storeSettings.compile;
      if (onStore = $viewsSub.onBeforeStoreItem) {
        // e.g. provide an external compiler or preprocess the item.
        compile = onStore(thisStore, name, item, compile) || compile;
      }
      if (!name) {
        item = compile(undefined, item);
      } else if (item === null) {
        // If item is null, delete this entry
        delete thisStore[name];
      } else {
        thisStore[name] = compile ? (item = compile(name, item, parentTmpl, storeName, storeSettings)) : item;
      }
      if (item) {
        item._is = storeName;
      }
      if (onStore = $viewsSub.onStoreItem) {
        // e.g. JsViews integration
        onStore(thisStore, name, item, compile);
      }
      return item;
    }

    var storeNames = storeName + "s";

    $views[storeNames] = theStore;
    jsvStores[storeName] = storeSettings;
  }

  //==============
  // renderContent
  //==============

  function renderContent(data, context, parentView, key, isLayout, onRender) {
    // Render template against data as a tree of subviews (nested rendered template instances), or as a string (top-level template).
    // If the data is the parent view, treat as layout template, re-render with the same data context.
    var i, l, dataItem, newView, childView, itemResult, swapContent, tagCtx, contentTmpl, tag_, outerOnRender, tmplName, tmpl,
      self = this,
      allowDataLink = !self.attr || self.attr === "html",
      result = "";

    if (key === true) {
      swapContent = true;
      key = 0;
    }
    if (self.tag) {
      // This is a call from renderTag or tagCtx.render()
      tagCtx = self;
      self = self.tag;
      tag_ = self._;
      tmplName = self.tagName;
      tmpl = tagCtx.tmpl;
      context = extendCtx(context, self.ctx);
      contentTmpl = tagCtx.content; // The wrapped content - to be added to views, below
      if (tagCtx.props.link === false) {
        // link=false setting on block tag
        // We will override inherited value of link by the explicit setting link=false taken from props
        // The child views of an unlinked view are also unlinked. So setting child back to true will not have any effect.
        context = context || {};
        context.link = false;
      }
      parentView = parentView || tagCtx.view;
      data = data === undefined ? parentView : data;
    } else {
      tmpl = self.jquery && (self[0] || error('Unknown template: "' + self.selector + '"')) // This is a call from $(selector).render
        || self;
    }
    if (tmpl) {
      if (!parentView && data && data._is === "view") {
        parentView = data; // When passing in a view to render or link (and not passing in a parent view) use the passed in view as parentView
      }
      if (parentView) {
        contentTmpl = contentTmpl || parentView.content; // The wrapped content - to be added as #content property on views, below
        onRender = onRender || parentView._.onRender;
        if (data === parentView) {
          // Inherit the data from the parent view.
          // This may be the contents of an {{if}} block
          // Set isLayout = true so we don't iterate the if block if the data is an array.
          data = parentView.data;
          isLayout = true;
        }
        context = extendCtx(context, parentView.ctx);
      }
      if (!parentView || parentView.data === undefined) {
        (context = context || {}).root = data; // Provide ~root as shortcut to top-level data.
      }

      // Set additional context on views created here, (as modified context inherited from the parent, and to be inherited by child views)
      // Note: If no jQuery, $extend does not support chained copies - so limit extend() to two parameters

      if (!tmpl.fn) {
        tmpl = $templates[tmpl] || $templates(tmpl);
      }

      if (tmpl) {
        onRender = (context && context.link) !== false && allowDataLink && onRender;
        // If link===false, do not call onRender, so no data-linking marker nodes
        outerOnRender = onRender;
        if (onRender === true) {
          // Used by view.refresh(). Don't create a new wrapper view.
          outerOnRender = undefined;
          onRender = parentView._.onRender;
        }
        if ($.isArray(data) && !isLayout) {
          // Create a view for the array, whose child views correspond to each data item. (Note: if key and parentView are passed in
          // along with parent view, treat as insert -e.g. from view.addViews - so parentView is already the view item for array)
          newView = swapContent
            ? parentView :
            (key !== undefined && parentView) || View(context, "array", parentView, data, tmpl, key, contentTmpl, onRender);
          for (i = 0, l = data.length; i < l; i++) {
            // Create a view for each data item.
            dataItem = data[i];
            childView = View(context, "item", newView, dataItem, tmpl, (key || 0) + i, contentTmpl, onRender);
            itemResult = tmpl.fn(dataItem, childView, $views);
            result += newView._.onRender ? newView._.onRender(itemResult, childView) : itemResult;
          }
        } else {
          // Create a view for singleton data object. The type of the view will be the tag name, e.g. "if" or "myTag" except for
          // "item", "array" and "data" views. A "data" view is from programatic render(object) against a 'singleton'.
          newView = swapContent ? parentView : View(context, tmplName || "data", parentView, data, tmpl, key, contentTmpl, onRender);
          if (tag_ && !self.flow) {
            newView.tag = self;
          }
          result += tmpl.fn(data, newView, $views);
        }
        return outerOnRender ? outerOnRender(result, newView) : result;
      }
    }
    return "";
  }

  //===========================
  // Build and compile template
  //===========================

  // Generate a reusable function that will serve to render a template against data
  // (Compile AST then build template function)

  function error(message) {
    throw new $views.sub.Error(message);
  }

  function syntaxError(message) {
    error("Syntax error\n" + message);
  }

  function tmplFn(markup, tmpl, isLinkExpr, convertBack) {
    // Compile markup to AST (abtract syntax tree) then build the template function code from the AST nodes
    // Used for compiling templates, and also by JsViews to build functions for data link expressions

    //==== nested functions ====
    function pushprecedingContent(shift) {
      shift -= loc;
      if (shift) {
        content.push(markup.substr(loc, shift).replace(rNewLine, "\\n"));
      }
    }

    function blockTagCheck(tagName) {
      tagName && syntaxError('Unmatched or missing tag: "{{/' + tagName + '}}" in template:\n' + markup);
    }

    function parseTag(all, bind, tagName, converter, colon, html, comment, codeTag, params, slash, closeBlock, index) {

      //    bind         tag        converter colon html     comment            code      params            slash   closeBlock
      // /{(\^)?{(?:(?:(\w+(?=[\/\s}]))|(?:(\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\*)))\s*((?:[^}]|}(?!}))*?)(\/)?|(?:\/(\w+)))}}/g
      // Build abstract syntax tree (AST): [ tagName, converter, params, content, hash, bindings, contentMarkup ]
      if (html) {
        colon = ":";
        converter = "html";
      }
      slash = slash || isLinkExpr;
      var noError, current0,
        pathBindings = bind && [],
        code = "",
        hash = "",
        passedCtx = "",
        // Block tag if not self-closing and not {{:}} or {{>}} (special case) and not a data-link expression
        block = !slash && !colon && !comment;

      //==== nested helper function ====
      tagName = tagName || colon;
      pushprecedingContent(index);
      loc = index + all.length; // location marker - parsed up to here
      if (codeTag) {
        if (allowCode) {
          content.push(["*", "\n" + params.replace(rUnescapeQuotes, "$1") + "\n"]);
        }
      } else if (tagName) {
        if (tagName === "else") {
          if (rTestElseIf.test(params)) {
            syntaxError('for "{{else if expr}}" use "{{else expr}}"');
          }
          pathBindings = current[6];
          current[7] = markup.substring(current[7], index); // contentMarkup for block tag
          current = stack.pop();
          content = current[3];
          block = true;
        }
        if (params) {
          // remove newlines from the params string, to avoid compiled code errors for unterminated strings
          params = params.replace(rNewLine, " ");
          code = parseParams(params, pathBindings, tmpl)
            .replace(rBuildHash, function (all, isCtx, keyValue) {
              if (isCtx) {
                passedCtx += keyValue + ",";
              } else {
                hash += keyValue + ",";
              }
              return "";
            });
        }
        hash = hash.slice(0, -1);
        code = code.slice(0, -1);
        noError = hash && (hash.indexOf("noerror:true") + 1) && hash || "";

        newNode = [
          tagName,
          converter || !!convertBack || "",
          code,
          block && [],
          'params:"' + params + '",props:{' + hash + "}"
          + (passedCtx ? ",ctx:{" + passedCtx.slice(0, -1) + "}" : ""),
          noError,
          pathBindings || 0
        ];
        content.push(newNode);
        if (block) {
          stack.push(current);
          current = newNode;
          current[7] = loc; // Store current location of open tag, to be able to add contentMarkup when we reach closing tag
        }
      } else if (closeBlock) {
        current0 = current[0];
        blockTagCheck(closeBlock !== current0 && current0 !== "else" && closeBlock);
        current[7] = markup.substring(current[7], index); // contentMarkup for block tag
        current = stack.pop();
      }
      blockTagCheck(!current && closeBlock);
      content = current[3];
    }
    //==== /end of nested functions ====

    var newNode,
      allowCode = tmpl && tmpl.allowCode,
      astTop = [],
      loc = 0,
      stack = [],
      content = astTop,
      current = [, , , astTop];

    markup = markup.replace(rEscapeQuotes, "\\$&");

    //TODO	result = tmplFnsCache[markup]; // Only cache if template is not named and markup length < ...,
    //and there are no bindings or subtemplates?? Consider standard optimization for data-link="a.b.c"
    //		if (result) {
    //			tmpl.fn = result;
    //		} else {

    //		result = markup;

    blockTagCheck(stack[0] && stack[0][3].pop()[0]);

    // Build the AST (abstract syntax tree) under astTop
    markup.replace(rTag, parseTag);

    pushprecedingContent(markup.length);

    if (loc = astTop[astTop.length - 1]) {
      blockTagCheck("" + loc !== loc && (+loc[7] === loc[7]) && loc[0]);
    }
    //			result = tmplFnsCache[markup] = buildCode(astTop, tmpl);
    //		}
    return buildCode(astTop, isLinkExpr ? markup : tmpl, isLinkExpr);
  }

  function buildCode(ast, tmpl, isLinkExpr) {
    // Build the template function code from the AST nodes, and set as property on the passed-in template object
    // Used for compiling templates, and also by JsViews to build functions for data link expressions
    var i, node, tagName, converter, params, hash, hasTag, hasEncoder, getsVal, hasCnvt, useCnvt, tmplBindings, pathBindings,
      nestedTmpls, tmplName, nestedTmpl, tagAndElses, content, markup, nextIsElse, oldCode, isElse, isGetVal, prm, tagCtxFn,
      tmplBindingKey = 0,
      code = "",
      noError = "",
      tmplOptions = {},
      l = ast.length;

    if ("" + tmpl === tmpl) {
      tmplName = isLinkExpr ? 'data-link="' + tmpl.replace(rNewLine, " ").slice(1, -1) + '"' : tmpl;
      tmpl = 0;
    } else {
      tmplName = tmpl.tmplName || "unnamed";
      if (tmpl.allowCode) {
        tmplOptions.allowCode = true;
      }
      if (tmpl.debug) {
        tmplOptions.debug = true;
      }
      tmplBindings = tmpl.bnds;
      nestedTmpls = tmpl.tmpls;
    }
    for (i = 0; i < l; i++) {
      // AST nodes: [ tagName, converter, params, content, hash, noError, pathBindings, contentMarkup, link ]
      node = ast[i];

      // Add newline for each callout to t() c() etc. and each markup string
      if ("" + node === node) {
        // a markup string to be inserted
        code += '\nret+="' + node + '";';
      } else {
        // a compiled tag expression to be inserted
        tagName = node[0];
        if (tagName === "*") {
          // Code tag: {{* }}
          code += "" + node[1];
        } else {
          converter = node[1];
          params = node[2];
          content = node[3];
          hash = node[4];
          noError = node[5];
          markup = node[7];

          if (!(isElse = tagName === "else")) {
            tmplBindingKey = 0;
            if (tmplBindings && (pathBindings = node[6])) { // Array of paths, or false if not data-bound
              tmplBindingKey = tmplBindings.push(pathBindings);
            }
          }
          if (isGetVal = tagName === ":") {
            if (converter) {
              tagName = converter === "html" ? ">" : converter + tagName;
            }
            if (noError) {
              // If the tag includes noerror=true, we will do a try catch around expressions for named or unnamed parameters
              // passed to the tag, and return the empty string for each expression if it throws during evaluation
              //TODO This does not work for general case - supporting noError on multiple expressions, e.g. tag args and properties.
              //Consider replacing with try<a.b.c(p,q) + a.d, xxx> and return the value of the expression a.b.c(p,q) + a.d, or, if it throws, return xxx||'' (rather than always the empty string)
              prm = "prm" + i;
              noError = "try{var " + prm + "=[" + params + "][0];}catch(e){" + prm + '="";}\n';
              params = prm;
            }
          } else {
            if (content) {
              // Create template object for nested template
              nestedTmpl = TmplObject(markup, tmplOptions);
              nestedTmpl.tmplName = tmplName + "/" + tagName;
              // Compile to AST and then to compiled function
              buildCode(content, nestedTmpl);
              nestedTmpls.push(nestedTmpl);
            }

            if (!isElse) {
              // This is not an else tag.
              tagAndElses = tagName;
              // Switch to a new code string for this bound tag (and its elses, if it has any) - for returning the tagCtxs array
              oldCode = code;
              code = "";
            }
            nextIsElse = ast[i + 1];
            nextIsElse = nextIsElse && nextIsElse[0] === "else";
          }

          hash += ",args:[" + params + "]}";

          if (isGetVal && pathBindings || converter && tagName !== ">") {
            // For convertVal we need a compiled function to return the new tagCtx(s)
            tagCtxFn = new Function("data,view,j,u", " // "
              + tmplName + " " + tmplBindingKey + " " + tagName + "\n" + noError + "return {" + hash + ";");
            tagCtxFn.paths = pathBindings;
            tagCtxFn._ctxs = tagName;
            if (isLinkExpr) {
              return tagCtxFn;
            }
            useCnvt = 1;
          }

          code += (isGetVal
            ? "\n" + (pathBindings ? "" : noError) + (isLinkExpr ? "return " : "ret+=") + (useCnvt // Call _cnvt if there is a converter: {{cnvt: ... }} or {^{cnvt: ... }}
              ? (useCnvt = 0, hasCnvt = true, 'c("' + converter + '",view,' + (pathBindings
                ? ((tmplBindings[tmplBindingKey - 1] = tagCtxFn), tmplBindingKey) // Store the compiled tagCtxFn in tmpl.bnds, and pass the key to convertVal()
                : "{" + hash) + ");")
              : tagName === ">"
                ? (hasEncoder = true, "h(" + params + ");")
                : (getsVal = true, "(v=" + params + ")!=" + (isLinkExpr ? "=" : "") + 'u?v:"";') // Strict equality just for data-link="title{:expr}" so expr=null will remove title attribute 
            )
            : (hasTag = true, "{tmpl:" // Add this tagCtx to the compiled code for the tagCtxs to be passed to renderTag()
              + (content ? nestedTmpls.length : "0") + "," // For block tags, pass in the key (nestedTmpls.length) to the nested content template
              + hash + ","));

          if (tagAndElses && !nextIsElse) {
            code = "[" + code.slice(0, -1) + "]"; // This is a data-link expression or the last {{else}} of an inline bound tag. We complete the code for returning the tagCtxs array
            if (isLinkExpr || pathBindings) {
              // This is a bound tag (data-link expression or inline bound tag {^{tag ...}}) so we store a compiled tagCtxs function in tmp.bnds
              code = new Function("data,view,j,u", " // " + tmplName + " " + tmplBindingKey + " " + tagAndElses + "\nreturn " + code + ";");
              if (pathBindings) {
                (tmplBindings[tmplBindingKey - 1] = code).paths = pathBindings;
              }
              code._ctxs = tagName;
              if (isLinkExpr) {
                return code; // For a data-link expression we return the compiled tagCtxs function
              }
            }

            // This is the last {{else}} for an inline tag.
            // For a bound tag, pass the tagCtxs fn lookup key to renderTag.
            // For an unbound tag, include the code directly for evaluating tagCtxs array
            code = oldCode + '\nret+=t("' + tagAndElses + '",view,this,' + (tmplBindingKey || code) + ");";
            pathBindings = 0;
            tagAndElses = 0;
          }
        }
      }
    }
    // Include only the var references that are needed in the code
    code = "// " + tmplName
      + "\nvar j=j||" + (jQuery ? "jQuery." : "js") + "views"
      + (getsVal ? ",v" : "")                      // gets value
      + (hasTag ? ",t=j._tag" : "")                // has tag
      + (hasCnvt ? ",c=j._cnvt" : "")              // converter
      + (hasEncoder ? ",h=j.converters.html" : "") // html converter
      + (isLinkExpr ? ";\n" : ',ret="";\n')
      + ($viewsSettings.tryCatch ? "try{\n" : "")
      + (tmplOptions.debug ? "debugger;" : "")
      + code + (isLinkExpr ? "\n" : "\nreturn ret;\n")
      + ($viewsSettings.tryCatch ? "\n}catch(e){return j._err(e);}" : "");
    try {
      code = new Function("data,view,j,u", code);
    } catch (e) {
      syntaxError("Compiled template code:\n\n" + code, e);
    }
    if (tmpl) {
      tmpl.fn = code;
    }
    return code;
  }

  function parseParams(params, bindings, tmpl) {

    //function pushBindings() { // Consider structured path bindings
    //	if (bindings) {
    //		named ? bindings[named] = bindings.pop(): bindings.push(list = []);
    //	}
    //}

    function parseTokens(all, lftPrn0, lftPrn, path, operator, err, eq, path2, prn, comma, lftPrn2, apos, quot, rtPrn, rtPrnDot, prn2, space, index, full) {
      // rParams = /(\()(?=\s*\()|(?:([([])\s*)?(?:([#~]?[\w$.^]+)?\s*((\+\+|--)|\+|-|&&|\|\||===|!==|==|!=|<=|>=|[<>%*!:?\/]|(=))\s*|([#~]?[\w$.^]+)([([])?)|(,\s*)|(\(?)\\?(?:(')|("))|(?:\s*((\))(?=\s*\.|\s*\^)|\)|\])([([]?))|(\s+)/g,
      //          lftPrn        lftPrn2                 path    operator err                                                eq          path2       prn    comma   lftPrn2   apos quot      rtPrn rtPrnDot           prn2   space
      // (left paren? followed by (path? followed by operator) or (path followed by paren?)) or comma or apos or quot or right paren or space
      var expr;
      operator = operator || "";
      lftPrn = lftPrn || lftPrn0 || lftPrn2;
      path = path || path2;
      prn = prn || prn2 || "";

      function parsePath(all, object, helper, view, viewProperty, pathTokens, leafToken) {
        // rPath = /^(?:null|true|false|\d[\d.]*|([\w$]+|~([\w$]+)|#(view|([\w$]+))?)([\w$.^]*?)(?:[.[^]([\w$]+)\]?)?)$/g,
        //                                        object   helper    view  viewProperty pathTokens       leafToken
        if (object) {
          bindings && !isAlias && bindings.push(path); // Add path binding for paths on props and args,
          // but not within foo=expr (named parameter) or ~foo=expr (passing in template parameter aliases).
          //					bindings && !isAlias && list.push(path);
          if (object !== ".") {
            var ret = (helper
              ? 'view.hlp("' + helper + '")'
              : view
                ? "view"
                : "data")
              + (leafToken
                ? (viewProperty
                  ? "." + viewProperty
                  : helper
                    ? ""
                    : (view ? "" : "." + object)
                ) + (pathTokens || "")
                : (leafToken = helper ? "" : view ? viewProperty || "" : object, ""));

            ret = ret + (leafToken ? "." + leafToken : "");

            return ret.slice(0, 9) === "view.data"
              ? ret.slice(5) // convert #view.data... to data...
              : ret;
          }
        }
        return all;
      }

      if (err) {
        syntaxError(params);
      } else {
        if (bindings && rtPrnDot) {
          // This is a binding to a path in which an object is returned by a helper/data function/expression, e.g. foo()^x.y or (a?b:c)^x.y
          // We create a compiled function to get the object instance (which will be called when the dependent data of the subexpression changes, to return the new object, and trigger re-binding of the subsequent path)
          expr = pathStart[parenDepth];
          if (full.length - 2 > index - expr) { // We need to compile a subexpression
            expr = full.slice(expr, index + 1);
            rtPrnDot = delimOpenChar1 + ":" + expr + delimCloseChar0; // The parameter or function subexpression
            rtPrnDot = tmplLinks[rtPrnDot] = tmplLinks[rtPrnDot] || tmplFn(delimOpenChar0 + rtPrnDot + delimCloseChar1, tmpl, true); // Compile the expression (or use cached copy already in tmpl.links)
            if (!rtPrnDot.paths) {
              parseParams(expr, rtPrnDot.paths = [], tmpl);
            }
            bindings.push({ _jsvOb: rtPrnDot }); // Insert special object for in path bindings, to be used for binding the compiled sub expression ()
            //list.push({_jsvOb: rtPrnDot});
          }
        }
        return (aposed
          // within single-quoted string
          ? (aposed = !apos, (aposed ? all : '"'))
          : quoted
            // within double-quoted string
            ? (quoted = !quot, (quoted ? all : '"'))
            :
            (
              (lftPrn
                ? (parenDepth++, pathStart[parenDepth] = index++, lftPrn)
                : "")
              + (space
                ? (parenDepth
                  ? ""
                  //: (pushBindings(), named
                  //	? (named = isAlias = false, "\b")
                  //	: ",")
                  : named
                    ? (named = isAlias = false, "\b")
                    : ","
                )
                : eq
                  // named param
                  // Insert backspace \b (\x08) as separator for named params, used subsequently by rBuildHash
                  ? (parenDepth && syntaxError(params), named = path, /*pushBindings(),*/isAlias = path.charAt(0) === "~", '\b' + path + ':')
                  : path
                    // path
                    ? (path.split("^").join(".").replace(rPath, parsePath)
                      + (prn
                        ? (fnCall[++parenDepth] = true, path.charAt(0) !== "." && (pathStart[parenDepth] = index), prn)
                        : operator)
                    )
                    : operator
                      ? operator
                      : rtPrn
                        // function
                        ? ((fnCall[parenDepth--] = false, rtPrn)
                          + (prn
                            ? (fnCall[++parenDepth] = true, prn)
                            : "")
                        )
                        : comma
                          ? (fnCall[parenDepth] || syntaxError(params), ",") // We don't allow top-level literal arrays or objects
                          : lftPrn0
                            ? ""
                            : (aposed = apos, quoted = quot, '"')
              ))
        );
      }
    }

    var named, isAlias,// list,
      tmplLinks = tmpl.links,
      fnCall = {},
      pathStart = { 0: -1 },
      parenDepth = 0,
      quoted = false, // boolean for string content in double quotes
      aposed = false; // or in single quotes

    //pushBindings();

    return (params + " ").replace(rParams, parseTokens);
  }

  //==========
  // Utilities
  //==========

  // Merge objects, in particular contexts which inherit from parent contexts
  function extendCtx(context, parentContext) {
    // Return copy of parentContext, unless context is defined and is different, in which case return a new merged context
    // If neither context nor parentContext are undefined, return undefined
    return context && context !== parentContext
      ? (parentContext
        ? $extend($extend({}, parentContext), context)
        : context)
      : parentContext && $extend({}, parentContext);
  }

  // Get character entity for HTML and Attribute encoding
  function getCharEntity(ch) {
    return charEntities[ch] || (charEntities[ch] = "&#" + ch.charCodeAt(0) + ";");
  }

  //========================== Initialize ==========================

  for (jsvStoreName in jsvStores) {
    registerStore(jsvStoreName, jsvStores[jsvStoreName]);
  }

  var $templates = $views.templates,
    $converters = $views.converters,
    $helpers = $views.helpers,
    $tags = $views.tags,
    $viewsSub = $views.sub,
    $viewsSettings = $views.settings;

  if (jQuery) {
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // jQuery is loaded, so make $ the jQuery object
    $ = jQuery;
    $.fn.render = renderContent;

  } else {
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // jQuery is not loaded.

    $ = global.jsviews = {};

    $.isArray = Array && Array.isArray || function (obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };

    //	//========================== Future Node.js support ==========================
    //	if ((nodeJsModule = global.module) && nodeJsModule.exports) {
    //		nodeJsModule.exports = $;
    //	}
  }

  $.render = $render;
  $.views = $views;
  $.templates = $templates = $views.templates;

  //========================== Register tags ==========================

  $tags({
    "else": function () { }, // Does nothing but ensures {{else}} tags are recognized as valid
    "if": {
      render: function (val) {
        // This function is called once for {{if}} and once for each {{else}}.
        // We will use the tag.rendering object for carrying rendering state across the calls.
        // If not done (a previous block has not been rendered), look at expression for this block and render the block if expression is truthy
        // Otherwise return ""
        var self = this,
          ret = (self.rendering.done || !val && (arguments.length || !self.tagCtx.index))
            ? ""
            : (self.rendering.done = true, self.selected = self.tagCtx.index,
              // Test is satisfied, so render content on current context. We call tagCtx.render() rather than return undefined
              // (which would also render the tmpl/content on the current context but would iterate if it is an array)
              self.tagCtx.render());
        return ret;
      },
      onUpdate: function (ev, eventArgs, tagCtxs) {
        var tci, prevArg, different;
        for (tci = 0; (prevArg = this.tagCtxs[tci]) && prevArg.args.length; tci++) {
          prevArg = prevArg.args[0];
          different = !prevArg !== !tagCtxs[tci].args[0];
          if (!!prevArg || different) {
            return different;
            // If newArg and prevArg are both truthy, return false to cancel update. (Even if values on later elses are different, we still don't want to update, since rendered output would be unchanged)
            // If newArg and prevArg are different, return true, to update
            // If newArg and prevArg are both falsey, move to the next {{else ...}}
          }
        }
        // Boolean value of all args are unchanged (falsey), so return false to cancel update
        return false;
      },
      flow: true
    },
    "for": {
      render: function (val) {
        // This function is called once for {{for}} and once for each {{else}}.
        // We will use the tag.rendering object for carrying rendering state across the calls.
        var self = this,
          tagCtx = self.tagCtx,
          noArg = !arguments.length,
          result = "",
          done = noArg || 0;

        if (!self.rendering.done) {
          if (noArg) {
            result = undefined;
          } else if (val !== undefined) {
            result += tagCtx.render(val);
            // {{for}} (or {{else}}) with no argument will render the block content
            done += $.isArray(val) ? val.length : 1;
          }
          if (self.rendering.done = done) {
            self.selected = tagCtx.index;
          }
          // If nothing was rendered we will look at the next {{else}}. Otherwise, we are done.
        }
        return result;
      },
      //onUpdate: function(ev, eventArgs, tagCtxs) {
      //Consider adding filtering for perf optimization. However the below prevents update on some scenarios which _should_ update - namely when there is another array on which for also depends.
      //var i, l, tci, prevArg;
      //for (tci = 0; (prevArg = this.tagCtxs[tci]) && prevArg.args.length; tci++) {
      //	if (prevArg.args[0] !== tagCtxs[tci].args[0]) {
      //		return true;
      //	}
      //}
      //return false;
      //},
      onArrayChange: function (ev, eventArgs) {
        var arrayView,
          self = this,
          change = eventArgs.change;
        if (this.tagCtxs[1] && ( // There is an {{else}}
          change === "insert" && ev.target.length === eventArgs.items.length // inserting, and new length is same as inserted length, so going from 0 to n
          || change === "remove" && !ev.target.length // removing , and new length 0, so going from n to 0
          || change === "refresh" && !eventArgs.oldItems.length !== !ev.target.length // refreshing, and length is going from 0 to n or from n to 0
        )) {
          this.refresh();
        } else {
          for (arrayView in self._.arrVws) {
            arrayView = self._.arrVws[arrayView];
            if (arrayView.data === ev.target) {
              arrayView._.onArrayChange.apply(arrayView, arguments);
            }
          }
        }
        ev.done = true;
      },
      flow: true
    },
    include: {
      flow: true
    },
    "*": {
      // {{* code... }} - Ignored if template.allowCode is false. Otherwise include code in compiled template
      render: function (value) {
        return value; // Include the code.
      },
      flow: true
    }
  });

  //========================== Register converters ==========================

  $converters({
    html: function (text) {
      // HTML encode: Replace < > & and ' and " by corresponding entities.
      return text != undefined ? String(text).replace(rHtmlEncode, getCharEntity) : ""; // null and undefined return ""
    },
    attr: function (text) {
      // Attribute encode: Replace < > & ' and " by corresponding entities.
      return text != undefined ? String(text).replace(rAttrEncode, getCharEntity) : text === null ? null : ""; // null returns null, e.g. to remove attribute. undefined returns ""
    },
    url: function (text) {
      // URL encoding helper.
      return text != undefined ? encodeURI(String(text)) : text === null ? null : ""; // null returns null, e.g. to remove attribute. undefined returns ""
    }
  });

  //========================== Define default delimiters ==========================
  $viewsDelimiters();

})(this, this.jQuery);
/*! jsObservable v1.0.0-alpha: http://github.com/BorisMoore/jsviews and http://jsviews.com/jsviews */
/*
* Subcomponent of JsViews
* Data change events for data-linking
*
* Copyright 2013, Boris Moore
* Released under the MIT License.
*/
// informal pre beta commit counter: v1.0.0-alpha (39) (Beta Candidate)

(function (global, $, undefined) {
  // global is the this object, which is window when running in the usual browser environment.
  // $ is the global var jQuery or jsviews
  "use strict";

  if (!$) {
    throw "requires jQuery or JsRender";
  }
  if ($.observable) { return; } // JsObservable is already loaded

  //========================== Top-level vars ==========================

  var versionNumber = "v1.0.0-alpha",

    cbBindings, cbBindingsId, oldLength, _data,
    $eventSpecial = $.event.special,
    $viewsSub = $.views ? $.views.sub : {},
    cbBindingKey = 1,
    splice = [].splice,
    concat = [].concat,
    $isArray = $.isArray,
    $expando = $.expando,
    OBJECT = "object",
    propertyChangeStr = $viewsSub.propChng = $viewsSub.propChng || "propertyChange",// These two settings can be overridden on settings after loading
    arrayChangeStr = $viewsSub.arrChng = $viewsSub.arrChng || "arrayChange",        // jsRender, and prior to loading jquery.observable.js and/or JsViews
    cbBindingsStore = $viewsSub._cbBnds = $viewsSub._cbBnds || {},
    observeStr = propertyChangeStr + ".observe",
    $isFunction = $.isFunction,
    observeObjKey = 1,
    observeCbKey = 1,
    $hasData = $.hasData;

  //========================== Top-level functions ==========================

  function $observable(data) {
    return $isArray(data)
      ? new ArrayObservable(data)
      : new ObjectObservable(data);
  }

  function ObjectObservable(data) {
    this._data = data;
    return this;
  }

  function ArrayObservable(data) {
    this._data = data;
    return this;
  }

  function wrapArray(data) {
    return $isArray(data)
      ? [data]
      : data;
  }

  function validateIndex(index) {
    if (typeof index !== "number") {
      throw "Invalid index.";
    }
  }

  function resolvePathObjects(paths, root) {
    paths = $isArray(paths) ? paths : [paths];

    var i, path,
      object = root,
      nextObj = object,
      l = paths.length,
      out = [];

    for (i = 0; i < l; i++) {
      path = paths[i];
      if ($isFunction(path)) {
        splice.apply(out, [out.length, 1].concat(resolvePathObjects(path.call(root, root), root)));
        continue;
      } else if ("" + path !== path) {
        root = nextObj = path;
        if (nextObj !== object) {
          out.push(object = nextObj);
        }
        continue;
      }
      if (nextObj !== object) {
        out.push(object = nextObj);
      }
      out.push(path);
    }
    return out;
  }

  function removeCbBindings(cbBindings, cbBindingsId) {
    // If the cbBindings collection is empty we will remove it from the cbBindingsStore
    var cb, found;

    for (cb in cbBindings) {
      found = true;
      break;
    }
    if (!found) {
      delete cbBindingsStore[cbBindingsId];
    }
  }

  function onObservableChange(ev, eventArgs) {
    if (!(ev.data && ev.data.off)) {
      // Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)
      var value = eventArgs.oldValue,
        ctx = ev.data;
      if (ev.type === arrayChangeStr) {
        ctx.cb.array(ev, eventArgs);
      } else if (ctx.prop === "*" || ctx.prop === eventArgs.path) {
        if (typeof value === OBJECT) {
          $unobserve(wrapArray(value), ctx.path, ctx.cb);
        }
        if (typeof (value = eventArgs.value) === OBJECT) {
          $observe(wrapArray(value), ctx.path, ctx.cb); // If value is an array, observe wrapped array, so that observe() doesn't flatten out this argument
        }
        ctx.cb(ev, eventArgs);
      }
    }
  }

  function $observe() {
    // $.observable.observe(root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserveOrOrigRoot)
    function observeOnOff(namespace, pathStr, isArrayBinding, off) {
      var obIdExpando = $hasData(object),
        boundObOrArr = wrapArray(object);
      cbBindings = 0;
      if (unobserve || off) {
        if (obIdExpando) {
          $(boundObOrArr).off(namespace, onObservableChange);
          // jQuery off event does not provide the event data, with the callback and we need to remove this object from the corresponding bindings hash, cbBindingsStore[cb._bnd].
          // So we have registered a jQuery special 'remove' event, which stored the cbBindingsStore[cb._bnd] bindings hash in the cbBindings var,
          // so we can immediately remove this object from that bindings hash.
          if (cbBindings) {
            delete cbBindings[$.data(object, "obId")];
          }
        }
      } else {
        if (events = obIdExpando && $._data(object)) {
          events = events && events.events;
          events = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];
          el = events && events.length;

          while (el--) {
            if ((data = events[el].data) && data.cb === callback) {
              if (isArrayBinding) {
                // Duplicate exists, so skip. (This can happen e.g. with {^{for people ~foo=people}})
                return;
              } else if (pathStr === "*" && data.prop !== pathStr) {
                $(object).off(namespace + "." + data.prop, onObservableChange);
                // We remove this object from bindings hash (see above).
                if (cbBindings) {
                  delete cbBindings[$.data(object, "obId")];
                }
              }
            }
          }
        }
        $(boundObOrArr).on(namespace, null, isArrayBinding ? { cb: callback } : { path: pathStr, prop: prop, cb: callback }, onObservableChange);
        if (bindings) {
          // Add object to bindings, and add the counter to the jQuery data on the object
          bindings[$.data(object, "obId") || $.data(object, "obId", observeObjKey++)] = object;
        }
      }
    }

    function onUpdatedExpression(exprOb, paths, unobserve) {
      // Use the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.
      // If it is an array, register array binding
      exprOb._ob = contextCb(exprOb, origRoot);
      var origRt = origRoot;
      return function () {
        var obj = exprOb._ob,
          len = paths.length;
        if (typeof obj === OBJECT) {
          bindArray(obj, true);
          if (len) {
            $unobserve(wrapArray(obj), paths, callback, contextCb, origRt);
          }
        }
        obj = exprOb._ob = contextCb(exprOb, origRt);
        // Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object
        if (typeof obj === OBJECT) {
          bindArray(obj);
          if (len) {
            $observe(wrapArray(obj), paths, callback, contextCb, origRt);
          }
        }
      }
    }

    function bindArray(arr, unbind) {
      if (callback && callback.array && $isArray(arr)) {
        // This is a data-bound tag which has an onArrayChange handler, e.g. {^{for}}, and the leaf object is an array
        // - so we add the arrayChange binding
        var prevObj = object;
        object = arr;
        observeOnOff(arrayChangeStr + ".observe.obs" + callback._bnd, undefined, true, unbind);
        object = prevObj;
      }
    }

    var i, parts, prop, path, dep, object, unobserve, callback, cbId, el, data, events, contextCb, items, bindings, depth, innerCb,
      topLevel = 1,
      ns = observeStr,
      paths = concat.apply([], arguments),	// flatten the arguments
      lastArg = paths.pop(),
      origRoot = paths[0],
      root = "" + origRoot !== origRoot ? paths.shift() : undefined,	// First parameter is the root object, unless a string
      l = paths.length;

    origRoot = root;

    if ($isFunction(lastArg)) {
      callback = lastArg;
    } else {
      if (lastArg === true) {
        unobserve = lastArg;
      } else if (lastArg) {
        origRoot = lastArg;
        topLevel = 0;
      }
      lastArg = paths[l - 1];
      if (l && lastArg === undefined || $isFunction(lastArg)) {
        callback = paths.pop(); // If preceding is callback this will be contextCb param - which may be undefined
        l--;
      }
    }
    if ($isFunction(paths[l - 1])) {
      contextCb = callback;
      callback = paths.pop();
      l--;
    }

    // Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to
    // remove onObservableChange handlers that wrap that callback
    ns += unobserve
      ? (callback ? ".obs" + callback._bnd : "")
      : ".obs" + (cbId = callback._bnd = callback._bnd || observeCbKey++);

    if (unobserve && l === 0 && root) {
      $(root).off(observeStr, onObservableChange);
    }
    if (!unobserve) {
      bindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {};
    }
    depth = 0;
    for (i = 0; i < l; i++) {
      path = paths[i];
      bindArray(object, unobserve);
      object = root;
      if ("" + path === path) {
        //path = path || "*"; // This ensures that foo(person) will depend on any changes in foo
        // - equivalent to foo(person.*) - were it legal, or to adding foo.depends = []
        parts = path.split("^");
        if (parts[1]) {
          // We bind the leaf, plus additional nodes based on depth.
          // "a.b.c^d.e" is depth 2, so listens to changes of e, plus changes of d and of c
          depth = parts[0].split(".").length;
          path = parts.join(".");
          depth = path.split(".").length - depth;
          // if more than one ^ in the path, the first one determines depth
        }
        if (contextCb && (items = contextCb(path, root))) {
          // If contextCb returns an array of objects and paths, we will insert them
          // into the sequence, replacing the current item (path)
          l += items.length - 1;
          splice.apply(paths, [i--, 1].concat(items));
          continue;
        }
        parts = path.split(".");
      } else {
        if (topLevel && !$isFunction(path)) {
          if (path._jsvOb) {
            if (!unobserve) {
              // This is a compiled function for binding to an object returned by a helper/data function.
              path._cb = innerCb = onUpdatedExpression(path, paths.slice(i + 1));
              path._rt = origRoot;
              innerCb._bnd = callback._bnd; // Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too. 
            }
            $observe(path._rt, paths.slice(0, i), path._cb, contextCb, unobserve);
            path = path._ob;
          }
          object = path; // For top-level calls, objects in the paths array become the origRoot for subsequent paths.
        }
        root = path;
        parts = [root];
      }
      while (object && typeof object === "object" && (prop = parts.shift()) !== undefined) {
        if ("" + prop === prop) {
          if (prop === "") {
            continue;
          }
          if ((parts.length < depth + 1) && !object.nodeType) {
            // Add observer for each token in path starting at depth, and on to the leaf
            if (!unobserve && (events = $hasData(object) && $._data(object))) {
              events = events.events;
              events = events && events.propertyChange;
              el = events && events.length;
              while (el--) { // Skip duplicates
                data = events[el].data;
                if (data && data.cb === callback && ((data.prop === prop && data.path === parts.join(".")) || data.prop === "*")) {
                  break;
                }
              }
              if (el > -1) {
                // Duplicate binding found, so move on
                object = object[prop];
                continue;
              }
            }
            if (prop === "*") {
              if ($isFunction(object)) {
                if (dep = object.depends) {
                  $observe(dep, callback, unobserve || origRoot);
                }
              } else {
                observeOnOff(ns, prop);
              }
              break;
            } else if (prop && !($isFunction(dep = object[prop]) && dep.depends)) {
              // If leaf is a computed observable (function with declared dependencies) we do not
              // currently observe 'swapping' of the observable - only changes in its dependencies.
              observeOnOff(ns + "." + prop, parts.join("."));
            }
          }
          prop = prop ? object[prop] : object;
        }
        if ($isFunction(prop)) {
          if (dep = prop.depends) {
            // This is a computed observable. We will observe any declared dependencies
            $observe(object, resolvePathObjects(dep, object), callback, contextCb, unobserve || wrapArray(origRoot));
          }
          break;
        }
        object = prop;
      }
    }
    bindArray(object, unobserve);
    if (cbId) {
      removeCbBindings(bindings, cbId);
    }

    // Return the bindings to the top-level caller, along with the cbId
    return { cbId: cbId, bnd: bindings, leaf: object };
  }

  function $unobserve() {
    [].push.call(arguments, true); // Add true as additional final argument
    return $observe.apply(this, arguments);
  }

  //========================== Initialize ==========================

  $.observable = $observable;
  $observable.Object = ObjectObservable;
  $observable.Array = ArrayObservable;
  $observable.observe = $observe;
  $observable.unobserve = $unobserve;

  ObjectObservable.prototype = {
    _data: null,

    data: function () {
      return this._data;
    },

    observe: function (paths, callback) {
      return $observe(this._data, paths, callback);
    },

    unobserve: function (paths, callback) {
      return $unobserve(this._data, paths, callback);
    },

    setProperty: function (path, value, nonStrict) {
      var leaf, key, pair, parts,
        self = this,
        object = self._data;

      path = path || "";
      if (object) {
        if ($isArray(path)) {
          // This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,
          // and does not provide simple support of convertTo and convertFrom functions.
          key = path.length;
          while (key--) {
            pair = path[key];
            self.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict) //If nonStrict not specified, default to true;
          }
        } else if ("" + path !== path) {
          // Object representation where property name is path and property value is value.
          for (key in path) {
            self.setProperty(key, path[key], value);
          }
        } else if (path.indexOf($expando) < 0) {
          // Simple single property case.
          parts = path.split(".");
          while (object && parts.length > 1) {
            object = object[parts.shift()];
          }
          self._setProperty(object, parts.join("."), value, nonStrict);
        }
      }
      return self;
    },

    _setProperty: function (leaf, path, value, nonStrict) {
      var setter, getter,
        property = path ? leaf[path] : leaf;

      if ($isFunction(property)) {
        if (property.set) {
          // Case of property setter/getter - with convention that property is getter and property.set is setter
          getter = property;
          setter = property.set === true ? property : property.set;
          property = property.call(leaf); //get
        }
      }

      if (property !== value || nonStrict && property != value) { // Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.
        // Date objects don't support != comparison. Treat as special case.
        if (!(property instanceof Date) || property > value || property < value) {
          if (setter) {
            setter.call(leaf, value);	//set
            value = getter.call(leaf);	//get updated value
          } else {
            leaf[path] = value;
          }
          this._trigger(leaf, { path: path, value: value, oldValue: property });
        }
      }
    },

    _trigger: function (target, eventArgs) {
      $(target).triggerHandler(propertyChangeStr, eventArgs);
    }
  };

  ArrayObservable.prototype = {
    _data: null,

    data: function () {
      return this._data;
    },

    insert: function (index, data) {
      validateIndex(index);

      if (arguments.length > 1) {
        data = $isArray(data) ? data : [data];
        // data can be a single item (including a null/undefined value) or an array of items.
        // Note the provided items are inserted without being cloned, as direct feferences to the provided objects

        if (data.length) {
          this._insert(index, data);
        }
      }
      return this;
    },

    _insert: function (index, data) {
      _data = this._data;
      oldLength = _data.length;
      splice.apply(_data, [index, 0].concat(data));
      this._trigger({ change: "insert", index: index, items: data });
    },

    remove: function (index, numToRemove) {
      validateIndex(index);

      numToRemove = (numToRemove === undefined || numToRemove === null) ? 1 : numToRemove;
      if (numToRemove && index > -1) {
        var items = this._data.slice(index, index + numToRemove);
        numToRemove = items.length;
        if (numToRemove) {
          this._remove(index, numToRemove, items);
        }
      }
      return this;
    },

    _remove: function (index, numToRemove, items) {
      _data = this._data;
      oldLength = _data.length;
      _data.splice(index, numToRemove);
      this._trigger({ change: "remove", index: index, items: items });
    },

    move: function (oldIndex, newIndex, numToMove) {
      validateIndex(oldIndex);
      validateIndex(newIndex);

      numToMove = (numToMove === undefined || numToMove === null) ? 1 : numToMove;
      if (numToMove) {
        var items = this._data.slice(oldIndex, oldIndex + numToMove);
        this._move(oldIndex, newIndex, numToMove, items);
      }
      return this;
    },

    _move: function (oldIndex, newIndex, numToMove, items) {
      _data = this._data;
      oldLength = _data.length;
      _data.splice(oldIndex, numToMove);
      _data.splice.apply(_data, [newIndex, 0].concat(items));
      this._trigger({ change: "move", oldIndex: oldIndex, index: newIndex, items: items });
    },

    refresh: function (newItems) {
      var oldItems = this._data.slice(0);
      this._refresh(oldItems, newItems);
      return this;
    },

    _refresh: function (oldItems, newItems) {
      _data = this._data;
      oldLength = _data.length;
      splice.apply(_data, [0, _data.length].concat(newItems));
      this._trigger({ change: "refresh", oldItems: oldItems });
    },

    _trigger: function (eventArgs) {
      var length = _data.length,
        $data = $([_data]);
      $data.triggerHandler(arrayChangeStr, eventArgs);
      if (length !== oldLength) {
        $data.triggerHandler(propertyChangeStr, { path: "length", value: length, oldValue: oldLength });
      }
    }
  };

  $eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {
    // The jQuery 'off' method does not provide the event data from the event(s) that are being unbound, so we register
    // a jQuery special 'remove' event, and get the data.cb._bnd from the event here and provide the corresponding cbBindings hash via the
    // cbBindings var to the unobserve handler, so we can immediately remove this object from that bindings hash, after 'unobserving'.
    remove: function (evData) {
      if ((evData = evData.data) && (evData.off = 1, evData = evData.cb)) { //Set off=1 as marker for disposed event
        // Get the cb._bnd from ev.data.cb._bnd
        cbBindings = cbBindingsStore[cbBindingsId = evData._bnd];
      }
    },
    teardown: function (namespaces) {
      if (cbBindings) {
        delete cbBindings[$.data(this, "obId")];
        removeCbBindings(cbBindings, cbBindingsId);
      }
    }
  };
})(this, this.jQuery || this.jsviews);
/*! JsViews v1.0.0-alpha: http://github.com/BorisMoore/jsviews and http://jsviews.com/jsviews */
/*
* Interactive data-driven views using templates and data-linking.
* Requires jQuery, and jsrender.js (next-generation jQuery Templates, optimized for pure string-based rendering)
*    See JsRender at  http://github.com/BorisMoore/jsrender and http://jsviews.com/jsrender
*
* Copyright 2013, Boris Moore
* Released under the MIT License.
*/
// informal pre beta commit counter: v1.0.0-alpha (39) (Beta Candidate)

(function (global, $, undefined) {
  // global is the this object, which is window when running in the usual browser environment.
  // $ is the global var jQuery
  "use strict";

  if (!$) {
    // jQuery is not loaded.
    throw "requires jQuery"; // for Beta (at least) we require jQuery
  }

  if (!$.views) {
    // JsRender is not loaded.
    throw "requires JsRender"; // JsRender must be loaded before JsViews
  }

  if (!$.observable) {
    // JsRender is not loaded.
    throw "requires jquery.observable"; // jquery.observable.js must be loaded before JsViews
  }

  if ($.link) { return; } // JsViews is already loaded

  //========================== Top-level vars ==========================

  var versionNumber = "v1.0.0-alpha",

    LinkedView, activeBody, $view, rTag, delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, linkChar, validate,
    document = global.document,
    $views = $.views,
    $viewsSub = $views.sub,
    $viewsSettings = $views.settings,
    $extend = $viewsSub.extend,
    topView = $viewsSub.View(undefined, "top"), // Top-level view
    $isFunction = $.isFunction,
    $templates = $views.templates,
    $observable = $.observable,
    $observe = $observable.observe,
    jsvAttrStr = "data-jsv",
    $viewsLinkAttr = $viewsSettings.linkAttr || "data-link",  // Allows override on settings prior to loading jquery.views.js

    // These two settings can be overridden on settings after loading jsRender, and prior to loading jquery.observable.js and/or JsViews
    propertyChangeStr = $viewsSettings.propChng = $viewsSettings.propChng || "propertyChange",
    arrayChangeStr = $viewsSub.arrChng = $viewsSub.arrChng || "arrayChange",

    cbBindingsStore = $viewsSub._cbBnds = $viewsSub._cbBnds || {},
    elementChangeStr = "change.jsv",
    onBeforeChangeStr = "onBeforeChange",
    onAfterChangeStr = "onAfterChange",
    onAfterCreateStr = "onAfterCreate",
    closeScript = '"></script>',
    openScript = '<script type="jsv',
    bindElsSel = "script,[" + jsvAttrStr + "]",
    linkViewsSel = bindElsSel + ",[" + $viewsLinkAttr + "]",
    fnSetters = {
      value: "val",
      input: "val",
      html: "html",
      text: "text"
    },
    valueBinding = { from: { fromAttr: "value" }, to: { toAttr: "value" } },
    oldCleanData = $.cleanData,
    oldJsvDelimiters = $viewsSettings.delimiters,
    error = $viewsSub.error,
    syntaxError = $viewsSub.syntaxError,
    // rFirstElem = /<(?!script)(\w+)([>]*\s+on\w+\s*=)?[>\s]/, // This was without the DomLevel0 test.
    rFirstElem = /<(?!script)(\w+)(?:[^>]*(on\w+)\s*=)?[^>]*>/,
    safeFragment = document.createDocumentFragment(),
    qsa = document.querySelector,

    // elContent maps tagNames which have only element content, so may not support script nodes.
    elContent = { ol: 1, ul: 1, table: 1, tbody: 1, thead: 1, tfoot: 1, tr: 1, colgroup: 1, dl: 1, select: 1, optgroup: 1 },
    badParent = { tr: "table" },
    // wrapMap provide appropriate wrappers for inserting innerHTML, used in insertBefore
    wrapMap = $viewsSettings.wrapMap = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      legend: [1, "<fieldset>", "</fieldset>"],
      thead: [1, "<table>", "</table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      area: [1, "<map>", "</map>"],
      svg: [1, "<svg>", "</svg>"],
      div: [1, "x<div>", "</div>"] // Needed in IE7 to serialize link tags correctly, insert comments correctly, etc.
    },
    voidElems = {
      br: 1, img: 1, input: 1, hr: 1, area: 1, base: 1, col: 1, link: 1, meta: 1,
      command: 1, embed: 1, keygen: 1, param: 1, source: 1, track: 1, wbr: 1
    },
    displayStyles = {},
    viewStore = { 0: topView },
    bindingStore = {},
    bindingKey = 1,
    rViewPath = /^#(view\.?)?/,
    rConvertMarkers = /(^|(\/>)|(<\/\w+>)|>|)(\s*)([#\/]\d+[_^])`(\s*)(<\w+(?=[\s\/>]))?|\s*(?:(<\w+(?=[\s\/>]))|(<\/\w+>)(\s*)|(\/>)\s*)/g,
    rOpenViewMarkers = /(#)()(\d+)(_)/g,
    rOpenMarkers = /(#)()(\d+)([_^])/g,
    rViewMarkers = /(?:(#)|(\/))(\d+)(_)/g,
    rOpenTagMarkers = /(#)()(\d+)(\^)/g,
    rMarkerTokens = /(?:(#)|(\/))(\d+)([_^])([-+@\d]+)?/g;

  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  //========================== Top-level functions ==========================

  //===============
  // Event handlers
  //===============

  function elemChangeHandler(ev) {
    var setter, cancel, fromAttr, linkCtx, sourceValue, cvtBack, cnvtName, target, $source, view, binding, bindings, l,
      source = ev.target, onBeforeChange, onAfterChange,
      to = source._jsvBnd;

    // _jsvBnd is a string with the syntax: "&bindingId1&bindingId2"
    if (to) {
      bindings = to.slice(1).split("&");
      l = bindings.length;
      while (l--) {
        if (binding = bindingStore[bindings[l]]) {
          linkCtx = binding.linkCtx;
          view = linkCtx.view;
          if (to = binding.to) {
            // The binding has a 'to' field, which is of the form [[targetObject, toPath], cvtBack]
            $source = $(source);
            onBeforeChange = view.hlp(onBeforeChangeStr);
            onAfterChange = view.hlp(onAfterChangeStr);
            fromAttr = defaultAttr(source);
            setter = fnSetters[fromAttr];
            sourceValue = $isFunction(fromAttr) ? fromAttr(source) : setter ? $source[setter]() : $source.attr(fromAttr);

            if ((!onBeforeChange || !(cancel = onBeforeChange.call(view, ev) === false)) && sourceValue !== undefined) {
              cnvtName = to[1];
              to = to[0]; // [object, path]
              target = to[0];
              target = target._jsvOb ? target._ob : target;
              to = to[2] || to[1];
              if ($isFunction(cnvtName)) {
                cvtBack = cnvtName;
              } else {
                cvtBack = view.tmpl.converters;
                cvtBack = cvtBack && cvtBack[cnvtName] || $views.converters[cnvtName];
              }
              if (cvtBack) {
                sourceValue = cvtBack.call(linkCtx.tag, sourceValue);
              }
              if (sourceValue !== undefined && target) {
                $observable(target).setProperty(to, sourceValue);
                if (onAfterChange) {
                  onAfterChange.call(linkCtx, ev);
                }
              }
            }
            if (cancel) {
              ev.stopImmediatePropagation();
            }
          }
        }
      }
    }
  }

  function propertyChangeHandler(ev, eventArgs, linkFn) {
    var attr, setter, changed, sourceValue, css, tag, prevNode, nextNode, oldLinkCtx, inlineTag,
      linkCtx = this,
      source = linkCtx.data,
      target = linkCtx.elem,
      cvt = linkCtx.cvt,
      attrOrProp = "attr",
      parentElem = target.parentNode,
      targetElem = parentElem,
      $target = $(target),
      view = linkCtx.view,
      onEvent = view.hlp(onBeforeChangeStr);

    if (parentElem && (!onEvent || !(eventArgs && onEvent.call(linkCtx, ev, eventArgs) === false))
      // If data changed, the ev.data is set to be the path. Use that to filter the handler action...
      && !(eventArgs && ev.data.prop !== "*" && ev.data.prop !== eventArgs.path)) {

      // Set linkCtx on view, dynamically, just during this handler call
      oldLinkCtx = view.linkCtx;
      view.linkCtx = linkCtx;
      if (eventArgs) {
        linkCtx.eventArgs = eventArgs;
      }
      if (!ev || eventArgs || linkCtx._initVal) {
        delete linkCtx._initVal;
        sourceValue = linkFn.call(view.tmpl, source, view, $views);
        // Compiled link expression for linkTag: return tagCtx or tagCtxs

        attr = linkCtx.attr || defaultAttr(target, true, cvt !== undefined);
        if (tag = linkCtx.tag) {
          // Existing tag instance
          if (eventArgs && tag.onUpdate && tag.onUpdate(ev, eventArgs, sourceValue) === false || attr === "none") {
            // onUpdate returned false, or attr === "none", so we just need to bind, and we are done
            observeAndBind(linkCtx, source, target);
            view.linkCtx = oldLinkCtx;
            return;
          }
          sourceValue = tag.tagName.slice(-1) === ":" // Call convertVal if it is a {{cvt:...}} - otherwise call renderTag
            ? $views._cnvt(tag.tagName.slice(0, -1), view, sourceValue)
            : $views._tag(tag.tagName, view, view.tmpl, sourceValue);
        } else if (linkFn._ctxs) {
          // For {{: ...}} without a convert or convertBack, we already have the sourceValue, and we are done
          // For {{: ...}} with either cvt or cvtBack we call convertVal to get the sourceValue and instantiate the tag
          // If cvt is undefined then this is a tag, and we call renderTag to get the rendered content and instantiate the tag
          cvt = cvt === "" ? "true" : cvt; // If there is a cvtBack but no cvt, set cvt to "true"
          sourceValue = cvt // Call convertVal if it is a {{cvt:...}} - otherwise call renderTag
            ? $views._cnvt(cvt, view, sourceValue) // convertVal
            : $views._tag(linkFn._ctxs, view, view.tmpl, sourceValue); // renderTag
          tag = view._.tag; // In both convertVal and renderTag we have instantiated a tag
          attr = linkCtx.attr || attr; // linkCtx.attr may have been set to tag.attr during tag instantiation in renderTag
        }
        if (tag) {
          // Initialize the tag with element references
          tag.parentElem = (linkCtx.expr || tag._elCnt) ? target : target.parentNode;
          prevNode = tag._prv;
          nextNode = tag._nxt;
          tag.refresh = refreshTag;
        }

        if ($isFunction(sourceValue)) {
          error(linkCtx.expr + ": missing parens");
        }

        if (attr === "visible") {
          attr = "css-display";
          sourceValue = sourceValue
            // Make sure we set the correct display style for showing this particular element ("block", "inline" etc.)
            ? getElementDefaultDisplay(target)
            : "none";
        }
        if (css = attr.lastIndexOf("css-", 0) === 0 && attr.substr(4)) {
          // Possible optimization for perf on integer values
          //					prev = $.style(target, css);
          //					if (+sourceValue === sourceValue) {
          //						// support using integer data values, e.g. 100 for width:"100px"
          //						prev = parseInt(prev);
          //					}
          //					if (changed = prev !== sourceValue) {
          //						$.style(target, css, sourceValue);
          //					}
          if (changed = $.style(target, css) !== sourceValue) {
            $.style(target, css, sourceValue);
          }
        } else if (attr !== "link") { // attr === "link" is for tag controls which do data binding but have no rendered output or target
          if (attr === "value") {
            if (target.type === "checkbox") {
              sourceValue = sourceValue && sourceValue !== "false";
              // The string value "false" can occur with data-link="checked{attr:expr}" - as a result of attr, and hence using convertVal()
              attrOrProp = "prop";
              attr = "checked";
              // We will set the "checked" property
              // We will compare this with the current value
            }
          } else if (attr === "radio") {
            // This is a special binding attribute for radio buttons, which corresponds to the default 'to' binding.
            // This allows binding both to value (for each input) and to the default checked radio button (for each input in named group,
            // e.g. binding to parent data).
            // Place value binding first: <input type="radio" data-link="value{:name} {:#get('data').data.currency:} " .../>
            // or (allowing any order for the binding expressions):
            // <input type="radio" value="{{:name}}" data-link="{:#get('data').data.currency:} value^{:name}" .../>

            if (target.value === ("" + sourceValue)) {
              // If the data value corresponds to the value attribute of this radio button input, set the checked property to true
              sourceValue = true;
              attrOrProp = "prop";
              attr = "checked";
            } else {
              // Otherwise, go straight to observeAndBind, without updating.
              // (The browser will remove the 'checked' attribute, when another radio button in the group is checked).
              observeAndBind(linkCtx, source, target);
              view.linkCtx = oldLinkCtx;
              return;
            }
          } else if (attr === "selected" || attr === "disabled" || attr === "multiple" || attr === "readlonly") {
            sourceValue = (sourceValue && sourceValue !== "false") ? attr : null;
            // Use attr, not prop, so when the options (for example) are changed dynamically, but include the previously selected value,
            // they will still be selected after the change
          }

          setter = fnSetters[attr];

          if (setter) {
            if (changed = tag || $target[setter]() !== sourceValue) {
              if (attr === "html") {
                if (tag) {
                  inlineTag = tag._.inline;
                  tag.refresh(sourceValue);
                  if (!inlineTag && tag._.inline) {
                    // data-linked tag: data-link="{tagname ...}" has been converted to inline
                    // We will skip the observeAndBind call below, since the inserted tag binding above replaces that binding
                    view.linkCtx = oldLinkCtx;
                    return;
                  }
                } else {
                  // data-linked value: data-link="expr" or data-link="{:expr}" or data-link="{:expr:}" (with no convert or convertBack)
                  $target.empty();
                  targetElem = target;
                  view.link(source, targetElem, prevNode, nextNode, sourceValue, tag && { tag: tag._tgId });
                }
              } else if (attr === "text" && !target.children[0]) {
                // This code is faster then $target,text()
                if (target.textContent !== undefined) {
                  target.textContent = sourceValue;
                } else {
                  target.innerText = sourceValue === null ? "" : sourceValue;
                }
              } else {
                $target[setter](sourceValue);
              }
              // Removing this for now, to avoid side-effects when you programmatically set the value, and want the focus to stay on the text box
              //							if (target.nodeName.toLowerCase() === "input") {
              //								$target.blur(); // Issue with IE. This ensures HTML rendering is updated.
              //							}
            }
          } else if (changed = $target[attrOrProp](attr) != sourceValue) {
            // Setting an attribute to undefined should remove the attribute
            $target[attrOrProp](attr, sourceValue === undefined && attrOrProp === "attr" ? null : sourceValue);
          }
        }

        if (eventArgs && changed && (onEvent = view.hlp(onAfterChangeStr))) {
          onEvent.call(linkCtx, ev, eventArgs);
        }
      }
      observeAndBind(linkCtx, source, target);

      // Remove dynamically added linkCtx from view
      view.linkCtx = oldLinkCtx;
    }
  }

  function arrayChangeHandler(ev, eventArgs) {
    var self = this,
      onBeforeChange = self.hlp(onBeforeChangeStr),
      onAfterChange = self.hlp(onAfterChangeStr);

    if (!onBeforeChange || onBeforeChange.call(ev, eventArgs) !== false) {
      if (eventArgs) {
        // This is an observable action (not a trigger/handler call from pushValues, or similar, for which eventArgs will be null)
        var action = eventArgs.change,
          index = eventArgs.index,
          items = eventArgs.items;

        switch (action) {
          case "insert":
            self.addViews(index, items);
            break;
          case "remove":
            self.removeViews(index, items.length);
            break;
          case "move":
            self.refresh(); // Could optimize this
            break;
          case "refresh":
            self.refresh();
            break;
          // Othercases: (e.g.undefined, for setProperty on observable object) etc. do nothing
        }
      }
      if (onAfterChange) {
        onAfterChange.call(this, ev, eventArgs);
      }
    }
  }

  //=============================
  // Utilities for event handlers
  //=============================

  function getElementDefaultDisplay(elem) {
    // Get the 'visible' display style for the element
    var testElem, nodeName,
      getComputedStyle = global.getComputedStyle,
      cStyle = (elem.currentStyle || getComputedStyle.call(global, elem, "")).display;

    if (cStyle === "none" && !(cStyle = displayStyles[nodeName = elem.nodeName])) {
      // Currently display: none, and the 'visible' style has not been cached.
      // We create an element to find the correct visible display style for this nodeName
      testElem = document.createElement(nodeName);
      document.body.appendChild(testElem);
      cStyle = (getComputedStyle ? getComputedStyle.call(global, testElem, "") : testElem.currentStyle).display;
      // Cache the result as a hash against nodeName
      displayStyles[nodeName] = cStyle;
      document.body.removeChild(testElem);
    }
    return cStyle;
  }

  function setArrayChangeLink(view) {
    // Add/remove arrayChange handler on view
    var handler, arrayBinding,
      data = view.data, // undefined if view is being removed
      bound = view._.bnd; // true for top-level link() or data-link="{for}", or the for tag instance for {^{for}} (or for any custom tag that has an onArrayChange handler)

    if (!view._.useKey && bound) {
      // This is an array view. (view._.useKey not defined => data is array), and is data-bound to collection change events

      if (arrayBinding = view._.bndArr) {
        // First remove the current handler if there is one
        $([arrayBinding[1]]).off(arrayChangeStr, arrayBinding[0]);
        view._.bndArr = undefined;
      }
      if (bound !== !!bound && !bound.linkCtx) {
        // bound is not a boolean, so it is the bound tag that 'owns' this array binding - e.g. {^{for...}}
        if (data) {
          bound._.arrVws[view._.id] = view;
        } else {
          delete bound._.arrVws[view._.id]; // if view.data is undefined, view is being removed
        }
      } else if (data) {
        // If this view is not being removed, but the data array has been replaced, then bind to the new data array
        handler = function (ev) {
          if (!(ev.data && ev.data.off)) {
            // Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)
            // If view.data is undefined, do nothing. (Corresponds to case where there is another handler on the same data whose
            // effect was to remove this view, and which happened to precede this event in the trigger sequence. So although this
            // event has been removed now, it is still called since already on the trigger sequence)
            arrayChangeHandler.apply(view, arguments);
          }
        };
        $([data]).on(arrayChangeStr, handler);
        view._.bndArr = [handler, data];
      }
    }
  }

  function defaultAttr(elem, to, linkGetVal) {
    // to: true - default attribute for setting data value on HTML element; false: default attribute for getting value from HTML element
    // Merge in the default attribute bindings for this target element
    var nodeName = elem.nodeName.toLowerCase(),
      attr = $viewsSettings.merge[nodeName];
    return attr
      ? (to
        ? ((nodeName === "input" && elem.type === "radio") // For radio buttons, bind from value, but bind to 'radio' - special value.
          ? "radio"
          : attr.to.toAttr)
        : attr.from.fromAttr)
      : to
        ? linkGetVal ? "text" : "html" // Default innerText for data-link="a.b.c" or data-link="{:a.b.c}" - otherwise innerHTML
        : ""; // Default is not to bind from
  }

  //==============================
  // Rendering and DOM insertion
  //==============================

  function renderAndLink(view, index, tmpl, views, data, context, refresh) {
    var html, linkToNode, prevView, nodesToRemove, bindId,
      parentNode = view.parentElem,
      prevNode = view._prv,
      nextNode = view._nxt,
      elCnt = view._elCnt;

    if (prevNode && prevNode.parentNode !== parentNode) {
      error("Missing parentNode");
      // Abandon, since node has already been removed, or wrapper element has been inserted between prevNode and parentNode
    }

    if (refresh) {
      nodesToRemove = view.nodes();
      if (elCnt && prevNode && prevNode !== nextNode) {
        // This prevNode will be removed from the DOM, so transfer the view tokens on prevNode to nextNode of this 'viewToRefresh'
        transferViewTokens(prevNode, nextNode, parentNode, view._.id, "_", true);
      }

      // Remove child views
      view.removeViews(undefined, undefined, true);
      linkToNode = nextNode;

      if (elCnt) {
        prevNode = prevNode
          ? prevNode.previousSibling
          : nextNode
            ? nextNode.previousSibling
            : parentNode.lastChild;
      }

      // Remove HTML nodes
      $(nodesToRemove).remove();

      for (bindId in view._.bnds) {
        // The view bindings may have already been removed above in: $(nodesToRemove).remove();
        // If not, remove them here:
        removeViewBinding(bindId);
      }
    } else {
      // addViews. Only called if view is of type "array"
      if (index) {
        // index is a number, so indexed view in view array
        prevView = views[index - 1];
        if (!prevView) {
          return false; // If subview for provided index does not exist, do nothing
        }
        prevNode = prevView._nxt;
      }
      if (elCnt) {
        linkToNode = prevNode;
        prevNode = linkToNode
          ? linkToNode.previousSibling         // There is a linkToNode, so insert after previousSibling, or at the beginning
          : parentNode.lastChild;              // If no prevView and no prevNode, index is 0 and there are the container is empty,
        // so prevNode = linkToNode = null. But if prevNode._nxt is null then we set prevNode to parentNode.lastChild
        // (which must be before the prevView) so we insert after that node - and only link the inserted nodes
      } else {
        linkToNode = prevNode.nextSibling;
      }
    }
    html = tmpl.render(data, context, view, refresh || index, view._.useKey && refresh, true);
    // Pass in self._.useKey as test for layout template (which corresponds to when self._.useKey > 0 and self.data is an array)

    // Link the new HTML nodes to the data
    view.link(data, parentNode, prevNode, linkToNode, html, prevView);
    //}, 0);
  }

  //=====================
  // addBindingMarkers
  //=====================

  function addBindingMarkers(value, view, tmplBindingKey) {
    // Insert binding markers into the rendered template output, which will get converted to appropriate
    // data-jsv attributes (element-only content) or script marker nodes (phrasing or flow content), in convertMarkers,
    // within view.link, prior to inserting into the DOM. Linking will then bind based on these markers in the DOM.
    var id, tag, end;
    if (tmplBindingKey) {
      // This is a binding marker for a data-bound tag {^{...}}
      end = "^`";
      tag = view._.tag // This is {^{>...}} or {^{tag ...}} or {{cvt:...} - so tag was defined in convertVal or renderTag
        || {         // This is {^{:...}} so tag is not yet defined
        _: {
          inline: true,
          bnd: tmplBindingKey
        },
        tagCtx: {
          view: view
        },
        flow: true
      };
      id = tag._tgId;
      tag.refresh = refreshTag;
      if (!id) {
        bindingStore[id = bindingKey++] = tag; // Store the tag temporarily, ready for databinding.
        // During linking, in addDataBinding, the tag will be attached to the linkCtx,
        // and then in observeAndBind, bindingStore[bindId] will be replaced by binding info.
        tag._tgId = "" + id;
      }
    } else {
      // This is a binding marker for a view
      // Add the view to the store of current linked views
      end = "_`";
      viewStore[id = view._.id] = view;
    }
    // Example: "_#23`TheValue_/23`"
    return "#" + id + end
      + (value === undefined ? "" : value) // For {^{:name}} this gives the equivalent semantics to compiled (v=data.name)!=u?v:""; used in {{:name}} or data-link="name"
      + "/" + id + end;
  }

  //==============================
  // Data-linking and data binding
  //==============================

  //---------------
  // observeAndBind
  //---------------

  function observeAndBind(linkCtx, source, target) { //TODO? linkFnArgs) {;
    var tag, binding, cvtBack, paths, lastPath, pathIndex,
      depends = [],
      bindId = linkCtx._bndId || "" + bindingKey++,
      handler = linkCtx._hdlr;

    delete linkCtx._bndId;

    if (tag = linkCtx.tag) {
      // Use the 'depends' paths set on linkCtx.tag - which may have been set on declaration
      // or in events: init, render, onBeforeLink, onAfterLink etc.
      depends = tag.depends || depends;
      depends = $isFunction(depends) ? tag.depends(tag) : depends;
      cvtBack = tag.onChange;
    }
    cvtBack = cvtBack || linkCtx._cvtBk;
    if (!linkCtx._depends || ("" + linkCtx._depends !== "" + depends)) {
      // Only bind the first time, or if the new depends (toString) has changed from when last bound
      if (linkCtx._depends) {
        // Unobserve previous binding
        $observe(source, linkCtx._depends, handler, true);
      }
      binding = $observe($.isArray(source) ? [source] : source, paths = linkCtx.fn.paths || linkCtx.fn, depends, handler, linkCtx._ctxCb);
      // The binding returned by $observe has a bnd array with the source objects of the individual bindings.
      binding.elem = target; // The target of all the individual bindings
      binding.linkCtx = linkCtx;
      binding._tgId = bindId;
      // Add to the _jsvBnd on the target the view id and binding id - for unbinding when the target element is removed
      target._jsvBnd = target._jsvBnd || "";
      target._jsvBnd += "&" + bindId;
      linkCtx._depends = depends;
      // Store the binding key on the view, for disposal when the view is removed
      linkCtx.view._.bnds[bindId] = bindId;
      // Store the binding.
      bindingStore[bindId] = binding; // Note: If this corresponds to a bound tag, we are replacing the
      // temporarily stored tag by the stored binding. The tag will now be at binding.linkCtx.tag

      if (cvtBack !== undefined) {
        // Two-way binding.
        // We set the binding.to[1] to be the cvtBack, and  binding.to[0] to be either the path to the target, or [object, path] where the target is the path on the provided object.
        // So for a path with an object call: a.b.getObject().d.e, then we set to[0] to be [returnedObject, "d.e"], and we bind to the path on the returned object as target
        // Otherwise our target is the first path, paths[0], which we will convert with contextCb() for paths like ~a.b.c or #x.y.z
        //TODO add support for two-way binding with named props <input data-link="{:a foo=b:}" - currently will not bind to the correct target
        pathIndex = paths.length;
        while ("" + (lastPath = paths[--pathIndex]) !== lastPath) { }; // If the lastPath is an object (e.g. with _jsvOb property), take preceding one
        lastPath = paths[pathIndex] = lastPath.split("^").join("."); // We don't need the "^" since binding has happened. For to binding, require just "."s
        binding.to = lastPath.charAt(0) === "."
          ? [[paths[pathIndex - 1], lastPath.slice(1)], cvtBack]
          : [linkCtx._ctxCb(paths[0]) || [source, paths[0]], cvtBack];
      }
    }
  }

  //-------
  // $.link
  //-------

  function tmplLink(to, from, context, parentView, prevNode, nextNode) {
    return $link(this, to, from, context, parentView, prevNode, nextNode);
  }

  function $link(tmplOrLinkTag, to, from, context, parentView, prevNode, nextNode) {
    if (tmplOrLinkTag && to) {
      to = to.jquery ? to : $(to); // to is a jquery object or an element or selector

      if (!activeBody) {
        activeBody = document.body;
        $(activeBody).on(elementChangeStr, elemChangeHandler);
      }

      var i, k, html, vwInfos, view, placeholderParent, targetEl,
        onRender = addBindingMarkers,
        replaceMode = context && context.target === "replace",
        l = to.length;

      while (l--) {
        targetEl = to[l];

        if ("" + tmplOrLinkTag === tmplOrLinkTag) {
          // tmplOrLinkTag is a string: treat as data-link expression.
          addDataBinding(tmplOrLinkTag, targetEl, $view(targetEl), from, context);
        } else {
          parentView = parentView || $view(targetEl);

          if (tmplOrLinkTag.markup !== undefined) {
            // This is a call to template.link()
            if (parentView.link === false) {
              context = context || {};
              context.link = onRender = false; // If link=false, don't allow nested context to switch on linking
            }
            // Set link=false, explicitly, to disable linking within a template nested within a linked template
            if (replaceMode) {
              placeholderParent = targetEl.parentNode;
            }

            html = tmplOrLinkTag.render(from, context, parentView, undefined, undefined, onRender);
            // TODO Consider finding a way to bind data (link) within template without html being different for each view, the HTML can
            // be evaluated once outside the while (l--), and pushed into a document fragment, then cloned and inserted at each target.

            if (placeholderParent) {
              // This is target="replace" mode
              prevNode = targetEl.previousSibling;
              nextNode = targetEl.nextSibling;
              $.cleanData([targetEl], true);
              placeholderParent.removeChild(targetEl);

              targetEl = placeholderParent;
            } else {
              prevNode = nextNode = undefined; // When linking from a template, prevNode and nextNode parameters are ignored
              $(targetEl).empty();
            }
          } else if (tmplOrLinkTag !== true) {
            break;
          }

          // TODO Consider deferred linking API feature on per-template basis - {@{ instead of {^{ which allows the user to see the rendered content
          // before that content is linked, with better perceived perf. Have view.link return a deferred, and pass that to onAfterLink...
          // or something along those lines.
          // setTimeout(function() {

          if (targetEl._dfr && !nextNode) {
            // We are inserting new content and the target element has some deferred binding annotations,and there is no nextNode.
            // Those views may be stale views (that will be recreated in this new linking action) so we will first remove them
            // (if not already removed).
            vwInfos = viewInfos(targetEl._dfr, true, rOpenViewMarkers);

            for (i = 0, k = vwInfos.length; i < k; i++) {
              view = vwInfos[i];
              if ((view = viewStore[view.id]) && view.data !== undefined) {
                // If this is the _prv (prevNode) for a view, remove the view
                // - unless view.data is undefined, in which case it is already being removed
                view.parent.removeViews(view._.key, undefined, true);
              }
            }
            targetEl._dfr = "";
          }

          // Link the content of the element, since this is a call to template.link(), or to $(el).link(true, ...),
          parentView.link(from, targetEl, prevNode, nextNode, html);
          //}, 0);
        }
      }
    }
    return to; // Allow chaining, to attach event handlers, etc.
  }

  //----------
  // view.link
  //----------

  function viewLink(outerData, parentNode, prevNode, nextNode, html, refresh) {
    // Optionally insert HTML into DOM using documentFragments (and wrapping HTML appropriately).
    // Data-link existing contents of parentNode, or the inserted HTML, if provided

    // Depending on the content model for the HTML elements, the standard data-linking markers inserted in the HTML by addBindingMarkers during
    // template rendering will be converted either to script marker nodes or, for element-only content sections, by data-jsv element annotations.

    // Data-linking will then add _prv and _nxt to views, where:
    //     _prv: References the previous node (script element of type "jsv123"), or (for elCnt=true), the first element node in the view
    //     _nxt: References the last node (script element of type "jsv/123"), or (for elCnt=true), the next element node after the view.

    //==== nested functions ====
    function convertMarkers(all, preceding, selfClose, closeTag, spaceBefore, id, spaceAfter, tag1, tag2, closeTag2, spaceAfterClose, selfClose2) {
      //rConvertMarkers = /(^|(\/>)|(<\/\w+>)|>|)(\s*)_([#\/]\d+_)`(\s*)(<\w+(?=[\s\/>]))?|\s*(?:(<\w+(?=[\s\/>]))|(<\/\w+>)(\s*)|(\/>)\s*)/g,
      //                 prec, slfCl, clTag,  spaceBefore, id,    spaceAfter, tag1,                  tag2,             clTag2,  sac   slfCl2,
      // Convert the markers that were included by addBindingMarkers in template output, to appropriate DOM annotations:
      // data-jsv attributes (for element-only content) or script marker nodes (within phrasing or flow content).

      // TODO consider detecting 'quoted' contexts (attribute strings) so that attribute encoding does not need to encode >
      // Currently rAttrEncode = /[><"'&]/g includes '>' encoding in order to avoid erroneous parsing of <span title="&lt;a/>">

      var endOfElCnt = "";
      tag = tag1 || tag2 || "";
      closeTag = closeTag || selfClose || closeTag2 || selfClose2;
      if (closeTag) {
        if (validate && (selfClose || selfClose2) && !voidElems[parentTag]) {
          syntaxError("'<" + parentTag + "... />' in:\n" + html);
        }
        prevElCnt = elCnt;
        parentTag = tagStack.shift();
        elCnt = elContent[parentTag];
        if (prevElCnt) {
          // If there are ids (markers since the last tag), move them to the defer string
          defer += ids;
          ids = "";
          if (!elCnt) {
            endOfElCnt = (closeTag2 || "") + openScript + "@" + defer + closeScript + (spaceAfterClose || "");
            defer = deferStack.shift();
          } else {
            defer += "-"; // Will be used for stepping back through deferred tokens
          }
        }
      }
      if (elCnt) {
        // elContent maps tagNames which have only element content, so may not support script nodes.
        // We are in element-only content, can remove white space, and use data-jsv attributes on elements as markers
        // Example: <tr data-jsv="/2_#6_"> - close marker for view 2 and open marker for view 6

        if (id) {
          // append marker for this id, to ids string
          ids += id;
        } else {
          preceding = (closeTag2 || selfClose2 || "");
        }
        if (tag) {
          preceding += tag;
          if (ids) {
            preceding += ' ' + jsvAttrStr + '="' + ids + '"';
            ids = "";
          }
        }
      } else {
        // We are in phrasing or flow content, so use script marker nodes
        // Example: <script type="jsv3/"></script> - data-bound tag, close marker
        preceding = id
          ? (preceding + endOfElCnt + spaceBefore + openScript + id + closeScript + spaceAfter + tag)
          : endOfElCnt || all;
      }
      if (tag) {
        // If there are ids (markers since the last tag), move them to the defer string
        tagStack.unshift(parentTag);
        parentTag = tag.slice(1);
        if (tagStack[0] === badParent[parentTag]) {
          // TODO: move this to design-time validation check
          error('"' + parentTag + '" has incorrect parent tag');
        }
        if ((elCnt = elContent[parentTag]) && !prevElCnt) {
          deferStack.unshift(defer);
          defer = "";
        }
        prevElCnt = elCnt;
        //TODO Consider providing validation which throws if you place <span> as child of <tr>, etc. - since if not caught,
        //this can cause errors subsequently which are difficult to debug.
        //				if (elContent[tagStack[0]]>2 && !elCnt) {
        //					error(parentTag + " in " + tagStack[0]);
        //				}
        if (defer && elCnt) {
          defer += "+"; // Will be used for stepping back through deferred tokens
        }
      }
      return preceding;
    }

    function processViewInfos(vwInfos, targetParent) {
      // If targetParent, we are processing viewInfos (which may include navigation through '+-' paths) and hooking up to the right parentElem etc.
      // (and elem may also be defined - the next node)
      // If no targetParent, then we are processing viewInfos on newly inserted content
      var deferPath, deferChar, bindChar, parentElem, id, onAftCr, deep,
        addedBindEls = [];

      // In elCnt context (element-only content model), prevNode is the first node after the open, nextNode is the first node after the close.
      // If both are null/undefined, then open and close are at end of parent content, so the view is empty, and its placeholder is the
      // 'lastChild' of the parentNode. If there is a prevNode, then it is either the first node in the view, or the view is empty and
      // its placeholder is the 'previousSibling' of the prevNode, which is also the nextNode.
      if (vwInfos) {
        //targetParent = targetParent || targetElem && targetElem.previousSibling;
        //targetParent = targetElem ? targetElem.previousSibling : targetParent;
        len = vwInfos.length;
        if (vwInfos.tokens.charAt(0) === "@") {
          // This is a special script element that was created in convertMarkers() to process deferred bindings, and inserted following the
          // target parent element - because no element tags were encountered to carry those binding tokens.
          targetParent = elem.previousSibling;
          elem.parentNode.removeChild(elem);
          elem = null;
        }
        len = vwInfos.length;
        while (len--) {
          vwInfo = vwInfos[len];
          //if (prevIds.indexOf(vwInfo.token) < 0) { // This token is a newly created view or tag binding
          bindChar = vwInfo.ch;
          if (deferPath = vwInfo.path) {
            // We have a 'deferred path'
            j = deferPath.length - 1;
            while (deferChar = deferPath.charAt(j--)) {
              // Use the "+" and"-" characters to navigate the path back to the original parent node where the deferred bindings ocurred
              if (deferChar === "+") {
                if (deferPath.charAt(j) === "-") {
                  j--;
                  targetParent = targetParent.previousSibling;
                } else {
                  targetParent = targetParent.parentNode;
                }
              } else {
                targetParent = targetParent.lastChild;
              }
              // Note: Can use previousSibling and lastChild, not previousElementSibling and lastElementChild,
              // since we have removed white space within elCnt. Hence support IE < 9
            }
          }
          if (bindChar === "^") {
            if (tag = bindingStore[id = vwInfo.id]) {
              // The binding may have been deleted, for example in a different handler to an array collectionChange event
              // This is a tag binding
              deep = targetParent && (!elem || elem.parentNode !== targetParent);
              if (!elem || deep) {
                tag.parentElem = targetParent;
              }
              if (vwInfo.elCnt) {
                if (vwInfo.open) {
                  if (targetParent) {
                    // This is an 'open view' node (preceding script marker node,
                    // or if elCnt, the first element in the view, with a data-jsv annotation) for binding
                    targetParent._dfr = "#" + id + bindChar + (targetParent._dfr || "");
                  }
                } else if (deep) {
                  // There is no ._nxt so add token to _dfr. It is deferred.
                  targetParent._dfr = "/" + id + bindChar + (targetParent._dfr || "");
                }
              }
              // This is an open or close marker for a data-bound tag {^{...}}. Add it to bindEls.
              addedBindEls.push([deep ? null : elem, vwInfo]);
            }
          } else if (view = viewStore[id = vwInfo.id]) {
            // The view may have been deleted, for example in a different handler to an array collectionChange event
            if (!view.link) {
              // If view is not already extended for JsViews, extend and initialize the view object created in JsRender, as a JsViews view
              view.parentElem = targetParent || elem && elem.parentNode || parentNode;
              $extend(view, LinkedView);
              view._.onRender = addBindingMarkers;
              view._.onArrayChange = arrayChangeHandler;
              setArrayChangeLink(view);
            }
            parentElem = view.parentElem;
            if (vwInfo.open) {
              // This is an 'open view' node (preceding script marker node,
              // or if elCnt, the first element in the view, with a data-jsv annotation) for binding
              view._elCnt = vwInfo.elCnt;
              if (targetParent) {
                targetParent._dfr = "#" + id + bindChar + (targetParent._dfr || "");
              } else {
                // No targetParent, so there is a ._nxt elem (and this is processing tokens on the elem)
                if (!view._prv) {
                  parentElem._dfr = removeSubStr(parentElem._dfr, "#" + id + bindChar);
                }
                view._prv = elem;
              }
            } else {
              // This is a 'close view' marker node for binding
              if (targetParent && (!elem || elem.parentNode !== targetParent)) {
                // There is no ._nxt so add token to _dfr. It is deferred.
                targetParent._dfr = "/" + id + bindChar + (targetParent._dfr || "");
                view._nxt = undefined;
              } else if (elem) {
                // This view did not have a ._nxt, but has one now, so token may be in _dfr, and must be removed. (No longer deferred)
                if (!view._nxt) {
                  parentElem._dfr = removeSubStr(parentElem._dfr, "/" + id + bindChar);
                }
                view._nxt = elem;
              }
              linkCtx = view.linkCtx;
              if (onAftCr = onAfterCreate || (view.ctx && view.ctx.onAfterCreate)) {
                onAftCr.call(linkCtx, view);
              }
            }
            //}
          }
        }
        len = addedBindEls.length;
        while (len--) {
          // These were added in reverse order to addedBindEls. We push them in BindEls in the correct order.
          bindEls.push(addedBindEls[len]);
        }
      }
      return !vwInfos || vwInfos.elCnt;
    }

    function getViewInfos(vwInfos) {
      // Used by view.childTags() and tag.childTags()
      // Similar to processViewInfos in how it steps through bindings to find tags. Only finds data-bound tags.
      var level, parentTag;

      if (len = vwInfos && vwInfos.length) {
        for (j = 0; j < len; j++) {
          vwInfo = vwInfos[j];
          if (get.id) {
            get.id = get.id !== vwInfo.id && get.id;
          } else {
            // This is an open marker for a data-bound tag {^{...}}, within the content of the tag whose id is get.id. Add it to bindEls.
            parentTag = tag = bindingStore[vwInfo.id].linkCtx.tag;
            if (!tag.flow) {
              if (!deep) {
                level = 1;
                while (parentTag = parentTag.parent) {
                  level++;
                }
                tagDepth = tagDepth || level; // The level of the first tag encountered.
              }
              if ((deep || level === tagDepth) && (!tagName || tag.tagName === tagName)) {
                // Filter on top-level or tagName as appropriate
                tags.push(tag);
              }
            }
          }
        }
      }
    }

    function dataLink() {
      //================ Data-link and fixup of data-jsv annotations ================
      elems = qsa ? parentNode.querySelectorAll(linkViewsSel) : $(linkViewsSel, parentNode).get();
      l = elems.length;

      // The prevNode will be in the returned query, since we called markPrevOrNextNode() on it.
      // But it may have contained nodes that satisfy the selector also.
      if (prevNode) {
        // Find the last contained node one to use as the prevNode - so we only link subsequent elems in the query
        prevNodes = qsa ? prevNode.querySelectorAll(linkViewsSel) : $(linkViewsSel, prevNode).get();
        prevNode = prevNodes.length ? prevNodes[prevNodes.length - 1] : prevNode;
      }
      tagDepth = 0;
      for (i = 0; i < l; i++) {
        elem = elems[i];
        if (prevNode && !found) {
          // If prevNode is set, not false, skip linking. If this element is the prevNode, set to false so subsequent elements will link.
          found = (elem === prevNode);
        } else if (nextNode && elem === nextNode) {
          // If nextNode is set then break when we get to nextNode
          break;
        } else if (elem.parentNode
          // elem has not been removed from DOM
          && processInfos(viewInfos(elem, undefined, tags && rOpenTagMarkers))
          // If a link() call, processViewInfos() adds bindings to bindEls, and returns true for non-script nodes, for adding data-link bindings
          // If a childTags() call getViewInfos adds tag bindings to tags array.
          && elem.getAttribute($viewsLinkAttr)) {
          bindEls.push([elem]);
        }
      }

      // Remove temporary marker script nodes they were added by markPrevOrNextNode
      unmarkPrevOrNextNode(prevNode, elCnt);
      unmarkPrevOrNextNode(nextNode, elCnt);

      if (get) {
        lazyLink && lazyLink.resolve();
        return;
      }

      if (elCnt && defer + ids) {
        // There are some views with elCnt, for which the open or close did not precede any HTML tag - so they have not been processed yet
        elem = nextNode;
        if (defer) {
          if (nextNode) {
            processViewInfos(viewInfos(defer + "+", true), nextNode);
          } else {
            processViewInfos(viewInfos(defer, true), parentNode);
          }
        }
        processViewInfos(viewInfos(ids, true), parentNode);
        // If there were any tokens on nextNode which have now been associated with inserted HTML tags, remove them from nextNode
        if (nextNode) {
          tokens = nextNode.getAttribute(jsvAttrStr);
          if (l = tokens.indexOf(prevIds) + 1) {
            tokens = tokens.slice(l + prevIds.length - 1);
          }
          nextNode.setAttribute(jsvAttrStr, ids + tokens);
        }
      }

      //================ Bind the data-link elements, and the data-bound tags ================
      l = bindEls.length;
      for (i = 0; i < l; i++) {
        elem = bindEls[i];
        linkInfo = elem[1];
        elem = elem[0];
        if (linkInfo) {
          tag = bindingStore[linkInfo.id];
          tag = tag.linkCtx ? tag.linkCtx.tag : tag;
          // The tag may have been stored temporarily on the bindingStore - or may have already been replaced by the actual binding
          if (linkInfo.open) {
            // This is an 'open bound tag' binding annotation for a data-bound tag {^{...}}
            if (elem) {
              tag.parentElem = elem.parentNode;
              tag._prv = elem;
            }
            tag._elCnt = linkInfo.elCnt;
            if (tag && (!tag.onBeforeLink || tag.onBeforeLink() !== false) && !tag._.bound) {
              // By default we data-link depth-first ("on the way in"), which is better for perf. But if a tag needs nested tags to be linked (refreshed)
              // first, before linking its content, then make onBeforeLink() return false. In that case we data-link depth-first, so nested tags will have already refreshed.
              tag._.bound = true;
              view = tag.tagCtx.view;
              addDataBinding(undefined, tag._prv, view, view.data || outerData, linkInfo.id);
            }

            tag._.linking = true;
          } else {
            tag._nxt = elem;
            if (tag._.linking) {
              // This is a 'close bound tag' binding annotation
              // Add data binding
              view = tag.tagCtx.view;
              tag.contents = getContents;
              tag.nodes = getNodes;
              tag.childTags = getChildTags;

              delete tag._.linking;
              if (tag && tag.onAfterLink) {
                tag.onAfterLink();
              }
              if (!tag._.bound) {
                tag._.bound = true;
                addDataBinding(undefined, tag._prv, view, view.data || outerData, linkInfo.id);
              }
            }
          }
        } else {
          view = $view(elem);
          // Add data binding for a data-linked element (with data-link attribute)
          addDataBinding(elem.getAttribute($viewsLinkAttr), elem, view, view.data || outerData);
        }
      }
      lazyLink && lazyLink.resolve();
    }
    //==== /end of nested functions ====

    var linkCtx, tag, i, l, j, len, elems, elem, view, vwInfos, vwInfo, linkInfo, prevNodes, token, prevView, nextView, node, tags, deep, tagName,
      tagDepth, get, depth, fragment, copiedNode, firstTag, parentTag, wrapper, div, tokens, elCnt, prevElCnt, htmlTag, ids, prevIds, found, lazyLink,
      noDomLevel0 = $viewsSettings.noDomLevel0,
      self = this,
      thisId = self._.id + "_",
      defer = "",
      // The marker ids for which no tag was encountered (empty views or final closing markers) which we carry over to container tag
      bindEls = [],
      tagStack = [],
      deferStack = [],
      onAfterCreate = self.hlp(onAfterCreateStr),
      processInfos = processViewInfos;

    if (refresh) {
      lazyLink = refresh.lazyLink && $.Deferred();
      if (refresh.tmpl) {
        // refresh is the prevView, passed in from addViews()
        prevView = "/" + refresh._.id + "_";
      } else {
        get = refresh.get;
        if (refresh.tag) {
          thisId = refresh.tag + "^";
          refresh = true;
        }
      }
      refresh = refresh === true;
    }

    if (get) {
      processInfos = getViewInfos;
      tags = get.tags;
      deep = get.deep;
      tagName = get.name;
    }

    parentNode = parentNode
      ? ("" + parentNode === parentNode
        ? $(parentNode)[0]  // It is a string, so treat as selector
        : parentNode.jquery
          ? parentNode[0] // A jQuery object - take first element.
          : parentNode)
      : (self.parentElem      // view.link()
        || document.body);  // link(null, data) to link the whole document

    parentTag = parentNode.tagName.toLowerCase();
    elCnt = !!elContent[parentTag];

    prevNode = prevNode && markPrevOrNextNode(prevNode, elCnt);
    nextNode = nextNode && markPrevOrNextNode(nextNode, elCnt) || null;

    if (html !== undefined) {
      //================ Insert html into DOM using documentFragments (and wrapping HTML appropriately). ================
      // Also convert markers to DOM annotations, based on content model.
      // Corresponds to nextNode ? $(nextNode).before(html) : $(parentNode).html(html);
      // but allows insertion to wrap correctly even with inserted script nodes. jQuery version will fail e.g. under tbody or select.
      // This version should also be slightly faster
      div = document.createElement("div");
      wrapper = div;
      prevIds = ids = "";
      htmlTag = parentNode.namespaceURI === "http://www.w3.org/2000/svg" ? "svg" : (firstTag = rFirstElem.exec(html)) && firstTag[1] || "";
      if (noDomLevel0 && firstTag && firstTag[2]) {
        error("Unsupported: " + firstTag[2]); // For security reasons, don't allow insertion of elements with onFoo attributes.
      }
      if (elCnt) {
        // Now look for following view, and find its tokens, or if not found, get the parentNode._dfr tokens
        node = nextNode;
        while (node && !(nextView = viewInfos(node))) {
          node = node.nextSibling;
        }
        if (tokens = nextView ? nextView.tokens : parentNode._dfr) {
          token = prevView || "";
          if (refresh || !prevView) {
            token += "#" + thisId;
          }
          j = tokens.indexOf(token);
          if (j + 1) {
            j += token.length;
            // Transfer the initial tokens to inserted nodes, by setting them as the ids variable, picked up in convertMarkers
            prevIds = ids = tokens.slice(0, j);
            tokens = tokens.slice(j);
            if (nextView) {
              node.setAttribute(jsvAttrStr, tokens);
            } else {
              parentNode._dfr = tokens;
            }
          }
        }
      }

      //================ Convert the markers to DOM annotations, based on content model. ================
      //			oldElCnt = elCnt;
      html = ("" + html).replace(rConvertMarkers, convertMarkers);
      //			if (!!oldElCnt !== !!elCnt) {
      //				error("Parse: " + html); // Parse error. Content not well-formed?
      //			}
      // Append wrapper element to doc fragment
      safeFragment.appendChild(div);

      // Go to html and back, then peel off extra wrappers
      // Corresponds to jQuery $(nextNode).before(html) or $(parentNode).html(html);
      // but supports svg elements, and other features missing from jQuery version (and this version should also be slightly faster)
      htmlTag = wrapMap[htmlTag] || wrapMap.div;
      depth = htmlTag[0];
      wrapper.innerHTML = htmlTag[1] + html + htmlTag[2];
      while (depth--) {
        wrapper = wrapper.lastChild;
      }
      safeFragment.removeChild(div);
      fragment = document.createDocumentFragment();
      while (copiedNode = wrapper.firstChild) {
        fragment.appendChild(copiedNode);
      }
      // Insert into the DOM
      parentNode.insertBefore(fragment, nextNode);
    }

    if (lazyLink) {
      setTimeout(dataLink, 0);
    } else {
      dataLink();
    }

    return lazyLink && lazyLink.promise();
  }

  function addDataBinding(linkMarkup, node, currentView, data, boundTagId) {
    // Add data binding for data-linked elements or {^{...}} data-bound tags
    var tmpl, tokens, attr, convertBack, params, trimLen, tagExpr, linkFn, linkCtx, tag, rTagIndex;

    if (boundTagId) {
      // {^{...}} bound tag. So only one linkTag in linkMarkup
      tag = bindingStore[boundTagId];
      tag = tag.linkCtx ? tag.linkCtx.tag : tag;

      linkCtx = tag.linkCtx || {
        data: data,             // source
        elem: tag._elCnt ? tag.parentElem : node,             // target
        view: currentView,
        attr: "html", // Script marker nodes are associated with {^{ and always target HTML.
        fn: tag._.bnd,
        tag: tag,
        // Pass the boundTagId in the linkCtx, so that it can be picked up in observeAndBind
        _bndId: boundTagId
      };
      bindDataLinkTarget(linkCtx, linkCtx.fn);
    } else if (linkMarkup && node) {
      // Compiled linkFn expressions could be stored in the tmpl.links array of the template
      // TODO - consider also caching globally so that if {{:foo}} or data-link="foo" occurs in different places,
      // the compiled template for this is cached and only compiled once...
      //links = currentView.links || currentView.tmpl.links;

      tmpl = currentView.tmpl;

      //			if (!(linkTags = links[linkMarkup])) {
      // This is the first time this view template has been linked, so we compile the data-link expressions, and store them on the template.

      linkMarkup = normalizeLinkTag(linkMarkup, node);
      rTag.lastIndex = 0;
      while (tokens = rTag.exec(linkMarkup)) { // TODO require } to be followed by whitespace or $, and remove the \}(!\}) option.
        // Iterate over the data-link expressions, for different target attrs,
        // (only one if there is a boundTagId - the case of data-bound tag {^{...}})
        // e.g. <input data-link="{:firstName:} title{>~description(firstName, lastName)}"
        // tokens: [all, attr, bindOnly, tagExpr, tagName, converter, colon, html, comment, code, params]
        rTagIndex = rTag.lastIndex;
        attr = boundTagId ? "html" : tokens[1]; // Script marker nodes are associated with {^{ and always target HTML.
        tagExpr = tokens[3];
        params = tokens[10];
        convertBack = undefined;

        linkCtx = {
          data: data,             // source
          elem: tag && tag._elCnt ? tag.parentElem : node,             // target
          view: currentView,
          attr: attr,
          _initVal: !tokens[2]
        };

        if (tokens[6]) {
          // TODO include this in the original rTag regex
          // Only for {:} link"

          if (!attr && (convertBack = /:([\w$]*)$/.exec(params))) {
            // two-way binding
            convertBack = convertBack[1];
            if (convertBack !== undefined) {
              // There is a convertBack function
              trimLen = - convertBack.length - 1;
              tagExpr = tagExpr.slice(0, trimLen - 1) + delimCloseChar0; // Remove the convertBack string from expression.
              params = params.slice(0, trimLen);
            }
          }
          if (convertBack === null) {
            convertBack = undefined;
          }
          linkCtx.cvt = tokens[5] || "";
        }
        // Compile the linkFn expression which evaluates and binds a data-link expression
        // TODO - optimize for the case of simple data path with no conversion, helpers, etc.:
        //     i.e. data-link="a.b.c". Avoid creating new instances of Function every time. Can use a default function for all of these...

        linkCtx.expr = attr + tagExpr;
        linkFn = tmpl.links[tagExpr];
        if (!linkFn) {
          tmpl.links[tagExpr] = linkFn = $viewsSub.tmplFn(delimOpenChar0 + tagExpr + delimCloseChar1, tmpl, true, convertBack);
          $viewsSub.parse(params, linkFn.paths = [], tmpl);
        }
        linkCtx.fn = linkFn;
        if (!attr && convertBack !== undefined) {
          // Default target, so allow 2 way binding
          linkCtx._cvtBk = convertBack;
        }

        bindDataLinkTarget(linkCtx, linkFn);
        // We store rTagIndex in local scope, since this addDataBinding method can sometimes be called recursively,
        // and each is using the same rTag instance.
        rTag.lastIndex = rTagIndex;
      }
      //		}
    }
  }

  function bindDataLinkTarget(linkCtx, linkFn) {
    // Add data link bindings for a link expression in data-link attribute markup
    function handler(ev, eventArgs) {
      propertyChangeHandler.call(linkCtx, ev, eventArgs, linkFn);
      // If the link expression uses a custom tag, the propertyChangeHandler call will call renderTag, which will set tagCtx on linkCtx
    }

    // Consider for issue https://github.com/BorisMoore/jsviews/issues/158 arrayChange support on data-link etc.
    //handler.array = function() {
    //	...
    //}

    linkCtx._ctxCb = getContextCb(linkCtx.view); // _ctxCb is for filtering/appending to dependency paths: function(path, object) { return [(object|path)*]}
    linkCtx._hdlr = handler;
    if (linkCtx.tag && linkCtx.tag.onArrayChange) {
      handler.array = function (ev, eventArgs) {
        linkCtx.tag.onArrayChange(ev, eventArgs);
      };
    }
    handler(true);
  }

  //=====================
  // Data-linking helpers
  //=====================

  function removeSubStr(str, substr) {
    var k;
    return str
      ? (k = str.indexOf(substr),
        (k + 1
          ? str.slice(0, k) + str.slice(k + substr.length)
          : str))
      : "";
  }

  function markerNodeInfo(node) {
    return node &&
      ("" + node === node
        ? node
        : node.tagName === "SCRIPT"
          ? node.type.slice(3)
          : node.nodeType === 1 && node.getAttribute(jsvAttrStr) || "");
  }

  function viewInfos(node, isVal, rBinding) {
    // Test whether node is a script marker nodes, and if so, return metadata
    function getInfos(all, open, close, id, ch, elPath) {
      infos.push({
        elCnt: elCnt,
        id: id,
        ch: ch,
        open: open,
        close: close,
        path: elPath,
        token: all
      });
    }
    var elCnt, tokens,
      infos = [];
    if (tokens = isVal ? node : markerNodeInfo(node)) {
      infos.elCnt = !node.type;
      elCnt = tokens.charAt(0) === "@" || !node.type;
      infos.tokens = tokens;
      // rMarkerTokens = /(?:(#)|(\/))(\d+)([_^])([-+@\d]+)?/g;
      tokens.replace(rBinding || rMarkerTokens, getInfos);
      return infos;
    }
  }

  function unmarkPrevOrNextNode(node, elCnt) {
    if (node) {
      if (node.type === "jsv") {
        node.parentNode.removeChild(node);
      } else if (elCnt && node.getAttribute($viewsLinkAttr) === "") {
        node.removeAttribute($viewsLinkAttr);
      }
    }
  }

  function markPrevOrNextNode(node, elCnt) {
    var marker = node;
    while (elCnt && marker && marker.nodeType !== 1) {
      marker = marker.previousSibling;
    }
    if (marker) {
      if (marker.nodeType !== 1) {
        // For text nodes, we will add a script node before
        marker = document.createElement("SCRIPT");
        marker.type = "jsv";
        node.parentNode.insertBefore(marker, node);
      } else if (!markerNodeInfo(marker) && !marker.getAttribute($viewsLinkAttr)) {
        // For element nodes, we will add a data-link attribute (unless there is already one)
        // so that this node gets included in the node linking process.
        marker.setAttribute($viewsLinkAttr, "");
      }
    }
    return marker;
  }

  function normalizeLinkTag(linkMarkup, node) {
    linkMarkup = $.trim(linkMarkup);
    return linkMarkup.slice(-1) !== delimCloseChar0
      // If simplified syntax is used: data-link="expression", convert to data-link="{:expression}",
      // or for inputs, data-link="{:expression:}" for (default) two-way binding
      ? linkMarkup = delimOpenChar1 + ":" + linkMarkup + (defaultAttr(node) ? ":" : "") + delimCloseChar0
      : linkMarkup;
  }

  //===========================
  // Methods for views and tags
  //===========================

  function getContents(select, deep) {
    // For a view or a tag, return jQuery object with the content nodes,
    var filtered,
      nodes = $(this.nodes());
    if (nodes[0]) {
      filtered = select ? nodes.filter(select) : nodes;
      nodes = deep && select ? filtered.add(nodes.find(select)) : filtered;
    }
    return nodes;
  }

  function getNodes(withMarkers, prevNode, nextNode) {
    // For a view or a tag, return top-level nodes
    // Do not return any script marker nodes, unless withMarkers is true
    // Optionally limit range, by passing in prevNode or nextNode parameters

    var node,
      self = this,
      elCnt = self._elCnt,
      prevIsFirstNode = !prevNode && elCnt,
      nodes = [];

    prevNode = prevNode || self._prv;
    nextNode = nextNode || self._nxt;

    node = prevIsFirstNode
      ? (prevNode === self._nxt
        ? self.parentElem.lastSibling
        : prevNode)
      : (self._.inline === false
        ? prevNode || self.linkCtx.elem.firstChild
        : prevNode && prevNode.nextSibling);

    while (node && (!nextNode || node !== nextNode)) {
      if (withMarkers || elCnt || !markerNodeInfo(node)) {
        // All the top-level nodes in the view
        // (except script marker nodes, unless withMarkers = true)
        // (Note: If a script marker node, viewInfo.elCnt undefined)
        nodes.push(node);
      }
      node = node.nextSibling;
    }
    return nodes;
  }

  function getChildTags(deep, tagName) {
    // For a view or a tag, return child tags - at any depth, or as immediate children only.
    if (deep !== !!deep) {
      // deep not boolean, so this is childTags(tagName) - which looks for top-level tags of given tagName
      tagName = deep;
      deep = undefined;
    }

    var self = this,
      view = self.link ? self : self.tagCtx.view, // this may be a view or a tag. If a tag, get the view from tag.view.tagCtx
      prevNode = self._prv,
      elCnt = self._elCnt,
      tags = [];

    if (prevNode) {
      view.link(
        undefined,
        self.parentElem,
        elCnt ? prevNode.previousSibling : prevNode,
        self._nxt,
        undefined,
        { get: { tags: tags, deep: deep, name: tagName, id: elCnt && self._tgId } }
      );
    }
    return tags;
  }

  function refreshTag(sourceValue) {
    var skipBinding, nodesToRemove, promise,
      tag = this,
      target = tag.parentElem,
      view = tag.tagCtx.view,
      prevNode = tag._prv,
      nextNode = tag._nxt,
      elCnt = tag._elCnt,
      inline = tag._.inline,
      props = tag.tagCtx.props;

    if (tag.disposed) { error("Removed tag"); }
    if (sourceValue === undefined) {
      sourceValue = tag._.bnd.call(view.tmpl, view.data, view, $views); // get tagCtxs
      if (inline) {
        sourceValue = $views._tag(tag, view, view.tmpl, sourceValue); // get rendered HTML for tag
      }
    }
    if (!tag.flow && !tag.render && !tag.template) {
      // We allow a data-linked tag control which does not render to set content on the data-linked element during init, onBeforeLink and onAfterLink
    } else if (inline) {
      nodesToRemove = tag.nodes(true);

      if (elCnt) {
        if (prevNode && prevNode !== nextNode) {
          // This prevNode will be removed from the DOM, so transfer the view tokens on prevNode to nextNode of this 'viewToRefresh'
          transferViewTokens(prevNode, nextNode, target, tag._tgId, "^", true);
        }
        prevNode = prevNode
          ? prevNode.previousSibling
          : nextNode
            ? nextNode.previousSibling
            : target.lastChild;
      }
      // Remove HTML nodes
      $(nodesToRemove).remove();
    } else {
      // data-linked value using converter(s): data-link="{cvt: ... :cvtBack}" or tag: data-link="{tagname ...}"
      if (!tag.flow && props.inline) {
        // data-link="{tagname ...}"
        view._.tag = tag;
        sourceValue = addBindingMarkers(sourceValue, view, true);
        view._.tag = undefined;
        skipBinding = tag._.inline = true;
      }

      $(target).empty();
    }
    // Data link the new contents of the target node
    if (!skipBinding && tag.onBeforeLink) {
      tag.onBeforeLink();
    }
    promise = view.link(view.data, target, prevNode, nextNode, sourceValue, tag && { tag: tag._tgId, lazyLink: props.lazyLink });
    if (!skipBinding && tag.onAfterLink) {
      if (promise) {
        promise.then(function () {
          tag.onAfterLink();
        });
      } else {
        tag.onAfterLink();
      }
    }
    return promise || tag;
  }

  //=========
  // Disposal
  //=========

  function clean(elems) {
    // Remove data-link bindings, or contained views
    var j, l, l2, elem, vwInfos, vwItem, bindings,
      elemArray = [],
      len = elems.length,
      i = len;
    while (i--) {
      // Copy into an array, so that deletion of nodes from DOM will not cause our 'i' counter to get shifted
      // (Note: This seems as fast or faster than elemArray = [].slice.call(elems); ...)
      elemArray.push(elems[i]);
    }
    i = len;
    while (i--) {
      elem = elemArray[i];
      if (elem.parentNode) {
        // Has not already been removed from the DOM
        if (bindings = elem._jsvBnd) {
          // Get propertyChange bindings for this element
          // This may be an element with data-link, or the opening script marker node for a data-bound tag {^{...}}
          // bindings is a string with the syntax: "(&bindingId)*"
          bindings = bindings.slice(1).split("&");
          elem._jsvBnd = "";
          l = bindings.length;
          while (l--) {
            // Remove associated bindings
            removeViewBinding(bindings[l]); // unbind bindings with this bindingId on this view
          }
        }
        if (vwInfos = viewInfos(markerNodeInfo(elem) + (elem._dfr || ""), true, rOpenMarkers)) {
          for (j = 0, l2 = vwInfos.length; j < l2; j++) {
            vwItem = vwInfos[j];
            if (vwItem.ch === "_") {
              if ((vwItem = viewStore[vwItem.id]) && vwItem.data !== undefined) {
                // If this is the _prv (prevNode) for a view, remove the view
                // - unless view.data is undefined, in which case it is already being removed
                vwItem.parent.removeViews(vwItem._.key, undefined, true);
              }
            } else {
              removeViewBinding(vwItem.id); // unbind bindings with this bindingId on this view
            }
          }
        }
      }
    }
  }

  function removeViewBinding(bindId) {
    // Unbind
    var objId, linkCtx, tag, object, obsId,
      binding = bindingStore[bindId];
    if (binding) {
      for (objId in binding.bnd) {
        object = binding.bnd[objId];
        obsId = ".obs" + binding.cbId;
        if ($.isArray(object)) {
          $([object]).off(arrayChangeStr + obsId).off(propertyChangeStr + obsId); // There may be either or both of arrayChange and propertyChange
        } else {
          $(object).off(propertyChangeStr + obsId);
        }
        delete binding.bnd[objId];
      }

      linkCtx = binding.linkCtx;
      if (tag = linkCtx.tag) {
        if (tag.onDispose) {
          tag.onDispose();
        }
        if (!tag._elCnt) {
          tag._prv && tag._prv.parentNode.removeChild(tag._prv);
          tag._nxt && tag._nxt.parentNode.removeChild(tag._nxt);
        }
        tag.disposed = true;
      }
      delete linkCtx.view._.bnds[bindId];
      delete bindingStore[bindId];
      delete $viewsSub._cbBnds[binding.cbId];
    }
  }

  function $unlink(tmplOrLinkTag, to) {
    if (!arguments.length) {
      // Call to $.unlink() is equivalent to $.unlink(true, "body")
      if (activeBody) {
        $(activeBody).off(elementChangeStr, elemChangeHandler);
        activeBody = undefined;
      }
      tmplOrLinkTag = true;
      topView.removeViews();
      clean(document.body.getElementsByTagName("*"));
    } else if (to) {
      to = to.jquery ? to : $(to); // to is a jquery object or an element or selector
      if (tmplOrLinkTag === true) {
        // Call to $(el).unlink(true) - unlink content of element, but don't remove bindings on element itself
        $.each(to, function () {
          var innerView;
          //TODO fix this for better perf. Rather that calling inner view multiple times which does querySelectorAll each time, consider a single querySelectorAll
          // or simply call view.removeViews() on the top-level views under the target 'to' node, then clean(...)
          while ((innerView = $view(this, true)) && innerView.parent) {
            innerView.parent.removeViews(innerView._.key, undefined, true);
          }
          clean(this.getElementsByTagName("*"));
        });
      } else if (tmplOrLinkTag === undefined) {
        // Call to $(el).unlink()
        clean(to);
        //TODO provide this unlink API
        //			} else if ("" + tmplOrLinkTag === tmplOrLinkTag) {
        //				// Call to $(el).unlink(tmplOrLinkTag ...)
        //				$.each(to, function() {
        //					...
        //				});
      }
      //TODO - unlink the content and the arrayChange, but not any other bindings on the element (if container rather than "replace")
    }
    return to; // Allow chaining, to attach event handlers, etc.
  }

  function tmplUnlink(to, from) {
    return $unlink(this, to, from);
  }

  //========
  // Helpers
  //========

  function getContextCb(view) {
    // TODO Consider exposing or allowing override, as public API
    view = view || $.view();
    return function (path, object) {
      // TODO consider only calling the contextCb on the initial token in path '~a.b.c' and not calling again on
      // the individual tokens, 'a', 'b', 'c'...  Currently it is called multiple times
      var tokens, tag,
        items = [object];
      if (view && path) {
        if (path._jsvOb) {
          return path._jsvOb.call(view.tmpl, object, view, $views);
        }
        if (path.charAt(0) === "~") {
          // We return new items to insert into the sequence, replacing the "~a.b.c" string:
          // [helperObject 'a', "a.b.c" currentDataItem] so currentDataItem becomes the object for subsequent paths.
          if (path.slice(0, 4) === "~tag") {
            tag = view.ctx;
            if (path.charAt(4) === ".") {
              // "~tag.xxx"
              tokens = path.slice(5).split(".");
              tag = tag.tag;
            }
            if (tokens) {
              return tag ? [tag, tokens.join("."), object] : [];
            }
          }
          path = path.slice(1).split(".");
          if (object = view.hlp(path.shift())) {
            if (path.length) {
              items.unshift(path.join("."));
            }
            items.unshift(object);
          }
          return object ? items : [];
        }
        if (path.charAt(0) === "#") {
          // We return new items to insert into the sequence, replacing the "#a.b.c" string: [view, "a.b.c" currentDataItem]
          // so currentDataItem becomes the object for subsequent paths. The 'true' flag makes the paths bind only to leaf changes.
          return path === "#data" ? [] : [view, path.replace(rViewPath, ""), object];
        }
      }
    };
  }

  function inputAttrib(elem) {
    return elem.type === "checkbox" ? elem.checked : elem.value;
  }

  //========================== Initialize ==========================

  //=====================
  // JsRender integration
  //=====================

  $viewsSub.onStoreItem = function (store, name, item) {
    if (item && store === $templates) {
      item.link = tmplLink;
      item.unlink = tmplUnlink;
      if (name) {
        $.link[name] = function () {
          return tmplLink.apply(item, arguments);
        };
        $.unlink[name] = function () {
          return tmplUnlink.apply(item, arguments);
        };
      }
    }
  };

  // Initialize default delimiters
  ($viewsSettings.delimiters = function () {
    var delimChars = oldJsvDelimiters.apply($views, arguments);
    delimOpenChar0 = delimChars[0];
    delimOpenChar1 = delimChars[1];
    delimCloseChar0 = delimChars[2];
    delimCloseChar1 = delimChars[3];
    linkChar = delimChars[4];
    rTag = new RegExp("(?:^|\\s*)([\\w-]*)(\\" + linkChar + ")?(\\" + delimOpenChar1 + $viewsSub.rTag + "\\" + delimCloseChar0 + ")", "g");

    // Default rTag:      attr  bind tagExpr   tag         converter colon html     comment            code      params
    //          (?:^|\s*)([\w-]*)(\^)?({(?:(?:(\w+(?=[\/\s}]))|(?:(\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\*)))\s*((?:[^}]|}(?!}))*?))})
    return this;
  })();

  //===============
  // Public helpers
  //===============

  $viewsSub.viewInfos = viewInfos;
  // Expose viewInfos() as public helper method

  //====================================
  // Additional members for linked views
  //====================================

  function transferViewTokens(prevNode, nextNode, parentElem, id, viewOrTagChar, refresh) {
    // Transfer tokens on prevNode of viewToRemove/viewToRefresh to nextNode or parentElem._dfr
    var i, l, vwInfos, vwInfo, viewOrTag, viewId, tokens,
      precedingLength = 0,
      emptyView = prevNode === nextNode;

    if (prevNode) {
      // prevNode is either the first node in the viewOrTag, or has been replaced by the vwInfos tokens string
      vwInfos = viewInfos(prevNode) || [];
      for (i = 0, l = vwInfos.length; i < l; i++) {
        // Step through views or tags on the prevNode
        vwInfo = vwInfos[i];
        viewId = vwInfo.id;
        if (viewId === id && vwInfo.ch === viewOrTagChar) {
          if (refresh) {
            // This is viewOrTagToRefresh, this is the last viewOrTag to process...
            l = 0;
          } else {
            // This is viewOrTagToRemove, so we are done...
            break;
          }
        }
        if (!emptyView) {
          viewOrTag = vwInfo.ch === "_"
            ? viewStore[viewId]
            : bindingStore[viewId].linkCtx.tag;
          if (vwInfo.open) {
            // A "#m" token
            viewOrTag._prv = nextNode;
          } else if (vwInfo.close) {
            // A "/m" token
            viewOrTag._nxt = nextNode;
          }
        }
        precedingLength += viewId.length + 2;
      }

      if (precedingLength) {
        prevNode.setAttribute(jsvAttrStr, prevNode.getAttribute(jsvAttrStr).slice(precedingLength));
      }
      tokens = nextNode ? nextNode.getAttribute(jsvAttrStr) : parentElem._dfr;
      if (l = tokens.indexOf("/" + id + viewOrTagChar) + 1) {
        tokens = vwInfos.tokens.slice(0, precedingLength) + tokens.slice(l + (refresh ? -1 : id.length + 1));
      }
      if (tokens) {
        if (nextNode) {
          // If viewOrTagToRemove was an empty viewOrTag, we will remove both #n and /n
          // (and any intervening tokens) from the nextNode (=== prevNode)
          // If viewOrTagToRemove was not empty, we will take tokens preceding #n from prevNode,
          // and concatenate with tokens following /n on nextNode
          nextNode.setAttribute(jsvAttrStr, tokens);
        } else {
          parentElem._dfr = tokens;
        }
      }
    } else {
      // !prevNode, so there may be a deferred nodes token on the parentElem. Remove it.
      parentElem._dfr = removeSubStr(parentElem._dfr, "#" + id + viewOrTagChar);
      if (!refresh && !nextNode) {
        // If this viewOrTag is being removed, and there was no .nxt, remove closing token from deferred tokens
        parentElem._dfr = removeSubStr(parentElem._dfr, "/" + id + viewOrTagChar);
      }
    }
  }

  LinkedView = {
    // Note: a linked view will also, after linking have nodes[], _prv (prevNode), _nxt (nextNode) ...
    addViews: function (index, dataItems, tmpl) {
      // if view is not an array view, do nothing
      var i, viewsCount,
        self = this,
        itemsCount = dataItems.length,
        views = self.views;

      if (!self._.useKey && itemsCount && (tmpl = self.tmpl)) {
        // view is of type "array"
        // Use passed-in template if provided, since self added view may use a different template than the original one used to render the array.
        viewsCount = views.length + itemsCount;

        if (renderAndLink(self, index, tmpl, views, dataItems, self.ctx) !== false) {
          for (i = index + itemsCount; i < viewsCount; i++) {
            $observable(views[i]).setProperty("index", i);
            //This is fixing up index, but not key, and not index on child views. From child views, use view.get("item").index.
          }
        }
      }
      return self;
    },

    removeViews: function (index, itemsCount, keepNodes) {
      // view.removeViews() removes all the child views
      // view.removeViews( index ) removes the child view with specified index or key
      // view.removeViews( index, count ) removes the specified nummber of child views, starting with the specified index
      function removeView(index) {
        var id, bindId, parentElem, prevNode, nextNode, nodesToRemove,
          viewToRemove = views[index];

        if (viewToRemove && viewToRemove.link) {
          id = viewToRemove._.id;
          if (!keepNodes) {
            // Remove the HTML nodes from the DOM, unless they have already been removed, including nodes of child views
            nodesToRemove = viewToRemove.nodes();
          }

          // Remove child views, without removing nodes
          viewToRemove.removeViews(undefined, undefined, true);

          viewToRemove.data = undefined; // Set data to undefined: used as a flag that this view is being removed
          prevNode = viewToRemove._prv;
          nextNode = viewToRemove._nxt;
          parentElem = viewToRemove.parentElem;
          // If prevNode and nextNode are the same, the view is empty
          if (!keepNodes) {
            // Remove the HTML nodes from the DOM, unless they have already been removed, including nodes of child views
            if (viewToRemove._elCnt) {
              // if keepNodes is false (and transferring of tokens has not already been done at a higher level)
              // then transfer tokens from prevNode which is being removed, to nextNode.
              transferViewTokens(prevNode, nextNode, parentElem, id, "_");
            }
            $(nodesToRemove).remove();
          }
          if (!viewToRemove._elCnt) {
            prevNode.parentNode && parentElem.removeChild(prevNode);
            nextNode.parentNode && parentElem.removeChild(nextNode);
          }
          setArrayChangeLink(viewToRemove);
          for (bindId in viewToRemove._.bnds) {
            removeViewBinding(bindId);
          }
          delete viewStore[id];
        }
      }

      var current, view, viewsCount,
        self = this,
        isArray = !self._.useKey,
        views = self.views;

      if (isArray) {
        viewsCount = views.length;
      }
      if (index === undefined) {
        // Remove all child views
        if (isArray) {
          // views and data are arrays
          current = viewsCount;
          while (current--) {
            removeView(current);
          }
          self.views = [];
        } else {
          // views and data are objects
          for (view in views) {
            // Remove by key
            removeView(view);
          }
          self.views = {};
        }
      } else {
        if (itemsCount === undefined) {
          if (isArray) {
            // The parentView is data array view.
            // Set itemsCount to 1, to remove this item
            itemsCount = 1;
          } else {
            // Remove child view with key 'index'
            removeView(index);
            delete views[index];
          }
        }
        if (isArray && itemsCount) {
          current = index + itemsCount;
          // Remove indexed items (parentView is data array view);
          while (current-- > index) {
            removeView(current);
          }
          views.splice(index, itemsCount);
          if (viewsCount = views.length) {
            // Fixup index on following view items...
            while (index < viewsCount) {
              $observable(views[index]).setProperty("index", index++);
            }
          }
        }
      }
      return this;
    },

    refresh: function (context) {
      var self = this,
        parent = self.parent;

      if (parent) {
        renderAndLink(self, self.index, self.tmpl, parent.views, self.data, context, true);
        setArrayChangeLink(self);
      }
      return self;
    },

    nodes: getNodes,
    contents: getContents,
    childTags: getChildTags,
    link: viewLink
  };

  //=========================
  // Extend $.views.settings
  //=========================

  $viewsSettings.merge = {
    input: {
      from: { fromAttr: inputAttrib }, to: { toAttr: "value" }
    },
    textarea: valueBinding,
    select: valueBinding,
    optgroup: {
      from: { fromAttr: "label" }, to: { toAttr: "label" }
    }
  };

  if ($viewsSettings.debugMode) {
    // In debug mode create global for accessing views, etc
    validate = !$viewsSettings.noValidate;
    global._jsv = {
      views: viewStore,
      bindings: bindingStore
    };
  }

  //========================
  // Extend jQuery namespace
  //========================

  $extend($, {

    //=======================
    // jQuery $.view() plugin
    //=======================

    view: $views.view = $view = function (node, inner, type) {
      // $.view() returns top view
      // $.view(node) returns view that contains node
      // $.view(selector) returns view that contains first selected element
      // $.view(nodeOrSelector, type) returns nearest containing view of given type
      // $.view(nodeOrSelector, "root") returns root containing view (child of top view)
      // $.view(nodeOrSelector, true, type) returns nearest inner (contained) view of given type

      if (inner !== !!inner) {
        // inner not boolean, so this is view(nodeOrSelector, type)
        type = inner;
        inner = undefined;
      }
      var view, vwInfos, i, j, k, l, elem, elems,
        level = 0,
        body = document.body;

      if (node && node !== body && topView._.useKey > 1) {
        // Perf optimization for common cases

        node = "" + node === node
          ? $(node)[0]
          : node.jquery
            ? node[0]
            : node;

        if (node) {
          if (inner) {
            // Treat supplied node as a container element and return the first view encountered.
            elems = qsa ? node.querySelectorAll(bindElsSel) : $(bindElsSel, node).get();
            l = elems.length;
            for (i = 0; i < l; i++) {
              elem = elems[i];
              vwInfos = viewInfos(elem, undefined, rOpenViewMarkers);

              for (j = 0, k = vwInfos.length; j < k; j++) {
                view = vwInfos[j];
                if (view = viewStore[view.id]) {
                  view = view && type ? view.get(true, type) : view;
                  if (view) {
                    return view;
                  }
                }
              }
            }
          } else {
            while (node) {
              // Move back through siblings and up through parents to find preceding node which is a _prv (prevNode)
              // script marker node for a non-element-content view, or a _prv (first node) for an elCnt view
              if (vwInfos = viewInfos(node, undefined, rViewMarkers)) {
                l = vwInfos.length;
                while (l--) {
                  view = vwInfos[l];
                  if (view.open) {
                    if (level < 1) {
                      view = viewStore[view.id];
                      return view && type ? view.get(type) : view || topView;
                    }
                    level--;
                  } else {
                    // level starts at zero. If we hit a view.close, then we move level to 1, and we don't return a view until
                    // we are back at level zero (or a parent view with level < 0)
                    level++;
                  }
                }
              }
              node = node.previousSibling || node.parentNode;
            }
          }
        }
      }
      return inner ? undefined : topView;
    },

    link: $views.link = $link,
    unlink: $views.unlink = $unlink,

    //=====================
    // override $.cleanData
    //=====================
    cleanData: function (elems) {
      if (elems.length) {
        // Remove JsViews bindings. Also, remove from the DOM any corresponding script marker nodes
        clean(elems);
        // (elems HTMLCollection no longer includes removed script marker nodes)
        oldCleanData.call($, elems);
      }
    }
  });

  //===============================
  // Extend jQuery instance plugins
  //===============================

  $extend($.fn, {
    link: function (expr, from, context, parentView, prevNode, nextNode) {
      return $link(expr, this, from, context, parentView, prevNode, nextNode);
    },
    unlink: function (expr) {
      return $unlink(expr, this);
    },
    view: function (type) {
      return $view(this[0], type);
    }
  });

  //===============
  // Extend topView
  //===============

  $extend(topView, { tmpl: { links: {}, tags: {} } });
  $extend(topView, LinkedView);
  topView._.onRender = addBindingMarkers;

})(this, this.jQuery);

define("jsrender", function () { });

// jquery.royalslider v9.4.92
(function (l) {
  function t(b, f) {
    var c, g, a = this, e = navigator.userAgent.toLowerCase(); a.uid = l.rsModules.uid++; a.ns = ".rs" + a.uid; var d = document.createElement("div").style, j = ["webkit", "Moz", "ms", "O"], h = "", k = 0; for (c = 0; c < j.length; c++)g = j[c], !h && g + "Transform" in d && (h = g), g = g.toLowerCase(), window.requestAnimationFrame || (window.requestAnimationFrame = window[g + "RequestAnimationFrame"], window.cancelAnimationFrame = window[g + "CancelAnimationFrame"] || window[g + "CancelRequestAnimationFrame"]); window.requestAnimationFrame ||
      (window.requestAnimationFrame = function (a) { var b = (new Date).getTime(), c = Math.max(0, 16 - (b - k)), d = window.setTimeout(function () { a(b + c) }, c); k = b + c; return d }); window.cancelAnimationFrame || (window.cancelAnimationFrame = function (a) { clearTimeout(a) }); a.isIPAD = e.match(/(ipad)/); j = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || 0 > e.indexOf("compatible") && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || []; c = j[1] || ""; g = j[2] || "0";
    j = {}; c && (j[c] = !0, j.version = g); j.chrome && (j.webkit = !0); a._a = j; a.isAndroid = -1 < e.indexOf("android"); a.slider = l(b); a.ev = l(a); a._b = l(document); a.st = l.extend({}, l.fn.royalSlider.defaults, f); a._c = a.st.transitionSpeed; a._d = 0; if (a.st.allowCSS3 && (!j.webkit || a.st.allowCSS3OnWebkit)) e = h + (h ? "T" : "t"), a._e = e + "ransform" in d && e + "ransition" in d, a._e && (a._f = h + (h ? "P" : "p") + "erspective" in d); h = h.toLowerCase(); a._g = "-" + h + "-"; a._h = "vertical" === a.st.slidesOrientation ? !1 : !0; a._i = a._h ? "left" : "top"; a._j = a._h ? "width" : "height";
    a._k = -1; a._l = "fade" === a.st.transitionType ? !1 : !0; a._l || (a.st.sliderDrag = !1, a._m = 10); a._n = "z-index:0; display:none; opacity:0;"; a._o = 0; a._p = 0; a._q = 0; l.each(l.rsModules, function (b, c) { "uid" !== b && c.call(a) }); a.slides = []; a._r = 0; (a.st.slides ? l(a.st.slides) : a.slider.children().detach()).each(function () { a._s(this, !0) }); a.st.randomizeSlides && a.slides.sort(function () { return 0.5 - Math.random() }); a.numSlides = a.slides.length; a._t(); a.st.startSlideId ? a.st.startSlideId > a.numSlides - 1 && (a.st.startSlideId = a.numSlides -
      1) : a.st.startSlideId = 0; a._o = a.staticSlideId = a.currSlideId = a._u = a.st.startSlideId; a.currSlide = a.slides[a.currSlideId]; a._v = 0; a.msTouch = !1; a.slider.addClass((a._h ? "rsHor" : "rsVer") + (a._l ? "" : " rsFade")); d = '<div class="rsOverflow"><div class="rsContainer">'; a.slidesSpacing = a.st.slidesSpacing; a._w = (a._h ? a.slider.width() : a.slider.height()) + a.st.slidesSpacing; a._x = Boolean(0 < a._y); 1 >= a.numSlides && (a._z = !1); a._a1 = a._z && a._l ? 2 === a.numSlides ? 1 : 2 : 0; a._b1 = 6 > a.numSlides ? a.numSlides : 6; a._c1 = 0; a._d1 = 0; a.slidesJQ =
        []; for (c = 0; c < a.numSlides; c++)a.slidesJQ.push(l('<div style="' + (a._l ? "" : c !== a.currSlideId ? a._n : "z-index:0;") + '" class="rsSlide "></div>')); a._e1 = d = l(d + "</div></div>"); h = a.ns; a.msEnabled = window.navigator.msPointerEnabled; a.msEnabled ? (a.msTouch = Boolean(1 < window.navigator.msMaxTouchPoints), a.hasTouch = !1, a._n1 = 0.2, a._j1 = "MSPointerDown" + h, a._k1 = "MSPointerMove" + h, a._l1 = "MSPointerUp" + h, a._m1 = "MSPointerCancel" + h) : (a._j1 = "mousedown" + h, a._k1 = "mousemove" + h, a._l1 = "mouseup" + h, a._m1 = "mouseup" + h, "ontouchstart" in
          window || "createTouch" in document ? (a.hasTouch = !0, a._j1 += " touchstart" + h, a._k1 += " touchmove" + h, a._l1 += " touchend" + h, a._m1 += " touchcancel" + h, a._n1 = 0.5, a.st.sliderTouch && (a._f1 = !0)) : (a.hasTouch = !1, a._n1 = 0.2)); a.st.sliderDrag && (a._f1 = !0, j.msie || j.opera ? a._g1 = a._h1 = "pointer" : j.mozilla ? (a._g1 = "-moz-grab", a._h1 = "-moz-grabbing") : j.webkit && -1 != navigator.platform.indexOf("Mac") && (a._g1 = "-webkit-grab", a._h1 = "-webkit-grabbing"), a._i1()); a.slider.html(d); a._o1 = a.st.controlsInside ? a._e1 : a.slider; a._p1 = a._e1.children(".rsContainer");
    a.msEnabled && a._p1.css("-ms-touch-action", a._h ? "pan-y" : "pan-x"); a._q1 = l('<div class="rsPreloader"></div>'); d = a._p1.children(".rsSlide"); a._r1 = a.slidesJQ[a.currSlideId]; a._s1 = 0; a._e ? (a._t1 = "transition-property", a._u1 = "transition-duration", a._v1 = "transition-timing-function", a._w1 = a._x1 = a._g + "transform", a._f ? (j.webkit && !j.chrome && a.slider.addClass("rsWebkit3d"), /iphone|ipad|ipod/gi.test(navigator.appVersion), a._y1 = "translate3d(", a._z1 = "px, ", a._a2 = "px, 0px)") : (a._y1 = "translate(", a._z1 = "px, ", a._a2 = "px)"),
      a._l ? a._p1[a._g + a._t1] = a._g + "transform" : (h = {}, h[a._g + a._t1] = "opacity", h[a._g + a._u1] = a.st.transitionSpeed + "ms", h[a._g + a._v1] = a.st.css3easeInOut, d.css(h))) : (a._x1 = "left", a._w1 = "top"); var n; l(window).on("resize" + a.ns, function () { n && clearTimeout(n); n = setTimeout(function () { a.updateSliderSize() }, 50) }); a.ev.trigger("rsAfterPropsSetup"); a.updateSliderSize(); a.st.keyboardNavEnabled && a._b2(); if (a.st.arrowsNavHideOnTouch && (a.hasTouch || a.msTouch)) a.st.arrowsNav = !1; a.st.arrowsNav && (d = a._o1, l('<div class="rsArrow rsArrowLeft"><div class="rsArrowIcn"></div></div><div class="rsArrow rsArrowRight"><div class="rsArrowIcn"></div></div>').appendTo(d),
        a._c2 = d.children(".rsArrowLeft").click(function (b) { b.preventDefault(); a.prev() }), a._d2 = d.children(".rsArrowRight").click(function (b) { b.preventDefault(); a.next() }), a.st.arrowsNavAutoHide && !a.hasTouch && (a._c2.addClass("rsHidden"), a._d2.addClass("rsHidden"), d.one("mousemove.arrowshover", function () { a._c2.removeClass("rsHidden"); a._d2.removeClass("rsHidden") }), d.hover(function () { a._e2 || (a._c2.removeClass("rsHidden"), a._d2.removeClass("rsHidden")) }, function () { a._e2 || (a._c2.addClass("rsHidden"), a._d2.addClass("rsHidden")) })),
        a.ev.on("rsOnUpdateNav", function () { a._f2() }), a._f2()); if (a._f1) a._p1.on(a._j1, function (b) { a._g2(b) }); else a.dragSuccess = !1; var m = ["rsPlayBtnIcon", "rsPlayBtn", "rsCloseVideoBtn", "rsCloseVideoIcn"]; a._p1.click(function (b) { if (!a.dragSuccess) { var c = l(b.target).attr("class"); if (-1 !== l.inArray(c, m) && a.toggleVideo()) return !1; if (a.st.navigateByClick && !a._h2) { if (l(b.target).closest(".rsNoDrag", a._r1).length) return !0; a._i2(b) } a.ev.trigger("rsSlideClick") } }).on("click.rs", "a", function () {
          if (a.dragSuccess) return !1;
          a._h2 = !0; setTimeout(function () { a._h2 = !1 }, 3)
        }); a.ev.trigger("rsAfterInit")
  } l.rsModules || (l.rsModules = { uid: 0 }); t.prototype = {
    constructor: t, _i2: function (b) { b = b[this._h ? "pageX" : "pageY"] - this._j2; b >= this._q ? this.next() : 0 > b && this.prev() }, _t: function () {
      var b; b = this.st.numImagesToPreload; if (this._z = this.st.loop) 2 === this.numSlides ? (this._z = !1, this.st.loopRewind = !0) : 2 > this.numSlides && (this.st.loopRewind = this._z = !1); this._z && 0 < b && (4 >= this.numSlides ? b = 1 : this.st.numImagesToPreload > (this.numSlides - 1) / 2 && (b = Math.floor((this.numSlides -
        1) / 2))); this._y = b
    }, _s: function (b, f) {
      function c(a, b) { b ? e.images.push(a.attr(b)) : e.images.push(a.text()); if (j) { j = !1; e.caption = "src" === b ? a.attr("alt") : a.contents(); e.image = e.images[0]; e.videoURL = a.attr("data-rsVideo"); var c = a.attr("data-rsw"), d = a.attr("data-rsh"); "undefined" !== typeof c && !1 !== c && "undefined" !== typeof d && !1 !== d ? (e.iW = parseInt(c, 10), e.iH = parseInt(d, 10)) : g.st.imgWidth && g.st.imgHeight && (e.iW = g.st.imgWidth, e.iH = g.st.imgHeight) } } var g = this, a, e = {}, d, j = !0; b = l(b); g._k2 = b; g.ev.trigger("rsBeforeParseNode",
        [b, e]); if (!e.stopParsing) return b = g._k2, e.id = g._r, e.contentAdded = !1, g._r++, e.images = [], e.isBig = !1, e.hasCover || (b.hasClass("rsImg") ? (d = b, a = !0) : (d = b.find(".rsImg"), d.length && (a = !0)), a ? (e.bigImage = d.eq(0).attr("data-rsBigImg"), d.each(function () { var a = l(this); a.is("a") ? c(a, "href") : a.is("img") ? c(a, "src") : c(a) })) : b.is("img") && (b.addClass("rsImg rsMainSlideImage"), c(b, "src"))), d = b.find(".rsCaption"), d.length && (e.caption = d.remove()), e.content = b, g.ev.trigger("rsAfterParseNode", [b, e]), f && g.slides.push(e), 0 ===
          e.images.length && (e.isLoaded = !0, e.isRendered = !1, e.isLoading = !1, e.images = null), e
    }, _b2: function () { var b = this, f, c, g = function (a) { 37 === a ? b.prev() : 39 === a && b.next() }; b._b.on("keydown" + b.ns, function (a) { if (!b._l2 && (c = a.keyCode, (37 === c || 39 === c) && !f)) g(c), f = setInterval(function () { g(c) }, 700) }).on("keyup" + b.ns, function () { f && (clearInterval(f), f = null) }) }, goTo: function (b, f) { b !== this.currSlideId && this._m2(b, this.st.transitionSpeed, !0, !f) }, destroy: function (b) {
      this.ev.trigger("rsBeforeDestroy"); this._b.off("keydown" +
        this.ns + " keyup" + this.ns + " " + this._k1 + " " + this._l1); this._p1.off(this._j1 + " click"); this.slider.data("royalSlider", null); l.removeData(this.slider, "royalSlider"); l(window).off("resize" + this.ns); b && this.slider.remove(); this.ev = this.slider = this.slides = null
    }, _n2: function (b, f) {
      function c(c, e, f) { c.isAdded ? (g(e, c), a(e, c)) : (f || (f = d.slidesJQ[e]), c.holder ? f = c.holder : (f = d.slidesJQ[e] = l(f), c.holder = f), c.appendOnLoaded = !1, a(e, c, f), g(e, c), d._p2(c, f, b), c.isAdded = !0) } function g(a, c) {
        c.contentAdded || (d.setItemHtml(c,
          b), b || (c.contentAdded = !0))
      } function a(a, b, c) { d._l && (c || (c = d.slidesJQ[a]), c.css(d._i, (a + d._d1 + p) * d._w)) } function e(a) { if (k) { if (a > n - 1) return e(a - n); if (0 > a) return e(n + a) } return a } var d = this, j, h, k = d._z, n = d.numSlides; if (!isNaN(f)) return e(f); var m = d.currSlideId, p, q = b ? Math.abs(d._o2 - d.currSlideId) >= d.numSlides - 1 ? 0 : 1 : d._y, r = Math.min(2, q), u = !1, t = !1, s; for (h = m; h < m + 1 + r; h++)if (s = e(h), (j = d.slides[s]) && (!j.isAdded || !j.positionSet)) { u = !0; break } for (h = m - 1; h > m - 1 - r; h--)if (s = e(h), (j = d.slides[s]) && (!j.isAdded || !j.positionSet)) {
        t =
        !0; break
      } if (u) for (h = m; h < m + q + 1; h++)s = e(h), p = Math.floor((d._u - (m - h)) / d.numSlides) * d.numSlides, (j = d.slides[s]) && c(j, s); if (t) for (h = m - 1; h > m - 1 - q; h--)s = e(h), p = Math.floor((d._u - (m - h)) / n) * n, (j = d.slides[s]) && c(j, s); if (!b) { r = e(m - q); m = e(m + q); q = r > m ? 0 : r; for (h = 0; h < n; h++)if (!(r > m && h > r - 1) && (h < q || h > m)) if ((j = d.slides[h]) && j.holder) j.holder.detach(), j.isAdded = !1 }
    }, setItemHtml: function (b, f) {
      var c = this, g = function () {
        if (b.images) {
          if (!b.isLoading) {
            var e, f; b.content.hasClass("rsImg") ? (e = b.content, f = !0) : e = b.content.find(".rsImg:not(img)");
            e && !e.is("img") && e.each(function () { var a = l(this), c = '<img class="rsImg" src="' + (a.is("a") ? a.attr("href") : a.text()) + '" />'; f ? b.content = l(c) : a.replaceWith(c) }); e = f ? b.content : b.content.find("img.rsImg"); h(); e.eq(0).addClass("rsMainSlideImage"); b.iW && b.iH && (b.isLoaded || c._q2(b), d()); b.isLoading = !0; if (b.isBig) l("<img />").on("load.rs error.rs", function () { l(this).off("load.rs error.rs"); a([this], !0) }).attr("src", b.image); else {
              b.loaded = []; b.numStartedLoad = 0; e = function () {
                l(this).off("load.rs error.rs"); b.loaded.push(this);
                b.loaded.length === b.numStartedLoad && a(b.loaded, !1)
              }; for (var g = 0; g < b.images.length; g++) { var j = l("<img />"); b.numStartedLoad++; j.on("load.rs error.rs", e).attr("src", b.images[g]) }
            }
          }
        } else b.isRendered = !0, b.isLoaded = !0, b.isLoading = !1, d(!0)
      }, a = function (a, c) {
        if (a.length) {
          var d = a[0]; if (c !== b.isBig) (d = b.holder.children()) && 1 < d.length && k(); else if (b.iW && b.iH) e(); else if (b.iW = d.width, b.iH = d.height, b.iW && b.iH) e(); else {
            var f = new Image; f.onload = function () {
              f.width ? (b.iW = f.width, b.iH = f.height, e()) : setTimeout(function () {
                f.width &&
                (b.iW = f.width, b.iH = f.height); e()
              }, 1E3)
            }; f.src = d.src
          }
        } else e()
      }, e = function () { b.isLoaded = !0; b.isLoading = !1; d(); k(); j() }, d = function () {
        if (!b.isAppended && c.ev) {
          var a = c.st.visibleNearby, d = b.id - c._o; if (!f && !b.appendOnLoaded && c.st.fadeinLoadedSlide && (0 === d || (a || c._r2 || c._l2) && (-1 === d || 1 === d))) a = { visibility: "visible", opacity: 0 }, a[c._g + "transition"] = "opacity 400ms ease-in-out", b.content.css(a), setTimeout(function () { b.content.css("opacity", 1) }, 16); b.holder.find(".rsPreloader").length ? b.holder.append(b.content) :
            b.holder.html(b.content); b.isAppended = !0; b.isLoaded && (c._q2(b), j()); b.sizeReady || (b.sizeReady = !0, setTimeout(function () { c.ev.trigger("rsMaybeSizeReady", b) }, 100))
        }
      }, j = function () { !b.loadedTriggered && c.ev && (b.isLoaded = b.loadedTriggered = !0, b.holder.trigger("rsAfterContentSet"), c.ev.trigger("rsAfterContentSet", b)) }, h = function () { c.st.usePreloader && b.holder.html(c._q1.clone()) }, k = function () { if (c.st.usePreloader) { var a = b.holder.find(".rsPreloader"); a.length && a.remove() } }; b.isLoaded ? d() : f ? !c._l && b.images &&
        b.iW && b.iH ? g() : (b.holder.isWaiting = !0, h(), b.holder.slideId = -99) : g()
    }, _p2: function (b) { this._p1.append(b.holder); b.appendOnLoaded = !1 }, _g2: function (b, f) {
      var c = this, g, a = "touchstart" === b.type; c._s2 = a; c.ev.trigger("rsDragStart"); if (l(b.target).closest(".rsNoDrag", c._r1).length) return c.dragSuccess = !1, !0; !f && c._r2 && (c._t2 = !0, c._u2()); c.dragSuccess = !1; if (c._l2) a && (c._v2 = !0); else {
        a && (c._v2 = !1); c._w2(); if (a) { var e = b.originalEvent.touches; if (e && 0 < e.length) g = e[0], 1 < e.length && (c._v2 = !0); else return } else b.preventDefault(),
          g = b, c.msEnabled && (g = g.originalEvent); c._l2 = !0; c._b.on(c._k1, function (a) { c._x2(a, f) }).on(c._l1, function (a) { c._y2(a, f) }); c._z2 = ""; c._a3 = !1; c._b3 = g.pageX; c._c3 = g.pageY; c._d3 = c._v = (!f ? c._h : c._e3) ? g.pageX : g.pageY; c._f3 = 0; c._g3 = 0; c._h3 = !f ? c._p : c._i3; c._j3 = (new Date).getTime(); if (a) c._e1.on(c._m1, function (a) { c._y2(a, f) })
      }
    }, _k3: function (b, f) {
      if (this._l3) {
        var c = this._m3, g = b.pageX - this._b3, a = b.pageY - this._c3, e = this._h3 + g, d = this._h3 + a, j = !f ? this._h : this._e3, e = j ? e : d, d = this._z2; this._a3 = !0; this._b3 = b.pageX; this._c3 =
          b.pageY; "x" === d && 0 !== g ? this._f3 = 0 < g ? 1 : -1 : "y" === d && 0 !== a && (this._g3 = 0 < a ? 1 : -1); d = j ? this._b3 : this._c3; g = j ? g : a; f ? e > this._n3 ? e = this._h3 + g * this._n1 : e < this._o3 && (e = this._h3 + g * this._n1) : this._z || (0 >= this.currSlideId && 0 < d - this._d3 && (e = this._h3 + g * this._n1), this.currSlideId >= this.numSlides - 1 && 0 > d - this._d3 && (e = this._h3 + g * this._n1)); this._h3 = e; 200 < c - this._j3 && (this._j3 = c, this._v = d); f ? this._q3(this._h3) : this._l && this._p3(this._h3)
      }
    }, _x2: function (b, f) {
      var c = this, g, a = "touchmove" === b.type; if (!c._s2 || a) {
        if (a) {
          if (c._r3) return;
          var e = b.originalEvent.touches; if (e) { if (1 < e.length) return; g = e[0] } else return
        } else g = b, c.msEnabled && (g = g.originalEvent); c._a3 || (c._e && (!f ? c._p1 : c._s3).css(c._g + c._u1, "0s"), function j() { c._l2 && (c._t3 = requestAnimationFrame(j), c._u3 && c._k3(c._u3, f)) }()); if (c._l3) b.preventDefault(), c._m3 = (new Date).getTime(), c._u3 = g; else if (e = !f ? c._h : c._e3, g = Math.abs(g.pageX - c._b3) - Math.abs(g.pageY - c._c3) - (e ? -7 : 7), 7 < g) { if (e) b.preventDefault(), c._z2 = "x"; else if (a) { c._v3(); return } c._l3 = !0 } else if (-7 > g) {
          if (e) {
            if (a) {
              c._v3();
              return
            }
          } else b.preventDefault(), c._z2 = "y"; c._l3 = !0
        }
      }
    }, _v3: function () { this._r3 = !0; this._a3 = this._l2 = !1; this._y2() }, _y2: function (b, f) {
      function c(a) { return 100 > a ? 100 : 500 < a ? 500 : a } function g(b, d) { if (a._l || f) j = (-a._u - a._d1) * a._w, h = Math.abs(a._p - j), a._c = h / d, b && (a._c += 250), a._c = c(a._c), a._x3(j, !1) } var a = this, e, d, j, h; d = "touchend" === b.type || "touchcancel" === b.type; if (!a._s2 || d) if (a._s2 = !1, a.ev.trigger("rsDragRelease"), a._u3 = null, a._l2 = !1, a._r3 = !1, a._l3 = !1, a._m3 = 0, cancelAnimationFrame(a._t3), a._a3 && (f ? a._q3(a._h3) :
        a._l && a._p3(a._h3)), a._b.off(a._k1).off(a._l1), d && a._e1.off(a._m1), a._i1(), !a._a3 && !a._v2 && f && a._w3) { var k = l(b.target).closest(".rsNavItem"); k.length && a.goTo(k.index()) } else {
          e = !f ? a._h : a._e3; if (!a._a3 || "y" === a._z2 && e || "x" === a._z2 && !e) if (!f && a._t2) { a._t2 = !1; if (a.st.navigateByClick) { a._i2(a.msEnabled ? b.originalEvent : b); a.dragSuccess = !0; return } a.dragSuccess = !0 } else { a._t2 = !1; a.dragSuccess = !1; return } else a.dragSuccess = !0; a._t2 = !1; a._z2 = ""; var n = a.st.minSlideOffset; d = d ? b.originalEvent.changedTouches[0] :
            a.msEnabled ? b.originalEvent : b; var m = e ? d.pageX : d.pageY, p = a._d3; d = a._v; var q = a.currSlideId, r = a.numSlides, u = e ? a._f3 : a._g3, t = a._z; Math.abs(m - p); e = m - d; d = (new Date).getTime() - a._j3; d = Math.abs(e) / d; if (0 === u || 1 >= r) g(!0, d); else {
              if (!t && !f) if (0 >= q) { if (0 < u) { g(!0, d); return } } else if (q >= r - 1 && 0 > u) { g(!0, d); return } if (f) {
                j = a._i3; if (j > a._n3) j = a._n3; else if (j < a._o3) j = a._o3; else {
                  n = d * d / 0.006; k = -a._i3; m = a._y3 - a._z3 + a._i3; 0 < e && n > k ? (k += a._z3 / (15 / (0.003 * (n / d))), d = d * k / n, n = k) : 0 > e && n > m && (m += a._z3 / (15 / (0.003 * (n / d))), d = d * m / n, n =
                    m); k = Math.max(Math.round(d / 0.003), 50); j += n * (0 > e ? -1 : 1); if (j > a._n3) { a._a4(j, k, !0, a._n3, 200); return } if (j < a._o3) { a._a4(j, k, !0, a._o3, 200); return }
                } a._a4(j, k, !0)
              } else p + n < m ? 0 > u ? g(!1, d) : a._m2("prev", c(Math.abs(a._p - (-a._u - a._d1 + 1) * a._w) / d), !1, !0, !0) : p - n > m ? 0 < u ? g(!1, d) : a._m2("next", c(Math.abs(a._p - (-a._u - a._d1 - 1) * a._w) / d), !1, !0, !0) : g(!1, d)
            }
      }
    }, _p3: function (b) { b = this._p = b; this._e ? this._p1.css(this._x1, this._y1 + (this._h ? b + this._z1 + 0 : 0 + this._z1 + b) + this._a2) : this._p1.css(this._h ? this._x1 : this._w1, b) }, updateSliderSize: function (b) {
      var f,
      c; if (this.st.autoScaleSlider) { var g = this.st.autoScaleSliderWidth, a = this.st.autoScaleSliderHeight; this.st.autoScaleHeight ? (f = this.slider.width(), f != this.width && (this.slider.css("height", f * (a / g)), f = this.slider.width()), c = this.slider.height()) : (c = this.slider.height(), c != this.height && (this.slider.css("width", c * (g / a)), c = this.slider.height()), f = this.slider.width()) } else f = this.slider.width(), c = this.slider.height(); if (b || f != this.width || c != this.height) {
        this.width = f; this.height = c; this._b4 = f; this._c4 = c; this.ev.trigger("rsBeforeSizeSet");
        this.ev.trigger("rsAfterSizePropSet"); this._e1.css({ width: this._b4, height: this._c4 }); this._w = (this._h ? this._b4 : this._c4) + this.st.slidesSpacing; this._d4 = this.st.imageScalePadding; for (f = 0; f < this.slides.length; f++)b = this.slides[f], b.positionSet = !1, b && (b.images && b.isLoaded) && (b.isRendered = !1, this._q2(b)); if (this._e4) for (f = 0; f < this._e4.length; f++)b = this._e4[f], b.holder.css(this._i, (b.id + this._d1) * this._w); this._n2(); this._l && (this._e && this._p1.css(this._g + "transition-duration", "0s"), this._p3((-this._u -
          this._d1) * this._w)); this.ev.trigger("rsOnUpdateNav")
      } this._j2 = this._e1.offset(); this._j2 = this._j2[this._i]
    }, appendSlide: function (b, f) { var c = this._s(b); if (isNaN(f) || f > this.numSlides) f = this.numSlides; this.slides.splice(f, 0, c); this.slidesJQ.splice(f, 0, '<div style="' + (this._l ? "position:absolute;" : this._n) + '" class="rsSlide"></div>'); f < this.currSlideId && this.currSlideId++; this.ev.trigger("rsOnAppendSlide", [c, f]); this._f4(f); f === this.currSlideId && this.ev.trigger("rsAfterSlideChange") }, removeSlide: function (b) {
      var f =
        this.slides[b]; f && (f.holder && f.holder.remove(), b < this.currSlideId && this.currSlideId--, this.slides.splice(b, 1), this.slidesJQ.splice(b, 1), this.ev.trigger("rsOnRemoveSlide", [b]), this._f4(b), b === this.currSlideId && this.ev.trigger("rsAfterSlideChange"))
    }, _f4: function () {
      var b = this, f = b.numSlides, f = 0 >= b._u ? 0 : Math.floor(b._u / f); b.numSlides = b.slides.length; 0 === b.numSlides ? (b.currSlideId = b._d1 = b._u = 0, b.currSlide = b._g4 = null) : b._u = f * b.numSlides + b.currSlideId; for (f = 0; f < b.numSlides; f++)b.slides[f].id = f; b.currSlide =
        b.slides[b.currSlideId]; b._r1 = b.slidesJQ[b.currSlideId]; b.currSlideId >= b.numSlides ? b.goTo(b.numSlides - 1) : 0 > b.currSlideId && b.goTo(0); b._t(); b._l && b._z && b._p1.css(b._g + b._u1, "0ms"); b._h4 && clearTimeout(b._h4); b._h4 = setTimeout(function () { b._l && b._p3((-b._u - b._d1) * b._w); b._n2(); b._l || b._r1.css({ display: "block", opacity: 1 }) }, 14); b.ev.trigger("rsOnUpdateNav")
    }, _i1: function () { this._f1 && this._l && (this._g1 ? this._e1.css("cursor", this._g1) : (this._e1.removeClass("grabbing-cursor"), this._e1.addClass("grab-cursor"))) },
    _w2: function () { this._f1 && this._l && (this._h1 ? this._e1.css("cursor", this._h1) : (this._e1.removeClass("grab-cursor"), this._e1.addClass("grabbing-cursor"))) }, next: function (b) { this._m2("next", this.st.transitionSpeed, !0, !b) }, prev: function (b) { this._m2("prev", this.st.transitionSpeed, !0, !b) }, _m2: function (b, f, c, g, a) {
      var e = this, d, j, h; e.ev.trigger("rsBeforeMove", [b, g]); h = "next" === b ? e.currSlideId + 1 : "prev" === b ? e.currSlideId - 1 : b = parseInt(b, 10); if (!e._z) {
        if (0 > h) { e._i4("left", !g); return } if (h >= e.numSlides) {
          e._i4("right",
            !g); return
        }
      } e._r2 && (e._u2(!0), c = !1); j = h - e.currSlideId; h = e._o2 = e.currSlideId; var k = e.currSlideId + j; g = e._u; var l; e._z ? (k = e._n2(!1, k), g += j) : g = k; e._o = k; e._g4 = e.slidesJQ[e.currSlideId]; e._u = g; e.currSlideId = e._o; e.currSlide = e.slides[e.currSlideId]; e._r1 = e.slidesJQ[e.currSlideId]; var k = e.st.slidesDiff, m = Boolean(0 < j); j = Math.abs(j); var p = Math.floor(h / e._y), q = Math.floor((h + (m ? k : -k)) / e._y), p = (m ? Math.max(p, q) : Math.min(p, q)) * e._y + (m ? e._y - 1 : 0); p > e.numSlides - 1 ? p = e.numSlides - 1 : 0 > p && (p = 0); h = m ? p - h : h - p; h > e._y && (h = e._y);
      if (j > h + k) { e._d1 += (j - (h + k)) * (m ? -1 : 1); f *= 1.4; for (h = 0; h < e.numSlides; h++)e.slides[h].positionSet = !1 } e._c = f; e._n2(!0); a || (l = !0); d = (-g - e._d1) * e._w; l ? setTimeout(function () { e._j4 = !1; e._x3(d, b, !1, c); e.ev.trigger("rsOnUpdateNav") }, 0) : (e._x3(d, b, !1, c), e.ev.trigger("rsOnUpdateNav"))
    }, _f2: function () {
      this.st.arrowsNav && (1 >= this.numSlides ? (this._c2.css("display", "none"), this._d2.css("display", "none")) : (this._c2.css("display", "block"), this._d2.css("display", "block"), !this._z && !this.st.loopRewind && (0 === this.currSlideId ?
        this._c2.addClass("rsArrowDisabled") : this._c2.removeClass("rsArrowDisabled"), this.currSlideId === this.numSlides - 1 ? this._d2.addClass("rsArrowDisabled") : this._d2.removeClass("rsArrowDisabled"))))
    }, _x3: function (b, f, c, g, a) {
      function e() { var a; if (j && (a = j.data("rsTimeout"))) j !== h && j.css({ opacity: 0, display: "none", zIndex: 0 }), clearTimeout(a), j.data("rsTimeout", ""); if (a = h.data("rsTimeout")) clearTimeout(a), h.data("rsTimeout", "") } var d = this, j, h, k = {}; isNaN(d._c) && (d._c = 400); d._p = d._h3 = b; d.ev.trigger("rsBeforeAnimStart");
      d._e ? d._l ? (d._c = parseInt(d._c, 10), c = d._g + d._v1, k[d._g + d._u1] = d._c + "ms", k[c] = g ? l.rsCSS3Easing[d.st.easeInOut] : l.rsCSS3Easing[d.st.easeOut], d._p1.css(k), g || !d.hasTouch ? setTimeout(function () { d._p3(b) }, 5) : d._p3(b)) : (d._c = d.st.transitionSpeed, j = d._g4, h = d._r1, h.data("rsTimeout") && h.css("opacity", 0), e(), j && j.data("rsTimeout", setTimeout(function () { k[d._g + d._u1] = "0ms"; k.zIndex = 0; k.display = "none"; j.data("rsTimeout", ""); j.css(k); setTimeout(function () { j.css("opacity", 0) }, 16) }, d._c + 60)), k.display = "block", k.zIndex =
        d._m, k.opacity = 0, k[d._g + d._u1] = "0ms", k[d._g + d._v1] = l.rsCSS3Easing[d.st.easeInOut], h.css(k), h.data("rsTimeout", setTimeout(function () { h.css(d._g + d._u1, d._c + "ms"); h.data("rsTimeout", setTimeout(function () { h.css("opacity", 1); h.data("rsTimeout", "") }, 20)) }, 20))) : d._l ? (k[d._h ? d._x1 : d._w1] = b + "px", d._p1.animate(k, d._c, g ? d.st.easeInOut : d.st.easeOut)) : (j = d._g4, h = d._r1, h.stop(!0, !0).css({ opacity: 0, display: "block", zIndex: d._m }), d._c = d.st.transitionSpeed, h.animate({ opacity: 1 }, d._c, d.st.easeInOut), e(), j && j.data("rsTimeout",
          setTimeout(function () { j.stop(!0, !0).css({ opacity: 0, display: "none", zIndex: 0 }) }, d._c + 60))); d._r2 = !0; d.loadingTimeout && clearTimeout(d.loadingTimeout); d.loadingTimeout = a ? setTimeout(function () { d.loadingTimeout = null; a.call() }, d._c + 60) : setTimeout(function () { d.loadingTimeout = null; d._k4(f) }, d._c + 60)
    }, _u2: function (b) {
      this._r2 = !1; clearTimeout(this.loadingTimeout); if (this._l) if (this._e) { if (!b) { b = this._p; var f = this._h3 = this._l4(); this._p1.css(this._g + this._u1, "0ms"); b !== f && this._p3(f) } } else this._p1.stop(!0),
        this._p = parseInt(this._p1.css(this._x1), 10); else 20 < this._m ? this._m = 10 : this._m++
    }, _l4: function () { var b = window.getComputedStyle(this._p1.get(0), null).getPropertyValue(this._g + "transform").replace(/^matrix\(/i, "").split(/, |\)$/g), f = 0 === b[0].indexOf("matrix3d"); return parseInt(b[this._h ? f ? 12 : 4 : f ? 13 : 5], 10) }, _m4: function (b, f) { return this._e ? this._y1 + (f ? b + this._z1 + 0 : 0 + this._z1 + b) + this._a2 : b }, _k4: function () {
      this._l || (this._r1.css("z-index", 0), this._m = 10); this._r2 = !1; this.staticSlideId = this.currSlideId;
      this._n2(); this._n4 = !1; this.ev.trigger("rsAfterSlideChange")
    }, _i4: function (b, f) { var c = this, g = (-c._u - c._d1) * c._w; if (!(0 === c.numSlides || c._r2)) if (c.st.loopRewind) c.goTo("left" === b ? c.numSlides - 1 : 0, f); else if (c._l) { c._c = 200; var a = function () { c._r2 = !1 }; c._x3(g + ("left" === b ? 30 : -30), "", !1, !0, function () { c._r2 = !1; c._x3(g, "", !1, !0, a) }) } }, _q2: function (b) {
      if (!b.isRendered) {
        var f = b.content, c = "rsMainSlideImage", g, a = this.st.imageAlignCenter, e = this.st.imageScaleMode, d; b.videoURL && (c = "rsVideoContainer", "fill" !== e ? g =
          !0 : (d = f, d.hasClass(c) || (d = d.find("." + c)), d.css({ width: "100%", height: "100%" }), c = "rsMainSlideImage")); f.hasClass(c) || (f = f.find("." + c)); if (f) {
            var j = b.iW, c = b.iH; b.isRendered = !0; if ("none" !== e || a) {
              b = "fill" !== e ? this._d4 : 0; d = this._b4 - 2 * b; var h = this._c4 - 2 * b, k, l, m = {}; if ("fit-if-smaller" === e && (j > d || c > h)) e = "fit"; if ("fill" === e || "fit" === e) k = d / j, l = h / c, k = "fill" == e ? k > l ? k : l : "fit" == e ? k < l ? k : l : 1, j = Math.ceil(j * k, 10), c = Math.ceil(c * k, 10); "none" !== e && (m.width = j, m.height = c, g && f.find(".rsImg").css({ width: "100%", height: "100%" }));
              a && (m.marginLeft = Math.floor((d - j) / 2) + b, m.marginTop = Math.floor((h - c) / 2) + b); f.css(m)
            }
          }
      }
    }
  }; l.rsProto = t.prototype; l.fn.royalSlider = function (b) { var f = arguments; return this.each(function () { var c = l(this); if ("object" === typeof b || !b) c.data("royalSlider") || c.data("royalSlider", new t(c, b)); else if ((c = c.data("royalSlider")) && c[b]) return c[b].apply(c, Array.prototype.slice.call(f, 1)) }) }; l.fn.royalSlider.defaults = {
    slidesSpacing: 8, startSlideId: 0, loop: !1, loopRewind: !1, numImagesToPreload: 4, fadeinLoadedSlide: !0, slidesOrientation: "horizontal",
    transitionType: "move", transitionSpeed: 600, controlNavigation: "bullets", controlsInside: !0, arrowsNav: !0, arrowsNavAutoHide: !0, navigateByClick: !0, randomizeSlides: !1, sliderDrag: !0, sliderTouch: !0, keyboardNavEnabled: !1, fadeInAfterLoaded: !0, allowCSS3: !0, allowCSS3OnWebkit: !0, addActiveClass: !1, autoHeight: !1, easeOut: "easeOutSine", easeInOut: "easeInOutSine", minSlideOffset: 10, imageScaleMode: "fit-if-smaller", imageAlignCenter: !0, imageScalePadding: 4, usePreloader: !0, autoScaleSlider: !1, autoScaleSliderWidth: 800, autoScaleSliderHeight: 400,
    autoScaleHeight: !0, arrowsNavHideOnTouch: !1, globalCaption: !1, slidesDiff: 2
  }; l.rsCSS3Easing = { easeOutSine: "cubic-bezier(0.390, 0.575, 0.565, 1.000)", easeInOutSine: "cubic-bezier(0.445, 0.050, 0.550, 0.950)" }; l.extend(jQuery.easing, { easeInOutSine: function (b, f, c, g, a) { return -g / 2 * (Math.cos(Math.PI * f / a) - 1) + c }, easeOutSine: function (b, f, c, g, a) { return g * Math.sin(f / a * (Math.PI / 2)) + c }, easeOutCubic: function (b, f, c, g, a) { return g * ((f = f / a - 1) * f * f + 1) + c } })
})(jQuery, window);
// jquery.rs.active-class v1.0.1
(function (c) { c.rsProto._o4 = function () { var b, a = this; if (a.st.addActiveClass) a.ev.on("rsOnUpdateNav", function () { b && clearTimeout(b); b = setTimeout(function () { a._g4 && a._g4.removeClass("rsActiveSlide"); a._r1 && a._r1.addClass("rsActiveSlide"); b = null }, 50) }) }; c.rsModules.activeClass = c.rsProto._o4 })(jQuery);
// jquery.rs.animated-blocks v1.0.7
(function (j) {
  j.extend(j.rsProto, {
    _p4: function () {
      function l() { var g = a.currSlide; if (a.currSlide && a.currSlide.isLoaded && a._t4 !== g) { if (0 < a._s4.length) { for (b = 0; b < a._s4.length; b++)clearTimeout(a._s4[b]); a._s4 = [] } if (0 < a._r4.length) { var f; for (b = 0; b < a._r4.length; b++)if (f = a._r4[b]) a._e ? (f.block.css(a._g + a._u1, "0s"), f.block.css(f.css)) : f.block.stop(!0).css(f.css), a._t4 = null, g.animBlocksDisplayed = !1; a._r4 = [] } g.animBlocks && (g.animBlocksDisplayed = !0, a._t4 = g, a._u4(g.animBlocks)) } } var a = this, b; a._q4 = {
        fadeEffect: !0,
        moveEffect: "top", moveOffset: 20, speed: 400, easing: "easeOutSine", delay: 200
      }; a.st.block = j.extend({}, a._q4, a.st.block); a._r4 = []; a._s4 = []; a.ev.on("rsAfterInit", function () { l() }); a.ev.on("rsBeforeParseNode", function (a, b, d) { b = j(b); d.animBlocks = b.find(".rsABlock").css("display", "none"); d.animBlocks.length || (d.animBlocks = b.hasClass("rsABlock") ? b.css("display", "none") : !1) }); a.ev.on("rsAfterContentSet", function (b, f) { f.id === a.slides[a.currSlideId].id && setTimeout(function () { l() }, a.st.fadeinLoadedSlide ? 300 : 0) });
      a.ev.on("rsAfterSlideChange", function () { l() })
    }, _v4: function (j, a) { setTimeout(function () { j.css(a) }, 6) }, _u4: function (l) {
      var a = this, b, g, f, d, h, e, m; a._s4 = []; l.each(function (l) {
        b = j(this); g = {}; f = {}; d = null; var c = b.attr("data-move-offset"), c = c ? parseInt(c, 10) : a.st.block.moveOffset; if (0 < c && ((e = b.data("move-effect")) ? (e = e.toLowerCase(), "none" === e ? e = !1 : "left" !== e && ("top" !== e && "bottom" !== e && "right" !== e) && (e = a.st.block.moveEffect, "none" === e && (e = !1))) : e = a.st.block.moveEffect, e && "none" !== e)) {
          var n; n = "right" === e || "left" ===
            e ? !0 : !1; var k; m = !1; a._e ? (k = 0, h = a._x1) : (n ? isNaN(parseInt(b.css("right"), 10)) ? h = "left" : (h = "right", m = !0) : isNaN(parseInt(b.css("bottom"), 10)) ? h = "top" : (h = "bottom", m = !0), h = "margin-" + h, m && (c = -c), a._e ? k = parseInt(b.css(h), 10) : (k = b.data("rs-start-move-prop"), void 0 === k && (k = parseInt(b.css(h), 10), b.data("rs-start-move-prop", k)))); f[h] = a._m4("top" === e || "left" === e ? k - c : k + c, n); g[h] = a._m4(k, n)
        } if (c = b.attr("data-fade-effect")) { if ("none" === c.toLowerCase() || "false" === c.toLowerCase()) c = !1 } else c = a.st.block.fadeEffect;
        c && (f.opacity = 0, g.opacity = 1); if (c || e) d = {}, d.hasFade = Boolean(c), Boolean(e) && (d.moveProp = h, d.hasMove = !0), d.speed = b.data("speed"), isNaN(d.speed) && (d.speed = a.st.block.speed), d.easing = b.data("easing"), d.easing || (d.easing = a.st.block.easing), d.css3Easing = j.rsCSS3Easing[d.easing], d.delay = b.data("delay"), isNaN(d.delay) && (d.delay = a.st.block.delay * l); c = {}; a._e && (c[a._g + a._u1] = "0ms"); c.moveProp = g.moveProp; c.opacity = g.opacity; c.display = "none"; a._r4.push({ block: b, css: c }); a._v4(b, f); a._s4.push(setTimeout(function (b,
          d, c, e) { return function () { b.css("display", "block"); if (c) { var g = {}; if (a._e) { var f = ""; c.hasMove && (f += c.moveProp); c.hasFade && (c.hasMove && (f += ", "), f += "opacity"); g[a._g + a._t1] = f; g[a._g + a._u1] = c.speed + "ms"; g[a._g + a._v1] = c.css3Easing; b.css(g); setTimeout(function () { b.css(d) }, 24) } else setTimeout(function () { b.animate(d, c.speed, c.easing) }, 16) } delete a._s4[e] } }(b, g, d, l), 6 >= d.delay ? 12 : d.delay))
      })
    }
  }); j.rsModules.animatedBlocks = j.rsProto._p4
})(jQuery);
// jquery.rs.auto-height v1.0.2
(function (b) {
  b.extend(b.rsProto, {
    _w4: function () {
      var a = this; if (a.st.autoHeight) {
        var b, d, e, c = function (c) { e = a.slides[a.currSlideId]; if (b = e.holder) if ((d = b.height()) && void 0 !== d) a._c4 = d, a._e || !c ? a._e1.css("height", d) : a._e1.stop(!0, !0).animate({ height: d }, a.st.transitionSpeed) }; a.ev.on("rsMaybeSizeReady.rsAutoHeight", function (a, b) { e === b && c() }); a.ev.on("rsAfterContentSet.rsAutoHeight", function (a, b) { e === b && c() }); a.slider.addClass("rsAutoHeight"); a.ev.one("rsAfterInit", function () {
          setTimeout(function () {
            c(!1);
            setTimeout(function () { a.slider.append('<div style="clear:both; float: none;"></div>'); a._e && a._e1.css(a._g + "transition", "height " + a.st.transitionSpeed + "ms ease-in-out") }, 16)
          }, 16)
        }); a.ev.on("rsBeforeAnimStart", function () { c(!0) }); a.ev.on("rsBeforeSizeSet", function () { setTimeout(function () { c(!1) }, 16) })
      }
    }
  }); b.rsModules.autoHeight = b.rsProto._w4
})(jQuery);
// jquery.rs.autoplay v1.0.5
(function (b) {
  b.extend(b.rsProto, {
    _x4: function () {
      var a = this, d; a._y4 = { enabled: !1, stopAtAction: !0, pauseOnHover: !0, delay: 2E3 }; !a.st.autoPlay && a.st.autoplay && (a.st.autoPlay = a.st.autoplay); a.st.autoPlay = b.extend({}, a._y4, a.st.autoPlay); a.st.autoPlay.enabled && (a.ev.on("rsBeforeParseNode", function (a, c, f) { c = b(c); if (d = c.attr("data-rsDelay")) f.customDelay = parseInt(d, 10) }), a.ev.one("rsAfterInit", function () { a._z4() }), a.ev.on("rsBeforeDestroy", function () {
        a.stopAutoPlay(); a.slider.off("mouseenter mouseleave"); b(window).off("blur" +
          a.ns + " focus" + a.ns)
      }))
    }, _z4: function () {
      var a = this; a.startAutoPlay(); a.ev.on("rsAfterContentSet", function (b, e) { !a._l2 && (!a._r2 && a._a5 && e === a.currSlide) && a._b5() }); a.ev.on("rsDragRelease", function () { a._a5 && a._c5 && (a._c5 = !1, a._b5()) }); a.ev.on("rsAfterSlideChange", function () { a._a5 && a._c5 && (a._c5 = !1, a.currSlide.isLoaded && a._b5()) }); a.ev.on("rsDragStart", function () { a._a5 && (a.st.autoPlay.stopAtAction ? a.stopAutoPlay() : (a._c5 = !0, a._d5())) }); a.ev.on("rsBeforeMove", function (b, e, c) {
        a._a5 && (c && a.st.autoPlay.stopAtAction ?
          a.stopAutoPlay() : (a._c5 = !0, a._d5()))
      }); a._e5 = !1; a.ev.on("rsVideoStop", function () { a._a5 && (a._e5 = !1, a._b5()) }); a.ev.on("rsVideoPlay", function () { a._a5 && (a._c5 = !1, a._d5(), a._e5 = !0) }); b(window).on("blur" + a.ns, function () { a._a5 && (a._c5 = !0, a._d5()) }).on("focus" + a.ns, function () { a._a5 && a._c5 && (a._c5 = !1, a._b5()) }); a.st.autoPlay.pauseOnHover && (a._f5 = !1, a.slider.hover(function () { a._a5 && (a._c5 = !1, a._d5(), a._f5 = !0) }, function () { a._a5 && (a._f5 = !1, a._b5()) }))
    }, toggleAutoPlay: function () {
      this._a5 ? this.stopAutoPlay() :
      this.startAutoPlay()
    }, startAutoPlay: function () { this._a5 = !0; this.currSlide.isLoaded && this._b5() }, stopAutoPlay: function () { this._e5 = this._f5 = this._c5 = this._a5 = !1; this._d5() }, _b5: function () { var a = this; !a._f5 && !a._e5 && (a._g5 = !0, a._h5 && clearTimeout(a._h5), a._h5 = setTimeout(function () { var b; !a._z && !a.st.loopRewind && (b = !0, a.st.loopRewind = !0); a.next(!0); b && (a.st.loopRewind = !1) }, !a.currSlide.customDelay ? a.st.autoPlay.delay : a.currSlide.customDelay)) }, _d5: function () {
      !this._f5 && !this._e5 && (this._g5 = !1, this._h5 &&
        (clearTimeout(this._h5), this._h5 = null))
    }
  }); b.rsModules.autoplay = b.rsProto._x4
})(jQuery);
// jquery.rs.bullets v1.0.1
(function (c) {
  c.extend(c.rsProto, {
    _i5: function () {
      var a = this; "bullets" === a.st.controlNavigation && (a.ev.one("rsAfterPropsSetup", function () { a._j5 = !0; a.slider.addClass("rsWithBullets"); for (var b = '<div class="rsNav rsBullets">', e = 0; e < a.numSlides; e++)b += '<div class="rsNavItem rsBullet"><span></span></div>'; a._k5 = b = c(b + "</div>"); a._l5 = b.appendTo(a.slider).children(); a._k5.on("click.rs", ".rsNavItem", function () { a._m5 || a.goTo(c(this).index()) }) }), a.ev.on("rsOnAppendSlide", function (b, c, d) {
        d >= a.numSlides ? a._k5.append('<div class="rsNavItem rsBullet"><span></span></div>') :
        a._l5.eq(d).before('<div class="rsNavItem rsBullet"><span></span></div>'); a._l5 = a._k5.children()
      }), a.ev.on("rsOnRemoveSlide", function (b, c) { var d = a._l5.eq(c); d && d.length && (d.remove(), a._l5 = a._k5.children()) }), a.ev.on("rsOnUpdateNav", function () { var b = a.currSlideId; a._n5 && a._n5.removeClass("rsNavSelected"); b = a._l5.eq(b); b.addClass("rsNavSelected"); a._n5 = b }))
    }
  }); c.rsModules.bullets = c.rsProto._i5
})(jQuery);
// jquery.rs.deeplinking v1.0.6 + jQuery hashchange plugin v1.3 Copyright (c) 2010 Ben Alman
(function (b) {
  b.extend(b.rsProto, {
    _o5: function () {
      var a = this, g, c, e; a._p5 = { enabled: !1, change: !1, prefix: "" }; a.st.deeplinking = b.extend({}, a._p5, a.st.deeplinking); if (a.st.deeplinking.enabled) {
        var h = a.st.deeplinking.change, d = "#" + a.st.deeplinking.prefix, f = function () { var a = window.location.hash; return a && (a = parseInt(a.substring(d.length), 10), 0 <= a) ? a - 1 : -1 }, j = f(); -1 !== j && (a.st.startSlideId = j); h && (b(window).on("hashchange" + a.ns, function () { if (!g) { var b = f(); 0 > b || (b > a.numSlides - 1 && (b = a.numSlides - 1), a.goTo(b)) } }),
          a.ev.on("rsBeforeAnimStart", function () { c && clearTimeout(c); e && clearTimeout(e) }), a.ev.on("rsAfterSlideChange", function () { c && clearTimeout(c); e && clearTimeout(e); e = setTimeout(function () { g = !0; window.location.replace(("" + window.location).split("#")[0] + d + (a.currSlideId + 1)); c = setTimeout(function () { g = !1; c = null }, 60) }, 400) })); a.ev.on("rsBeforeDestroy", function () { c = e = null; h && b(window).off("hashchange" + a.ns) })
      }
    }
  }); b.rsModules.deeplinking = b.rsProto._o5
})(jQuery);
(function (b, a, g) {
  function c(a) { a = a || location.href; return "#" + a.replace(/^[^#]*#?(.*)$/, "$1") } "$:nomunge"; var e = document, h, d = b.event.special, f = e.documentMode, j = "onhashchange" in a && (f === g || 7 < f); b.fn.hashchange = function (a) { return a ? this.bind("hashchange", a) : this.trigger("hashchange") }; b.fn.hashchange.delay = 50; d.hashchange = b.extend(d.hashchange, { setup: function () { if (j) return !1; b(h.start) }, teardown: function () { if (j) return !1; b(h.stop) } }); var p = function () {
    var e = c(), d = r(n); e !== n ? (q(n = e, d), b(a).trigger("hashchange")) :
      d !== n && (location.href = location.href.replace(/#.*/, "") + d); l = setTimeout(p, b.fn.hashchange.delay)
  }, d = {}, l, n = c(), q = f = function (a) { return a }, r = f; d.start = function () { l || p() }; d.stop = function () { l && clearTimeout(l); l = g }; if (a.attachEvent && !a.addEventListener && !j) {
    var k, m; d.start = function () {
      k || (m = (m = b.fn.hashchange.src) && m + c(), k = b('<iframe tabindex="-1" title="empty"/>').hide().one("load", function () { m || q(c()); p() }).attr("src", m || "javascript:0").insertAfter("body")[0].contentWindow, e.onpropertychange = function () {
        try {
          "title" ===
          event.propertyName && (k.document.title = e.title)
        } catch (a) { }
      })
    }; d.stop = f; r = function () { return c(k.location.href) }; q = function (a, d) { var c = k.document, f = b.fn.hashchange.domain; a !== d && (c.title = e.title, c.open(), f && c.write('<script>document.domain="' + f + '"\x3c/script>'), c.close(), k.location.hash = a) }
  } h = d
})(jQuery, this);
// jquery.rs.fullscreen v1.0.5
(function (c) {
  c.extend(c.rsProto, {
    _q5: function () { var a = this; a._r5 = { enabled: !1, keyboardNav: !0, buttonFS: !0, nativeFS: !1, doubleTap: !0 }; a.st.fullscreen = c.extend({}, a._r5, a.st.fullscreen); if (a.st.fullscreen.enabled) a.ev.one("rsBeforeSizeSet", function () { a._s5() }) }, _s5: function () {
      var a = this; a._t5 = !a.st.keyboardNavEnabled && a.st.fullscreen.keyboardNav; if (a.st.fullscreen.nativeFS) {
        a._u5 = {
          supportsFullScreen: !1, isFullScreen: function () { return !1 }, requestFullScreen: function () { }, cancelFullScreen: function () { }, fullScreenEventName: "",
          prefix: ""
        }; var b = ["webkit", "moz", "o", "ms", "khtml"]; if (!a.isAndroid) if ("undefined" != typeof document.cancelFullScreen) a._u5.supportsFullScreen = !0; else for (var d = 0; d < b.length; d++)if (a._u5.prefix = b[d], "undefined" != typeof document[a._u5.prefix + "CancelFullScreen"]) { a._u5.supportsFullScreen = !0; break } a._u5.supportsFullScreen ? (a.nativeFS = !0, a._u5.fullScreenEventName = a._u5.prefix + "fullscreenchange" + a.ns, a._u5.isFullScreen = function () {
          switch (this.prefix) {
            case "": return document.fullScreen; case "webkit": return document.webkitIsFullScreen;
            default: return document[this.prefix + "FullScreen"]
          }
        }, a._u5.requestFullScreen = function (a) { return "" === this.prefix ? a.requestFullScreen() : a[this.prefix + "RequestFullScreen"]() }, a._u5.cancelFullScreen = function () { return "" === this.prefix ? document.cancelFullScreen() : document[this.prefix + "CancelFullScreen"]() }) : a._u5 = !1
      } a.st.fullscreen.buttonFS && (a._v5 = c('<div class="rsFullscreenBtn"><div class="rsFullscreenIcn"></div></div>').appendTo(a._o1).on("click.rs", function () { a.isFullscreen ? a.exitFullscreen() : a.enterFullscreen() }))
    },
    enterFullscreen: function (a) {
      var b = this; if (b._u5) if (a) b._u5.requestFullScreen(c("html")[0]); else { b._b.on(b._u5.fullScreenEventName, function () { b._u5.isFullScreen() ? b.enterFullscreen(!0) : b.exitFullscreen(!0) }); b._u5.requestFullScreen(c("html")[0]); return } if (!b._w5) {
        b._w5 = !0; b._b.on("keyup" + b.ns + "fullscreen", function (a) { 27 === a.keyCode && b.exitFullscreen() }); b._t5 && b._b2(); a = c(window); b._x5 = a.scrollTop(); b._y5 = a.scrollLeft(); b._z5 = c("html").attr("style"); b._a6 = c("body").attr("style"); b._b6 = b.slider.attr("style");
        c("body, html").css({ overflow: "hidden", height: "100%", width: "100%", margin: "0", padding: "0" }); b.slider.addClass("rsFullscreen"); var d; for (d = 0; d < b.numSlides; d++)a = b.slides[d], a.isRendered = !1, a.bigImage && (a.isBig = !0, a.isMedLoaded = a.isLoaded, a.isMedLoading = a.isLoading, a.medImage = a.image, a.medIW = a.iW, a.medIH = a.iH, a.slideId = -99, a.bigImage !== a.medImage && (a.sizeType = "big"), a.isLoaded = a.isBigLoaded, a.isLoading = !1, a.image = a.bigImage, a.images[0] = a.bigImage, a.iW = a.bigIW, a.iH = a.bigIH, a.isAppended = a.contentAdded =
          !1, b._c6(a)); b.isFullscreen = !0; b._w5 = !1; b.updateSliderSize(); b.ev.trigger("rsEnterFullscreen")
      }
    }, exitFullscreen: function (a) {
      var b = this; if (b._u5) { if (!a) { b._u5.cancelFullScreen(c("html")[0]); return } b._b.off(b._u5.fullScreenEventName) } if (!b._w5) {
        b._w5 = !0; b._b.off("keyup" + b.ns + "fullscreen"); b._t5 && b._b.off("keydown" + b.ns); c("html").attr("style", b._z5 || ""); c("body").attr("style", b._a6 || ""); var d; for (d = 0; d < b.numSlides; d++)a = b.slides[d], a.isRendered = !1, a.bigImage && (a.isBig = !1, a.slideId = -99, a.isBigLoaded =
          a.isLoaded, a.isBigLoading = a.isLoading, a.bigImage = a.image, a.bigIW = a.iW, a.bigIH = a.iH, a.isLoaded = a.isMedLoaded, a.isLoading = !1, a.image = a.medImage, a.images[0] = a.medImage, a.iW = a.medIW, a.iH = a.medIH, a.isAppended = a.contentAdded = !1, b._c6(a, !0), a.bigImage !== a.medImage && (a.sizeType = "med")); b.isFullscreen = !1; a = c(window); a.scrollTop(b._x5); a.scrollLeft(b._y5); b._w5 = !1; b.slider.removeClass("rsFullscreen"); b.updateSliderSize(); setTimeout(function () { b.updateSliderSize() }, 1); b.ev.trigger("rsExitFullscreen")
      }
    }, _c6: function (a) {
      var b =
        !a.isLoaded && !a.isLoading ? '<a class="rsImg rsMainSlideImage" href="' + a.image + '"></a>' : '<img class="rsImg rsMainSlideImage" src="' + a.image + '"/>'; a.content.hasClass("rsImg") ? a.content = c(b) : a.content.find(".rsImg").eq(0).replaceWith(b); !a.isLoaded && (!a.isLoading && a.holder) && a.holder.html(a.content)
    }
  }); c.rsModules.fullscreen = c.rsProto._q5
})(jQuery);
// jquery.rs.global-caption v1.0
(function (b) { b.extend(b.rsProto, { _d6: function () { var a = this; a.st.globalCaption && (a.ev.on("rsAfterInit", function () { a.globalCaption = b('<div class="rsGCaption"></div>').appendTo(!a.st.globalCaptionInside ? a.slider : a._e1); a.globalCaption.html(a.currSlide.caption) }), a.ev.on("rsBeforeAnimStart", function () { a.globalCaption.html(a.currSlide.caption) })) } }); b.rsModules.globalCaption = b.rsProto._d6 })(jQuery);
// jquery.rs.nav-auto-hide v1.0
(function (b) { b.extend(b.rsProto, { _e6: function () { var a = this; if (a.st.navAutoHide && !a.hasTouch) a.ev.one("rsAfterInit", function () { if (a._k5) { a._k5.addClass("rsHidden"); var b = a.slider; b.one("mousemove.controlnav", function () { a._k5.removeClass("rsHidden") }); b.hover(function () { a._k5.removeClass("rsHidden") }, function () { a._k5.addClass("rsHidden") }) } }) } }); b.rsModules.autoHideNav = b.rsProto._e6 })(jQuery);
// jquery.rs.tabs v1.0.2
(function (e) {
  e.extend(e.rsProto, {
    _f6: function () {
      var a = this; "tabs" === a.st.controlNavigation && (a.ev.on("rsBeforeParseNode", function (a, d, b) { d = e(d); b.thumbnail = d.find(".rsTmb").remove(); b.thumbnail.length ? b.thumbnail = e(document.createElement("div")).append(b.thumbnail).html() : (b.thumbnail = d.attr("data-rsTmb"), b.thumbnail || (b.thumbnail = d.find(".rsImg").attr("data-rsTmb")), b.thumbnail = b.thumbnail ? '<img src="' + b.thumbnail + '"/>' : "") }), a.ev.one("rsAfterPropsSetup", function () { a._g6() }), a.ev.on("rsOnAppendSlide",
        function (c, d, b) { b >= a.numSlides ? a._k5.append('<div class="rsNavItem rsTab">' + d.thumbnail + "</div>") : a._l5.eq(b).before('<div class="rsNavItem rsTab">' + item.thumbnail + "</div>"); a._l5 = a._k5.children() }), a.ev.on("rsOnRemoveSlide", function (c, d) { var b = a._l5.eq(d); b && (b.remove(), a._l5 = a._k5.children()) }), a.ev.on("rsOnUpdateNav", function () { var c = a.currSlideId; a._n5 && a._n5.removeClass("rsNavSelected"); c = a._l5.eq(c); c.addClass("rsNavSelected"); a._n5 = c }))
    }, _g6: function () {
      var a = this, c; a._j5 = !0; c = '<div class="rsNav rsTabs">';
      for (var d = 0; d < a.numSlides; d++)c += '<div class="rsNavItem rsTab">' + a.slides[d].thumbnail + "</div>"; c = e(c + "</div>"); a._k5 = c; a._l5 = c.children(".rsNavItem"); a.slider.append(c); a._k5.click(function (b) { b = e(b.target).closest(".rsNavItem"); b.length && a.goTo(b.index()) })
    }
  }); e.rsModules.tabs = e.rsProto._f6
})(jQuery);
// jquery.rs.thumbnails v1.0.5
(function (f) {
  f.extend(f.rsProto, {
    _h6: function () {
      var a = this; "thumbnails" === a.st.controlNavigation && (a._i6 = { drag: !0, touch: !0, orientation: "horizontal", navigation: !0, arrows: !0, arrowLeft: null, arrowRight: null, spacing: 4, arrowsAutoHide: !1, appendSpan: !1, transitionSpeed: 600, autoCenter: !0, fitInViewport: !0, firstMargin: !0, paddingTop: 0, paddingBottom: 0 }, a.st.thumbs = f.extend({}, a._i6, a.st.thumbs), a._j6 = !0, !1 === a.st.thumbs.firstMargin ? a.st.thumbs.firstMargin = 0 : !0 === a.st.thumbs.firstMargin && (a.st.thumbs.firstMargin =
        a.st.thumbs.spacing), a.ev.on("rsBeforeParseNode", function (a, c, b) { c = f(c); b.thumbnail = c.find(".rsTmb").remove(); b.thumbnail.length ? b.thumbnail = f(document.createElement("div")).append(b.thumbnail).html() : (b.thumbnail = c.attr("data-rsTmb"), b.thumbnail || (b.thumbnail = c.find(".rsImg").attr("data-rsTmb")), b.thumbnail = b.thumbnail ? '<img src="' + b.thumbnail + '"/>' : "") }), a.ev.one("rsAfterPropsSetup", function () { a._k6() }), a._n5 = null, a.ev.on("rsOnUpdateNav", function () {
          var e = f(a._l5[a.currSlideId]); e !== a._n5 && (a._n5 &&
            (a._n5.removeClass("rsNavSelected"), a._n5 = null), a._l6 && a._m6(a.currSlideId), a._n5 = e.addClass("rsNavSelected"))
        }), a.ev.on("rsOnAppendSlide", function (e, c, b) { e = "<div" + a._n6 + ' class="rsNavItem rsThumb">' + a._o6 + c.thumbnail + "</div>"; b >= a.numSlides ? a._s3.append(e) : a._l5.eq(b).before(e); a._l5 = a._s3.children(); a.updateThumbsSize() }), a.ev.on("rsOnRemoveSlide", function (e, c) { var b = a._l5.eq(c); b && (b.remove(), a._l5 = a._s3.children(), a.updateThumbsSize()) }))
    }, _k6: function () {
      var a = this, e = "rsThumbs", c = a.st.thumbs,
      b = "", g, d, h = c.spacing; a._j5 = !0; a._e3 = "vertical" === c.orientation ? !1 : !0; a._n6 = g = h ? ' style="margin-' + (a._e3 ? "right" : "bottom") + ":" + h + 'px;"' : ""; a._i3 = 0; a._p6 = !1; a._m5 = !1; a._l6 = !1; a._q6 = c.arrows && c.navigation; d = a._e3 ? "Hor" : "Ver"; a.slider.addClass("rsWithThumbs rsWithThumbs" + d); b += '<div class="rsNav rsThumbs rsThumbs' + d + '"><div class="' + e + 'Container">'; a._o6 = c.appendSpan ? '<span class="thumbIco"></span>' : ""; for (var j = 0; j < a.numSlides; j++)d = a.slides[j], b += "<div" + g + ' class="rsNavItem rsThumb">' + d.thumbnail + a._o6 +
        "</div>"; b = f(b + "</div></div>"); g = {}; c.paddingTop && (g[a._e3 ? "paddingTop" : "paddingLeft"] = c.paddingTop); c.paddingBottom && (g[a._e3 ? "paddingBottom" : "paddingRight"] = c.paddingBottom); b.css(g); a._s3 = f(b).find("." + e + "Container"); a._q6 && (e += "Arrow", c.arrowLeft ? a._r6 = c.arrowLeft : (a._r6 = f('<div class="' + e + " " + e + 'Left"><div class="' + e + 'Icn"></div></div>'), b.append(a._r6)), c.arrowRight ? a._s6 = c.arrowRight : (a._s6 = f('<div class="' + e + " " + e + 'Right"><div class="' + e + 'Icn"></div></div>'), b.append(a._s6)), a._r6.click(function () {
          var b =
            (Math.floor(a._i3 / a._t6) + a._u6) * a._t6; a._a4(b > a._n3 ? a._n3 : b)
        }), a._s6.click(function () { var b = (Math.floor(a._i3 / a._t6) - a._u6) * a._t6; a._a4(b < a._o3 ? a._o3 : b) }), c.arrowsAutoHide && !a.hasTouch && (a._r6.css("opacity", 0), a._s6.css("opacity", 0), b.one("mousemove.rsarrowshover", function () { a._l6 && (a._r6.css("opacity", 1), a._s6.css("opacity", 1)) }), b.hover(function () { a._l6 && (a._r6.css("opacity", 1), a._s6.css("opacity", 1)) }, function () { a._l6 && (a._r6.css("opacity", 0), a._s6.css("opacity", 0)) }))); a._k5 = b; a._l5 = a._s3.children();
      a.msEnabled && a.st.thumbs.navigation && a._s3.css("-ms-touch-action", a._e3 ? "pan-y" : "pan-x"); a.slider.append(b); a._w3 = !0; a._v6 = h; c.navigation && a._e && a._s3.css(a._g + "transition-property", a._g + "transform"); a._k5.on("click.rs", ".rsNavItem", function () { a._m5 || a.goTo(f(this).index()) }); a.ev.off("rsBeforeSizeSet.thumbs").on("rsBeforeSizeSet.thumbs", function () { a._w6 = a._e3 ? a._c4 : a._b4; a.updateThumbsSize(!0) })
    }, updateThumbsSize: function () {
      var a = this, e = a._l5.first(), c = {}, b = a._l5.length; a._t6 = (a._e3 ? e.outerWidth() :
        e.outerHeight()) + a._v6; a._y3 = b * a._t6 - a._v6; c[a._e3 ? "width" : "height"] = a._y3 + a._v6; a._z3 = a._e3 ? a._k5.width() : a._k5.height(); a._o3 = -(a._y3 - a._z3) - a.st.thumbs.firstMargin; a._n3 = a.st.thumbs.firstMargin; a._u6 = Math.floor(a._z3 / a._t6); if (a._y3 < a._z3) a.st.thumbs.autoCenter && a._q3((a._z3 - a._y3) / 2), a.st.thumbs.arrows && a._r6 && (a._r6.addClass("rsThumbsArrowDisabled"), a._s6.addClass("rsThumbsArrowDisabled")), a._l6 = !1, a._m5 = !1, a._k5.off(a._j1); else if (a.st.thumbs.navigation && !a._l6 && (a._l6 = !0, !a.hasTouch && a.st.thumbs.drag ||
          a.hasTouch && a.st.thumbs.touch)) a._m5 = !0, a._k5.on(a._j1, function (b) { a._g2(b, !0) }); a._e && (c[a._g + "transition-duration"] = "0ms"); a._s3.css(c); if (a._w3 && (a.isFullscreen || a.st.thumbs.fitInViewport)) a._e3 ? a._c4 = a._w6 - a._k5.outerHeight() : a._b4 = a._w6 - a._k5.outerWidth()
    }, setThumbsOrientation: function (a, e) { this._w3 && (this.st.thumbs.orientation = a, this._k5.remove(), this.slider.removeClass("rsWithThumbsHor rsWithThumbsVer"), this._k6(), this._k5.off(this._j1), e || this.updateSliderSize(!0)) }, _q3: function (a) {
      this._i3 =
      a; this._e ? this._s3.css(this._x1, this._y1 + (this._e3 ? a + this._z1 + 0 : 0 + this._z1 + a) + this._a2) : this._s3.css(this._e3 ? this._x1 : this._w1, a)
    }, _a4: function (a, e, c, b, g) {
      var d = this; if (d._l6) {
        e || (e = d.st.thumbs.transitionSpeed); d._i3 = a; d._x6 && clearTimeout(d._x6); d._p6 && (d._e || d._s3.stop(), c = !0); var h = {}; d._p6 = !0; d._e ? (h[d._g + "transition-duration"] = e + "ms", h[d._g + "transition-timing-function"] = c ? f.rsCSS3Easing[d.st.easeOut] : f.rsCSS3Easing[d.st.easeInOut], d._s3.css(h), d._q3(a)) : (h[d._e3 ? d._x1 : d._w1] = a + "px", d._s3.animate(h,
          e, c ? "easeOutCubic" : d.st.easeInOut)); b && (d._i3 = b); d._y6(); d._x6 = setTimeout(function () { d._p6 = !1; g && (d._a4(b, g, !0), g = null) }, e)
      }
    }, _y6: function () { this._q6 && (this._i3 === this._n3 ? this._r6.addClass("rsThumbsArrowDisabled") : this._r6.removeClass("rsThumbsArrowDisabled"), this._i3 === this._o3 ? this._s6.addClass("rsThumbsArrowDisabled") : this._s6.removeClass("rsThumbsArrowDisabled")) }, _m6: function (a, e) {
      var c = 0, b, f = a * this._t6 + 2 * this._t6 - this._v6 + this._n3, d = Math.floor(this._i3 / this._t6); this._l6 && (this._j6 && (e = !0,
        this._j6 = !1), f + this._i3 > this._z3 ? (a === this.numSlides - 1 && (c = 1), d = -a + this._u6 - 2 + c, b = d * this._t6 + this._z3 % this._t6 + this._v6 - this._n3) : 0 !== a ? (a - 1) * this._t6 <= -this._i3 + this._n3 && a - 1 <= this.numSlides - this._u6 && (b = (-a + 1) * this._t6 + this._n3) : b = this._n3, b !== this._i3 && (c = void 0 === b ? this._i3 : b, c > this._n3 ? this._q3(this._n3) : c < this._o3 ? this._q3(this._o3) : void 0 !== b && (e ? this._q3(b) : this._a4(b))), this._y6())
    }
  }); f.rsModules.thumbnails = f.rsProto._h6
})(jQuery);
// jquery.rs.video v1.1.1
(function (f) {
  f.extend(f.rsProto, {
    _z6: function () {
      var a = this; a._a7 = { autoHideArrows: !0, autoHideControlNav: !1, autoHideBlocks: !1, autoHideCaption: !1, disableCSS3inFF: !0, youTubeCode: '<iframe src="http://www.youtube.com/embed/%id%?rel=1&autoplay=1&showinfo=0&autoplay=1&wmode=transparent" frameborder="no"></iframe>', vimeoCode: '<iframe src="http://player.vimeo.com/video/%id%?byline=0&amp;portrait=0&amp;autoplay=1" frameborder="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>' }; a.st.video =
        f.extend({}, a._a7, a.st.video); a.ev.on("rsBeforeSizeSet", function () { a._b7 && setTimeout(function () { var b = a._r1, b = b.hasClass("rsVideoContainer") ? b : b.find(".rsVideoContainer"); a._c7 && a._c7.css({ width: b.width(), height: b.height() }) }, 32) }); var c = a._a.mozilla; a.ev.on("rsAfterParseNode", function (b, e, d) {
          b = f(e); if (d.videoURL) {
            a.st.video.disableCSS3inFF && c && (a._e = a._f = !1); e = f('<div class="rsVideoContainer"></div>'); var g = f('<div class="rsBtnCenterer"><div class="rsPlayBtn"><div class="rsPlayBtnIcon"></div></div></div>');
            b.hasClass("rsImg") ? d.content = e.append(b).append(g) : d.content.find(".rsImg").wrap(e).after(g)
          }
        }); a.ev.on("rsAfterSlideChange", function () { a.stopVideo() })
    }, toggleVideo: function () { return this._b7 ? this.stopVideo() : this.playVideo() }, playVideo: function () {
      var a = this; if (!a._b7) {
        var c = a.currSlide; if (!c.videoURL) return !1; var b = a._d7 = c.content, c = c.videoURL, e, d; c.match(/youtu\.be/i) || c.match(/youtube\.com/i) ? (d = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/, (d = c.match(d)) && 11 ==
          d[7].length && (e = d[7]), void 0 !== e && (a._c7 = a.st.video.youTubeCode.replace("%id%", e))) : c.match(/vimeo\.com/i) && (d = /(www\.)?vimeo.com\/(\d+)($|\/)/, (d = c.match(d)) && (e = d[2]), void 0 !== e && (a._c7 = a.st.video.vimeoCode.replace("%id%", e))); a.videoObj = f(a._c7); a.ev.trigger("rsOnCreateVideoElement", [c]); a.videoObj.length && (a._c7 = f('<div class="rsVideoFrameHolder"><div class="rsPreloader"></div><div class="rsCloseVideoBtn"><div class="rsCloseVideoIcn"></div></div></div>'), a._c7.find(".rsPreloader").after(a.videoObj),
            b = b.hasClass("rsVideoContainer") ? b : b.find(".rsVideoContainer"), a._c7.css({ width: b.width(), height: b.height() }).find(".rsCloseVideoBtn").off("click.rsv").on("click.rsv", function (b) { a.stopVideo(); b.preventDefault(); b.stopPropagation(); return !1 }), b.append(a._c7), a.isIPAD && b.addClass("rsIOSVideo"), a._e7(!1), setTimeout(function () { a._c7.addClass("rsVideoActive") }, 10), a.ev.trigger("rsVideoPlay"), a._b7 = !0); return !0
      } return !1
    }, stopVideo: function () {
      var a = this; return a._b7 ? (a.isIPAD && a.slider.find(".rsCloseVideoBtn").remove(),
        a._e7(!0), setTimeout(function () { a.ev.trigger("rsOnDestroyVideoElement", [a.videoObj]); var c = a._c7.find("iframe"); if (c.length) try { c.attr("src", "") } catch (b) { } a._c7.remove(); a._c7 = null }, 16), a.ev.trigger("rsVideoStop"), a._b7 = !1, !0) : !1
    }, _e7: function (a) {
      var c = [], b = this.st.video; b.autoHideArrows && (this._c2 && (c.push(this._c2, this._d2), this._e2 = !a), this._v5 && c.push(this._v5)); b.autoHideControlNav && this._k5 && c.push(this._k5); b.autoHideBlocks && this.currSlide.animBlocks && c.push(this.currSlide.animBlocks); b.autoHideCaption &&
        this.globalCaption && c.push(this.globalCaption); if (c.length) for (b = 0; b < c.length; b++)a ? c[b].removeClass("rsHidden") : c[b].addClass("rsHidden")
    }
  }); f.rsModules.video = f.rsProto._z6
})(jQuery);
// jquery.rs.visible-nearby v1.0.2
(function (d) {
  d.rsProto._f7 = function () {
    var a = this; a.st.visibleNearby && a.st.visibleNearby.enabled && (a._g7 = { enabled: !0, centerArea: 0.6, center: !0, breakpoint: 0, breakpointCenterArea: 0.8, hiddenOverflow: !0, navigateByCenterClick: !1 }, a.st.visibleNearby = d.extend({}, a._g7, a.st.visibleNearby), a.ev.one("rsAfterPropsSetup", function () {
      a._h7 = a._e1.css("overflow", "visible").wrap('<div class="rsVisibleNearbyWrap"></div>').parent(); a.st.visibleNearby.hiddenOverflow || a._h7.css("overflow", "visible"); a._o1 = a.st.controlsInside ?
        a._h7 : a.slider
    }), a.ev.on("rsAfterSizePropSet", function () { var b, c = a.st.visibleNearby; b = c.breakpoint && a.width < c.breakpoint ? c.breakpointCenterArea : c.centerArea; a._h ? (a._b4 *= b, a._h7.css({ height: a._c4, width: a._b4 / b }), a._d = a._b4 * (1 - b) / 2 / b) : (a._c4 *= b, a._h7.css({ height: a._c4 / b, width: a._b4 }), a._d = a._c4 * (1 - b) / 2 / b); c.navigateByCenterClick || (a._q = a._h ? a._b4 : a._c4); c.center && a._e1.css("margin-" + (a._h ? "left" : "top"), a._d) }))
  }; d.rsModules.visibleNearby = d.rsProto._f7
})(jQuery);

define("royalSlider", function () { });

define('widgets/delaysBoard', [
  'jquery',
  'UTILS',
  'dataprovider',
  'data/delays',
  'i18n_general',
  'moment',

  'jsrender',
  'royalSlider'
], function ($, Utils, DataProvider, Delays, GeneralI18n, moment) {

  var eventEmitter,
    delays = {},
    isHome = false,
    $context;

  $.views.converters({
    htmlParse: function (val) {
      return $("<div>" + val + "</div>").html();
    }  /* , ....  */
  });

  function sanitizeDelays(data) {
    return new Delays(data);
  }

  function loadDelaysData(callback, callbackErrors) {
    DataProvider.delays({}, function (statusCode, data) {
      switch (statusCode) {
        case 200:
          var delays = sanitizeDelays(data);
          callback(delays);
          break;

        default:
          callbackErrors();
          break;
      }
    });
  }

  var _WaitingTime = function (elt, options) {
    var defaultOpts = {
      templateSelector: "#" + $(elt).attr("data-template")
    };

    this.opts = $.extend({}, defaultOpts, options);
    this.elt = $(elt);
    this.template = $.templates(this.opts.templateSelector);

    return this.init();
  };

  _WaitingTime.prototype = {
    init: function () {
      var _this = this;

      var buildDelayPanel = function (delays) {
        _this.innerMarkup = _this.template.render(delays);

        _this.elt.html(_this.innerMarkup);
      };

      var CONFIG = {
        receiverEvent: _this.elt.data("automaticupdate-receiverevent") || null,
        triggeredEvent: _this.elt.data("automaticupdate-triggeredevent") || null
      };

      var $errorPanel = null;

      var loadData = function () {
        if ($errorPanel) {
          $errorPanel.remove();
        }
        loadDelaysData(function (delays) {
          buildDelayPanel(delays);
          ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["updatedCompleted", { server: { now: moment().format("X"), next: moment().add(120, 's').format("X") }, client: { now: moment().format("X") } }]);

        }, function () {
          // Show Errors
          $errorPanel = $("<div class='delayboard-errors'><span class='icon icon-attention'></span><span class='delayboard-errors-label'>" + GeneralI18n.ErrorAjaxGlobal + "</span></div>");
          _this.elt.prepend($errorPanel);
          ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["updatedError", { server: { now: moment().format("X") } }]);
        });
      };

      ADM.eventEmitter.addListener(CONFIG.triggeredEvent, function () {
        loadData();
      });

      ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["start", {
        server: {
          now: moment().format("X"),
          next: moment().add(10, 's').format("X")
        }, client: { now: moment().format("X") }
      }]);

      loadData();
    }
  };

  var DelaysBoard = {
    init: function (context) {
      eventEmitter = ADM.eventEmitter;
      $context = $(context);

      if ($('body').hasClass('front')) {
        isHome = true;
      }

      $context.each(function () {
        var waitingTimePanel = new _WaitingTime($(this), {});
      });
    }
  };

  return DelaysBoard;
});

/**
* i18n
*
* This file is added in the head of the page and parse by Drupal to index the i18n key
*
*
*/

var ADM = window.ADM || {};
if (typeof ADM.i18n === "undefined") { ADM.i18n = {}; }

// Fallback when we're in static solution.
if (typeof Drupal == "undefined" || !Drupal) {
  Drupal = {};
  Drupal.t = function (key, args) { return key; };
  Drupal.formatPlural = function (count, singular, plural, args) { return singular; };
}


// CHOSEN
ADM.i18n.chosen = {
  "noResultMatch": Drupal.t("No results match")
};

// DATATABLES
ADM.i18n.datatables = {
  "sEmptyTable": Drupal.t("No data available in table"),
  "sInfo": Drupal.t("Showing _START_ to _END_ of _TOTAL_ entries"),
  "sInfoEmpty": Drupal.t("Showing 0 to 0 of 0 entries"),
  "sInfoFiltered": Drupal.t("(filtered from _MAX_ total entries)"),
  //avoid empty strings
  "sInfoPostFix": (""),
  //avoid empty strings
  "sInfoThousands": (","),
  "sLengthMenu": Drupal.t("Show _MENU_ entries"),
  "sLoadingRecords": Drupal.t("Loading..."),
  "sProcessing": Drupal.t("Processing..."),
  "sSearch": Drupal.t("Search:"),
  "sZeroRecords": Drupal.t("No matching records found"),
  "oPaginate": {
    "sFirst": Drupal.t("First"),
    "sLast": Drupal.t("Last"),
    "sNext": Drupal.t("Next"),
    "sPrevious": Drupal.t("Previous")
  },
  "oAria": {
    "sSortAscending": Drupal.t(": activate to sort column ascending"),
    "sSortDescending": Drupal.t(": activate to sort column descending")
  }
};

ADM.i18n.modal = {
  "tClose": Drupal.t("Close (Esc)"),
  "tLoading": Drupal.t("Loading..."),
  "tPrev": Drupal.t("Previous (Left arrow key)"),
  "tNext": Drupal.t("Next (Right arrow key)"),
  "tCounter": Drupal.t("%curr% of %total%"),
  "image.tError": Drupal.t("<a href=\"%url%\">The image</a> could not be loaded."),
  "ajax.tError": Drupal.t("<a href=\"%url%\">The content</a> could not be loaded.")
};

// GENERAL
ADM.i18n.general = {
  "searchForFlight": Drupal.t("Search for flights ..."),
  "trackBySms": Drupal.t("Track by SMS"),
  "enProvenanceDe": Drupal.t("From", {}, { 'context': 'flightboard' }),
  "heureArrivee": Drupal.t("Arrival time"),
  "Statut": Drupal.t("Status"),
  "Porte": Drupal.t("Gate"),
  "Phone": Drupal.t("Phone :"),
  "SansFrais": Drupal.t("Toll free :"),
  "Website": Drupal.t("Website "),
  "ADestinationDe": Drupal.t("To", {}, { 'context': 'flightboard' }),
  "HeureDeDepart": Drupal.t("Departure time"),
  "Vol": Drupal.t("Flight"),
  "ErrorAjaxFilter": Drupal.t("Sorry, a system error prevents us from displaying the list of commerces that you've requested.."),
  "ErrorAjaxFilterLink": Drupal.t("Try refreshing the page later."),
  "ErrorAjaxGlobal": Drupal.t("Failure of the last attempt. The service is temporarily unavailable."),
  "RequestImages": Drupal.t("Ask the selected images"),
  "SelectAImage": Drupal.t("Please select an image"),
  "currently": Drupal.t("currently", {}, { 'context': 'flightboard' }),
  "selHours": Drupal.t("Time"),
  "HomeNewsMobile": Drupal.t("Press releases, public notices and other communications"),
  "HomeNews": Drupal.t("See all"),
  "RefreshData": Drupal.t("Refresh flight information"),
  "previous": Drupal.t("Previous"),
  "next": Drupal.t("Next"),
  "play": Drupal.t("Play"),
  "pause": Drupal.t("Pause"),
  "search": Drupal.t("Search"),
  "priorityLow": Drupal.t("Low occupancy"),
  "priorityMedium": Drupal.t("Average occupancy"),
  "priorityHigh": Drupal.t("High occupancy"),
  "toggleFlightDetail": Drupal.t("Toggle the flight detail"),
  "noRevisionFlight": Drupal.t('No revision for this flight.'),
  "compagny": Drupal.t('Compagny'),
  "doorNumber": Drupal.t('Door number'),
};

// MOMENT JS
ADM.i18n.moment = {
  relativeTime: {
    future: Drupal.t("in %s"),
    past: Drupal.t("%s ago"),
    s: Drupal.t("a few seconds"),
    m: Drupal.t("a minute"),
    mm: Drupal.t("%d minutes"),
    h: Drupal.t("an hour"),
    hh: Drupal.t("%d hours"),
    d: Drupal.t("a day"),
    dd: Drupal.t("%d days"),
    M: Drupal.t("a month"),
    MM: Drupal.t("%d months"),
    y: Drupal.t("a year"),
    yy: Drupal.t("%d years")
  }
};

// MOBISCROLL
ADM.i18n.mobiscroll = {
  setText: Drupal.t('Confirm'),
  cancelText: Drupal.t('Cancel'),
  clearText: Drupal.t('Erase'),
  selectedText: Drupal.t('Selected'),
  // Datetime component
  dateFormat: 'dd/mm/yy', // Don't change this format otherwise the parking widget gonna broke
  dateOrder: 'ddmmyy',   // Don't change this format otherwise the parking widget gonna broke
  dayNames: [Drupal.t('Sunday'), Drupal.t('Monday'), Drupal.t('Tuesday'), Drupal.t('Wednesday'), Drupal.t('Thursday'), Drupal.t('Friday'), Drupal.t('Saturday')],
  dayNamesShort: [Drupal.t('Sun'), Drupal.t('Mon'), Drupal.t('Tue'), Drupal.t('Wed'), Drupal.t('Thu'), Drupal.t('Fri'), Drupal.t('Sat')],
  dayText: Drupal.t('Day'),
  hourText: Drupal.t('Hours'),
  minuteText: Drupal.t('Minutes'),
  monthNames: [Drupal.t('January'), Drupal.t('February'), Drupal.t('March'), Drupal.t('April'), Drupal.t('May'), Drupal.t('June'), Drupal.t('July'), Drupal.t('August'), Drupal.t('September'), Drupal.t('October'), Drupal.t('November'), Drupal.t('December')],
  monthNamesShort: [Drupal.t('Jan'), Drupal.t('Feb'), Drupal.t('Mar'), Drupal.t('Apr'), Drupal.t('May'), Drupal.t('Jun'), Drupal.t('Jul'), Drupal.t('Aug'), Drupal.t('Sep'), Drupal.t('Oct'), Drupal.t('Nov'), Drupal.t('Dec')],
  monthText: Drupal.t('Month'),
  secText: Drupal.t('Seconds'),
  timeFormat: Drupal.t('hh:ii A'),
  timeWheels: Drupal.t('hhiiA'),
  yearText: Drupal.t('Year'),
  nowText: Drupal.t('Now'),
  dateText: Drupal.t('Date'),
  timeText: Drupal.t('Time'),
  calendarText: Drupal.t('Calendar'),
  // Time / Timespan component
  labels: [Drupal.t('Years'), Drupal.t('Months'), Drupal.t('Days'), Drupal.t('Hours'), Drupal.t('Minutes'), Drupal.t('Seconds'), ''],
  labelsShort: [Drupal.t('Yrs'), Drupal.t('Mths'), Drupal.t('Days'), Drupal.t('Hrs'), Drupal.t('Mins'), Drupal.t('Secs'), '']
};

ADM.i18n.searchFlightAutocomplete = {
  "label-arrival": Drupal.t("Arrivals"),
  "label-departure": Drupal.t("Departures"),
  "label-all-arrival": Drupal.t("See all arrivals"),
  "label-all-departure": Drupal.t("See all departures"),
  "label-all-flights": Drupal.t("See all flights"),
  "label-more": Drupal.t("More results"),
  "label-noresult": Drupal.t("No flight matches your criteria."),
  "label-error": Drupal.t("Failure of the last attempt. The service is temporarily unavailable."),
};

//interactivemap infowindow
ADM.i18n.interactivemap = {
  "moreinfo": Drupal.t("More Info")
};

define("i18n/i18n", function () { });

define('momentWithi18n', ['moment', 'UTILS'], function (moment, Utils) {

  var i18n = ADM.i18n.moment;

  var momenti18n = {
    relativeTime: {
      future: i18n.relativeTime.future,
      past: i18n.relativeTime.past,
      s: i18n.relativeTime.s,
      m: i18n.relativeTime.m,
      mm: i18n.relativeTime.mm,
      h: i18n.relativeTime.h,
      hh: i18n.relativeTime.hh,
      d: i18n.relativeTime.d,
      dd: i18n.relativeTime.dd,
      M: i18n.relativeTime.M,
      MM: i18n.relativeTime.MM,
      y: i18n.relativeTime.y,
      yy: i18n.relativeTime.yy
    }
  };

  moment.lang(Utils.getLang(), momenti18n);

  return momenti18n;

});
// Livestamp.js / v1.1.2 / (c) 2012 Matt Bradley / MIT License


/* !-------- WARNING:: This version is modified to respond our needs ----------- */


(function (plugin) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('livestamp', ['jquery', 'moment'], plugin);
  } else {
    // Browser globals
    plugin(jQuery, moment);
  }
}(function ($, moment) {
  var updateInterval = 1e3,
    paused = false,
    $livestamps = $([]),

    init = function () {
      livestampGlobal.resume();
    },

    prep = function ($el, timestamp) {
      var oldData = $el.data('livestampdata');
      if (typeof timestamp == 'number')
        timestamp *= 1e3;

      $el.removeAttr('data-livestamp')
        .removeData('livestamp');

      timestamp = moment(timestamp);
      if (moment.isMoment(timestamp) && !isNaN(+timestamp)) {
        var newData = $.extend({}, { 'original': $el.contents() }, oldData);
        newData.moment = moment(timestamp);

        $el.data('livestampdata', newData).empty();
        $livestamps.push($el[0]);
      }
    },

    run = function () {
      if (paused) return;
      livestampGlobal.update();
      setTimeout(run, updateInterval);
    },

    livestampGlobal = {
      update: function () {

        $('[data-livestamp]').each(function () {
          var $this = $(this);
          prep($this, $this.data('livestamp'));
        });

        var toRemove = [];
        $livestamps.each(function () {
          var $this = $(this),
            data = $this.data('livestampdata');


          if (data === undefined)
            toRemove.push(this);
          else if (moment.isMoment(data.moment)) {
            var from = $this.html(),
              to = data.moment.fromNow();
            // modified: mamzellejuu :: Added trigger event
            var e2 = $.Event('update.livestamp');
            $this.trigger(e2, [from, to]);
            if (!e2.isDefaultPrevented())
              $this.html(to);

            if (from != to) {
              var e = $.Event('change.livestamp');
              $this.trigger(e, [from, to]);
              if (!e.isDefaultPrevented())
                $this.html(to);
            }
          }
        });

        $livestamps = $livestamps.not(toRemove);
        delete $livestamps.prevObject
      },

      pause: function () {
        paused = true;
      },

      resume: function () {
        paused = false;
        run();
      },

      interval: function (interval) {
        if (interval === undefined)
          return updateInterval;
        updateInterval = interval;
      }
    },

    livestampLocal = {
      add: function ($el, timestamp) {
        if (typeof timestamp == 'number')
          timestamp *= 1e3;
        timestamp = moment(timestamp);

        if (moment.isMoment(timestamp) && !isNaN(+timestamp)) {
          $el.each(function () {
            prep($(this), timestamp);
          });
          livestampGlobal.update();
        }

        return $el;
      },

      destroy: function ($el) {
        $livestamps = $livestamps.not($el);
        $el.each(function () {
          var $this = $(this),
            data = $this.data('livestampdata');

          if (data === undefined)
            return $el;

          $this
            .html(data.original ? data.original : '')
            .removeData('livestampdata');
        });

        return $el;
      },

      isLivestamp: function ($el) {
        return $el.data('livestampdata') !== undefined;
      }
    };

  $.livestamp = livestampGlobal;
  $(init);
  $.fn.livestamp = function (method, options) {
    if (!livestampLocal[method]) {
      options = method;
      method = 'add';
    }

    return livestampLocal[method](this, options);
  };

}));
define('widgets/automaticUpdate', [
  'jquery',
  'i18n/i18n',
  'UTILS',
  'UTILS_TIME',
  'UTILS_DATE',
  'UTILS_UPDATER',
  'i18n_general',
  'gsap',
  'canvasLoader',
  'livestamp'
], function ($, i18n, Utils, TimeConvertor, DateUtils, Updater, Generali18n) {

  var eventEmitter;

  function Spinner(opts) {
    var $container = opts.$el,
      $spinner,
      speed = 0,
      diameter = 16,
      color = "#6c757b",
      fps = 30,
      uniqueId = Utils.getUniqueId(),
      spinnerId = "canvasLoader-" + uniqueId,
      spinnerTimeout;

    function init() {
      $container.append("<span id='" + opts.id + "' style='display:inline-block'></span><span class='refresher'><span class='visually-hidden'>" + Generali18n.RefreshData + "</span></span>");

      $spinner = new CanvasLoader(opts.id, { id: spinnerId });
      $spinner.setSpeed(speed);
      $spinner.setDiameter(diameter);
      $spinner.setColor(color);
      $spinner.setFPS(fps);
      $spinner.show();

      $("#" + opts.id).addClass("canvasloader-wrapper");
    }

    init();

    return {
      start: function () {
        clearTimeout(spinnerTimeout);
        $("#" + opts.id).css({ "display": "block" });
        $spinner.setSpeed(2);

        $container.find(".refresher").css({ "display": "none" });
      },
      stop: function () {
        setTimeout(function () {
          $("#" + opts.id).css({ "display": "none" });
          $spinner.setSpeed(0);
          $container.find(".refresher").css({ "display": "block" });
        }, 800);
      }
    };
  }

  /************************************** INTERFACE ************************************************/

  function AutomaticUpdateCtrl() { }
  AutomaticUpdateCtrl.prototype.CONFIG;
  AutomaticUpdateCtrl.prototype.updater;
  AutomaticUpdateCtrl.prototype.eventEmitter;
  AutomaticUpdateCtrl.prototype.isStopped = false;

  AutomaticUpdateCtrl.prototype.init = function (config) {
    this.updater = Updater.create(this);
    this.updater.setCallback(this.update);
    this.CONFIG = config;
  };
  AutomaticUpdateCtrl.prototype.update = function () {
    eventEmitter.emitEvent(this.CONFIG.triggeredEvent, []);
  };

  AutomaticUpdateCtrl.prototype.updateCompleted = function (args) { };
  AutomaticUpdateCtrl.prototype.updateError = function (args) { };
  AutomaticUpdateCtrl.prototype.start = function () { };
  AutomaticUpdateCtrlWithTimestamp.prototype.stop = function () { };

  AutomaticUpdateCtrl.prototype.getExponentialInterval = function (obj) {
    var currentInterval;

    if (obj.currentInterval < obj.numInterval) {
      obj.currentInterval++;
      currentInterval = obj.current;
    } else {
      obj.currentInterval = 1;
      obj.current = (obj.current * 2);
      currentInterval = obj.current;
    }

    return currentInterval;
  };

  // Timestamp
  function AutomaticUpdateCtrlWithTimestamp() { }
  AutomaticUpdateCtrlWithTimestamp.prototype = new AutomaticUpdateCtrl();

  AutomaticUpdateCtrlWithTimestamp.prototype.lastTimeIntervalError = {
    byDefault: TimeConvertor.getMilisecondsToSeconds(10),
    current: TimeConvertor.getMilisecondsToSeconds(10),
    currentInterval: 0,
    numInterval: 5
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.isStopped = false;

  AutomaticUpdateCtrlWithTimestamp.prototype.start = function (args) {

    var updateTimestamp = args.server.now,
      nextUpdateTimestamp = args.server.next,
      updateInterval;

    if (typeof updateTimestamp !== "undefined" && typeof nextUpdateTimestamp != "undefined") {
      if (!this.isStopped) {

        updateInterval = this.getIntervalByTimestamps(updateTimestamp, nextUpdateTimestamp);

        this.updater.setTimeInterval(updateInterval);
        this.updater.startOnce();
      }

      this.CONFIG.$label.attr("data-livestamp", args.client.now);// Use this method otherwise this.CONFIG.$label.livestamp(args.client.now); because i got problem, sometimes it show "dans quelques secondes".
    }
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.stop = function (args) {
    if (this.updater) {
      this.isStopped = true;
      this.updater.stop();
    }
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.startError = function (args) {
    var _t = this,
      updateTimestamp = args.server.now;

    currentInterval = _t.getExponentialInterval(_t.lastTimeIntervalError);

    if (!this.isStopped) {
      this.updater.setTimeInterval(currentInterval);
      this.updater.startOnce();
    }


    if (typeof updateTimestamp != "undefined") {
      this.CONFIG.$label.attr("data-livestamp", updateTimestamp);// Use this method otherwise this.CONFIG.$label.livestamp(args.client.now); because i got problem, sometimes it show "dans quelques secondes".
    }
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.update = function (args) {
    this.updater.stopOnce();
    eventEmitter.emitEvent(this.CONFIG.triggeredEvent, []);
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.reset = function () {
    var _t = this;

    // Reset the default value;
    _t.lastTimeIntervalError.current = _t.lastTimeIntervalError.byDefault;
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.updateCompleted = function (args) {
    this.start(args);
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.updateError = function (args) {
    this.startError(args);
  };

  AutomaticUpdateCtrlWithTimestamp.prototype.getIntervalByTimestamps = function (d1, d2) {
    var d1 = Number(d1),
      d2 = Number(d2);

    return (d2 - d1) > TimeConvertor.getMilisecondsToSeconds(1) ? (d2 - d1) + Math.random(0, 1000) : TimeConvertor.getMilisecondsToSeconds(30);
  };

  // Interval TODO:: Need to develop this when we'll need it
  function AutomaticUpdateCrtlWithInterval() { }
  AutomaticUpdateCrtlWithInterval.prototype = new AutomaticUpdateCtrl();

  AutomaticUpdateCrtlWithInterval.prototype.start = function (args) {
    console.log("Use regular interval defined by dom or default");
  };

  /*************************************** INITIALIZATION *******************************************/

  var AutomaticUpdate = {
    init: function (context) {
      eventEmitter = ADM.eventEmitter;
      $(context).each(function (index, el) {
        new AutomaticUpdateInstance(el);
      });
    }
  };

  function AutomaticUpdateInstance(el) {
    var $el = $(el),
      CONFIG = {
        $label: $el.find(".automaticupdate-label"),
        receiverEvent: $el.data("automaticupdate-receiverevent") || null,
        triggeredEvent: $el.data("automaticupdate-triggeredevent") || null,
        onStart: $el.attr("data-automaticupdate-start") || false,
        type: $el.attr("data-automaticupdate-type") || "interval"   // Value = "serverside" || "interval"
      },
      $trigger = $el.find($el.data("automaticupdate-trigger")) || "",
      $spinner,
      spinnerTimeout,
      ctrl;

    function init() {

      switch (CONFIG.type) {
        case "serverside":
          ctrl = new AutomaticUpdateCtrlWithTimestamp();
          break;

        case "interval":
          ctrl = new AutomaticUpdateCrtlWithInterval();
          break;
      }

      ctrl.init(CONFIG);
      if (haveTrigger()) createSpinnerForTrigger();
      createEvents();
    }

    function haveTrigger() {
      return ($trigger.length > 0) ? true : false;
    }

    function createSpinnerForTrigger() {
      $spinner = new Spinner({
        $el: $trigger,
        id: "canvasloader-container-" + Utils.getUniqueId()
      });
      $spinner.stop();
    }

    function activeTrigger() {
      $trigger.css("cursor", "pointer");
      $trigger.removeClass("automaticupdate-inactive");
    }

    function desactiveTrigger() {
      $trigger.css("cursor", "default");
      $trigger.addClass("automaticupdate-inactive");
    }

    function createEvents() {
      eventEmitter.addListener(CONFIG.receiverEvent, function (type, args) {
        switch (type) {
          case "start":
            if (CONFIG.onStart == "false") {
              ctrl.start(args);
            }
            break;

          case "stop":
            ctrl.stop();
            break;

          case "updatedCompleted":
            if (haveTrigger()) {
              $spinner.stop();
              activeTrigger();
            }
            ctrl.reset();
            ctrl.updateCompleted(args);
            break;

          case "updatedError":
            if (haveTrigger()) {
              $spinner.stop();
              activeTrigger();
            }
            ctrl.stop();
            ctrl.updateError(args);
            break;
        }
      });

      if (haveTrigger()) {
        $trigger.on("click", function (e) {
          e.preventDefault();

          if (!$trigger.hasClass("automaticupdate-inactive")) {
            $spinner.start();
            desactiveTrigger();
            ctrl.update();
          }
        });
      }
    }

    init();
  }

  return AutomaticUpdate;
});

/*global setTimeout: false, console: false */
(function () {

  var async = {};

  // global on the server, window in the browser
  var root = this,
    previous_async = root.async;

  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };

  //// cross-browser compatiblity functions ////

  var _forEach = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };

  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _forEach(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };

  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _forEach(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };

  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };

  //// exported async module functions ////

  //// nextTick implementation with browser-compatible fallback ////
  if (typeof process === 'undefined' || !(process.nextTick)) {
    async.nextTick = function (fn) {
      setTimeout(fn, 0);
    };
  }
  else {
    async.nextTick = process.nextTick;
  }

  async.forEach = function (arr, iterator, callback) {
    callback = callback || function () { };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _forEach(arr, function (x) {
      iterator(x, function (err) {
        if (err) {
          callback(err);
          callback = function () { };
        }
        else {
          completed += 1;
          if (completed === arr.length) {
            callback(null);
          }
        }
      });
    });
  };

  async.forEachSeries = function (arr, iterator, callback) {
    callback = callback || function () { };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () { };
        }
        else {
          completed += 1;
          if (completed === arr.length) {
            callback(null);
          }
          else {
            iterate();
          }
        }
      });
    };
    iterate();
  };

  async.forEachLimit = function (arr, limit, iterator, callback) {
    callback = callback || function () { };
    if (!arr.length || limit <= 0) {
      return callback();
    }
    var completed = 0;
    var started = 0;
    var running = 0;

    (function replenish() {
      if (completed === arr.length) {
        return callback();
      }

      while (running < limit && started < arr.length) {
        started += 1;
        running += 1;
        iterator(arr[started - 1], function (err) {
          if (err) {
            callback(err);
            callback = function () { };
          }
          else {
            completed += 1;
            running -= 1;
            if (completed === arr.length) {
              callback();
            }
            else {
              replenish();
            }
          }
        });
      }
    })();
  };


  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.forEach].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.forEachSeries].concat(args));
    };
  };


  var _asyncMap = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return { index: i, value: x };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (err, v) {
        results[x.index] = v;
        callback(err);
      });
    }, function (err) {
      callback(err, results);
    });
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);


  // reduce only has a series version, as doing reduce in parallel won't
  // work in many situations.
  async.reduce = function (arr, memo, iterator, callback) {
    async.forEachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  // inject alias
  async.inject = async.reduce;
  // foldl alias
  async.foldl = async.reduce;

  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
      return x;
    }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  // foldr alias
  async.foldr = async.reduceRight;

  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return { index: i, value: x };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  // select alias
  async.select = async.filter;
  async.selectSeries = async.filterSeries;

  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return { index: i, value: x };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);

  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () { };
        }
        else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);

  async.some = function (arr, iterator, main_callback) {
    async.forEach(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () { };
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  // any alias
  async.any = async.some;

  async.every = function (arr, iterator, main_callback) {
    async.forEach(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () { };
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  // all alias
  async.all = async.every;

  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        }
        else {
          callback(null, { value: x, criteria: criteria });
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      }
      else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };

  async.auto = function (tasks, callback) {
    callback = callback || function () { };
    var keys = _keys(tasks);
    if (!keys.length) {
      return callback(null);
    }

    var results = {};

    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      _forEach(listeners.slice(0), function (fn) {
        fn();
      });
    };

    addListener(function () {
      if (_keys(results).length === keys.length) {
        callback(null, results);
        callback = function () { };
      }
    });

    _forEach(keys, function (k) {
      var task = (tasks[k] instanceof Function) ? [tasks[k]] : tasks[k];
      var taskCallback = function (err) {
        if (err) {
          callback(err);
          // stop subsequent errors hitting callback multiple times
          callback = function () { };
        }
        else {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          taskComplete();
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return (a && results.hasOwnProperty(x));
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      }
      else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };

  async.waterfall = function (tasks, callback) {
    callback = callback || function () { };
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback(err);
          callback = function () { };
        }
        else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          }
          else {
            args.push(callback);
          }
          async.nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };

  async.parallel = function (tasks, callback) {
    callback = callback || function () { };
    if (tasks.constructor === Array) {
      async.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    }
    else {
      var results = {};
      async.forEach(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };

  async.series = function (tasks, callback) {
    callback = callback || function () { };
    if (tasks.constructor === Array) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    }
    else {
      var results = {};
      async.forEachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };

  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return (index < tasks.length - 1) ? makeCallback(index + 1) : null;
      };
      return fn;
    };
    return makeCallback(0);
  };

  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(
        null, args.concat(Array.prototype.slice.call(arguments))
      );
    };
  };

  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);

  async.whilst = function (test, iterator, callback) {
    if (test()) {
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        async.whilst(test, iterator, callback);
      });
    }
    else {
      callback();
    }
  };

  async.doWhilst = function (iterator, test, callback) {
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (test()) {
        async.doWhilst(iterator, test, callback);
      }
      else {
        callback();
      }
    });
  };

  async.until = function (test, iterator, callback) {
    if (!test()) {
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        async.until(test, iterator, callback);
      });
    }
    else {
      callback();
    }
  };

  async.doUntil = function (iterator, test, callback) {
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (!test()) {
        async.doUntil(iterator, test, callback);
      }
      else {
        callback();
      }
    });
  };

  async.queue = function (worker, concurrency) {
    var workers = 0;
    var q = {
      tasks: [],
      concurrency: concurrency,
      saturated: null,
      empty: null,
      drain: null,
      push: function (data, callback) {
        if (data.constructor !== Array) {
          data = [data];
        }
        _forEach(data, function (task) {
          q.tasks.push({
            data: task,
            callback: typeof callback === 'function' ? callback : null
          });
          if (q.saturated && q.tasks.length == concurrency) {
            q.saturated();
          }
          async.nextTick(q.process);
        });
      },
      process: function () {
        if (workers < q.concurrency && q.tasks.length) {
          var task = q.tasks.shift();
          if (q.empty && q.tasks.length == 0) q.empty();
          workers += 1;
          worker(task.data, function () {
            workers -= 1;
            if (task.callback) {
              task.callback.apply(task, arguments);
            }
            if (q.drain && q.tasks.length + workers == 0) q.drain();
            q.process();
          });
        }
      },
      length: function () {
        return q.tasks.length;
      },
      running: function () {
        return workers;
      }
    };
    return q;
  };

  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
        var args = Array.prototype.slice.call(arguments, 1);
        if (typeof console !== 'undefined') {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          }
          else if (console[name]) {
            _forEach(args, function (x) {
              console[name](x);
            });
          }
        }
      }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  /*async.info = _console_fn('info');
  async.warn = _console_fn('warn');
  async.error = _console_fn('error');*/

  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        callback.apply(null, memo[key]);
      }
      else if (key in queues) {
        queues[key].push(callback);
      }
      else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
          memo[key] = arguments;
          var q = queues[key];
          delete queues[key];
          for (var i = 0, l = q.length; i < l; i++) {
            q[i].apply(null, arguments);
          }
        }]));
      }
    };
    memoized.unmemoized = fn;
    return memoized;
  };

  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };

  // AMD / RequireJS
  if (typeof define !== 'undefined' && define.amd) {
    define('async', [], function () {
      return async;
    });
  }
  // Node.js
  else if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  }
  // included directly via <script> tag
  else {
    root.async = async;
  }

}());

/*! jQuery UI - v1.10.3 - 2013-12-16
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.position.js, jquery.ui.autocomplete.js, jquery.ui.menu.js
* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */

(function ($, undefined) {

  var uuid = 0,
    runiqueId = /^ui-id-\d+$/;

  // $.ui might exist from components with no dependencies, e.g., $.ui.position
  $.ui = $.ui || {};

  $.extend($.ui, {
    version: "1.10.3",

    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  });

  // plugins
  $.fn.extend({
    focus: (function (orig) {
      return function (delay, fn) {
        return typeof delay === "number" ?
          this.each(function () {
            var elem = this;
            setTimeout(function () {
              $(elem).focus();
              if (fn) {
                fn.call(elem);
              }
            }, delay);
          }) :
          orig.apply(this, arguments);
      };
    })($.fn.focus),

    scrollParent: function () {
      var scrollParent;
      if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
        scrollParent = this.parents().filter(function () {
          return (/(relative|absolute|fixed)/).test($.css(this, "position")) && (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
        }).eq(0);
      } else {
        scrollParent = this.parents().filter(function () {
          return (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
        }).eq(0);
      }

      return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
    },

    zIndex: function (zIndex) {
      if (zIndex !== undefined) {
        return this.css("zIndex", zIndex);
      }

      if (this.length) {
        var elem = $(this[0]), position, value;
        while (elem.length && elem[0] !== document) {
          // Ignore z-index if position is set to a value where z-index is ignored by the browser
          // This makes behavior of this function consistent across browsers
          // WebKit always returns auto if the element is positioned
          position = elem.css("position");
          if (position === "absolute" || position === "relative" || position === "fixed") {
            // IE returns 0 when zIndex is not specified
            // other browsers return a string
            // we ignore the case of nested elements with an explicit value of 0
            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
            value = parseInt(elem.css("zIndex"), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }

      return 0;
    },

    uniqueId: function () {
      return this.each(function () {
        if (!this.id) {
          this.id = "ui-id-" + (++uuid);
        }
      });
    },

    removeUniqueId: function () {
      return this.each(function () {
        if (runiqueId.test(this.id)) {
          $(this).removeAttr("id");
        }
      });
    }
  });

  // selectors
  function focusable(element, isTabIndexNotNaN) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase();
    if ("area" === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
        return false;
      }
      img = $("img[usemap=#" + mapName + "]")[0];
      return !!img && visible(img);
    }
    return (/input|select|textarea|button|object/.test(nodeName) ?
      !element.disabled :
      "a" === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible(element);
  }

  function visible(element) {
    return $.expr.filters.visible(element) &&
      !$(element).parents().addBack().filter(function () {
        return $.css(this, "visibility") === "hidden";
      }).length;
  }

  $.extend($.expr[":"], {
    data: $.expr.createPseudo ?
      $.expr.createPseudo(function (dataName) {
        return function (elem) {
          return !!$.data(elem, dataName);
        };
      }) :
      // support: jQuery <1.8
      function (elem, i, match) {
        return !!$.data(elem, match[3]);
      },

    focusable: function (element) {
      return focusable(element, !isNaN($.attr(element, "tabindex")));
    },

    tabbable: function (element) {
      var tabIndex = $.attr(element, "tabindex"),
        isTabIndexNaN = isNaN(tabIndex);
      return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    }
  });

  // support: jQuery <1.8
  if (!$("<a>").outerWidth(1).jquery) {
    $.each(["Width", "Height"], function (i, name) {
      var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
        type = name.toLowerCase(),
        orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };

      function reduce(elem, size, border, margin) {
        $.each(side, function () {
          size -= parseFloat($.css(elem, "padding" + this)) || 0;
          if (border) {
            size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
          }
          if (margin) {
            size -= parseFloat($.css(elem, "margin" + this)) || 0;
          }
        });
        return size;
      }

      $.fn["inner" + name] = function (size) {
        if (size === undefined) {
          return orig["inner" + name].call(this);
        }

        return this.each(function () {
          $(this).css(type, reduce(this, size) + "px");
        });
      };

      $.fn["outer" + name] = function (size, margin) {
        if (typeof size !== "number") {
          return orig["outer" + name].call(this, size);
        }

        return this.each(function () {
          $(this).css(type, reduce(this, size, true, margin) + "px");
        });
      };
    });
  }

  // support: jQuery <1.8
  if (!$.fn.addBack) {
    $.fn.addBack = function (selector) {
      return this.add(selector == null ?
        this.prevObject : this.prevObject.filter(selector)
      );
    };
  }

  // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
  if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
    $.fn.removeData = (function (removeData) {
      return function (key) {
        if (arguments.length) {
          return removeData.call(this, $.camelCase(key));
        } else {
          return removeData.call(this);
        }
      };
    })($.fn.removeData);
  }





  // deprecated
  $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

  $.support.selectstart = "onselectstart" in document.createElement("div");
  $.fn.extend({
    disableSelection: function () {
      return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
        ".ui-disableSelection", function (event) {
          event.preventDefault();
        });
    },

    enableSelection: function () {
      return this.unbind(".ui-disableSelection");
    }
  });

  $.extend($.ui, {
    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    plugin: {
      add: function (module, option, set) {
        var i,
          proto = $.ui[module].prototype;
        for (i in set) {
          proto.plugins[i] = proto.plugins[i] || [];
          proto.plugins[i].push([option, set[i]]);
        }
      },
      call: function (instance, name, args) {
        var i,
          set = instance.plugins[name];
        if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
          return;
        }

        for (i = 0; i < set.length; i++) {
          if (instance.options[set[i][0]]) {
            set[i][1].apply(instance.element, args);
          }
        }
      }
    },

    // only used by resizable
    hasScroll: function (el, a) {

      //If overflow is hidden, the element might have extra content, but the user wants to hide it
      if ($(el).css("overflow") === "hidden") {
        return false;
      }

      var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
        has = false;

      if (el[scroll] > 0) {
        return true;
      }

      // TODO: determine which cases actually cause this to happen
      // if the element doesn't have the scroll set, see if it's possible to
      // set the scroll
      el[scroll] = 1;
      has = (el[scroll] > 0);
      el[scroll] = 0;
      return has;
    }
  });

})(jQuery);
(function ($, undefined) {

  var uuid = 0,
    slice = Array.prototype.slice,
    _cleanData = $.cleanData;
  $.cleanData = function (elems) {
    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
      try {
        $(elem).triggerHandler("remove");
        // http://bugs.jquery.com/ticket/8235
      } catch (e) { }
    }
    _cleanData(elems);
  };

  $.widget = function (name, base, prototype) {
    var fullName, existingConstructor, constructor, basePrototype,
      // proxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)
      proxiedPrototype = {},
      namespace = name.split(".")[0];

    name = name.split(".")[1];
    fullName = namespace + "-" + name;

    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }

    // create selector for plugin
    $.expr[":"][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };

    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }

      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      // copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend({}, prototype),
      // track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    });

    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = (function () {
        var _super = function () {
          return base.prototype[prop].apply(this, arguments);
        },
          _superApply = function (args) {
            return base.prototype[prop].apply(this, args);
          };
        return function () {
          var __super = this._super,
            __superApply = this._superApply,
            returnValue;

          this._super = _super;
          this._superApply = _superApply;

          returnValue = value.apply(this, arguments);

          this._super = __super;
          this._superApply = __superApply;

          return returnValue;
        };
      })();
    });
    constructor.prototype = $.widget.extend(basePrototype, {
      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
    }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;

        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }

    $.widget.bridge(name, constructor);
  };

  $.widget.extend = function (target) {
    var input = slice.call(arguments, 1),
      inputIndex = 0,
      inputLength = input.length,
      key,
      value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ?
              $.widget.extend({}, target[key], value) :
              // Don't extend strings, arrays, etc. with objects
              $.widget.extend({}, value);
            // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };

  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === "string",
        args = slice.call(arguments, 1),
        returnValue = this;

      // allow multiple hashes to be passed on init
      options = !isMethodCall && args.length ?
        $.widget.extend.apply(null, [options].concat(args)) :
        options;

      if (isMethodCall) {
        this.each(function () {
          var methodValue,
            instance = $.data(this, fullName);
          if (!instance) {
            return $.error("cannot call methods on " + name + " prior to initialization; " +
              "attempted to call method '" + options + "'");
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
            return $.error("no such method '" + options + "' for " + name + " widget instance");
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ?
              returnValue.pushStack(methodValue.get()) :
              methodValue;
            return false;
          }
        });
      } else {
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {})._init();
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }

      return returnValue;
    };
  };

  $.Widget = function ( /* options, element */) { };
  $.Widget._childConstructors = [];

  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      disabled: false,

      // callbacks
      create: null
    },
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = uuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
      this.options = $.widget.extend({},
        this.options,
        this._getCreateOptions(),
        options);

      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();

      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ?
          // element within the document
          element.ownerDocument :
          // element is window or document
          element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }

      this._create();
      this._trigger("create", null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,

    destroy: function () {
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
        .unbind(this.eventNamespace)
        // 1.9 BC for #7810
        // TODO remove dual storage
        .removeData(this.widgetName)
        .removeData(this.widgetFullName)
        // support: jquery <1.6.3
        // http://bugs.jquery.com/ticket/9413
        .removeData($.camelCase(this.widgetFullName));
      this.widget()
        .unbind(this.eventNamespace)
        .removeAttr("aria-disabled")
        .removeClass(
          this.widgetFullName + "-disabled " +
          "ui-state-disabled");

      // clean up events and states
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass("ui-state-hover");
      this.focusable.removeClass("ui-state-focus");
    },
    _destroy: $.noop,

    widget: function () {
      return this.element;
    },

    option: function (key, value) {
      var options = key,
        parts,
        curOption,
        i;

      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      if (typeof key === "string") {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (value === undefined) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (value === undefined) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }

      this._setOptions(options);

      return this;
    },
    _setOptions: function (options) {
      var key;

      for (key in options) {
        this._setOption(key, options[key]);
      }

      return this;
    },
    _setOption: function (key, value) {
      this.options[key] = value;

      if (key === "disabled") {
        this.widget()
          .toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
          .attr("aria-disabled", value);
        this.hoverable.removeClass("ui-state-hover");
        this.focusable.removeClass("ui-state-focus");
      }

      return this;
    },

    enable: function () {
      return this._setOption("disabled", false);
    },
    disable: function () {
      return this._setOption("disabled", true);
    },

    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement,
        instance = this;

      // no suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // no element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        // accept selectors, DOM elements
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }

      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck &&
            (instance.options.disabled === true ||
              $(this).hasClass("ui-state-disabled"))) {
            return;
          }
          return (typeof handler === "string" ? instance[handler] : handler)
            .apply(instance, arguments);
        }

        // copy the guid so direct unbinding works
        if (typeof handler !== "string") {
          handlerProxy.guid = handler.guid =
            handler.guid || handlerProxy.guid || $.guid++;
        }

        var match = event.match(/^(\w+)\s*(.*)$/),
          eventName = match[1] + instance.eventNamespace,
          selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },

    _off: function (element, eventName) {
      eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
    },

    _delay: function (handler, delay) {
      function handlerProxy() {
        return (typeof handler === "string" ? instance[handler] : handler)
          .apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },

    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          $(event.currentTarget).addClass("ui-state-hover");
        },
        mouseleave: function (event) {
          $(event.currentTarget).removeClass("ui-state-hover");
        }
      });
    },

    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          $(event.currentTarget).addClass("ui-state-focus");
        },
        focusout: function (event) {
          $(event.currentTarget).removeClass("ui-state-focus");
        }
      });
    },

    _trigger: function (type, event, data) {
      var prop, orig,
        callback = this.options[type];

      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ?
        type :
        this.widgetEventPrefix + type).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];

      // copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }

      this.element.trigger(event, data);
      return !($.isFunction(callback) &&
        callback.apply(this.element[0], [event].concat(data)) === false ||
        event.isDefaultPrevented());
    }
  };

  $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
    $.Widget.prototype["_" + method] = function (element, options, callback) {
      if (typeof options === "string") {
        options = { effect: options };
      }
      var hasOptions,
        effectName = !options ?
          method :
          options === true || typeof options === "number" ?
            defaultEffect :
            options.effect || defaultEffect;
      options = options || {};
      if (typeof options === "number") {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });

})(jQuery);
(function ($, undefined) {

  $.ui = $.ui || {};

  var cachedScrollbarWidth,
    max = Math.max,
    abs = Math.abs,
    round = Math.round,
    rhorizontal = /left|center|right/,
    rvertical = /top|center|bottom/,
    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
    rposition = /^\w+/,
    rpercent = /%$/,
    _position = $.fn.position;

  function getOffsets(offsets, width, height) {
    return [
      parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
      parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
    ];
  }

  function parseCss(element, property) {
    return parseInt($.css(element, property), 10) || 0;
  }

  function getDimensions(elem) {
    var raw = elem[0];
    if (raw.nodeType === 9) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: 0, left: 0 }
      };
    }
    if ($.isWindow(raw)) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
      };
    }
    if (raw.preventDefault) {
      return {
        width: 0,
        height: 0,
        offset: { top: raw.pageY, left: raw.pageX }
      };
    }
    return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset()
    };
  }

  $.position = {
    scrollbarWidth: function () {
      if (cachedScrollbarWidth !== undefined) {
        return cachedScrollbarWidth;
      }
      var w1, w2,
        div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
        innerDiv = div.children()[0];

      $("body").append(div);
      w1 = innerDiv.offsetWidth;
      div.css("overflow", "scroll");

      w2 = innerDiv.offsetWidth;

      if (w1 === w2) {
        w2 = div[0].clientWidth;
      }

      div.remove();

      return (cachedScrollbarWidth = w1 - w2);
    },
    getScrollInfo: function (within) {
      var overflowX = within.isWindow ? "" : within.element.css("overflow-x"),
        overflowY = within.isWindow ? "" : within.element.css("overflow-y"),
        hasOverflowX = overflowX === "scroll" ||
          (overflowX === "auto" && within.width < within.element[0].scrollWidth),
        hasOverflowY = overflowY === "scroll" ||
          (overflowY === "auto" && within.height < within.element[0].scrollHeight);
      return {
        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
        height: hasOverflowX ? $.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function (element) {
      var withinElement = $(element || window),
        isWindow = $.isWindow(withinElement[0]);
      return {
        element: withinElement,
        isWindow: isWindow,
        offset: withinElement.offset() || { left: 0, top: 0 },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
        height: isWindow ? withinElement.height() : withinElement.outerHeight()
      };
    }
  };

  $.fn.position = function (options) {
    if (!options || !options.of) {
      return _position.apply(this, arguments);
    }

    // make a copy, we don't want to modify arguments
    options = $.extend({}, options);

    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
      target = $(options.of),
      within = $.position.getWithinInfo(options.within),
      scrollInfo = $.position.getScrollInfo(within),
      collision = (options.collision || "flip").split(" "),
      offsets = {};

    dimensions = getDimensions(target);
    if (target[0].preventDefault) {
      // force left top to allow flipping
      options.at = "left top";
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
    // clone to reuse original targetOffset later
    basePosition = $.extend({}, targetOffset);

    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each(["my", "at"], function () {
      var pos = (options[this] || "").split(" "),
        horizontalOffset,
        verticalOffset;

      if (pos.length === 1) {
        pos = rhorizontal.test(pos[0]) ?
          pos.concat(["center"]) :
          rvertical.test(pos[0]) ?
            ["center"].concat(pos) :
            ["center", "center"];
      }
      pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
      pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

      // calculate offsets
      horizontalOffset = roffset.exec(pos[0]);
      verticalOffset = roffset.exec(pos[1]);
      offsets[this] = [
        horizontalOffset ? horizontalOffset[0] : 0,
        verticalOffset ? verticalOffset[0] : 0
      ];

      // reduce to just the positions without the offsets
      options[this] = [
        rposition.exec(pos[0])[0],
        rposition.exec(pos[1])[0]
      ];
    });

    // normalize collision option
    if (collision.length === 1) {
      collision[1] = collision[0];
    }

    if (options.at[0] === "right") {
      basePosition.left += targetWidth;
    } else if (options.at[0] === "center") {
      basePosition.left += targetWidth / 2;
    }

    if (options.at[1] === "bottom") {
      basePosition.top += targetHeight;
    } else if (options.at[1] === "center") {
      basePosition.top += targetHeight / 2;
    }

    atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
    basePosition.left += atOffset[0];
    basePosition.top += atOffset[1];

    return this.each(function () {
      var collisionPosition, using,
        elem = $(this),
        elemWidth = elem.outerWidth(),
        elemHeight = elem.outerHeight(),
        marginLeft = parseCss(this, "marginLeft"),
        marginTop = parseCss(this, "marginTop"),
        collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
        collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
        position = $.extend({}, basePosition),
        myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

      if (options.my[0] === "right") {
        position.left -= elemWidth;
      } else if (options.my[0] === "center") {
        position.left -= elemWidth / 2;
      }

      if (options.my[1] === "bottom") {
        position.top -= elemHeight;
      } else if (options.my[1] === "center") {
        position.top -= elemHeight / 2;
      }

      position.left += myOffset[0];
      position.top += myOffset[1];

      // if the browser doesn't support fractions, then round for consistent results
      if (!$.support.offsetFractions) {
        position.left = round(position.left);
        position.top = round(position.top);
      }

      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop
      };

      $.each(["left", "top"], function (i, dir) {
        if ($.ui.position[collision[i]]) {
          $.ui.position[collision[i]][dir](position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem
          });
        }
      });

      if (options.using) {
        // adds feedback as second argument to using callback, if present
        using = function (props) {
          var left = targetOffset.left - position.left,
            right = left + targetWidth - elemWidth,
            top = targetOffset.top - position.top,
            bottom = top + targetHeight - elemHeight,
            feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight
              },
              horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
              vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
            };
          if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
            feedback.horizontal = "center";
          }
          if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
            feedback.vertical = "middle";
          }
          if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
            feedback.important = "horizontal";
          } else {
            feedback.important = "vertical";
          }
          options.using.call(this, props, feedback);
        };
      }

      elem.offset($.extend(position, { using: using }));
    });
  };

  $.ui.position = {
    fit: {
      left: function (position, data) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
          outerWidth = within.width,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = withinOffset - collisionPosLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
          newOverRight;

        // element is wider than within
        if (data.collisionWidth > outerWidth) {
          // element is initially over the left side of within
          if (overLeft > 0 && overRight <= 0) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;
            // element is initially over right side of within
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset;
            // element is initially over both left and right sides of within
          } else {
            if (overLeft > overRight) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }
          // too far left -> align with left edge
        } else if (overLeft > 0) {
          position.left += overLeft;
          // too far right -> align with right edge
        } else if (overRight > 0) {
          position.left -= overRight;
          // adjust based on position and margin
        } else {
          position.left = max(position.left - collisionPosLeft, position.left);
        }
      },
      top: function (position, data) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
          outerHeight = data.within.height,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = withinOffset - collisionPosTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
          newOverBottom;

        // element is taller than within
        if (data.collisionHeight > outerHeight) {
          // element is initially over the top of within
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;
            // element is initially over bottom of within
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset;
            // element is initially over both top and bottom of within
          } else {
            if (overTop > overBottom) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }
          // too far up -> align with top
        } else if (overTop > 0) {
          position.top += overTop;
          // too far down -> align with bottom edge
        } else if (overBottom > 0) {
          position.top -= overBottom;
          // adjust based on position and margin
        } else {
          position.top = max(position.top - collisionPosTop, position.top);
        }
      }
    },
    flip: {
      left: function (position, data) {
        var within = data.within,
          withinOffset = within.offset.left + within.scrollLeft,
          outerWidth = within.width,
          offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = collisionPosLeft - offsetLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
          myOffset = data.my[0] === "left" ?
            -data.elemWidth :
            data.my[0] === "right" ?
              data.elemWidth :
              0,
          atOffset = data.at[0] === "left" ?
            data.targetWidth :
            data.at[0] === "right" ?
              -data.targetWidth :
              0,
          offset = -2 * data.offset[0],
          newOverRight,
          newOverLeft;

        if (overLeft < 0) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
          if (newOverRight < 0 || newOverRight < abs(overLeft)) {
            position.left += myOffset + atOffset + offset;
          }
        }
        else if (overRight > 0) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
          if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function (position, data) {
        var within = data.within,
          withinOffset = within.offset.top + within.scrollTop,
          outerHeight = within.height,
          offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = collisionPosTop - offsetTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
          top = data.my[1] === "top",
          myOffset = top ?
            -data.elemHeight :
            data.my[1] === "bottom" ?
              data.elemHeight :
              0,
          atOffset = data.at[1] === "top" ?
            data.targetHeight :
            data.at[1] === "bottom" ?
              -data.targetHeight :
              0,
          offset = -2 * data.offset[1],
          newOverTop,
          newOverBottom;
        if (overTop < 0) {
          newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
          if ((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
            position.top += myOffset + atOffset + offset;
          }
        }
        else if (overBottom > 0) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
          if ((position.top + myOffset + atOffset + offset) > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    },
    flipfit: {
      left: function () {
        $.ui.position.flip.left.apply(this, arguments);
        $.ui.position.fit.left.apply(this, arguments);
      },
      top: function () {
        $.ui.position.flip.top.apply(this, arguments);
        $.ui.position.fit.top.apply(this, arguments);
      }
    }
  };

  // fraction support test
  (function () {
    var testElement, testElementParent, testElementStyle, offsetLeft, i,
      body = document.getElementsByTagName("body")[0],
      div = document.createElement("div");

    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement(body ? "div" : "body");
    testElementStyle = {
      visibility: "hidden",
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: "none"
    };
    if (body) {
      $.extend(testElementStyle, {
        position: "absolute",
        left: "-1000px",
        top: "-1000px"
      });
    }
    for (i in testElementStyle) {
      testElement.style[i] = testElementStyle[i];
    }
    testElement.appendChild(div);
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore(testElement, testElementParent.firstChild);

    div.style.cssText = "position: absolute; left: 10.7432222px;";

    offsetLeft = $(div).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

    testElement.innerHTML = "";
    testElementParent.removeChild(testElement);
  })();

}(jQuery));
(function ($, undefined) {

  // used to prevent race conditions with remote data sources
  var requestIndex = 0;

  $.widget("ui.autocomplete", {
    version: "1.10.3",
    defaultElement: "<input>",
    options: {
      appendTo: null,
      autoFocus: false,
      delay: 300,
      minLength: 1,
      position: {
        my: "left top",
        at: "left bottom",
        collision: "none"
      },
      source: null,
      cancelClose: false,

      // callbacks
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },

    pending: 0,

    _create: function () {
      // Some browsers only repeat keydown events, not keypress events,
      // so we use the suppressKeyPress flag to determine if we've already
      // handled the keydown event. #7269
      // Unfortunately the code for & in keypress is the same as the up arrow,
      // so we use the suppressKeyPressRepeat flag to avoid handling keypress
      // events when we know the keydown event was used to modify the
      // search term. #7799
      var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
        nodeName = this.element[0].nodeName.toLowerCase(),
        isTextarea = nodeName === "textarea",
        isInput = nodeName === "input";

      this.isMultiLine =
        // Textareas are always multi-line
        isTextarea ? true :
          // Inputs are always single-line, even if inside a contentEditable element
          // IE also treats inputs as contentEditable
          isInput ? false :
            // All other element types are determined by whether or not they're contentEditable
            this.element.prop("isContentEditable");

      this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
      this.isNewMenu = true;

      this.element
        .addClass("ui-autocomplete-input")
        .attr("autocomplete", "off");

      this._on(this.element, {
        keydown: function (event) {
          /*jshint maxcomplexity:15*/
          if (this.element.prop("readOnly")) {
            suppressKeyPress = true;
            suppressInput = true;
            suppressKeyPressRepeat = true;
            return;
          }

          suppressKeyPress = false;
          suppressInput = false;
          suppressKeyPressRepeat = false;
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
            case keyCode.PAGE_UP:
              suppressKeyPress = true;
              this._move("previousPage", event);
              break;
            case keyCode.PAGE_DOWN:
              suppressKeyPress = true;
              this._move("nextPage", event);
              break;
            case keyCode.UP:
              suppressKeyPress = true;
              this._keyEvent("previous", event);
              break;
            case keyCode.DOWN:
              suppressKeyPress = true;
              this._keyEvent("next", event);
              break;
            case keyCode.ENTER:
            case keyCode.NUMPAD_ENTER:
              // when menu is open and has focus
              if (this.menu.active) {
                // #6055 - Opera still allows the keypress to occur
                // which causes forms to submit
                suppressKeyPress = true;
                event.preventDefault();
                this.menu.select(event);
              }
              break;
            case keyCode.TAB:
              if (this.menu.active) {
                this.menu.select(event);
              }
              break;
            case keyCode.ESCAPE:
              if (this.menu.element.is(":visible")) {
                this._value(this.term);
                this.close(event);
                // Different browsers have different default behavior for escape
                // Single press can mean undo or clear
                // Double press in IE means clear the whole form
                event.preventDefault();
              }
              break;
            default:
              suppressKeyPressRepeat = true;
              // search timeout should be triggered before the input value is changed
              this._searchTimeout(event);
              break;
          }
        },
        keypress: function (event) {
          if (suppressKeyPress) {
            suppressKeyPress = false;
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
              event.preventDefault();
            }
            return;
          }
          if (suppressKeyPressRepeat) {
            return;
          }

          // replicate some key handlers to allow them to repeat in Firefox and Opera
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
            case keyCode.PAGE_UP:
              this._move("previousPage", event);
              break;
            case keyCode.PAGE_DOWN:
              this._move("nextPage", event);
              break;
            case keyCode.UP:
              this._keyEvent("previous", event);
              break;
            case keyCode.DOWN:
              this._keyEvent("next", event);
              break;
          }
        },
        input: function (event) {
          if (suppressInput) {
            suppressInput = false;
            event.preventDefault();
            return;
          }
          this._searchTimeout(event);
        },
        focus: function () {
          this.selectedItem = null;
          this.previous = this._value();
        },
        blur: function (event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }

          clearTimeout(this.searching);
          this.close(event);
          this._change(event);
        }
      });

      this._initSource();
      this.menu = $("<ul>")
        .addClass("ui-autocomplete ui-front")
        .appendTo(this._appendTo())
        .menu({
          // disable ARIA support, the live region takes care of that
          role: null
        })
        .hide()
        .data("ui-menu");

      this._on(this.menu.element, {
        mousedown: function (event) {
          // prevent moving focus out of the text field
          event.preventDefault();

          // IE doesn't prevent moving focus even with event.preventDefault()
          // so we set a flag to know when we should ignore the blur event
          this.cancelBlur = true;
          this._delay(function () {
            delete this.cancelBlur;
          });

          // clicking on the scrollbar causes focus to shift to the body
          // but we can't detect a mouseup or a click immediately afterward
          // so we have to track the next mousedown and close the menu if
          // the user clicks somewhere outside of the autocomplete
          var menuElement = this.menu.element[0];
          if (!$(event.target).closest(".ui-menu-item").length) {
            this._delay(function () {
              var that = this;
              this.document.one("mousedown", function (event) {
                if (event.target !== that.element[0] &&
                  event.target !== menuElement &&
                  !$.contains(menuElement, event.target)) {
                  that.close();
                }
              });
            });
          }
        },
        menufocus: function (event, ui) {
          // support: Firefox
          // Prevent accidental activation of menu items in Firefox (#7024 #9118)
          if (this.isNewMenu) {
            this.isNewMenu = false;
            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
              this.menu.blur();

              this.document.one("mousemove", function () {
                $(event.target).trigger(event.originalEvent);
              });

              return;
            }
          }

          var item = ui.item.data("ui-autocomplete-item");
          if (false !== this._trigger("focus", event, { item: item })) {
            // use value to match what will end up in the input, if it was a key event
            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
              this._value(item.value);
            }
          } else {
            // Normally the input is populated with the item's value as the
            // menu is navigated, causing screen readers to notice a change and
            // announce the item. Since the focus event was canceled, this doesn't
            // happen, so we update the live region so that screen readers can
            // still notice the change and announce it.
            this.liveRegion.text(item.value);
          }
        },
        menuselect: function (event, ui) {
          var item = ui.item.data("ui-autocomplete-item"),
            previous = this.previous;

          // only trigger when focus was lost (click on menu)
          if (this.element[0] !== this.document[0].activeElement) {
            this.element.focus();
            this.previous = previous;
            // #6109 - IE triggers two focus events and the second
            // is asynchronous, so we need to reset the previous
            // term synchronously and asynchronously :-(
            this._delay(function () {
              this.previous = previous;
              this.selectedItem = item;
            });
          }

          if (false !== this._trigger("select", event, { item: item })) {
            this._value(item.value);
          }
          // reset the term after the select event
          // this allows custom select handling to work properly
          this.term = this._value();

          this.close(event);
          this.selectedItem = item;
        }
      });

      this.liveRegion = $("<span>", {
        role: "status",
        "aria-live": "polite"
      })
        .addClass("ui-helper-hidden-accessible")
        .insertBefore(this.element);

      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr("autocomplete");
        }
      });
    },

    _destroy: function () {
      clearTimeout(this.searching);
      this.element
        .removeClass("ui-autocomplete-input")
        .removeAttr("autocomplete");
      this.menu.element.remove();
      this.liveRegion.remove();
    },

    _setOption: function (key, value) {
      this._super(key, value);
      if (key === "source") {
        this._initSource();
      }
      if (key === "appendTo") {
        this.menu.element.appendTo(this._appendTo());
      }
      if (key === "disabled" && value && this.xhr) {
        this.xhr.abort();
      }
    },

    _appendTo: function () {
      var element = this.options.appendTo;

      if (element) {
        element = element.jquery || element.nodeType ?
          $(element) :
          this.document.find(element).eq(0);
      }

      if (!element) {
        element = this.element.closest(".ui-front");
      }

      if (!element.length) {
        element = this.document[0].body;
      }

      return element;
    },

    _initSource: function () {
      var array, url,
        that = this;
      if ($.isArray(this.options.source)) {
        array = this.options.source;
        this.source = function (request, response) {
          response($.ui.autocomplete.filter(array, request.term));
        };
      } else if (typeof this.options.source === "string") {
        url = this.options.source;
        this.source = function (request, response) {
          if (that.xhr) {
            that.xhr.abort();
          }
          that.xhr = $.ajax({
            url: url,
            data: request,
            dataType: "json",
            success: function (data) {
              response(data);
            },
            error: function () {
              response([]);
            }
          });
        };
      } else {
        this.source = this.options.source;
      }
    },

    _searchTimeout: function (event) {
      clearTimeout(this.searching);
      this.searching = this._delay(function () {
        // only search if the value has changed
        if (this.term !== this._value()) {
          this.selectedItem = null;
          this.search(null, event);
        }
      }, this.options.delay);
    },

    search: function (value, event) {
      value = value != null ? value : this._value();

      // always save the actual value, not the one passed as an argument
      this.term = this._value();

      if (value.length < this.options.minLength) {
        return this.close(event);
      }

      if (this._trigger("search", event) === false) {
        return;
      }

      return this._search(value);
    },

    _search: function (value) {
      this.pending++;
      this.element.addClass("ui-autocomplete-loading");
      this.cancelSearch = false;

      this.source({ term: value }, this._response());
    },

    _response: function () {
      var that = this,
        index = ++requestIndex;

      return function (content) {
        if (index === requestIndex) {
          that.__response(content);
        }

        that.pending--;
        if (!that.pending) {
          that.element.removeClass("ui-autocomplete-loading");
        }
      };
    },

    __response: function (content) {
      if (content) {
        content = this._normalize(content);
      }
      this._trigger("response", null, { content: content });
      if (!this.options.disabled && content && content.length && !this.cancelSearch) {
        this._suggest(content);
        this._trigger("open");
      } else {
        // use ._close() instead of .close() so we don't cancel future searches
        this._close();
      }
    },
    close: function (event) {
      if (!this.options.cancelClose) {
        this.cancelSearch = true;
        this._close(event);
      }
    },
    _close: function (event) {
      if (this.menu.element.is(":visible")) {
        this.menu.element.hide();
        this.menu.blur();
        this.isNewMenu = true;
        this._trigger("close", event);
      }
    },

    _change: function (event) {
      if (this.previous !== this._value()) {
        this._trigger("change", event, { item: this.selectedItem });
      }
    },

    _normalize: function (items) {
      // assume all items have the right format when the first item is complete
      if (items.length && items[0].label && items[0].value) {
        return items;
      }
      return $.map(items, function (item) {
        if (typeof item === "string") {
          return {
            label: item,
            value: item
          };
        }
        return $.extend({
          label: item.label || item.value,
          value: item.value || item.label
        }, item);
      });
    },

    _suggest: function (items) {
      var ul = this.menu.element.empty();
      this._renderMenu(ul, items);
      this.isNewMenu = true;
      this.menu.refresh();

      // size and position menu
      ul.show();
      this._resizeMenu();
      ul.position($.extend({
        of: this.element
      }, this.options.position));

      if (this.options.autoFocus) {
        this.menu.next();
      }
    },

    _resizeMenu: function () {
      var ul = this.menu.element;
      ul.outerWidth(Math.max(
        // Firefox wraps long text (possibly a rounding bug)
        // so we add 1px to avoid the wrapping (#7513)
        ul.width("").outerWidth() + 1,
        this.element.outerWidth()
      ));
    },

    _renderMenu: function (ul, items) {
      var that = this;
      $.each(items, function (index, item) {
        that._renderItemData(ul, item);
      });
    },

    _renderItemData: function (ul, item) {
      return this._renderItem(ul, item).data("ui-autocomplete-item", item);
    },

    _renderItem: function (ul, item) {
      return $("<li>")
        .append($("<a>").text(item.label))
        .appendTo(ul);
    },

    _move: function (direction, event) {
      if (!this.menu.element.is(":visible")) {
        this.search(null, event);
        return;
      }
      if (this.menu.isFirstItem() && /^previous/.test(direction) ||
        this.menu.isLastItem() && /^next/.test(direction)) {
        this._value(this.term);
        this.menu.blur();
        return;
      }
      this.menu[direction](event);
    },

    widget: function () {
      return this.menu.element;
    },

    _value: function () {
      return this.valueMethod.apply(this.element, arguments);
    },

    _keyEvent: function (keyEvent, event) {
      if (!this.isMultiLine || this.menu.element.is(":visible")) {
        this._move(keyEvent, event);

        // prevents moving cursor to beginning/end of the text field in some browsers
        event.preventDefault();
      }
    }
  });

  $.extend($.ui.autocomplete, {
    escapeRegex: function (value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    },
    filter: function (array, term) {
      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
      return $.grep(array, function (value) {
        return matcher.test(value.label || value.value || value);
      });
    }
  });


  // live region extension, adding a `messages` option
  // NOTE: This is an experimental API. We are still investigating
  // a full solution for string manipulation and internationalization.
  $.widget("ui.autocomplete", $.ui.autocomplete, {
    options: {
      messages: {
        noResults: "No search results.",
        results: function (amount) {
          return amount + (amount > 1 ? " results are" : " result is") +
            " available, use TAB key to navigate.";
        }
      }
    },

    __response: function (content) {
      var message;
      this._superApply(arguments);
      if (this.options.disabled || this.cancelSearch) {
        return;
      }
      if (content && content.length) {
        message = this.options.messages.results(content.length);
      } else {
        message = this.options.messages.noResults;
      }
      this.liveRegion.text(message);
    }
  });

}(jQuery));
(function ($, undefined) {

  $.widget("ui.menu", {
    version: "1.10.3",
    defaultElement: "<ul>",
    delay: 300,
    options: {
      icons: {
        submenu: "ui-icon-carat-1-e"
      },
      menus: "ul",
      position: {
        my: "left top",
        at: "right top"
      },
      role: "menu",

      // callbacks
      blur: null,
      focus: null,
      select: null
    },

    _create: function () {
      this.activeMenu = this.element;
      // flag used to prevent firing of the click handler
      // as the event bubbles up through nested menus
      this.mouseHandled = false;
      this.element
        .uniqueId()
        .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
        .toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length)
        .attr({
          role: this.options.role,
          tabIndex: 0
        })
        // need to catch all clicks on disabled menu
        // not possible through _on
        .bind("click" + this.eventNamespace, $.proxy(function (event) {
          if (this.options.disabled) {
            event.preventDefault();
          }
        }, this));

      if (this.options.disabled) {
        this.element
          .addClass("ui-state-disabled")
          .attr("aria-disabled", "true");
      }

      this._on({
        // Prevent focus from sticking to links inside menu after clicking
        // them (focus should always stay on UL during navigation).
        "mousedown .ui-menu-item > a": function (event) {
          event.preventDefault();
        },
        "click .ui-state-disabled > a": function (event) {
          event.preventDefault();
        },
        "click .ui-menu-item:has(a)": function (event) {
          var target = $(event.target).closest(".ui-menu-item");
          if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
            this.mouseHandled = true;

            this.select(event);
            // Open submenu on click
            if (target.has(".ui-menu").length) {
              this.expand(event);
            } else if (!this.element.is(":focus")) {
              // Redirect focus to the menu
              this.element.trigger("focus", [true]);

              // If the active item is on the top level, let it stay active.
              // Otherwise, blur the active item since it is no longer visible.
              if (this.active && this.active.parents(".ui-menu").length === 1) {
                clearTimeout(this.timer);
              }
            }
          }
        },
        "mouseenter .ui-menu-item": function (event) {
          var target = $(event.currentTarget);
          // Remove ui-state-active class from siblings of the newly focused menu item
          // to avoid a jump caused by adjacent elements both having a class with a border
          target.siblings().children(".ui-state-active").removeClass("ui-state-active");
          this.focus(event, target);
        },
        mouseleave: "collapseAll",
        "mouseleave .ui-menu": "collapseAll",
        focus: function (event, keepActiveItem) {
          // If there's already an active item, keep it active
          // If not, activate the first item
          var item = this.active || this.element.children(".ui-menu-item").eq(0);

          if (!keepActiveItem) {
            this.focus(event, item);
          }
        },
        blur: function (event) {
          this._delay(function () {
            if (!$.contains(this.element[0], this.document[0].activeElement)) {
              this.collapseAll(event);
            }
          });
        },
        keydown: "_keydown"
      });

      this.refresh();

      // Clicks outside of a menu collapse any open menus
      this._on(this.document, {
        click: function (event) {
          if (!$(event.target).closest(".ui-menu").length) {
            this.collapseAll(event);
          }

          // Reset the mouseHandled flag
          this.mouseHandled = false;
        }
      });
    },

    _destroy: function () {
      // Destroy (sub)menus
      this.element
        .removeAttr("aria-activedescendant")
        .find(".ui-menu").addBack()
        .removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons")
        .removeAttr("role")
        .removeAttr("tabIndex")
        .removeAttr("aria-labelledby")
        .removeAttr("aria-expanded")
        .removeAttr("aria-hidden")
        .removeAttr("aria-disabled")
        .removeUniqueId()
        .show();

      // Destroy menu items
      this.element.find(".ui-menu-item")
        .removeClass("ui-menu-item")
        .removeAttr("role")
        .removeAttr("aria-disabled")
        .children("a")
        .removeUniqueId()
        .removeClass("ui-corner-all ui-state-hover")
        .removeAttr("tabIndex")
        .removeAttr("role")
        .removeAttr("aria-haspopup")
        .children().each(function () {
          var elem = $(this);
          if (elem.data("ui-menu-submenu-carat")) {
            elem.remove();
          }
        });

      // Destroy menu dividers
      this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
    },

    _keydown: function (event) {
      /*jshint maxcomplexity:20*/
      var match, prev, character, skip, regex,
        preventDefault = true;

      function escape(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }

      switch (event.keyCode) {
        case $.ui.keyCode.PAGE_UP:
          this.previousPage(event);
          break;
        case $.ui.keyCode.PAGE_DOWN:
          this.nextPage(event);
          break;
        case $.ui.keyCode.HOME:
          this._move("first", "first", event);
          break;
        case $.ui.keyCode.END:
          this._move("last", "last", event);
          break;
        case $.ui.keyCode.UP:
          this.previous(event);
          break;
        case $.ui.keyCode.DOWN:
          this.next(event);
          break;
        case $.ui.keyCode.LEFT:
          this.collapse(event);
          break;
        case $.ui.keyCode.RIGHT:
          if (this.active && !this.active.is(".ui-state-disabled")) {
            this.expand(event);
          }
          break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
          this._activate(event);
          break;
        case $.ui.keyCode.ESCAPE:
          this.collapse(event);
          break;
        default:
          preventDefault = false;
          prev = this.previousFilter || "";
          character = String.fromCharCode(event.keyCode);
          skip = false;

          clearTimeout(this.filterTimer);

          if (character === prev) {
            skip = true;
          } else {
            character = prev + character;
          }

          regex = new RegExp("^" + escape(character), "i");
          match = this.activeMenu.children(".ui-menu-item").filter(function () {
            return regex.test($(this).children("a").text());
          });
          match = skip && match.index(this.active.next()) !== -1 ?
            this.active.nextAll(".ui-menu-item") :
            match;

          // If no matches on the current filter, reset to the last character pressed
          // to move down the menu to the first item that starts with that character
          if (!match.length) {
            character = String.fromCharCode(event.keyCode);
            regex = new RegExp("^" + escape(character), "i");
            match = this.activeMenu.children(".ui-menu-item").filter(function () {
              return regex.test($(this).children("a").text());
            });
          }

          if (match.length) {
            this.focus(event, match);
            if (match.length > 1) {
              this.previousFilter = character;
              this.filterTimer = this._delay(function () {
                delete this.previousFilter;
              }, 1000);
            } else {
              delete this.previousFilter;
            }
          } else {
            delete this.previousFilter;
          }
      }

      if (preventDefault) {
        event.preventDefault();
      }
    },

    _activate: function (event) {
      if (!this.active.is(".ui-state-disabled")) {
        if (this.active.children("a[aria-haspopup='true']").length) {
          this.expand(event);
        } else {
          this.select(event);
        }
      }
    },

    refresh: function () {
      var menus,
        icon = this.options.icons.submenu,
        submenus = this.element.find(this.options.menus);

      // Initialize nested menus
      submenus.filter(":not(.ui-menu)")
        .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
        .hide()
        .attr({
          role: this.options.role,
          "aria-hidden": "true",
          "aria-expanded": "false"
        })
        .each(function () {
          var menu = $(this),
            item = menu.prev("a"),
            submenuCarat = $("<span>")
              .addClass("ui-menu-icon ui-icon " + icon)
              .data("ui-menu-submenu-carat", true);

          item
            .attr("aria-haspopup", "true")
            .prepend(submenuCarat);
          menu.attr("aria-labelledby", item.attr("id"));
        });

      menus = submenus.add(this.element);

      // Don't refresh list items that are already adapted
      menus.children(":not(.ui-menu-item):has(a)")
        .addClass("ui-menu-item")
        .attr("role", "presentation")
        .children("a")
        .uniqueId()
        .addClass("ui-corner-all")
        .attr({
          tabIndex: -1,
          role: this._itemRole()
        });

      // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
      menus.children(":not(.ui-menu-item)").each(function () {
        var item = $(this);
        // hyphen, em dash, en dash
        if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
          item.addClass("ui-widget-content ui-menu-divider");
        }
      });

      // Add aria-disabled attribute to any disabled menu item
      menus.children(".ui-state-disabled").attr("aria-disabled", "true");

      // If the active item has been removed, blur the menu
      if (this.active && !$.contains(this.element[0], this.active[0])) {
        this.blur();
      }
    },

    _itemRole: function () {
      return {
        menu: "menuitem",
        listbox: "option"
      }[this.options.role];
    },

    _setOption: function (key, value) {
      if (key === "icons") {
        this.element.find(".ui-menu-icon")
          .removeClass(this.options.icons.submenu)
          .addClass(value.submenu);
      }
      this._super(key, value);
    },

    focus: function (event, item) {
      var nested, focused;
      this.blur(event, event && event.type === "focus");

      this._scrollIntoView(item);

      this.active = item.first();
      focused = this.active.children("a").addClass("ui-state-focus");
      // Only update aria-activedescendant if there's a role
      // otherwise we assume focus is managed elsewhere
      if (this.options.role) {
        this.element.attr("aria-activedescendant", focused.attr("id"));
      }

      // Highlight active parent menu item, if any
      this.active
        .parent()
        .closest(".ui-menu-item")
        .children("a:first")
        .addClass("ui-state-active");

      if (event && event.type === "keydown") {
        this._close();
      } else {
        this.timer = this._delay(function () {
          this._close();
        }, this.delay);
      }

      nested = item.children(".ui-menu");
      if (nested.length && (/^mouse/.test(event.type))) {
        this._startOpening(nested);
      }
      this.activeMenu = item.parent();

      this._trigger("focus", event, { item: item });
    },

    _scrollIntoView: function (item) {
      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
      if (this._hasScroll()) {
        borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
        paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
        scroll = this.activeMenu.scrollTop();
        elementHeight = this.activeMenu.height();
        itemHeight = item.height();

        if (offset < 0) {
          this.activeMenu.scrollTop(scroll + offset);
        } else if (offset + itemHeight > elementHeight) {
          this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
        }
      }
    },

    blur: function (event, fromFocus) {
      if (!fromFocus) {
        clearTimeout(this.timer);
      }

      if (!this.active) {
        return;
      }

      this.active.children("a").removeClass("ui-state-focus");
      this.active = null;

      this._trigger("blur", event, { item: this.active });
    },

    _startOpening: function (submenu) {
      clearTimeout(this.timer);

      // Don't open if already open fixes a Firefox bug that caused a .5 pixel
      // shift in the submenu position when mousing over the carat icon
      if (submenu.attr("aria-hidden") !== "true") {
        return;
      }

      this.timer = this._delay(function () {
        this._close();
        this._open(submenu);
      }, this.delay);
    },

    _open: function (submenu) {
      var position = $.extend({
        of: this.active
      }, this.options.position);

      clearTimeout(this.timer);
      this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
        .hide()
        .attr("aria-hidden", "true");

      submenu
        .show()
        .removeAttr("aria-hidden")
        .attr("aria-expanded", "true")
        .position(position);
    },

    collapseAll: function (event, all) {
      clearTimeout(this.timer);
      this.timer = this._delay(function () {
        // If we were passed an event, look for the submenu that contains the event
        var currentMenu = all ? this.element :
          $(event && event.target).closest(this.element.find(".ui-menu"));

        // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
        if (!currentMenu.length) {
          currentMenu = this.element;
        }

        this._close(currentMenu);

        this.blur(event);
        this.activeMenu = currentMenu;
      }, this.delay);
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function (startMenu) {
      if (!startMenu) {
        startMenu = this.active ? this.active.parent() : this.element;
      }

      startMenu
        .find(".ui-menu")
        .hide()
        .attr("aria-hidden", "true")
        .attr("aria-expanded", "false")
        .end()
        .find("a.ui-state-active")
        .removeClass("ui-state-active");
    },

    collapse: function (event) {
      var newItem = this.active &&
        this.active.parent().closest(".ui-menu-item", this.element);
      if (newItem && newItem.length) {
        this._close();
        this.focus(event, newItem);
      }
    },

    expand: function (event) {
      var newItem = this.active &&
        this.active
          .children(".ui-menu ")
          .children(".ui-menu-item")
          .first();

      if (newItem && newItem.length) {
        this._open(newItem.parent());

        // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
        this._delay(function () {
          this.focus(event, newItem);
        });
      }
    },

    next: function (event) {
      this._move("next", "first", event);
    },

    previous: function (event) {
      this._move("prev", "last", event);
    },

    isFirstItem: function () {
      return this.active && !this.active.prevAll(".ui-menu-item").length;
    },

    isLastItem: function () {
      return this.active && !this.active.nextAll(".ui-menu-item").length;
    },

    _move: function (direction, filter, event) {
      var next;
      if (this.active) {
        if (direction === "first" || direction === "last") {
          next = this.active
          [direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item")
            .eq(-1);
        } else {
          next = this.active
          [direction + "All"](".ui-menu-item")
            .eq(0);
        }
      }
      if (!next || !next.length || !this.active) {
        next = this.activeMenu.children(".ui-menu-item")[filter]();
      }

      this.focus(event, next);
    },

    nextPage: function (event) {
      var item, base, height;

      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isLastItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.nextAll(".ui-menu-item").each(function () {
          item = $(this);
          return item.offset().top - base - height < 0;
        });

        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children(".ui-menu-item")
        [!this.active ? "first" : "last"]());
      }
    },

    previousPage: function (event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isFirstItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.prevAll(".ui-menu-item").each(function () {
          item = $(this);
          return item.offset().top - base + height > 0;
        });

        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children(".ui-menu-item").first());
      }
    },

    _hasScroll: function () {
      return this.element.outerHeight() < this.element.prop("scrollHeight");
    },

    select: function (event) {
      // TODO: It should never be possible to not have an active item at this
      // point, but the tests don't trigger mouseenter before click.
      this.active = this.active || $(event.target).closest(".ui-menu-item");
      var ui = { item: this.active };
      if (!this.active.has(".ui-menu").length) {
        this.collapseAll(event, true);
      }
      this._trigger("select", event, ui);
    }
  });

}(jQuery));

define("autocomplete", ["jquery"], function () { });

define('widgets/searchFlightAutocomplete', [
  'jquery',
  'settings',
  'UTILS',
  'dataprovider',
  'UTILS_PRELOADER',
  'async',
  'autocomplete'
], function ($, Settings, Utils, DataProvider, DataProviderPreloader, async) {


  var eventEmitter;

  var SearchFlightAutocomplete = {

    effects: {
      easing: "easeInOutExpo",
      duration: 200
    },
    bindSurroundingActions: function (context) {
      var $input = $(context).find("input[type=text]");
      var $button = $(context).find(".fakebutton");
      var toggleActive = 0;
      var $alternatePlaceholder = $(context).find(".alternatePlaceholder");

      $input.on("focus", function () {

        if (Utils.getPlatform() === "mobile" || Utils.getPlatform() === "small") {
          $('html, body').animate({
            scrollTop: $(this).offset().top - 70
          }, 500);
        }

        if (!toggleActive) {

          toggleActive = 1;
        }
        $alternatePlaceholder.show(SearchFlightAutocomplete.effects);

      });

      $input.on("blur", function () {
        setTimeout(function () {
          const activeFocus = document.activeElement;
          if (activeFocus !== $button[0]) {
            $alternatePlaceholder.hide(SearchFlightAutocomplete.effects);
          }
        }, 0);
      });

      $button.on("blur", function () {
        setTimeout(function () {
          const activeFocus = document.activeElement;
          if (activeFocus !== $input[0]) {
            $alternatePlaceholder.hide(SearchFlightAutocomplete.effects);
          }
        }, 0);
      });
    },
    buildArrays: function (context, responseArray, type) {
      var cities = [];
      var companies = [];
      var flights = [];

      var results = [];
      var basePath = $(context).attr("data-redirect-path-" + type);
      var basePathAllFlights = $(context).attr("data-redirect-path-flights");

      $.each(responseArray.data.field_destination.list, function (index, value) {
        value.category = responseArray.data.field_destination.label;
        value.label = value.destination;
        value.value = basePath + "?city=" + value.destination;

        //check if we duplicate label
        var add = 1;
        $.each(cities, function (index, previousValue) {
          if (previousValue.label === value.label) {
            add = 0;
          }
        });

        if (add) {
          value.id = "destination_" + value.id;
          cities.push(value);
        }

      });

      $.each(responseArray.data.field_company.list, function (index, value) {
        value.category = responseArray.data.field_company.label;
        value.label = value.company;
        value.value = basePath + "?company=" + value.company;

        //check if we duplicate label
        var add = 1;
        $.each(companies, function (index, previousValue) {
          if (previousValue.label === value.label) {
            add = 0;
          }
        });
        if (add) {
          value.id = "company_" + value.id;
          companies.push(value);
        }
      });

      $.each(responseArray.data.flight.list, function (index, value) {
        value.category = responseArray.data.flight.label;
        value.label = value.flight;
        value.value = basePath + "?flightNumber=" + value.flight;
        value.id = "flight_" + value.id;

        //check if we duplicate label
        var add = 1;
        $.each(flights, function (index, previousValue) {
          if (previousValue.label === value.label) {
            add = 0;
          }
        });
        if (add) {
          value.id = "flight_" + value.id;
          flights.push(value);
        }

      });

      var addToMainList = function (list) {
        //if(number > 0){
        for (var i = 0; i < list.length; i++) {
          results.push(list[i]);
        }
        //}
      };

      addToMainList(cities);
      addToMainList(companies);
      addToMainList(flights);

      $.each(results, function (index, value) {
        results[index].type = type;

      });

      return results;
    },
    showNoResultMessage: function ($ul) {
      console.log("showNoResultMessage", $ul);
      $ul.html("");
      $ul.addClass("no-result");
      $ul.removeClass("has-result");
      $("<li>" + ADM.i18n.searchFlightAutocomplete["label-noresult"] + "</li>").appendTo($ul);
      if (!$('body').hasClass("not-front")) {
        $("<li class='ui-menu-seeall ui-menu-seeallflights'><a href='" + $('.searchFlightAutocomplete').attr("data-redirect-path-flights") + "'>" + ADM.i18n.searchFlightAutocomplete["label-all-flights"] + "</a></li>").appendTo($ul);
      }

      setTimeout(function () {
        $ul.show();
      }, 200);

    },
    showErrorMessage: function ($ul) {
      console.log("showErrorMessage", $ul);
      $ul.html("");
      $ul.addClass("no-result");
      $ul.removeClass("has-result");

      $("<li class='warning'>" + ADM.i18n.searchFlightAutocomplete["label-error"] + "</li>").appendTo($ul);

      dataLayer.push({ 'event': 'recherche_vol_arrival_error_' + Utils.getLang() });

      setTimeout(function () {
        $ul.show();
      }, 200);
    },
    hasResult: function (ul) {
      var $ul = $(ul);
      $ul.removeClass("no-result");
      $ul.addClass("has-result");
      var mode;
      if ($ul.hasClass("mode-arrival")) {
        mode = "arrival";
      } else {
        mode = "departure";
      }
      var $results = $ul.find("li").not(".ui-menu-seeall");

      if ($results.length === 0) {
        return false;
      } else {
        return true;
      }

    },

    bindAutocomplete: function (context) {

      var $input = $(context).find("input[type=text]");

      var $spinner = $(context).find(".autocompleteSpinner");

      var _this = this;
      var query = "";

      $.widget("custom.catcomplete", $.ui.autocomplete, {
        close: function (event) {
          var _this = this;
          setTimeout(function () {
            var target = document.activeElement;
            if ($(target).parents(".searchFlightAutocomplete").length > 0) {
              $(target).one("blur", function (e) {
                _this.cancelClose = true;
                _this.close(e);
              });
            } else {
              _this.cancelSearch = true;
              _this._close(event);
            }
          }, 1);
        },
        _renderItem: function (ul, item) {

          var re = new RegExp(query, "gi");
          var output = item.label.replace(re, "<strong>" + query + "</strong>");

          if (item.odd) {
            return $("<li class='ui-menu-item item-odd type-" + item.type + " item-id-" + item.id + "-" + item.type + "' role='option'><a href='" + item.hreftarget + "'>" + output + "</a></li>").appendTo(ul);
          } else {
            return $("<li class='ui-menu-item type-" + item.type + " item-id-" + item.id + "-" + item.type + "' role='option'><a href='" + item.hreftarget + "'>" + output + "</a></li>").appendTo(ul);
          }

        },
        _renderItemData: function (ul, item) {
          item.hreftarget = item.value;
          item.value = item.label;
          return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },
        _renderMenu: function (ul, items) {

          var that = this;

          var arrivalArray = [];
          var departureArray = [];
          var surplus = {
            arrival: 0,
            departure: 0
          };
          console.log("items", items);
          $.each(items, function (index, item) {
            if (item.type === "arrival") {
              if (arrivalArray.length < 4) {
                arrivalArray.push(item);
              } else {
                surplus.arrival = surplus.arrival + 1;
              }
            }
            if (item.type === "departure") {
              if (departureArray.length < 4) {
                departureArray.push(item);
              } else {
                surplus.departure = surplus.departure + 1;
              }
            }
          });


          if (departureArray.length === 0 && arrivalArray.length === 0) {
            dataLayer.push({ 'event': 'recherche_vol_arrival_no_result_' + Utils.getLang(), keyword: query });
          } else {
            var $lblArrivalTitle = $("<li class='ui-menu-seeall ui-menu-unselectable type-arrival'><span>" + ADM.i18n.searchFlightAutocomplete["label-arrival"] + "</span><a href='" + $('.searchFlightAutocomplete').attr("data-redirect-path-arrival") + "'>" + ADM.i18n.searchFlightAutocomplete["label-all-arrival"] + "</a></li>").data("ui-autocomplete-item", { value: "", id: "seeall", label: ADM.i18n.searchFlightAutocomplete["label-all-arrival"] }).appendTo(ul);

            if (arrivalArray.length === 0) {
              $lblArrivalTitle.hide();
            }
            if (arrivalArray.length === 0 && departureArray.length === 0) {
              SearchFlightAutocomplete.showNoResultMessage($(".ui-autocomplete"));

            } else {
              var odd = 0;
              $.each(arrivalArray, function (index, item) {
                if (odd === 0) {
                  item.odd = true;
                  odd = 1;
                } else {
                  odd = 0;
                }
                that._renderItemData(ul, item);
              });
            }
            if (surplus.arrival !== 0) {
              $("<li class='ui-menu-seeall type-arrival'><a href='" + $('.searchFlightAutocomplete').attr("data-redirect-path-arrival") + "?company=" + $(".ui-autocomplete").attr("data-term") + "'>" + ADM.i18n.searchFlightAutocomplete["label-more"] + " (" + surplus.arrival + ")</a></li>").data("ui-autocomplete-item", { value: "", id: "seeall", label: ADM.i18n.searchFlightAutocomplete["label-more"] + " (" + surplus.arrival + ")" }).appendTo(ul);
            }

            var $lblDepartureTitle = $("<li class='ui-menu-seeall ui-menu-unselectable type-departure'><span>" + ADM.i18n.searchFlightAutocomplete["label-departure"] + "</span><a href='" + $('.searchFlightAutocomplete').attr("data-redirect-path-departure") + "'>" + ADM.i18n.searchFlightAutocomplete["label-all-departure"] + "</a></li>").data("ui-autocomplete-item", { value: "", id: "seeall", label: ADM.i18n.searchFlightAutocomplete["label-all-departure"] }).appendTo(ul);

            if (departureArray.length === 0) {
              $lblDepartureTitle.hide();
            }
            if (departureArray.length === 0 && arrivalArray.length === 0) {
              SearchFlightAutocomplete.showNoResultMessage($(".ui-autocomplete"));
            } else {
              odd = 0;
              $.each(departureArray, function (index, item) {
                if (odd === 0) {
                  item.odd = true;
                  odd = 1;
                } else {
                  odd = 0;
                }
                that._renderItemData(ul, item);
              });
            }
            if (surplus.departure !== 0) {
              $("<li class='ui-menu-seeall type-departure'><a href='" + $('.searchFlightAutocomplete').attr("data-redirect-path-departure") + "?company=" + $(".ui-autocomplete").attr("data-term") + "'>" + ADM.i18n.searchFlightAutocomplete["label-more"] + " (" + surplus.departure + ")</a></li>").data("ui-autocomplete-item", { value: "", id: "seeall", label: ADM.i18n.searchFlightAutocomplete["label-more"] + " (" + surplus.departure + ")" }).appendTo(ul);
            }
          }

          ul.find(".ui-menu-item a").on('click keydown', function (event) {
            if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
              e.preventDefault();

              dataLayer.push({ 'event': 'recherche_vol_select_' + Utils.getLang() });

              if (!$(this).parent().hasClass("ui-menu-seeall")) {
                $input.val($(this).text());
              } else {
                $input.val("");
              }

              var _target = $(this).attr("href");
              $spinner.show();
              window.location.href = _target;

              $(".ui-autocomplete").css("display", "none");

            }
          });

        }
      });

      $input.catcomplete({
        appendTo: context,
        create: function (event, ui) {
          _this.bindSurroundingActions(context);
        },
        minLength: 2,
        delay: 200,
        cancelClose: true,
        source: function (request, callback) {

          $spinner.show();

          query = request.term; // leave here to hightlight letter in suggestion
          async.parallel({
            arrival: function (cb) {

              DataProvider.autocomplete({
                type: "arrival",
                ajaxOpts: {
                  snippet: $.trim(request.term)
                },
                loader: {
                  $ctn: $(context).find(".fakeSpinner")
                }
              }, function (data) {


                if (data !== null) {
                  var results = _this.buildArrays(context, data, 'arrival');
                  console.log('arrival', data, results);
                  cb(null, results);
                } else {
                  cb("error", null);
                }

              });

            },
            departure: function (cb) {

              DataProvider.autocomplete({
                type: "departure",
                ajaxOpts: {
                  snippet: $.trim(request.term)
                },
                loader: {
                  $ctn: $(context).find(".fakeSpinner")
                }
              }, function (data) {

                if (data !== null) {
                  var results = _this.buildArrays(context, data, 'departure');
                  console.log('departure', data, results);
                  cb(null, results);
                } else {
                  cb("error", null);
                }

              });

            }
          },
            function (err, results) {

              var offset = $input.offset();
              var width = $input.outerWidth();
              var height = $input.outerHeight();


              console.log("results", err, results, "results.departure", results.departure);
              if (err !== "error") {
                if (results.departure !== "undefined" && results.arrival !== "undefined") {

                  var allResults = results.arrival.concat(results.departure);
                  console.log("allResults.length ", allResults.length);
                  if (allResults.length === 0) {
                    if ($(".ui-autocomplete").length === 0) {
                      $("<ul class='ui-autocomplete ui-front ui-menu ui-widget ui-widget-content ui-corner-all' role='listbox'></ul>").append($(context));
                    }


                    console.log("ERROR2");
                    if ($('body').hasClass("not-front")) {
                      $(".ui-autocomplete").css({ left: 0, top: 70, width: width });
                    }
                    else {
                      $(".ui-autocomplete").css({ left: offset.left, top: offset.top + height, width: width });
                    }
                    SearchFlightAutocomplete.showNoResultMessage($(".ui-autocomplete"));
                    dataLayer.push({ 'event': 'recherche_vol_arrival_no_result_' + Utils.getLang(), keyword: request.term });

                    //$( "<li class='ui-menu-seeall'><a href='"+$toggleButton.find('a:not(.'+inactiveClass+')').attr("data-additional-link")+"'>" + ADM.i18n.searchFlightAutocomplete["label-all-"+type] + "</a></li>" ).data( "ui-autocomplete-item", { value:$toggleButton.find('a:not(.'+inactiveClass+')').attr("data-additional-link"), id:"seeall", label: ADM.i18n.searchFlightAutocomplete["label-all-"+type]  } ).appendTo( $(".ui-autocomplete") );
                  }
                  $(".ui-autocomplete").attr("data-term", $.trim(request.term));
                  callback(allResults);


                }
                $spinner.hide();
              } else {
                console.log("ERROR");
                $(".ui-autocomplete").css({ left: offset.left, top: offset.top + height, width: width });

                SearchFlightAutocomplete.showErrorMessage($(".ui-autocomplete"));
                callback({});
                $spinner.hide();
              }
            });
        },
        open: function (event, ui) {

          //fix suggestion position for mobile device
          //$(".ui-autocomplete").css({marginTop:"70px"});

          $spinner.hide();
          var $ul = $(context).find(".ui-autocomplete");
          $ul.removeAttr("tabindex");
          $(context).attr("aria-expanded", "true");
          var $items = $ul.find(".ui-menu-item");
          var $anchors = $items.find("a");
          $items.removeAttr("tabindex");
          $items.removeAttr("role");
          $anchors.removeAttr("tabindex");


        },
        select: function (event, ui) {

          $spinner.show();
          var target = ui.item.hreftarget;

          var lang = Utils.getLang();

          dataLayer.push({ 'event': 'recherche_vol_select_' + lang });

          if (ui.item.id !== "seeall") {
            event.preventDefault();
            $(event.target).val(ui.item.label);

            window.location.href = target;
          } else {

            //var _target =  $(".ui-autocomplete").find(".ui-menu-seeall a").attr("href");
            // $(event.target).val("");
            //window.location.href = _target;
          }

          $(".ui-autocomplete").css("display", "none");
          $(context).attr("aria-expanded", "false");

        },
        focus: function (event, ui) {
          event.preventDefault();

          if (ui.item !== undefined) {

            $(".ui-autocomplete li").removeClass("focused");
            $(".ui-autocomplete .item-id-" + ui.item.id).addClass("focused");

          }
          return false;
        },
        search: function (event, ui) {
          $(".ui-autocomplete").css("display", "none");
          $(context).attr("aria-expanded", "false");
          $spinner.show();
        }
      });


      var $suggestionCtn = $(".ui-autocomplete");

      eventEmitter.addListener('hideNav', function (platform) {
        $suggestionCtn.css("display", "none");
        $(context).attr("aria-expanded", "false");
      });
      eventEmitter.addListener('collapseNav', function (platform) {
        $suggestionCtn.css("display", "none");
        $(context).attr("aria-expanded", "false");
      });

      $(".fakebutton").on('click keydown', function (e) {
        if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
          e.preventDefault();
          $input.catcomplete("search", $input.val());
        }
      });
    },
    init: function (context) {

      eventEmitter = ADM.eventEmitter;
      $(context).css("display", "block");
      this.bindAutocomplete(context);

    }

  };

  return SearchFlightAutocomplete;
});

define('widgets/globalSearchWidget', [
  'jquery',
  'UTILS',
  'gsap'
], function ($, Utils) {

  var eventEmitter;

  var effects = {
    easing: "easeInOutExpo",
    duration: 230
  };


  var gsapEffects = {
    easing: Circ.easeInOut,
    duration: .4
  };



  var GlobalSearchWidget = {
    init: function (context) {
      eventEmitter = ADM.eventEmitter;
      var $context = $(context);

      $context.each(function (index, $currentContext) {
        var widget = new GlobalSearchPlugin($($currentContext));
      });
    }
  };



  function GlobalSearchPlugin($context) {
    var _t = this,
      $button = $context.find(".globalSearchWidget-button"),
      $form = $context.parents("form");
    $formitem = $context.find(".form-item"),
      $close = $button.find(".close"),
      $wrapper = $context.parents('.region-sub-nav'),
      platform = getPlatform(Utils.getPlatform()),
      lastPlatform = platform;
    mobileCtrl = new GlobalSearchPluginMobile($context),
      otherPlatformCtrl = new GlobalSearchOtherPlaftorm($context),
      isTweening = false,
      isOpen = false,
      $submitButtonText = Utils.getLang() === 'fr' ? 'Rechercher' : 'Search',
      $submitButton = $("<span class='icon search' role='button' aria-label=" + $submitButtonText + "></span>"),
      $input = $context.find("input[type=text]"),
      nav = $("header .nav"),
      mobileNav = $('.header-rebrand-mobile');


    /****************** Private *********************/

    $formitem.prepend($submitButton);
    $formitem.append("<span class='separator'></span>");

    function init() {
      createEvents();
    }

    function createEvents() {
      var inputPlaceholder = Utils.getLang() === 'fr' ? 'Rechercher' : 'Search';
      var $searchInput = nav.find('input');
      $searchInput.attr('placeholder', inputPlaceholder);
      mobileNav.find('input').attr('placeholder', inputPlaceholder);

      $button.on("click", function (evt) {
        evt.preventDefault();

        if (nav.hasClass('search-visible')) {
          nav.removeClass('search-visible');
        } else {
          nav.addClass('search-visible');
          $(this).blur();
          setTimeout(function () {
            $searchInput.focus();
          }, 300);
        }
      });

      $searchInput.focus(function () {
        if (!nav.hasClass('search-visible')) {
          nav.addClass('search-visible');
        }
      });

      $searchInput.on('keydown', function (e) {
        if (e.which === 9 || e.which === 27) {
          nav.removeClass('search-visible');
        }
      });


      $submitButton.on("click", function (evt) {
        $form.submit();
      });

      eventEmitter.addListener('plaformChanged', function (newPlatform) {
        var currentPlatform = getPlatform(newPlatform);

        if (currentPlatform != platform) {
          lastPlatform = platform;
          platform = currentPlatform;
          resetUI();
        }
      });

    }

    function resetUI() {
      //TODO :: Need to reset the css for the good platform
      if (getController(lastPlatform).resetUI) getController(lastPlatform).resetUI(isOpen);
      if (getController(platform).initUI) getController(platform).initUI(isOpen);

    }

    function triggerIfNotAnimating(handler) {
      return function () {
        if (!isTweening) handler();
      };
    }

    function getPlatform(platform) {
      switch (platform) {
        case "mobile":
          return "mobile";
          break;

        default:
          return "otherPlatform";
          break;
      }
    }

    function getController(platform) {
      switch (platform) {
        case "mobile":
          return mobileCtrl;
          break;

        case "otherPlatform":
          return otherPlatformCtrl;
          break;
      }
    }


    init();


    /****************** Public *********************/

    this.setIsOpen = function (state) {
      isOpen = state;
    };

    this.getIsOpen = function () {
      return isOpen
    };

    this.open = function () {
      _t.setIsOpen(true);

      $context.addClass("open");

      $formitem.slideDown({
        duration: effects.duration,
        easing: effects.easing,
        complete: function () {

          if (typeof getController(platform).onOpenCompleted != "undefined") getController(platform).onOpenCompleted();

        }
      });


      TweenLite.to($close, gsapEffects.duration, {
        css: {
          marginTop: 0
        },
        ease: gsapEffects.easing
      });


      getController(platform).open();
    };

    this.close = function () {
      _t.setIsOpen(false);

      $formitem.slideUp({
        duration: effects.duration,
        easing: effects.easing,
        complete: function () {
          $context.removeClass("open");
          if (typeof getController(platform).onCloseCompleted != "undefined") getController(platform).onCloseCompleted();

        }
      });


      TweenLite.to($close, gsapEffects.duration, {
        css: {
          marginTop: closeMarginTop
        },
        ease: gsapEffects.easing
      });


      getController(platform).close();
    };

  }


  /******************* Others Platforms *********************/

  function GlobalSearchOtherPlaftorm($context) {
    var _t = this,
      $button = $context.find(".globalSearchWidget-button"),
      $alertMessageCtn = $(".region-warnings"),
      $alertMessage = $(".alertmessage"),
      alertHeight = $alertMessage.outerHeight(),
      $formitem = $context.find(".form-item"),
      $formactions = $context.find(".form-actions");
    $wrapper = $context.parents('.region-sub-nav'),
      $close = $button.find(".close"),
      closeMarginTop = $button.find(".close").css("margin-top"),
      initWidth = $wrapper.css('width');

    this.resetUI = function (isOpen) {
    };

    this.initUI = function (isOpen) {

    };

    this.open = function () {

    };

    this.close = function () {

    };

    this.onOpenCompleted = function () {

    }

    this.onCloseCompleted = function () {

    };
  }


  /*************************** Mobile ************************/

  function GlobalSearchPluginMobile($context) {
    var _t = this,
      $formitem = $context.find(".form-item"),
      $wrapper = $context.parents('.region-sub-nav'),
      initWidth = $wrapper.css('width');


    this.open = function () {
      $formitem.slideDown({
        duration: effects.duration,
        easing: effects.easing
      });

    };

    this.close = function () {

    }

    this.onOpenCompleted = function () {
      $(window).unbind("scroll.search");
      $("body").scrollTop(0);
      setTimeout(function () {
        $formitem.find("input").css({ 'position': "absolute" });

        $formitem.find("input").css({ 'width': $formitem.parent().width() * 0.8 });
        $formitem.find("input").css({ 'zoom': "1" });
        $formitem.find("input").css({ '-webkit-transform': "scale3d(1,1,1)" });
        $formitem.find("input").css({ 'position': "relative" });
        $formitem.find("input").css({ '-webkit-transform': "none" });
        $formitem.find("input").css({ '-webkit-transform': "scale3d(1,1,1)" });


        var close = function () {

          $formitem.slideUp({
            duration: effects.duration,
            easing: effects.easing,
            complete: function () {
              $context.removeClass("open");
            }
          });


          TweenLite.to($close, gsapEffects.duration, {
            css: {
              marginTop: closeMarginTop
            },
            ease: gsapEffects.easing
          });
        };


        // fix for samsung s4 and BB

        setTimeout(function () {
          $(window).unbind("scroll.search");
          var iOS = (navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false);
          // On ios when we click in a input it trigger a scroll
          if (!iOS) {
            $(window).bind("scroll.search", close);
          }

        }, 200);

      }, 200);

      // Fix a bug with input (when were change orientation while typing)
      $(window).bind('orientationchange', function () {
        setTimeout(function () {
          $formitem.find("input").css({ 'width': $formitem.parent().width() * 0.8 });
        }, 200);
      });
    }

    this.onCloseCompleted = function () {
      setTimeout(function () {
        // fix for samsung s4
        $formitem.find("input").css({ 'position': "relative" });
        $formitem.find("input").css({ 'zoom': "0" });
        $formitem.find("input").css({ '-webkit-transform': "none" });

        $(window).unbind("scroll.search");
        $formitem.find("input").blur();
      }, 200);

    }
  }




  return GlobalSearchWidget;
});


define('widgets/stationnement', [
  'jquery',
  'moment',
  'mobiscroll',
  'mobi/config',
  'UTILS',
  'uiTools/tooltips',
  'UTILS_DATE',
  'i18n_general',
  'i18n/mobiscroll',
  'UTILS_PRELOADER'
], function ($, moment, mobiscroll, MobiConfig, Utils, Tooltips, DateUtils, i18n_general, Mobiscrolli18n, Preloader) {

  var maxHour = [23, 59];

  var eventEmitter;
  var lang = Utils.getLang(),
    currentDate = DateUtils.currentDateServer(),
    _enhancement = 'stationnement',
    _userAgent = navigator.userAgent;


  var ERROR_MESSAGES = {
    START_HOURS_INVALID: 'To complete your reservation, you need to allow a minimum of 2 hours before the time you wish to reserve.',
    END_DATE_INVALID: 'To complete your reservation, you need to allow a minimum stay of 4 hours.'
  };

  if (lang == "fr") {
    ERROR_MESSAGES = {
      START_HOURS_INVALID: 'Les réservations ne sont pas possibles en deçà de deux heures avant l’heure souhaitée.',
      END_DATE_INVALID: 'Les réservations ne sont pas possibles pour une durée de moins de 4 heures.'
    };
  }

  //Override value to 30 minuts steps
  currentDate = DateUtils.ceilHoursOnThirtyStep(currentDate);

  ADM.cancelFullscreen = function (element, $input) {
    if (Utils.isMobile.Android()) {
      if (document.exitFullscreen) {
        document.exitFullscreen();

      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();

      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();

      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    }
  };


  /* Callback backend */
  jQuery.fn.extend({
    ajaxParkingFormDrupalizedInit: function (fid, data) {

      /* Re-enhance form. */
      var $context = $('#' + fid);
      if ($context.length && $context.attr('data-enhance') == _enhancement) {
        var attr = 'data-enhance'
          , enhance = $('body').attr(attr) + ' ' + $context.attr(attr);

        $context.attr(attr, enhance).enhance();
      }

      var lang = Utils.getLang();

      var caa_member = false;
      var caa_member_value = $context.find("input[name='caa_number']").val();
      if (caa_member_value !== undefined && caa_member_value !== "" && caa_member_value !== null) {
        caa_member = true;
      }
      var codepromo = false;
      var codepromo_value = $context.find("input[name='promo_code']").val();
      if (codepromo_value !== undefined && codepromo_value !== "" && codepromo_value !== null) {
        codepromo = codepromo_value;
      }

      /* Open popup */
      if (data != null) {

        dataLayer.push({
          'event': 'consultation_stationnement_submit_success_' + lang,
          'caa_member': caa_member,
          'codepromo': codepromo
        });

        setTimeout(function () {

          $.magnificPopup.open({
            items: {
              src: $("#modAcceptLead"), // can be a HTML string, jQuery object, or CSS selector
              type: 'inline'
            },
            callbacks: {
              open: function () {

                // On crée un formulaire 'invisible' afin de pouvoir accéder au site 
                // de réservation de parking tout en envoyant les données en POST.
                $("#modAcceptLead .lnkOk").click(function (evt) {
                  evt.preventDefault();

                  var form = document.createElement("form");
                  form.setAttribute("method", "post");
                  form.setAttribute("action", data.base_url)
                  for (var i in data.params) {
                    console.log(i);
                    if (data.params.hasOwnProperty(i)) {
                      var input = document.createElement('input');
                      input.type = 'hidden';
                      input.name = i;
                      input.value = data.params[i];
                      form.appendChild(input);
                    }
                  }
                  document.body.appendChild(form);
                  form.submit();
                  document.body.removeChild(form);
                });
              }
            }
          });
        }, 50);
      } else {
        dataLayer.push({
          'event': 'consultation_stationnement_submit_error_' + lang,
          'caa_member': caa_member,
          'codepromo': codepromo
        });
      }
    }
  });

  /***********************************  Parking  ****************************************/
  var Parking = {
    init: function (context) {
      eventEmitter = ADM.eventEmitter;
      context.each(function (i, elt) {
        var $elt = $(elt);
        var _t = this;
        /* Form. */
        ParkingForm.init($elt);


        //Due to new promotion layout and position on mobile device (absolute at bottom)
        //we have to manage container's height with errors msg opened
        var $context = $(context);
        var stateWrapper = $context.find('.state-wrapper div.error');
        var parkingContainer = $('.widget-stationnement-content');

        if (Utils.getPlatform() === "mobile") {
          if (stateWrapper.css('display') == 'block') {
            parkingContainer.css('height', '480px');
          }
        }

        ADM.eventEmitter.addListener('plaformChanged', function (platform) {
          if (platform === "mobile") {
            if (stateWrapper.css('display') == 'block') {
              parkingContainer.css('height', '480px');
            }
          } else {
            if (stateWrapper.css('display') == 'block') {
              parkingContainer.css('height', 'auto');
            }
          }
        });

        var topFieldsContainer = $elt.find('.state-wrapper > fieldset').first().find('> div').eq(0);
        var bottomFieldsContainer = $elt.find('.state-wrapper > fieldset').first().find('> div').eq(1);

        var $dateIn = $('.ws_qsddd', elt);
        var $dateOut = $('.ws_qsrdd', elt);
        var $hourIn = $('.ws_qsddt', elt);
        var $hourOut = $('.ws_qsrdt', elt);
        var dateIn = new ParkingDate("in");
        var dateOut = new ParkingDate("out");

        $(".hoursIn-desktop", elt).append('<select><option value="">' + i18n_general.selHours + '</option></select>');
        $(".hoursOut-desktop", elt).append('<select><option value="">' + i18n_general.selHours + '</option></select>');

        var $hourInSelect = $(".hoursIn-desktop select", elt);
        var $hourOutSelect = $(".hoursOut-desktop select", elt);
        var isLoaded = false;

        disableField($hourIn);
        disableField($hourInSelect);
        disableField($hourOut);
        disableField($hourOutSelect);
        disableField($dateOut);

        createDateField($dateIn, dateIn)
          .then(createTimeField($hourIn, dateIn))
          .then(createDateField($dateOut, dateOut))
          .then(createTimeField($hourOut, dateOut))
          .then(function () {
            isLoaded = true;
          });

        if (Utils.isMobile.any()) {
          $(".hoursIn-mobile", context).show();
          $(".hoursIn-desktop", context).hide();
          $(".hoursOut-mobile", context).show();
          $(".hoursOut-desktop", context).hide();
          dataLayer.push({ 'event': 'versionB' });
        } else {
          var hourInFormName = $hourIn.attr('name');
          var hourOutFormName = $hourOut.attr('name');

          $hourInSelect.attr('name', hourInFormName);
          $hourOutSelect.attr('name', hourOutFormName);

          $hourIn.removeAttr('name');
          $hourOut.removeAttr('name');
        }

        $dateIn.on('dateUpdated', function ($event, data) {
          dateInChange(data.valueText);
        });

        function dateInChange(valueText) {
          setInHoursSelect($hourInSelect, valueText);

          var firstOption = $hourInSelect.find('option').eq(1).attr('value').replace("h", ":").split(':');
          var date = moment(dateIn.getMoment().toDate()).hours(firstOption[0]).minutes(firstOption[1]).toDate();
          var startHoursIsValid = parseInt(firstOption.join('')) <= parseInt($hourIn.val().replace('h', "").replace(':', ""));
          $hourIn.mobiscroll("option", "minDate", date);

          enableField($hourIn);
          enableField($hourInSelect);
          $dateIn.val(valueText);

          if (isLoaded) {
            removeError(topFieldsContainer);
            removeError(bottomFieldsContainer);
          }

          if (startHoursIsValid) {
            dateIn.setHour($hourIn.val().replace("h", ":"));
            $hourInSelect.val($hourIn.val());
          } else {
            if ($hourIn.val() !== "") {
              addError(topFieldsContainer, ERROR_MESSAGES.START_HOURS_INVALID);
            }
            $hourIn.val("");
            disableField($dateOut);
            disableField($hourOut);
            disableField($hourOutSelect);
          }

          var endDateValid = endDateIsValid(dateIn, dateOut, $dateOut, $hourOut);

          if (endDateValid === false) {
            addError(bottomFieldsContainer, ERROR_MESSAGES.END_DATE_INVALID);
            $dateOut.val('');
            disableField($hourOut);
            disableField($hourOutSelect);
          }

          $dateOut.mobiscroll("option", "minDate", getMinDateOut(dateIn));
          dateOut.setMinDate(getMinDateOut(dateIn));
        }

        $hourIn.on('timeUpdated', function (event, data) {
          hourInChange(data.valueText);
        });

        $hourInSelect.on('change', function () {
          var value = $hourInSelect.val();
          var valueText = '';

          if (value !== '') {
            valueText = value.replace("h", ":"); // Only done in FR because we need to have the time in this format(12:30);
          }
          hourInChange(valueText);
        });

        function hourInChange(valueText) {
          if (isLoaded) {
            removeError(topFieldsContainer);
            removeError(bottomFieldsContainer);
          }

          if (valueText !== "") {
            if (dateIn.isHourChanged(valueText)) {
              dateIn.setHour(valueText);
              $hourIn.mobiscroll('setDate', dateIn.getDate(), true);
            }

            enableField($dateOut);
            $dateOut.mobiscroll("option", "minDate", getMinDateOut(dateIn));
            dateOut.setMinDate(getMinDateOut(dateIn));

            var endHourSelectValue = $hourOutSelect.val();
            setHoursOutSelect($hourOutSelect, dateIn, dateOut);
            $hourOutSelect.val(endHourSelectValue);

            if (valueText !== $hourInSelect.val() && $hourInSelect.val() === "") {
              if (lang == "fr") {
                $hourInSelect.val(valueText.replace(":", "h"));
              } else {
                $hourInSelect.val(valueText);
              }
            }
          } else {
            $hourIn.val('');
            $hourInSelect.val('');
            disableField($dateOut);
            disableField($hourOutSelect);
          }

          if (endDateIsValid(dateIn, dateOut, $dateOut, $hourOut) === false) {
            addError(bottomFieldsContainer, ERROR_MESSAGES.END_DATE_INVALID);
            $dateOut.val('');
            disableField($hourOut);
            disableField($hourOutSelect);
          }
        }

        $dateOut.on('dateUpdated', function (event, data) {
          enableField($hourOut);
          enableField($hourOutSelect);
          $dateOut.val(data.valueText);

          if (isLoaded) {
            removeError(bottomFieldsContainer);
          }

          setHoursOutSelect($hourOutSelect, dateIn, dateOut);
          var firstOption = $hourOutSelect.find('option').eq(1).attr('value').replace("h", ":").split(':');
          var date = moment(dateOut.getMoment().toDate()).hours(firstOption[0]).minutes(firstOption[1]).toDate();
          $hourOut.mobiscroll("option", "minDate", date);

          if ($hourOut.val() !== "") {
            dateOut.setHour($hourOut.val().replace("h", ":"));
          }

          var endDateValid = endDateIsValid(dateIn, dateOut, $dateOut, $hourOut);
          if (endDateValid == false) {
            $hourOut.val('');
            addError(bottomFieldsContainer, ERROR_MESSAGES.END_DATE_INVALID);
          } else {
            $hourOutSelect.val($hourOut.val());
          }
        });

        $hourOut.on('timeUpdated', function (event, data) {
          hourOutChange(data.valueText);
        });

        $hourOutSelect.on('change', function () {
          var valueText = $hourOutSelect.val().replace("h", ":"); // Only done in FR because we need to have the time in this format(12:30);
          hourOutChange(valueText);
        });

        function hourOutChange(valueText) {
          if (isLoaded) {
            removeError(bottomFieldsContainer);
          }

          if (valueText !== "") {
            if (dateOut.isHourChanged(valueText)) {
              dateOut.setHour(valueText);
              $hourOut.mobiscroll('setDate', dateOut.getDate(), true);
            }

            if (valueText !== $hourOutSelect.val() && $hourOutSelect.val() === "") {
              if (lang == "fr") {
                $hourOutSelect.val(valueText.replace(":", "h"));
              } else {
                $hourOutSelect.val(valueText);
              }
            }
          } else {
            $hourOut.val('');
            $hourOutSelect.val('');
          }
        }


        /* Preloader */
        $elt.bind('ajax-progress-started', function (evt, element) {
          var $throbber = $('.throbber', element);
          if ($throbber.length) {
            var preloader = new Preloader({
              diameter: 20,
              $ctn: $throbber,
              color: '#ffffff',
              position: 'absolute'
            });

            preloader.show();
          }
        });

        return;
      });
    }
  };


  function addError(container, errorText) {
    var message = $('<div class="msg"><span>' + errorText + '</span></div>');

    removeError(container);
    setTimeout(function () {
      container.addClass('error');
      container.append(message);
    }, 10)
  }

  function removeError(container) {
    container.removeClass('error');
    container.find('.msg').each(function () {
      $(this).remove();
    });
  }

  function endDateIsValid(dateIn, dateOut, $dateOut, $hourOut) {
    if ($dateOut.val() !== "" && $hourOut.val() === "") {
      if (validate_endDateBiggerThenStartDate(dateIn, dateOut) == false) {
        return false;
      } else if (validate_inDateAndEndDateCanBeSameDay(dateIn, dateOut) == false) {
        return false;
      }
    }

    if ($dateOut.val() !== "" && $hourOut.val() !== "") {
      if (validate_inDateAndEndDateHave4HoursDifference(dateIn, dateOut) == false) {
        return false;
      }
    }

    return true;
  }

  function validate_endDateBiggerThenStartDate(dateIn, dateOut) {
    var dateInCopy = dateIn.getMoment().clone().toDate();
    var dateOutCopy = dateOut.getMoment().clone().toDate();

    return moment(dateInCopy.setHours(0, 0, 0, 0)).unix() <= moment(dateOutCopy.setHours(0, 0, 0, 0)).unix();
  }

  function validate_inDateAndEndDateCanBeSameDay(dateIn, dateOut) {
    var isSameDate = dateIn.getMoment().format('YYYY-MM-DD') === dateOut.getMoment().format('YYYY-MM-DD');

    if (isSameDate) {
      return dateIn.getMoment().hours() < 20;
    }

    return true;
  }

  function validate_inDateAndEndDateHave4HoursDifference(dateIn, dateOut) {
    var fourHoursInMilisecond = 4 * 60 * 60;

    return parseInt(dateOut.getMoment().unix()) - parseInt(dateIn.getMoment().unix()) >= fourHoursInMilisecond;
  }

  function disableField($field) {
    $field.attr('disabled', 'disabled')
    $field.parent().addClass('disabled');
    $field.val('');
  }

  function enableField($field) {
    $field.removeAttr('disabled')
    $field.parent().removeClass('disabled');
  }

  function setInHoursSelect($hourSelect, stringDate) {
    var minHours = getMinHoursIn(moment(stringDate).toDate());
    var list = getHTMLList(minHours);

    $hourSelect.html(list.join(''));
  }

  function setHoursOutSelect($hourSelect, dateIn, dateOut) {
    var isSameDate = dateIn.getMoment().format('YYYY-MM-DD') === dateOut.getMoment().format('YYYY-MM-DD');
    var isTheDateBefore = dateIn.getMoment().format('YYYY-MM-DD') === dateOut.getMoment().clone().subtract(1, 'days').format('YYYY-MM-DD');
    var minDateOutHours = moment(dateIn.getDate());

    if (isSameDate || (isTheDateBefore && dateIn.getMoment().hours() >= 20)) {
      if (dateIn.getMoment().format('HH:mm') === '23:59') {
        minDateOutHours = minDateOutHours.add(1, 'minutes');
      }

      minDateOutHours = minDateOutHours.add(4, 'hours');
    } else {
      minDateOutHours.add(1, 'days').hours(0).minutes(0);
    }

    var list = getHTMLList(minDateOutHours.toDate());

    $hourSelect.html(list.join(''));
  }

  function getMinHoursIn(date) {
    var now = new Date();
    var selectedDateIsToday = now.getDate() === date.getDate()
      && now.getMonth() === date.getMonth()
      && date.getFullYear() === now.getFullYear();

    var nowHours = parseInt(now.getHours() + '' + now.getMinutes());
    var maxHoursMinusTwo = parseInt(maxHour[0] - 2 + '' + maxHour[1])
    var beforeMaxHour = nowHours < maxHoursMinusTwo;

    if (selectedDateIsToday && beforeMaxHour) {
      if (now.getMinutes() <= 30) {
        return new Date(now.setHours(now.getHours() + 2, 30));
      }

      return new Date(now.setHours(now.getHours() + 3, 0));
    }

    var tomorrow = new Date(now.setDate(now.getDate() + 1));
    return new Date(tomorrow.setHours(0, 0));
  }

  function getHoursList(minHours) {
    var listHours = [];
    var start = 0;

    if (minHours !== undefined) {
      start = minHours.getHours();
    }

    for (var i = start; i <= 23; i++) {
      var hours = i < 10 ? '0' + i : i;

      listHours.push(hours + ':00');
      listHours.push(hours + ':30');
    }

    if (minHours !== undefined && minHours.getMinutes() === 30) {
      listHours.shift();
    }

    listHours.push(maxHour.join(':'));

    if (listHours[0] === "00:00") {
      listHours[0] = '00:01';
    }

    return listHours;
  }

  function getHTMLList(minHours) {
    var listOptions = getHoursList(minHours)
      .map(function (hourString) {
        if (lang == "fr") {
          return hourString.replace(":", "h");
        }

        return hourString;
      })
      .map(function (hourString) {
        return '<option value="' + hourString + '">' + hourString + '</option>';
      });

    listOptions.unshift('<option value="">' + i18n_general.selHours + '</option>');

    return listOptions;
  }

  function createTimeField(jqueryElement, parkingDate) {
    var creationCallback;
    var opts = {
      onClose: function (valueText, inst) {
        updateParkingDate(valueText);

        setTimeout(function () {
          jqueryElement.blur();
        }, 1000);

      },
      onShow: function () {
        jqueryElement.blur();
      },
      stepMinute: 30
    };

    function updateParkingDate(valueText) {
      valueText = valueText.replace("h", ":"); // Only done in FR because we need to have the time in this format(12:30);

      if (parkingDate.isHourChanged(valueText)) {
        parkingDate.setHour(valueText);

        jqueryElement.trigger('timeUpdated', {
          valueText: valueText
        });
      }
    }

    $.extend(opts, MobiConfig.getHourPickerDefaultOptions());
    jqueryElement.mobiscroll().time(opts);

    setTimeout(function () {
      if (jqueryElement[0].getAttribute('value') !== "") {
        updateParkingDate(jqueryElement[0].getAttribute('value'));
      }

      if (typeof creationCallback === "function") {
        creationCallback();
      }
    }, 10);

    return {
      then: function (callback) {
        creationCallback = callback;
        return callback;
      }
    }
  }

  function createDateField(jqueryElement, parkingDate) {
    var creationCallback;

    var opts = {
      minDate: parkingDate.getMinDate(),
      onClose: function (valueText, btn) {
        if (btn != "cancel") {
          if (parkingDate.isDateChanged(valueText) && btn != "cancel") {
            updateParkingDate(valueText);
          } else if (valueText !== "" && jqueryElement.val() === "") {
            jqueryElement.trigger('dateUpdated', {
              valueText: valueText
            });
          }
        }

        ADM.cancelFullscreen(document.documentElement, parkingDate);
        setTimeout(function () {
          jqueryElement.blur();
        }, 1000);
      },
      onSelect: function (valueText, inst) {
        inst.destroy();
      },
      onShow: function () {
        jqueryElement.blur();
      },
      onDestroy: function (inst) {
        var lastValue = jqueryElement.val();
        createDateField(jqueryElement, parkingDate);
        jqueryElement.val(lastValue);
      }
    };

    function updateParkingDate(valueText) {
      parkingDate.setDate(valueText);
      jqueryElement.trigger('dateUpdated', {
        valueText: valueText
      });
    }

    $.extend(opts, MobiConfig.getCalendarDefaultOptions());
    jqueryElement.mobiscroll().calendar(opts);

    setTimeout(function () {
      if (jqueryElement[0].getAttribute('value') !== "") {
        updateParkingDate(jqueryElement[0].getAttribute('value'));
        jqueryElement[0].setAttribute('value', '');
      }

      if (typeof creationCallback === "function") {
        creationCallback();
      }
    }, 10);

    return {
      then: function (callback) {
        creationCallback = callback;
        return callback;
      }
    }
  }

  function getMinDateOut(dateIn) {
    var date = dateIn.getDate();

    if (date.getHours() >= 20) {
      return moment(date).add(1, 'days').toDate();
    }

    return moment(date).toDate();
  }

  function ParkingDate(type) {
    var d = moment(currentDate),
      type = type,
      minDate = moment(currentDate),
      maxDate,
      isFirstRun = true;

    d.add('hours', 2);
    minDate.add('hours', 2);

    return {
      /************** Getter *************/
      getMoment: function () {
        return d;
      },
      getDate: function () {
        return d.toDate();
      },
      getHour: function () {
        return d.toDate();
      },
      getMinDate: function () {
        return minDate.toDate();
      },
      getMaxDate: function () {
        return (typeof maxDate != "undefined") ? maxDate.toDate() : null;
      },
      getMomentMinDate: function () {
        return minDate;
      },
      getMomentMaxDate: function () {
        return maxDate;
      },
      getHoursMinOpts: function () {
        var _t = this,
          isDateMin = _t.isDateMin();

        //console.log(type, isDateMin, _t.getMinDate())
        return isDateMin ? _t.getMinDate() : null;

      },
      getHoursMaxOpts: function () {
        var _t = this,
          isMaxDate = _t.isMaxDate();

        return (typeof maxDate != "undefined" && isMaxDate) ? _t.getMaxDate() : null;
      },
      isDateChanged: function (value) {
        var isChanged = false,
          temp = moment(value);

        if (d.format('YYYY-MM-DD') !== temp.format('YYYY-MM-DD')) isChanged = true;
        if (isFirstRun) {
          isFirstRun = false;
          isChanged = true;
        }
        return isChanged;
      },

      isHourChanged: function (value) {
        var isChanged = false,
          temp = moment(value);

        if (d.hours() != temp.hours() || d.minutes() != temp.minutes()) isChanged = true;

        return isChanged;
      },

      isDateMin: function () {
        var state = false;
        if (d.date() == minDate.date() && d.month() == minDate.month() && d.year() == minDate.year()) state = true;

        return state;
      },


      isMaxDate: function () {
        var state = false;
        if ((typeof maxDate != "undefined") && (d.date() == maxDate.date() && d.month() == maxDate.month() && d.year() == maxDate.year())) state = true;

        return state;
      },



      /************* Setter **************/
      resetDate: function () {
        d = minDate.clone();
      },
      setDateToMax: function () {
        if (typeof maxDate != "undefined") {
          d = maxDate.clone();
        }
      },
      setDate: function (value) {
        var temp = moment(value, Mobiscrolli18n.getDateFormated());
        var dateIsInvalid = (d instanceof Date && !isNaN(d)) === false;

        if (dateIsInvalid) {
          d = temp;
        } else {
          d.date(temp.date());
          d.month(temp.month());
          d.year(temp.year());
        }
      },
      setHour: function (value) {
        var temp = value.split(":"),
          hours = Number(temp[0]),
          minutes = Number(temp[1]);

        d.hours(hours);
        d.minutes(minutes);
      },
      setMinDate: function (value) {
        minDate = moment(value);
      },
      setMaxDate: function (value) {
        var temp = value.clone();

        switch (type) {
          case "in":
            maxDate = temp.subtract('days', 0);
            break;
        }
      }
    }
  }


  /*********************************  Parking Form UI ********************************/
  var ParkingForm = (function () {

    /* Fields removable */
    var initRemovalFields = function ($f) {

      var $form = $f
        , $links = $('a[data-rel]', $form)
        , $labels = $('label.removal', $form)
        , $inputs = $('input[type=text]', $labels)
        , $stateWrapper = $('> div.state-wrapper', $form);


      //new implementation
      var activateLink = function (l, lbl, lParent, dChk) {
        dChk.addClass("checked");
        lParent.addClass('activeLabel');
        lbl.css({ display: 'block' });
      };

      var inactiveLinks = function (lsParent) {
        var lsDivChks = lsParent.find('div.inputChk');
        var lsTxts = lsParent.find('input[type="text"]');
        lsParent.removeClass("activeLabel");
        lsParent.removeClass("error");
        lsDivChks.removeClass("checked");
        lsTxts.val('');
        lsTxts.attr("value", '');
        lsTxts.parent().css({ display: 'none' });
      };

      $links.each(function (i, link) {
        var $link = $(link)
          , rel = $link.data('rel')
          , $input = $('input[name=' + rel + ']', $form)
          , $label = $input.parents('label:first')
          , $ctrl = $('span', $label)
          , $linkParent = $link.parent()
          , $divChk = $linkParent.find('div.inputChk');

        $link.bind('click', function (evt) {
          evt.preventDefault();
          if (!$linkParent.hasClass('activeLabel') && !$stateWrapper.hasClass("open-state")) {
            //$link.trigger('_activating', [$link, $label, $linkParent]);
            $stateWrapper.addClass('open-state');
            inactiveLinks($links.parent());
            activateLink($link, $label, $linkParent, $divChk);
          }
          return false;
        });

        $ctrl.bind('click', function (evt) {
          evt.preventDefault();
          $stateWrapper.removeClass("open-state");
          inactiveLinks($links.parent());
        });

        $divChk.bind('click', function (evt) {
          if (!$(this).hasClass("checked") && !$stateWrapper.hasClass("open-state")) {
            $stateWrapper.addClass('open-state');
            inactiveLinks($links.parent());
            activateLink($link, $label, $linkParent, $divChk);
          } else if ($(this).hasClass("checked")) {
            $stateWrapper.removeClass("open-state");
            inactiveLinks($links.parent());
          }

        });
      });
    };

    return {
      init: function ($context) {
        $context.each(function (i, elt) {
          var $elt = $(elt);

          /* Removal fields CAA + promo code */
          initRemovalFields($elt);

          /* Tooltips infos */
          Tooltips.init($elt);
        });
      }
    }
  })();

  return Parking;
});

define('widgets/guidePerso', [
  'jquery',
  'UTILS'
], function ($, Utils) {

  var FormGuidePerso = {

    //Only for analytics
    init: function (context) {
      var $context = $(context);
      var redirectBasePath = $context.attr("data-base-path") || "/path/";
      var pathSeparator = $context.attr("data-separator") || ",";
      var $button = $context.find("input.form-submit");
      var $destination = $(context).find(".guide-destination");


      var lang = Utils.getLang();

      $button.click(function (evt) {

        //var destination = $destination.val();
        var destinationString = $destination.next(".custom-select").find("span.label").text();
        //var options = [];
        var optionString = "";
        var $optionsDropdown = $(context).find("div.guide-filters");
        var $options = $optionsDropdown.find(".select2-search-choice").find("div");
        console.log($optionsDropdown, $options);
        $options.each(function () {
          // var index = parseInt($(this).attr("data-option-array-index"));
          // var value = $optionsDropdown.find("option").eq(index).attr("value");
          //options.push(value);
          optionString = optionString + $(this).text() + ",";
        });
        /*
                      var optionBuiltPath = destination + pathSeparator;
                      $.each(options, function(index, value){
                          optionBuiltPath = optionBuiltPath + value + pathSeparator;
                      });
        */
        var optionString = optionString.slice(0, -1);

        dataLayer.push({
          'event': 'guide_success_' + lang,
          'guide': destinationString,
          'guide_choices': optionString
        });

        //optionBuiltPath = optionBuiltPath.slice(0, -1);
        //window.location = redirectBasePath + optionBuiltPath;
        /*
        console.log({
            'event': 'guide_success_'+ lang,
            'guide': destinationString,
            'guide_choices':optionString
        });
        */
      });
    }
  };

  return FormGuidePerso;
});
/*!
* jQuery throttle / debounce - v1.1 - 3/7/2010
* http://benalman.com/projects/jquery-throttle-debounce-plugin/
* 
* Copyright (c) 2010 "Cowboy" Ben Alman
* Dual licensed under the MIT and GPL licenses.
* http://benalman.com/about/license/
*/

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function (window, undefined) {
  '$:nomunge'; // Used by YUI compressor.

  // Since jQuery really isn't required for this plugin, use `jQuery` as the
  // namespace only if it already exists, otherwise use the `Cowboy` namespace,
  // creating it if necessary.
  var $ = window.jQuery || window.Cowboy || (window.Cowboy = {}),

    // Internal method reference.
    jq_throttle;

  // Method: jQuery.throttle
  // 
  // Throttle execution of a function. Especially useful for rate limiting
  // execution of handlers on events like resize and scroll. If you want to
  // rate-limit execution of a function to a single time, see the
  // <jQuery.debounce> method.
  // 
  // In this visualization, | is a throttled-function call and X is the actual
  // callback execution:
  // 
  // > Throttled with `no_trailing` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X    X        X    X    X    X    X    X
  // > 
  // > Throttled with `no_trailing` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X             X    X    X    X    X
  // 
  // Usage:
  // 
  // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', throttled );
  // > jQuery('selector').unbind( 'someevent', throttled );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
  //    true, callback will only execute every `delay` milliseconds while the
  //    throttled-function is being called. If no_trailing is false or
  //    unspecified, callback will be executed one final time after the last
  //    throttled-function call. (After the throttled-function has not been
  //    called for `delay` milliseconds, the internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the throttled-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, throttled, function.

  $.throttle = jq_throttle = function (delay, no_trailing, callback, debounce_mode) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id,

      // Keep track of the last time `callback` was executed.
      last_exec = 0;

    // `no_trailing` defaults to falsy.
    if (typeof no_trailing !== 'boolean') {
      debounce_mode = callback;
      callback = no_trailing;
      no_trailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
      var that = this,
        elapsed = +new Date() - last_exec,
        args = arguments;

      // Execute `callback` and update the `last_exec` timestamp.
      function exec() {
        last_exec = +new Date();
        callback.apply(that, args);
      };

      // If `debounce_mode` is true (at_begin) this is used to clear the flag
      // to allow future `callback` executions.
      function clear() {
        timeout_id = undefined;
      };

      if (debounce_mode && !timeout_id) {
        // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
      }

      // Clear any existing timeout.
      timeout_id && clearTimeout(timeout_id);

      if (debounce_mode === undefined && elapsed > delay) {
        // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();

      } else if (no_trailing !== true) {
        // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        // 
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        // 
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
      }
    };

    // Set the guid of `wrapper` function to the same of original callback, so
    // it can be removed in jQuery 1.4+ .unbind or .die by using the original
    // callback as a reference.
    if ($.guid) {
      wrapper.guid = callback.guid = callback.guid || $.guid++;
    }

    // Return the wrapper function.
    return wrapper;
  };

  // Method: jQuery.debounce
  // 
  // Debounce execution of a function. Debouncing, unlike throttling,
  // guarantees that a function is only executed a single time, either at the
  // very beginning of a series of calls, or at the very end. If you want to
  // simply rate-limit execution of a function, see the <jQuery.throttle>
  // method.
  // 
  // In this visualization, | is a debounced-function call and X is the actual
  // callback execution:
  // 
  // > Debounced with `at_begin` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // >                          X                                 X
  // > 
  // > Debounced with `at_begin` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X                                 X
  // 
  // Usage:
  // 
  // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', debounced );
  // > jQuery('selector').unbind( 'someevent', debounced );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
  //    unspecified, callback will only be executed `delay` milliseconds after
  //    the last debounced-function call. If at_begin is true, callback will be
  //    executed only at the first debounced-function call. (After the
  //    throttled-function has not been called for `delay` milliseconds, the
  //    internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the debounced-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, debounced, function.

  $.debounce = function (delay, at_begin, callback) {
    return callback === undefined
      ? jq_throttle(delay, at_begin, false)
      : jq_throttle(delay, callback, at_begin !== false);
  };

})(this);

define("debounce", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.throttle;
  };
}(this)));

define('stickyElement', [
  'jquery',
  'enquire',
  'debounce',
  'gsap'
], function ($, enquire) {

  var eventEmitter;
  var enquireQueries = ['screen and (max-width : 1029px)'];

  /* Options values */
  var options = {
    waypoints: {
      top: 0, //20 Offset ajouté à la position top du top waypoint
      bottom: 0 //50 
    },
    menu: {
      position: {
        top: 150, //120
        auto: 'auto'
      },
      maxHeight: 100,
      bottomPaddingPosition: 30
    },
    header: {
      maxHeight: 100,
      height: 0,
      animation: {
        duration: .8
      }
    }
  };

  /* Static configuration for sticky elements (not instance options) */
  var staticOptions = {
    position: {
      sticky: 150,
      auto: 'auto'
    },
    menu: {
      header: {
        maxHeight: 100,
        height: 0,
        animation: {
          duration: .4,
          easin: Power3.easeInOut
        }
      }
    }
  };

  /* Instance options 
   *
   * waypoints : 
   *      top: offset added to offset top position of the top waypoint of the instance
   *      bottom: offset added to offset bottom position of the bottom waypoint of the instance
   * position: 
   *      sticky: sticky position offset of the instance (override the static value)
   *      auto: non-sticky position of the instance (override the static value)
  */
  var instanceOpts = {
    menu: { /* Sticky menu type options */
      waypoints: {
        offsetTop: 120,
        offsetBottom: 40
      },
      parent: {
        offsetTop: -3
      }
    },
    pub: { /* Sticky Pub type options */
      waypoints: {
        offsetTop: 30,
        offsetBottom: 40
      },
      parent: {
        offsetTop: 110
      }
    },
    pubSubLevel: { /* Sticky Pub type options */
      waypoints: {
        offsetTop: 0,
        offsetBottom: 40
      },
      parent: {
        offsetTop: 20
      }
    },
    widget: { /* Sticky Pub type options */
      position: {
        sticky: 220,
        auto: 'auto'
      },
      waypoints: {
        offsetTop: -90,
        offsetBottom: 40
      },
      parent: {
        offsetTop: 110
      },
      top: 110
    },
    filter: { /* Sticky Filters type options */

    }
  };

  /* List of instance to refresh on resize and scroll */
  var _registry = [];

  /* Base class for sticky elements */
  var StickyElement = function ($el, opts) {
    var options = {
      sticky: 'sticky', /* Css class for sticky state */
      mutable: false,
      callbacks: {
        stick: function (o) { }, /* Callback on sticky state */
        unstick: function (o) { }, /* Callback on unsticky state */
        init: function (o) { } /* Callback on init */
      }
    };

    /* Options instance */
    this.options = $.extend({}, options, opts);

    /* Elements */
    this.el = ($el && $el.length) ? $el : null;

    /* Waypoints */
    var waypoints = this.options.waypoints;
    this.tWaypoint = waypoints.top;
    this.bWaypoint = waypoints.bottom;

    /* Statements top/bottom */
    this.statements = {
      top: true,
      bottom: false
    };

    return this.init();
  };

  $.extend(StickyElement.prototype, {
    init: function () {
      var o = this.options
        , cb = o.callbacks
        , self = this;

      if (cb.init) {
        /* exec. init callaback function */
        cb.init.call(null, this);
      }

      /* Top waypoint settings */
      this.tWaypoint.waypoint(function (dir) {
        if (dir == 'down') {
          self.stick(function () {
            self.statements.top = false;
          });
        } else {
          self.unstick(function () {
            self.statements.top = true;
          });
        }
      }, {
        offset: function () {
          /* Top position adjustment */
          return o.waypoints.offsetTop;
        }
      });

      /* Bottom waypoint settings */
      this.bWaypoint.waypoint(function (dir) {
        if (dir == 'down') {
          var top = self.getBottomPosition();
          self.fixedAtBottom(top, function () {
            self.statements.bottom = true;
          });
        } else {
          if (!self.isOnTop()) {
            self.stick(function () {
              self.statements.bottom = false;
            });
          }
        }
      }, {
        offset: function () {
          /* Return calculated offset bottom */
          return self.getBottomOffset();
        }
      });

      return this;
    },

    /* Get absolute position of the element on bottom sticky stop point */
    getBottomOffset: function () {
      /* Calculate offset to remove sticky and set absolute position */
      var height = this.el.innerHeight()
        , bottomOffset = this.options.waypoints.offsetBottom
        , stickyPosition = staticOptions.position.sticky
        , r = (height + bottomOffset) + stickyPosition;

      return r;
    },

    isOnTop: function () {
      return this.statements.top;
    },

    isOnBottom: function () {
      return this.statements.bottom;
    },

    /* 
     * Set element on sticky position and call 2 functions callbacks 
     * @argument fn {function} : callback (argument passed is the instance)
     * @return self instance
    */
    stick: function (fn) {
      /* Used the static Options position top */
      var opts = this.options
        , top = opts.position.sticky
        , css = opts.sticky;

      this.el.addClass(css).css({ top: top });

      /* Arguments function */
      if (typeof fn === 'function') {
        fn.call(this.el);
      }

      /* Callback function on stick */
      var c = this.options.callbacks
        , fn = 'stick';
      if (typeof c[fn] === 'function') {
        c[fn].call(null, this);
      }

      return this;
    },

    /**/
    unstick: function (fn) {
      var opts = this.options
        , auto = opts.position.auto
        , css = opts.sticky;

      this.el.removeClass(css).css({ top: auto });

      /* Arguments function */
      if (typeof fn === 'function') {
        fn.call(this.el);
      }

      /* Callback function on stick */
      var c = this.options.callbacks
        , fn = 'unstick';
      if (typeof c[fn] === 'function') {
        c[fn].call(null, this);
      }

      return this;
    },

    /* Unstick the element and set the top css property value
     * @argument top {int} : the value of the top offset
     * @argument fn {function} : argument callback (argument passed is the instance)
    */
    fixedAtBottom: function (top, fn) {
      var css = this.options.sticky;
      this.el.removeClass(css).css({ top: top });
      if (typeof fn == 'function') {
        fn.call(null);
      }

      return this;
    },

    getBottomPosition: function () {
      var o = this.options
        , fn = 'bottomPosition'
        , position = 0;

      if (typeof o[fn] != 'undefined') {
        position = o[fn].call(null, this);
      } else {
        var height = this.el.data('height') || 0
          , maxHeight = this.el.data('maxHeight') || 0
          , top = this.tWaypoint.offset().top + this.options.parent.offsetTop
          , bottom = this.bWaypoint.offset().top
          , offsetBottom = this.options.waypoints.offsetBottom;

        position = (bottom - top) - (height + maxHeight + offsetBottom);
      }

      return position;
    },

    /* Check if the element is sticked */
    isSticked: function () {
      var css = this.options.sticky;
      return this.el.hasClass(css);
    },

    /* Refresh the bottom position of the element if is on bottom and not sticked */
    refreshBottomPosition: function () {
      var opts = this.options
        , force = force || false;

      if (this.isOnBottom() && !this.isSticked()) {
        this.el.css({ top: this.getBottomPosition() });
      }

      return;
    },

    refresh: function () {
      var o = this.options
        , cb = o.callbacks;

      if (cb.init) {
        /* exec. init callaback function */
        cb.init.call(null, this);
      }

      return this;
    }
  });

  /* StickyElements */
  var animate = function ($el, val, fn) {
    var opts = staticOptions.menu.header.animation
      , duration = opts.duration
      , easin = opts.easin;

    TweenLite.to($el, duration, {
      maxHeight: val, ease: easin, onComplete: function () {
        if (typeof fn === 'function') {
          fn.call(null);
        }

        if (val != 0) {
          $el.css({ overflow: 'visible' });
        }
      }, onStart: function () {
        if (val == 0) {
          $el.css({ overflow: 'hidden' });
        }
      }
    });
    return;
  };

  var _Sticky = {
    /* Init */
    init: function ($context, type) {
      var $top = $('.zone-content:first .wrapper:first')
        , $bottom = $('footer');

      switch (type) {
        case 'menu':


          var opts = $.extend(true, {}, instanceOpts[type], {
            position: staticOptions.position,
            waypoints: {
              top: $('.col1:first', $top),
              bottom: $bottom
            },
            callbacks: {
              init: function (obj) {
                var $elt = obj.el

                /* TODO REMOVE */
                $elt.data('height', obj.el.height());
                return;
              }
            }
          });
          break;
        case 'pub':
          var optsType = ($('body').hasClass('third-level-page')) ? 'pubSubLevel' : type;

          var opts = $.extend(true, {}, instanceOpts[optsType], {
            position: staticOptions.position,
            waypoints: {
              top: $top,
              bottom: $bottom
            },
            callbacks: {
              stick: function () { return; },
              unstick: function () { return; },
              init: function (obj) {
                var $elt = obj.el;
                $elt.data('height', obj.el.height());

                if (!$("html").hasClass("ie7") && !$("html").hasClass("ie8")) {
                  /* Break points to disabled sticky statement */
                  enquire.register(enquireQueries[0], {
                    unmatch: function () {
                      //check if element must be unstick
                      if ($.inArray('div.wrapper', $.waypoints('above')) == -1) {
                        obj.unstick(function () {
                          obj.statements.top = true;
                          obj.statements.bottom = false;
                        });
                      }
                    }
                  });
                }


                return;
              }
            }
          });
          break;
        case 'widget':
          var opts = $.extend(true, {}, instanceOpts[type], {
            position: staticOptions.position,
            mutable: true,
            waypoints: {
              top: $top,
              bottom: $bottom
            },
            callbacks: {
              stick: function () { return; },
              unstick: function () { return; },
              init: function (obj) {
                var $elt = obj.el;
                $elt.data('height', obj.el.height());

                if (!$("html").hasClass("ie7") && !$("html").hasClass("ie8")) {
                  /* Break points to disabled sticky statement */
                  enquire.register(enquireQueries[0], {
                    match: function () {
                      $elt.addClass('sticky-disabled');
                    },
                    unmatch: function () {
                      $elt.removeClass('sticky-disabled');
                    }
                  });
                }


                return;
              }
            }
          });
          break;
      }

      return new StickyElement($context, opts);
    }
  };

  var Sticky = {
    init: function (context) {
      eventEmitter = ADM.eventEmitter;
      var refresh = function () {
        /* Refresh waypoints values */
        $.waypoints('refresh');

        /* Refresh all instances registered */
        if (_registry) {
          $(_registry).each(function (i, elt) {
            if (elt.options.mutable) {
              elt.refresh();
            }

            elt.refreshBottomPosition();
          });
        }
      };

      /* Init DOM elements on context */
      if (context) {
        /* Height off the heightest sticky element instance */
        var height = 0;

        /* Only a single sticky subnav menu per page */
        for (var i = 0, l = context.length; i < l; i++) {
          var $elt = $(context[i])
            , type = $elt.data('sticky-type')
            , stickyElt = _Sticky.init($elt, type);

          if (stickyElt) {
            /* Check for height element on load page scroll adjustment */
            var el = stickyElt.el
              , h = el.data('height') || 0
              , m = el.data('maxHeight') || 0
              , t = h + m;

            if (t > height) {
              height = t;
            }

            _registry.push(stickyElt);
          }
        }

        /* On resize window refresh values */
        $(window).resize(function () {
          refresh();
        });

        /* Refresh waypoints On Dom Height Changed */
        $(window).scroll($.throttle(1000, function () {
          refresh();
        }));

        /* Call by commerce interface */
        eventEmitter.addListener('domChanged', function () {
          refresh();
        });

        /* Scroll on page load */
        var scrollTop = $(window).scrollTop()
          , offset = $('body footer:first').offset().top
          , step = 50;

        if ((scrollTop + height + step) > offset) {
          // empèche les liens vers les anchors
          //window.scroll(0, 0);
        }

        if (!$("html").hasClass("ie7") && !$("html").hasClass("ie8")) {
          /* Break points to disabled sticky statement */

          enquire.register(enquireQueries[0], {
            unmatch: function () {
              refresh();
            }
          });
        }

      }
    }
  };

  return Sticky;
});

/*
*  jQuery OwlCarousel v1.3.2
*
*  Copyright (c) 2013 Bartosz Wojciechowski
*  http://www.owlgraphic.com/owlcarousel/
*
*  Licensed under MIT
*
*/

/*JS Lint helpers: */
/*global dragMove: false, dragEnd: false, $, jQuery, alert, window, document */
/*jslint nomen: true, continue:true */

if (typeof Object.create !== "function") {
  Object.create = function (obj) {
    function F() { }
    F.prototype = obj;
    return new F();
  };
}
(function ($, window, document) {

  var Carousel = {
    init: function (options, el) {
      var base = this;

      base.$elem = $(el);
      base.options = $.extend({}, $.fn.owlCarousel.options, base.$elem.data(), options);

      base.userOptions = options;
      base.loadContent();
    },

    loadContent: function () {
      var base = this, url;

      function getData(data) {
        var i, content = "";
        if (typeof base.options.jsonSuccess === "function") {
          base.options.jsonSuccess.apply(this, [data]);
        } else {
          for (i in data.owl) {
            if (data.owl.hasOwnProperty(i)) {
              content += data.owl[i].item;
            }
          }
          base.$elem.html(content);
        }
        base.logIn();
      }

      if (typeof base.options.beforeInit === "function") {
        base.options.beforeInit.apply(this, [base.$elem]);
      }

      if (typeof base.options.jsonPath === "string") {
        url = base.options.jsonPath;
        $.getJSON(url, getData);
      } else {
        base.logIn();
      }
    },

    logIn: function () {
      var base = this;

      base.$elem.data("owl-originalStyles", base.$elem.attr("style"))
        .data("owl-originalClasses", base.$elem.attr("class"));

      base.$elem.css({ opacity: 0 });
      base.orignalItems = base.options.items;
      base.checkBrowser();
      base.wrapperWidth = 0;
      base.checkVisible = null;
      base.setVars();
    },

    setVars: function () {
      var base = this;
      if (base.$elem.children().length === 0) { return false; }
      base.baseClass();
      base.eventTypes();
      base.$userItems = base.$elem.children();
      base.itemsAmount = base.$userItems.length;
      base.wrapItems();
      base.$owlItems = base.$elem.find(".owl-item");
      base.$owlWrapper = base.$elem.find(".owl-wrapper");
      base.playDirection = "next";
      base.prevItem = 0;
      base.prevArr = [0];
      base.currentItem = 0;
      base.customEvents();
      base.onStartup();
    },

    onStartup: function () {
      var base = this;
      base.updateItems();
      base.calculateAll();
      base.buildControls();
      base.updateControls();
      base.response();
      base.moveEvents();
      base.stopOnHover();
      base.owlStatus();

      if (base.options.transitionStyle !== false) {
        base.transitionTypes(base.options.transitionStyle);
      }
      if (base.options.autoPlay === true) {
        base.options.autoPlay = 5000;
      }
      base.play();

      base.$elem.find(".owl-wrapper").css("display", "block");

      if (!base.$elem.is(":visible")) {
        base.watchVisibility();
      } else {
        base.$elem.css("opacity", 1);
      }
      base.onstartup = false;
      base.eachMoveUpdate();
      if (typeof base.options.afterInit === "function") {
        base.options.afterInit.apply(this, [base.$elem]);
      }
    },

    eachMoveUpdate: function () {
      var base = this;

      if (base.options.lazyLoad === true) {
        base.lazyLoad();
      }
      if (base.options.autoHeight === true) {
        base.autoHeight();
      }
      base.onVisibleItems();

      if (typeof base.options.afterAction === "function") {
        base.options.afterAction.apply(this, [base.$elem]);
      }
    },

    updateVars: function () {
      var base = this;
      if (typeof base.options.beforeUpdate === "function") {
        base.options.beforeUpdate.apply(this, [base.$elem]);
      }
      base.watchVisibility();
      base.updateItems();
      base.calculateAll();
      base.updatePosition();
      base.updateControls();
      base.eachMoveUpdate();
      if (typeof base.options.afterUpdate === "function") {
        base.options.afterUpdate.apply(this, [base.$elem]);
      }
    },

    reload: function () {
      var base = this;
      window.setTimeout(function () {
        base.updateVars();
      }, 0);
    },

    watchVisibility: function () {
      var base = this;

      if (base.$elem.is(":visible") === false) {
        base.$elem.css({ opacity: 0 });
        window.clearInterval(base.autoPlayInterval);
        window.clearInterval(base.checkVisible);
      } else {
        return false;
      }
      base.checkVisible = window.setInterval(function () {
        if (base.$elem.is(":visible")) {
          base.reload();
          base.$elem.animate({ opacity: 1 }, 200);
          window.clearInterval(base.checkVisible);
        }
      }, 500);
    },

    wrapItems: function () {
      var base = this;
      base.$userItems.wrapAll("<div class=\"owl-wrapper\">").wrap("<div class=\"owl-item\"></div>");
      base.$elem.find(".owl-wrapper").wrap("<div class=\"owl-wrapper-outer\">");
      base.wrapperOuter = base.$elem.find(".owl-wrapper-outer");
      base.$elem.css("display", "block");
    },

    baseClass: function () {
      var base = this,
        hasBaseClass = base.$elem.hasClass(base.options.baseClass),
        hasThemeClass = base.$elem.hasClass(base.options.theme);

      if (!hasBaseClass) {
        base.$elem.addClass(base.options.baseClass);
      }

      if (!hasThemeClass) {
        base.$elem.addClass(base.options.theme);
      }
    },

    updateItems: function () {
      var base = this, width, i;

      if (base.options.responsive === false) {
        return false;
      }
      if (base.options.singleItem === true) {
        base.options.items = base.orignalItems = 1;
        base.options.itemsCustom = false;
        base.options.itemsDesktop = false;
        base.options.itemsDesktopSmall = false;
        base.options.itemsTablet = false;
        base.options.itemsTabletSmall = false;
        base.options.itemsMobile = false;
        return false;
      }

      width = $(base.options.responsiveBaseWidth).width();

      if (width > (base.options.itemsDesktop[0] || base.orignalItems)) {
        base.options.items = base.orignalItems;
      }
      if (base.options.itemsCustom !== false) {
        //Reorder array by screen size
        base.options.itemsCustom.sort(function (a, b) { return a[0] - b[0]; });

        for (i = 0; i < base.options.itemsCustom.length; i += 1) {
          if (base.options.itemsCustom[i][0] <= width) {
            base.options.items = base.options.itemsCustom[i][1];
          }
        }

      } else {

        if (width <= base.options.itemsDesktop[0] && base.options.itemsDesktop !== false) {
          base.options.items = base.options.itemsDesktop[1];
        }

        if (width <= base.options.itemsDesktopSmall[0] && base.options.itemsDesktopSmall !== false) {
          base.options.items = base.options.itemsDesktopSmall[1];
        }

        if (width <= base.options.itemsTablet[0] && base.options.itemsTablet !== false) {
          base.options.items = base.options.itemsTablet[1];
        }

        if (width <= base.options.itemsTabletSmall[0] && base.options.itemsTabletSmall !== false) {
          base.options.items = base.options.itemsTabletSmall[1];
        }

        if (width <= base.options.itemsMobile[0] && base.options.itemsMobile !== false) {
          base.options.items = base.options.itemsMobile[1];
        }
      }

      //if number of items is less than declared
      if (base.options.items > base.itemsAmount && base.options.itemsScaleUp === true) {
        base.options.items = base.itemsAmount;
      }
    },

    response: function () {
      var base = this,
        smallDelay,
        lastWindowWidth;

      if (base.options.responsive !== true) {
        return false;
      }
      lastWindowWidth = $(window).width();

      base.resizer = function () {
        if ($(window).width() !== lastWindowWidth) {
          if (base.options.autoPlay !== false) {
            window.clearInterval(base.autoPlayInterval);
          }
          window.clearTimeout(smallDelay);
          smallDelay = window.setTimeout(function () {
            lastWindowWidth = $(window).width();
            base.updateVars();
          }, base.options.responsiveRefreshRate);
        }
      };
      $(window).resize(base.resizer);
    },

    updatePosition: function () {
      var base = this;
      base.jumpTo(base.currentItem);
      if (base.options.autoPlay !== false) {
        base.checkAp();
      }
    },

    appendItemsSizes: function () {
      var base = this,
        roundPages = 0,
        lastItem = base.itemsAmount - base.options.items;

      base.$owlItems.each(function (index) {
        var $this = $(this);
        $this
          .css({ "width": base.itemWidth })
          .data("owl-item", Number(index));

        if (index % base.options.items === 0 || index === lastItem) {
          if (!(index > lastItem)) {
            roundPages += 1;
          }
        }
        $this.data("owl-roundPages", roundPages);
      });
    },

    appendWrapperSizes: function () {
      var base = this,
        width = base.$owlItems.length * base.itemWidth;

      base.$owlWrapper.css({
        "width": width * 2,
        "left": 0
      });
      base.appendItemsSizes();
    },

    calculateAll: function () {
      var base = this;
      base.calculateWidth();
      base.appendWrapperSizes();
      base.loops();
      base.max();
    },

    calculateWidth: function () {
      var base = this;
      base.itemWidth = Math.round(base.$elem.width() / base.options.items);
    },

    max: function () {
      var base = this,
        maximum = ((base.itemsAmount * base.itemWidth) - base.options.items * base.itemWidth) * -1;
      if (base.options.items > base.itemsAmount) {
        base.maximumItem = 0;
        maximum = 0;
        base.maximumPixels = 0;
      } else {
        base.maximumItem = base.itemsAmount - base.options.items;
        base.maximumPixels = maximum;
      }
      return maximum;
    },

    min: function () {
      return 0;
    },

    loops: function () {
      var base = this,
        prev = 0,
        elWidth = 0,
        i,
        item,
        roundPageNum;

      base.positionsInArray = [0];
      base.pagesInArray = [];

      for (i = 0; i < base.itemsAmount; i += 1) {
        elWidth += base.itemWidth;
        base.positionsInArray.push(-elWidth);

        if (base.options.scrollPerPage === true) {
          item = $(base.$owlItems[i]);
          roundPageNum = item.data("owl-roundPages");
          if (roundPageNum !== prev) {
            base.pagesInArray[prev] = base.positionsInArray[i];
            prev = roundPageNum;
          }
        }
      }
    },

    buildControls: function () {
      var base = this;
      if (base.options.navigation === true || base.options.pagination === true) {
        base.owlControls = $("<div class=\"owl-controls\"/>").toggleClass("clickable", !base.browser.isTouch).appendTo(base.$elem);
      }
      if (base.options.pagination === true) {
        base.buildPagination();
      }
      if (base.options.navigation === true) {
        base.buildButtons();
      }
    },

    buildButtons: function () {
      var base = this,
        buttonsWrapper = $("<div class=\"owl-buttons\"/>");
      base.owlControls.append(buttonsWrapper);

      base.buttonPrev = $("<div/>", {
        "class": "owl-prev",
        "html": base.options.navigationText[0] || ""
      });

      base.buttonNext = $("<div/>", {
        "class": "owl-next",
        "html": base.options.navigationText[1] || ""
      });

      buttonsWrapper
        .append(base.buttonPrev)
        .append(base.buttonNext);

      buttonsWrapper.on("touchstart.owlControls mousedown.owlControls", "div[class^=\"owl\"]", function (event) {
        event.preventDefault();
      });

      buttonsWrapper.on("touchend.owlControls mouseup.owlControls", "div[class^=\"owl\"]", function (event) {
        event.preventDefault();
        if ($(this).hasClass("owl-next")) {
          base.next();
        } else {
          base.prev();
        }
      });
    },

    buildPagination: function () {
      var base = this;

      base.paginationWrapper = $("<div class=\"owl-pagination\"/>");
      base.owlControls.append(base.paginationWrapper);

      base.paginationWrapper.on("touchend.owlControls mouseup.owlControls", ".owl-page", function (event) {
        event.preventDefault();
        if (Number($(this).data("owl-page")) !== base.currentItem) {
          base.goTo(Number($(this).data("owl-page")), true);
        }
      });
    },

    updatePagination: function () {
      var base = this,
        counter,
        lastPage,
        lastItem,
        i,
        paginationButton,
        paginationButtonInner;

      if (base.options.pagination === false) {
        return false;
      }

      base.paginationWrapper.html("");

      counter = 0;
      lastPage = base.itemsAmount - base.itemsAmount % base.options.items;

      for (i = 0; i < base.itemsAmount; i += 1) {
        if (i % base.options.items === 0) {
          counter += 1;
          if (lastPage === i) {
            lastItem = base.itemsAmount - base.options.items;
          }
          paginationButton = $("<div/>", {
            "class": "owl-page"
          });
          paginationButtonInner = $("<span></span>", {
            "text": base.options.paginationNumbers === true ? counter : "",
            "class": base.options.paginationNumbers === true ? "owl-numbers" : ""
          });
          paginationButton.append(paginationButtonInner);

          paginationButton.data("owl-page", lastPage === i ? lastItem : i);
          paginationButton.data("owl-roundPages", counter);

          base.paginationWrapper.append(paginationButton);
        }
      }
      base.checkPagination();
    },
    checkPagination: function () {
      var base = this;
      if (base.options.pagination === false) {
        return false;
      }
      base.paginationWrapper.find(".owl-page").each(function () {
        if ($(this).data("owl-roundPages") === $(base.$owlItems[base.currentItem]).data("owl-roundPages")) {
          base.paginationWrapper
            .find(".owl-page")
            .removeClass("active");
          $(this).addClass("active");
        }
      });
    },

    checkNavigation: function () {
      var base = this;

      if (base.options.navigation === false) {
        return false;
      }
      if (base.options.rewindNav === false) {
        if (base.currentItem === 0 && base.maximumItem === 0) {
          base.buttonPrev.addClass("disabled");
          base.buttonNext.addClass("disabled");
        } else if (base.currentItem === 0 && base.maximumItem !== 0) {
          base.buttonPrev.addClass("disabled");
          base.buttonNext.removeClass("disabled");
        } else if (base.currentItem === base.maximumItem) {
          base.buttonPrev.removeClass("disabled");
          base.buttonNext.addClass("disabled");
        } else if (base.currentItem !== 0 && base.currentItem !== base.maximumItem) {
          base.buttonPrev.removeClass("disabled");
          base.buttonNext.removeClass("disabled");
        }
      }
    },

    updateControls: function () {
      var base = this;
      base.updatePagination();
      base.checkNavigation();
      if (base.owlControls) {
        if (base.options.items >= base.itemsAmount) {
          base.owlControls.hide();
        } else {
          base.owlControls.show();
        }
      }
    },

    destroyControls: function () {
      var base = this;
      if (base.owlControls) {
        base.owlControls.remove();
      }
    },

    next: function (speed) {
      var base = this;

      if (base.isTransition) {
        return false;
      }

      base.currentItem += base.options.scrollPerPage === true ? base.options.items : 1;
      if (base.currentItem > base.maximumItem + (base.options.scrollPerPage === true ? (base.options.items - 1) : 0)) {
        if (base.options.rewindNav === true) {
          base.currentItem = 0;
          speed = "rewind";
        } else {
          base.currentItem = base.maximumItem;
          return false;
        }
      }
      base.goTo(base.currentItem, speed);
    },

    prev: function (speed) {
      var base = this;

      if (base.isTransition) {
        return false;
      }

      if (base.options.scrollPerPage === true && base.currentItem > 0 && base.currentItem < base.options.items) {
        base.currentItem = 0;
      } else {
        base.currentItem -= base.options.scrollPerPage === true ? base.options.items : 1;
      }
      if (base.currentItem < 0) {
        if (base.options.rewindNav === true) {
          base.currentItem = base.maximumItem;
          speed = "rewind";
        } else {
          base.currentItem = 0;
          return false;
        }
      }
      base.goTo(base.currentItem, speed);
    },

    goTo: function (position, speed, drag) {
      var base = this,
        goToPixel;

      if (base.isTransition) {
        return false;
      }
      if (typeof base.options.beforeMove === "function") {
        base.options.beforeMove.apply(this, [base.$elem]);
      }
      if (position >= base.maximumItem) {
        position = base.maximumItem;
      } else if (position <= 0) {
        position = 0;
      }

      base.currentItem = base.owl.currentItem = position;
      if (base.options.transitionStyle !== false && drag !== "drag" && base.options.items === 1 && base.browser.support3d === true) {
        base.swapSpeed(0);
        if (base.browser.support3d === true) {
          base.transition3d(base.positionsInArray[position]);
        } else {
          base.css2slide(base.positionsInArray[position], 1);
        }
        base.afterGo();
        base.singleItemTransition();
        return false;
      }
      goToPixel = base.positionsInArray[position];

      if (base.browser.support3d === true) {
        base.isCss3Finish = false;

        if (speed === true) {
          base.swapSpeed("paginationSpeed");
          window.setTimeout(function () {
            base.isCss3Finish = true;
          }, base.options.paginationSpeed);

        } else if (speed === "rewind") {
          base.swapSpeed(base.options.rewindSpeed);
          window.setTimeout(function () {
            base.isCss3Finish = true;
          }, base.options.rewindSpeed);

        } else {
          base.swapSpeed("slideSpeed");
          window.setTimeout(function () {
            base.isCss3Finish = true;
          }, base.options.slideSpeed);
        }
        base.transition3d(goToPixel);
      } else {
        if (speed === true) {
          base.css2slide(goToPixel, base.options.paginationSpeed);
        } else if (speed === "rewind") {
          base.css2slide(goToPixel, base.options.rewindSpeed);
        } else {
          base.css2slide(goToPixel, base.options.slideSpeed);
        }
      }
      base.afterGo();
    },

    jumpTo: function (position) {
      var base = this;
      if (typeof base.options.beforeMove === "function") {
        base.options.beforeMove.apply(this, [base.$elem]);
      }
      if (position >= base.maximumItem || position === -1) {
        position = base.maximumItem;
      } else if (position <= 0) {
        position = 0;
      }
      base.swapSpeed(0);
      if (base.browser.support3d === true) {
        base.transition3d(base.positionsInArray[position]);
      } else {
        base.css2slide(base.positionsInArray[position], 1);
      }
      base.currentItem = base.owl.currentItem = position;
      base.afterGo();
    },

    afterGo: function () {
      var base = this;

      base.prevArr.push(base.currentItem);
      base.prevItem = base.owl.prevItem = base.prevArr[base.prevArr.length - 2];
      base.prevArr.shift(0);

      if (base.prevItem !== base.currentItem) {
        base.checkPagination();
        base.checkNavigation();
        base.eachMoveUpdate();

        if (base.options.autoPlay !== false) {
          base.checkAp();
        }
      }
      if (typeof base.options.afterMove === "function" && base.prevItem !== base.currentItem) {
        base.options.afterMove.apply(this, [base.$elem]);
      }
    },

    stop: function () {
      var base = this;
      base.apStatus = "stop";
      window.clearInterval(base.autoPlayInterval);
    },

    checkAp: function () {
      var base = this;
      if (base.apStatus !== "stop") {
        base.play();
      }
    },

    play: function () {
      var base = this;
      base.apStatus = "play";
      if (base.options.autoPlay === false) {
        return false;
      }
      window.clearInterval(base.autoPlayInterval);
      base.autoPlayInterval = window.setInterval(function () {
        base.next(true);
      }, base.options.autoPlay);
    },

    swapSpeed: function (action) {
      var base = this;
      if (action === "slideSpeed") {
        base.$owlWrapper.css(base.addCssSpeed(base.options.slideSpeed));
      } else if (action === "paginationSpeed") {
        base.$owlWrapper.css(base.addCssSpeed(base.options.paginationSpeed));
      } else if (typeof action !== "string") {
        base.$owlWrapper.css(base.addCssSpeed(action));
      }
    },

    addCssSpeed: function (speed) {
      return {
        "-webkit-transition": "all " + speed + "ms ease",
        "-moz-transition": "all " + speed + "ms ease",
        "-o-transition": "all " + speed + "ms ease",
        "transition": "all " + speed + "ms ease"
      };
    },

    removeTransition: function () {
      return {
        "-webkit-transition": "",
        "-moz-transition": "",
        "-o-transition": "",
        "transition": ""
      };
    },

    doTranslate: function (pixels) {
      return {
        "-webkit-transform": "translate3d(" + pixels + "px, 0px, 0px)",
        "-moz-transform": "translate3d(" + pixels + "px, 0px, 0px)",
        "-o-transform": "translate3d(" + pixels + "px, 0px, 0px)",
        "-ms-transform": "translate3d(" + pixels + "px, 0px, 0px)",
        "transform": "translate3d(" + pixels + "px, 0px,0px)"
      };
    },

    transition3d: function (value) {
      var base = this;
      base.$owlWrapper.css(base.doTranslate(value));
    },

    css2move: function (value) {
      var base = this;
      base.$owlWrapper.css({ "left": value });
    },

    css2slide: function (value, speed) {
      var base = this;

      base.isCssFinish = false;
      base.$owlWrapper.stop(true, true).animate({
        "left": value
      }, {
        duration: speed || base.options.slideSpeed,
        complete: function () {
          base.isCssFinish = true;
        }
      });
    },

    checkBrowser: function () {
      var base = this,
        translate3D = "translate3d(0px, 0px, 0px)",
        tempElem = document.createElement("div"),
        regex,
        asSupport,
        support3d,
        isTouch;

      tempElem.style.cssText = "  -moz-transform:" + translate3D +
        "; -ms-transform:" + translate3D +
        "; -o-transform:" + translate3D +
        "; -webkit-transform:" + translate3D +
        "; transform:" + translate3D;
      regex = /translate3d\(0px, 0px, 0px\)/g;
      asSupport = tempElem.style.cssText.match(regex);
      support3d = (asSupport !== null && asSupport.length === 1);

      isTouch = "ontouchstart" in window || window.navigator.msMaxTouchPoints;

      base.browser = {
        "support3d": support3d,
        "isTouch": isTouch
      };
    },

    moveEvents: function () {
      var base = this;
      if (base.options.mouseDrag !== false || base.options.touchDrag !== false) {
        base.gestures();
        base.disabledEvents();
      }
    },

    eventTypes: function () {
      var base = this,
        types = ["s", "e", "x"];

      base.ev_types = {};

      if (base.options.mouseDrag === true && base.options.touchDrag === true) {
        types = [
          "touchstart.owl mousedown.owl",
          "touchmove.owl mousemove.owl",
          "touchend.owl touchcancel.owl mouseup.owl"
        ];
      } else if (base.options.mouseDrag === false && base.options.touchDrag === true) {
        types = [
          "touchstart.owl",
          "touchmove.owl",
          "touchend.owl touchcancel.owl"
        ];
      } else if (base.options.mouseDrag === true && base.options.touchDrag === false) {
        types = [
          "mousedown.owl",
          "mousemove.owl",
          "mouseup.owl"
        ];
      }

      base.ev_types.start = types[0];
      base.ev_types.move = types[1];
      base.ev_types.end = types[2];
    },

    disabledEvents: function () {
      var base = this;
      base.$elem.on("dragstart.owl", function (event) { event.preventDefault(); });
      base.$elem.on("mousedown.disableTextSelect", function (e) {
        return $(e.target).is('input, textarea, select, option');
      });
    },

    gestures: function () {
      /*jslint unparam: true*/
      var base = this,
        locals = {
          offsetX: 0,
          offsetY: 0,
          baseElWidth: 0,
          relativePos: 0,
          position: null,
          minSwipe: null,
          maxSwipe: null,
          sliding: null,
          dargging: null,
          targetElement: null
        };

      base.isCssFinish = true;

      function getTouches(event) {
        if (event.touches !== undefined) {
          return {
            x: event.touches[0].pageX,
            y: event.touches[0].pageY
          };
        }

        if (event.touches === undefined) {
          if (event.pageX !== undefined) {
            return {
              x: event.pageX,
              y: event.pageY
            };
          }
          if (event.pageX === undefined) {
            return {
              x: event.clientX,
              y: event.clientY
            };
          }
        }
      }

      function swapEvents(type) {
        if (type === "on") {
          $(document).on(base.ev_types.move, dragMove);
          $(document).on(base.ev_types.end, dragEnd);
        } else if (type === "off") {
          $(document).off(base.ev_types.move);
          $(document).off(base.ev_types.end);
        }
      }

      function dragStart(event) {
        var ev = event.originalEvent || event || window.event,
          position;

        if (ev.which === 3) {
          return false;
        }
        if (base.itemsAmount <= base.options.items) {
          return;
        }
        if (base.isCssFinish === false && !base.options.dragBeforeAnimFinish) {
          return false;
        }
        if (base.isCss3Finish === false && !base.options.dragBeforeAnimFinish) {
          return false;
        }

        if (base.options.autoPlay !== false) {
          window.clearInterval(base.autoPlayInterval);
        }

        if (base.browser.isTouch !== true && !base.$owlWrapper.hasClass("grabbing")) {
          base.$owlWrapper.addClass("grabbing");
        }

        base.newPosX = 0;
        base.newRelativeX = 0;

        $(this).css(base.removeTransition());

        position = $(this).position();
        locals.relativePos = position.left;

        locals.offsetX = getTouches(ev).x - position.left;
        locals.offsetY = getTouches(ev).y - position.top;

        swapEvents("on");

        locals.sliding = false;
        locals.targetElement = ev.target || ev.srcElement;
      }

      function dragMove(event) {
        var ev = event.originalEvent || event || window.event,
          minSwipe,
          maxSwipe;

        base.newPosX = getTouches(ev).x - locals.offsetX;
        base.newPosY = getTouches(ev).y - locals.offsetY;
        base.newRelativeX = base.newPosX - locals.relativePos;

        if (typeof base.options.startDragging === "function" && locals.dragging !== true && base.newRelativeX !== 0) {
          locals.dragging = true;
          base.options.startDragging.apply(base, [base.$elem]);
        }

        if ((base.newRelativeX > 8 || base.newRelativeX < -8) && (base.browser.isTouch === true)) {
          if (ev.preventDefault !== undefined) {
            ev.preventDefault();
          } else {
            ev.returnValue = false;
          }
          locals.sliding = true;
        }

        if ((base.newPosY > 10 || base.newPosY < -10) && locals.sliding === false) {
          $(document).off("touchmove.owl");
        }

        minSwipe = function () {
          return base.newRelativeX / 5;
        };

        maxSwipe = function () {
          return base.maximumPixels + base.newRelativeX / 5;
        };

        base.newPosX = Math.max(Math.min(base.newPosX, minSwipe()), maxSwipe());
        if (base.browser.support3d === true) {
          base.transition3d(base.newPosX);
        } else {
          base.css2move(base.newPosX);
        }
      }

      function dragEnd(event) {
        var ev = event.originalEvent || event || window.event,
          newPosition,
          handlers,
          owlStopEvent;

        ev.target = ev.target || ev.srcElement;

        locals.dragging = false;

        if (base.browser.isTouch !== true) {
          base.$owlWrapper.removeClass("grabbing");
        }

        if (base.newRelativeX < 0) {
          base.dragDirection = base.owl.dragDirection = "left";
        } else {
          base.dragDirection = base.owl.dragDirection = "right";
        }

        if (base.newRelativeX !== 0) {
          newPosition = base.getNewPosition();
          base.goTo(newPosition, false, "drag");
          if (locals.targetElement === ev.target && base.browser.isTouch !== true) {
            $(ev.target).on("click.disable", function (ev) {
              ev.stopImmediatePropagation();
              ev.stopPropagation();
              ev.preventDefault();
              $(ev.target).off("click.disable");
            });
            handlers = $._data(ev.target, "events").click;
            owlStopEvent = handlers.pop();
            handlers.splice(0, 0, owlStopEvent);
          }
        }
        swapEvents("off");
      }
      base.$elem.on(base.ev_types.start, ".owl-wrapper", dragStart);
    },

    getNewPosition: function () {
      var base = this,
        newPosition = base.closestItem();

      if (newPosition > base.maximumItem) {
        base.currentItem = base.maximumItem;
        newPosition = base.maximumItem;
      } else if (base.newPosX >= 0) {
        newPosition = 0;
        base.currentItem = 0;
      }
      return newPosition;
    },
    closestItem: function () {
      var base = this,
        array = base.options.scrollPerPage === true ? base.pagesInArray : base.positionsInArray,
        goal = base.newPosX,
        closest = null;

      $.each(array, function (i, v) {
        if (goal - (base.itemWidth / 20) > array[i + 1] && goal - (base.itemWidth / 20) < v && base.moveDirection() === "left") {
          closest = v;
          if (base.options.scrollPerPage === true) {
            base.currentItem = $.inArray(closest, base.positionsInArray);
          } else {
            base.currentItem = i;
          }
        } else if (goal + (base.itemWidth / 20) < v && goal + (base.itemWidth / 20) > (array[i + 1] || array[i] - base.itemWidth) && base.moveDirection() === "right") {
          if (base.options.scrollPerPage === true) {
            closest = array[i + 1] || array[array.length - 1];
            base.currentItem = $.inArray(closest, base.positionsInArray);
          } else {
            closest = array[i + 1];
            base.currentItem = i + 1;
          }
        }
      });
      return base.currentItem;
    },

    moveDirection: function () {
      var base = this,
        direction;
      if (base.newRelativeX < 0) {
        direction = "right";
        base.playDirection = "next";
      } else {
        direction = "left";
        base.playDirection = "prev";
      }
      return direction;
    },

    customEvents: function () {
      /*jslint unparam: true*/
      var base = this;
      base.$elem.on("owl.next", function () {
        base.next();
      });
      base.$elem.on("owl.prev", function () {
        base.prev();
      });
      base.$elem.on("owl.play", function (event, speed) {
        base.options.autoPlay = speed;
        base.play();
        base.hoverStatus = "play";
      });
      base.$elem.on("owl.stop", function () {
        base.stop();
        base.hoverStatus = "stop";
      });
      base.$elem.on("owl.goTo", function (event, item) {
        base.goTo(item);
      });
      base.$elem.on("owl.jumpTo", function (event, item) {
        base.jumpTo(item);
      });
    },

    stopOnHover: function () {
      var base = this;
      if (base.options.stopOnHover === true && base.browser.isTouch !== true && base.options.autoPlay !== false) {
        base.$elem.on("mouseover", function () {
          base.stop();
        });
        base.$elem.on("mouseout", function () {
          if (base.hoverStatus !== "stop") {
            base.play();
          }
        });
      }
    },

    lazyLoad: function () {
      var base = this,
        i,
        $item,
        itemNumber,
        $lazyImg,
        follow;

      if (base.options.lazyLoad === false) {
        return false;
      }
      for (i = 0; i < base.itemsAmount; i += 1) {
        $item = $(base.$owlItems[i]);

        if ($item.data("owl-loaded") === "loaded") {
          continue;
        }

        itemNumber = $item.data("owl-item");
        $lazyImg = $item.find(".lazyOwl");

        if (typeof $lazyImg.data("src") !== "string") {
          $item.data("owl-loaded", "loaded");
          continue;
        }
        if ($item.data("owl-loaded") === undefined) {
          $lazyImg.hide();
          $item.addClass("loading").data("owl-loaded", "checked");
        }
        if (base.options.lazyFollow === true) {
          follow = itemNumber >= base.currentItem;
        } else {
          follow = true;
        }
        if (follow && itemNumber < base.currentItem + base.options.items && $lazyImg.length) {
          base.lazyPreload($item, $lazyImg);
        }
      }
    },

    lazyPreload: function ($item, $lazyImg) {
      var base = this,
        iterations = 0,
        isBackgroundImg;

      if ($lazyImg.prop("tagName") === "DIV") {
        $lazyImg.css("background-image", "url(" + $lazyImg.data("src") + ")");
        isBackgroundImg = true;
      } else {
        $lazyImg[0].src = $lazyImg.data("src");
      }

      function showImage() {
        $item.data("owl-loaded", "loaded").removeClass("loading");
        $lazyImg.removeAttr("data-src");
        if (base.options.lazyEffect === "fade") {
          $lazyImg.fadeIn(400);
        } else {
          $lazyImg.show();
        }
        if (typeof base.options.afterLazyLoad === "function") {
          base.options.afterLazyLoad.apply(this, [base.$elem]);
        }
      }

      function checkLazyImage() {
        iterations += 1;
        if (base.completeImg($lazyImg.get(0)) || isBackgroundImg === true) {
          showImage();
        } else if (iterations <= 100) {//if image loads in less than 10 seconds 
          window.setTimeout(checkLazyImage, 100);
        } else {
          showImage();
        }
      }

      checkLazyImage();
    },

    autoHeight: function () {
      var base = this,
        $currentimg = $(base.$owlItems[base.currentItem]).find("img"),
        iterations;

      function addHeight() {
        var $currentItem = $(base.$owlItems[base.currentItem]).height();
        base.wrapperOuter.css("height", $currentItem + "px");
        if (!base.wrapperOuter.hasClass("autoHeight")) {
          window.setTimeout(function () {
            base.wrapperOuter.addClass("autoHeight");
          }, 0);
        }
      }

      function checkImage() {
        iterations += 1;
        if (base.completeImg($currentimg.get(0))) {
          addHeight();
        } else if (iterations <= 100) { //if image loads in less than 10 seconds 
          window.setTimeout(checkImage, 100);
        } else {
          base.wrapperOuter.css("height", ""); //Else remove height attribute
        }
      }

      if ($currentimg.get(0) !== undefined) {
        iterations = 0;
        checkImage();
      } else {
        addHeight();
      }
    },

    completeImg: function (img) {
      var naturalWidthType;

      if (!img.complete) {
        return false;
      }
      naturalWidthType = typeof img.naturalWidth;
      if (naturalWidthType !== "undefined" && img.naturalWidth === 0) {
        return false;
      }
      return true;
    },

    onVisibleItems: function () {
      var base = this,
        i;

      if (base.options.addClassActive === true) {
        base.$owlItems.removeClass("active");
      }
      base.visibleItems = [];
      for (i = base.currentItem; i < base.currentItem + base.options.items; i += 1) {
        base.visibleItems.push(i);

        if (base.options.addClassActive === true) {
          $(base.$owlItems[i]).addClass("active");
        }
      }
      base.owl.visibleItems = base.visibleItems;
    },

    transitionTypes: function (className) {
      var base = this;
      //Currently available: "fade", "backSlide", "goDown", "fadeUp"
      base.outClass = "owl-" + className + "-out";
      base.inClass = "owl-" + className + "-in";
    },

    singleItemTransition: function () {
      var base = this,
        outClass = base.outClass,
        inClass = base.inClass,
        $currentItem = base.$owlItems.eq(base.currentItem),
        $prevItem = base.$owlItems.eq(base.prevItem),
        prevPos = Math.abs(base.positionsInArray[base.currentItem]) + base.positionsInArray[base.prevItem],
        origin = Math.abs(base.positionsInArray[base.currentItem]) + base.itemWidth / 2,
        animEnd = 'webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend';

      base.isTransition = true;

      base.$owlWrapper
        .addClass('owl-origin')
        .css({
          "-webkit-transform-origin": origin + "px",
          "-moz-perspective-origin": origin + "px",
          "perspective-origin": origin + "px"
        });
      function transStyles(prevPos) {
        return {
          "position": "relative",
          "left": prevPos + "px"
        };
      }

      $prevItem
        .css(transStyles(prevPos, 10))
        .addClass(outClass)
        .on(animEnd, function () {
          base.endPrev = true;
          $prevItem.off(animEnd);
          base.clearTransStyle($prevItem, outClass);
        });

      $currentItem
        .addClass(inClass)
        .on(animEnd, function () {
          base.endCurrent = true;
          $currentItem.off(animEnd);
          base.clearTransStyle($currentItem, inClass);
        });
    },

    clearTransStyle: function (item, classToRemove) {
      var base = this;
      item.css({
        "position": "",
        "left": ""
      }).removeClass(classToRemove);

      if (base.endPrev && base.endCurrent) {
        base.$owlWrapper.removeClass('owl-origin');
        base.endPrev = false;
        base.endCurrent = false;
        base.isTransition = false;
      }
    },

    owlStatus: function () {
      var base = this;
      base.owl = {
        "userOptions": base.userOptions,
        "baseElement": base.$elem,
        "userItems": base.$userItems,
        "owlItems": base.$owlItems,
        "currentItem": base.currentItem,
        "prevItem": base.prevItem,
        "visibleItems": base.visibleItems,
        "isTouch": base.browser.isTouch,
        "browser": base.browser,
        "dragDirection": base.dragDirection
      };
    },

    clearEvents: function () {
      var base = this;
      base.$elem.off(".owl owl mousedown.disableTextSelect");
      $(document).off(".owl owl");
      $(window).off("resize", base.resizer);
    },

    unWrap: function () {
      var base = this;
      if (base.$elem.children().length !== 0) {
        base.$owlWrapper.unwrap();
        base.$userItems.unwrap().unwrap();
        if (base.owlControls) {
          base.owlControls.remove();
        }
      }
      base.clearEvents();
      base.$elem
        .attr("style", base.$elem.data("owl-originalStyles") || "")
        .attr("class", base.$elem.data("owl-originalClasses"));
    },

    destroy: function () {
      var base = this;
      base.stop();
      window.clearInterval(base.checkVisible);
      base.unWrap();
      base.$elem.removeData();
    },

    reinit: function (newOptions) {
      var base = this,
        options = $.extend({}, base.userOptions, newOptions);
      base.unWrap();
      base.init(options, base.$elem);
    },

    addItem: function (htmlString, targetPosition) {
      var base = this,
        position;

      if (!htmlString) { return false; }

      if (base.$elem.children().length === 0) {
        base.$elem.append(htmlString);
        base.setVars();
        return false;
      }
      base.unWrap();
      if (targetPosition === undefined || targetPosition === -1) {
        position = -1;
      } else {
        position = targetPosition;
      }
      if (position >= base.$userItems.length || position === -1) {
        base.$userItems.eq(-1).after(htmlString);
      } else {
        base.$userItems.eq(position).before(htmlString);
      }

      base.setVars();
    },

    removeItem: function (targetPosition) {
      var base = this,
        position;

      if (base.$elem.children().length === 0) {
        return false;
      }
      if (targetPosition === undefined || targetPosition === -1) {
        position = -1;
      } else {
        position = targetPosition;
      }

      base.unWrap();
      base.$userItems.eq(position).remove();
      base.setVars();
    }

  };

  $.fn.owlCarousel = function (options) {
    return this.each(function () {
      if ($(this).data("owl-init") === true) {
        return false;
      }
      $(this).data("owl-init", true);
      var carousel = Object.create(Carousel);
      carousel.init(options, this);
      $.data(this, "owlCarousel", carousel);
    });
  };

  $.fn.owlCarousel.options = {

    items: 5,
    itemsCustom: false,
    itemsDesktop: [1199, 4],
    itemsDesktopSmall: [979, 3],
    itemsTablet: [768, 2],
    itemsTabletSmall: false,
    itemsMobile: [479, 1],
    singleItem: false,
    itemsScaleUp: false,

    slideSpeed: 200,
    paginationSpeed: 800,
    rewindSpeed: 1000,

    autoPlay: false,
    stopOnHover: false,

    navigation: false,
    navigationText: ["prev", "next"],
    rewindNav: true,
    scrollPerPage: false,

    pagination: true,
    paginationNumbers: false,

    responsive: true,
    responsiveRefreshRate: 200,
    responsiveBaseWidth: window,

    baseClass: "owl-carousel",
    theme: "owl-theme",

    lazyLoad: false,
    lazyFollow: true,
    lazyEffect: "fade",

    autoHeight: false,

    jsonPath: false,
    jsonSuccess: false,

    dragBeforeAnimFinish: true,
    mouseDrag: true,
    touchDrag: true,

    addClassActive: false,
    transitionStyle: false,

    beforeUpdate: false,
    afterUpdate: false,
    beforeInit: false,
    afterInit: false,
    beforeMove: false,
    afterMove: false,
    afterAction: false,
    startDragging: false,
    afterLazyLoad: false
  };
}(jQuery, window, document));
define("owlcarousel", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.owlCarousel;
  };
}(this)));

/*
*	jQuery dotdotdot 1.6.13
*
*	Copyright (c) Fred Heusschen
*	www.frebsite.nl
*
*	Plugin website:
*	dotdotdot.frebsite.nl
*
*	Dual licensed under the MIT and GPL licenses.
*	http://en.wikipedia.org/wiki/MIT_License
*	http://en.wikipedia.org/wiki/GNU_General_Public_License
*/
!function (t, e) { function n(t, e, n) { var r = t.children(), o = !1; t.empty(); for (var i = 0, d = r.length; d > i; i++) { var l = r.eq(i); if (t.append(l), n && t.append(n), a(t, e)) { l.remove(), o = !0; break } n && n.detach() } return o } function r(e, n, i, d, l) { var s = !1, c = "table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, blockquote, select, optgroup, option, textarea, script, style", u = "script"; return e.contents().detach().each(function () { var h = this, f = t(h); if ("undefined" == typeof h || 3 == h.nodeType && 0 == t.trim(h.data).length) return !0; if (f.is(u)) e.append(f); else { if (s) return !0; e.append(f), l && e[e.is(c) ? "after" : "append"](l), a(i, d) && (s = 3 == h.nodeType ? o(f, n, i, d, l) : r(f, n, i, d, l), s || (f.detach(), s = !0)), s || l && l.detach() } }), s } function o(e, n, r, o, d) { var c = e[0]; if (!c) return !1; var h = s(c), f = -1 !== h.indexOf(" ") ? " " : "　", p = "letter" == o.wrap ? "" : f, g = h.split(p), v = -1, w = -1, b = 0, y = g.length - 1; for (o.fallbackToLetter && 0 == b && 0 == y && (p = "", g = h.split(p), y = g.length - 1); y >= b && (0 != b || 0 != y);) { var m = Math.floor((b + y) / 2); if (m == w) break; w = m, l(c, g.slice(0, w + 1).join(p) + o.ellipsis), a(r, o) ? (y = w, o.fallbackToLetter && 0 == b && 0 == y && (p = "", g = g[0].split(p), v = -1, w = -1, b = 0, y = g.length - 1)) : (v = w, b = w) } if (-1 == v || 1 == g.length && 0 == g[0].length) { var x = e.parent(); e.detach(); var T = d && d.closest(x).length ? d.length : 0; x.contents().length > T ? c = u(x.contents().eq(-1 - T), n) : (c = u(x, n, !0), T || x.detach()), c && (h = i(s(c), o), l(c, h), T && d && t(c).parent().append(d)) } else h = i(g.slice(0, v + 1).join(p), o), l(c, h); return !0 } function a(t, e) { return t.innerHeight() > e.maxHeight } function i(e, n) { for (; t.inArray(e.slice(-1), n.lastCharacter.remove) > -1;)e = e.slice(0, -1); return t.inArray(e.slice(-1), n.lastCharacter.noEllipsis) < 0 && (e += n.ellipsis), e } function d(t) { return { width: t.innerWidth(), height: t.innerHeight() } } function l(t, e) { t.innerText ? t.innerText = e : t.nodeValue ? t.nodeValue = e : t.textContent && (t.textContent = e) } function s(t) { return t.innerText ? t.innerText : t.nodeValue ? t.nodeValue : t.textContent ? t.textContent : "" } function c(t) { do t = t.previousSibling; while (t && 1 !== t.nodeType && 3 !== t.nodeType); return t } function u(e, n, r) { var o, a = e && e[0]; if (a) { if (!r) { if (3 === a.nodeType) return a; if (t.trim(e.text())) return u(e.contents().last(), n) } for (o = c(a); !o;) { if (e = e.parent(), e.is(n) || !e.length) return !1; o = c(e[0]) } if (o) return u(t(o), n) } return !1 } function h(e, n) { return e ? "string" == typeof e ? (e = t(e, n), e.length ? e : !1) : e.jquery ? e : !1 : !1 } function f(t) { for (var e = t.innerHeight(), n = ["paddingTop", "paddingBottom"], r = 0, o = n.length; o > r; r++) { var a = parseInt(t.css(n[r]), 10); isNaN(a) && (a = 0), e -= a } return e } if (!t.fn.dotdotdot) { t.fn.dotdotdot = function (e) { if (0 == this.length) return t.fn.dotdotdot.debug('No element found for "' + this.selector + '".'), this; if (this.length > 1) return this.each(function () { t(this).dotdotdot(e) }); var o = this; o.data("dotdotdot") && o.trigger("destroy.dot"), o.data("dotdotdot-style", o.attr("style") || ""), o.css("word-wrap", "break-word"), "nowrap" === o.css("white-space") && o.css("white-space", "normal"), o.bind_events = function () { return o.bind("update.dot", function (e, d) { e.preventDefault(), e.stopPropagation(), l.maxHeight = "number" == typeof l.height ? l.height : f(o), l.maxHeight += l.tolerance, "undefined" != typeof d && (("string" == typeof d || d instanceof HTMLElement) && (d = t("<div />").append(d).contents()), d instanceof t && (i = d)), g = o.wrapInner('<div class="dotdotdot" />').children(), g.contents().detach().end().append(i.clone(!0)).find("br").replaceWith("  <br />  ").end().css({ height: "auto", width: "auto", border: "none", padding: 0, margin: 0 }); var c = !1, u = !1; return s.afterElement && (c = s.afterElement.clone(!0), c.show(), s.afterElement.detach()), a(g, l) && (u = "children" == l.wrap ? n(g, l, c) : r(g, o, g, l, c)), g.replaceWith(g.contents()), g = null, t.isFunction(l.callback) && l.callback.call(o[0], u, i), s.isTruncated = u, u }).bind("isTruncated.dot", function (t, e) { return t.preventDefault(), t.stopPropagation(), "function" == typeof e && e.call(o[0], s.isTruncated), s.isTruncated }).bind("originalContent.dot", function (t, e) { return t.preventDefault(), t.stopPropagation(), "function" == typeof e && e.call(o[0], i), i }).bind("destroy.dot", function (t) { t.preventDefault(), t.stopPropagation(), o.unwatch().unbind_events().contents().detach().end().append(i).attr("style", o.data("dotdotdot-style") || "").data("dotdotdot", !1) }), o }, o.unbind_events = function () { return o.unbind(".dot"), o }, o.watch = function () { if (o.unwatch(), "window" == l.watch) { var e = t(window), n = e.width(), r = e.height(); e.bind("resize.dot" + s.dotId, function () { n == e.width() && r == e.height() && l.windowResizeFix || (n = e.width(), r = e.height(), u && clearInterval(u), u = setTimeout(function () { o.trigger("update.dot") }, 10)) }) } else c = d(o), u = setInterval(function () { var t = d(o); (c.width != t.width || c.height != t.height) && (o.trigger("update.dot"), c = d(o)) }, 100); return o }, o.unwatch = function () { return t(window).unbind("resize.dot" + s.dotId), u && clearInterval(u), o }; var i = o.contents(), l = t.extend(!0, {}, t.fn.dotdotdot.defaults, e), s = {}, c = {}, u = null, g = null; return l.lastCharacter.remove instanceof Array || (l.lastCharacter.remove = t.fn.dotdotdot.defaultArrays.lastCharacter.remove), l.lastCharacter.noEllipsis instanceof Array || (l.lastCharacter.noEllipsis = t.fn.dotdotdot.defaultArrays.lastCharacter.noEllipsis), s.afterElement = h(l.after, o), s.isTruncated = !1, s.dotId = p++, o.data("dotdotdot", !0).bind_events().trigger("update.dot"), l.watch && o.watch(), o }, t.fn.dotdotdot.defaults = { ellipsis: "... ", wrap: "word", fallbackToLetter: !0, lastCharacter: {}, tolerance: 0, callback: null, after: null, height: null, watch: !1, windowResizeFix: !0 }, t.fn.dotdotdot.defaultArrays = { lastCharacter: { remove: [" ", "　", ",", ";", ".", "!", "?"], noEllipsis: [] } }, t.fn.dotdotdot.debug = function () { }; var p = 1, g = t.fn.html; t.fn.html = function (n) { return n != e && !t.isFunction(n) && this.data("dotdotdot") ? this.trigger("update", [n]) : g.apply(this, arguments) }; var v = t.fn.text; t.fn.text = function (n) { return n != e && !t.isFunction(n) && this.data("dotdotdot") ? (n = t("<div />").text(n).html(), this.trigger("update", [n])) : v.apply(this, arguments) } } }(jQuery);
define("dotdotdot", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.dotdotdot;
  };
}(this)));

/**
* @see http://www.landmarkmlp.com/js-plugin/owl.carousel/
*/
define('widgets/bannersCarousel', [
  'jquery',
  'UTILS',
  'i18n_general',
  'owlcarousel',
  'dotdotdot',
  'gsap',
], function ($, Utils, Generali18n) {

  var eventEmitter;
  var owlRef;
  function setCarrouselControl($c) {
    var next = "<span class='visually-hidden'>" + Generali18n.next + "</span>";
    var prev = "<span class='visually-hidden'>" + Generali18n.previous + "</span>";
    var controls = '<button class="owl-prev">' + prev + '</button><button class="owl-next">' + next + '</button>';
    var buttons = $c.find('.owl-controls');
    buttons.append('<div class="owl-buttons">' + controls + '</div>');
    buttons.removeClass('clickable');
  }

  function setCarrouselPlayPause($c, owl) {
    var $play = "<button type='button' class='owl-carousel-btn owl-carousel-btn-play'><span class='visually-hidden'>" + Generali18n.play + "</span></button>";
    var $pause = "<button type='button' class='owl-carousel-btn owl-carousel-btn-pause'><span class='visually-hidden'>" + Generali18n.pause + "</span></button>";
    var buttons = $c.find('.owl-controls');
    buttons.append('<div class="owl-playpause">' + $play + $pause + '</div>');
    $c.find('.owl-playpause').addClass('owl-isPlaying');
    $c.find('.owl-playpause .owl-carousel-btn-play').on('click keydown', function (event) {
      if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
        playCarrousel($c, owl);
      }
    });
    $c.find('.owl-playpause .owl-carousel-btn-pause').on('click keydown', function (event) {
      if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
        stopCarrousel($c, owl);
      }
    });
  }

  function stopCarrousel($c, owl) {
    owl.stop();
    $c.find('.owl-playpause').removeClass('owl-isPlaying');
  }
  function playCarrousel($c, owl) {
    owl.play();
    $c.find('.owl-playpause').addClass('owl-isPlaying');
  }

  function bindCarrouselEvents($c, owl, opts) {
    var $prev = $c.find('.owl-controls .owl-prev');
    var $next = $c.find('.owl-controls .owl-next');

    $prev.on('click keydown', function (event) {
      if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
        event.preventDefault();
        owl.prev();
        if (opts && opts.autoPlay) {
          stopCarrousel($c, owl);
        }
      }
    });
    $next.on('click keydown', function (event) {
      if (event.type === 'click' || event.keyCode === 32 || event.keyCode === 13) {
        event.preventDefault();
        owl.next();
        if (opts && opts.autoPlay) {
          stopCarrousel($c, owl);
        }
      }
    });

    $c.on('keydown', function (event) {
      if (event.keyCode === 37) {
        event.preventDefault();
        owl.prev();
        if (opts && opts.autoPlay) {
          stopCarrousel($c, owl);
        }
      }
      if (event.keyCode === 39) {
        event.preventDefault();
        owl.next();
        if (opts && opts.autoPlay) {
          stopCarrousel($c, owl);
        }
      }
    });
  }

  var Carousel = function ($c) {
    var opts = {
      items: 2,
      itemsDesktop: [1235, 1],
      itemsDesktopSmall: [1016, 2],
      itemsTablet: [820, 1],
      itemsTabletSmall: [680, 2],
      itemsMobile: [615, 1],
      responsiveRefreshRate: 50,
      navigation: false,
      addClassActive: true,
      itemsScaleUp: true,
      afterInit: function () {
        setCarrouselControl($c);
      }
    };

    var type = $c.data('carousel-type');

    if (type != undefined) {
      switch (type) {
        case 'usefulsInformations':

          function getElm(selector) {
            var $container = $c.closest(".widget-usefuls-informations");

            if ($container.length) {
              var $paginationNumbersWrapper = $container.find(".widget-usefuls-informations__pagination-numbers-wrapper");

              if ($paginationNumbersWrapper.length) {
                var target = $paginationNumbersWrapper.find(selector);

                return target;
              }
            }

            return [];
          }

          $.extend(opts, {
            items: 1,
            itemsDesktopSmall: false,
            itemsTabletSmall: false,
            //autoHeight: true,
            pagination: false,
            afterInit: function () {
              var $owlCurrentSlide = getElm('[data-js-el="owl-current-slide"]');
              var $owlTotalItem = getElm('[data-js-el="owl-total-item"]');

              if ($owlCurrentSlide.length && $owlTotalItem.length) {
                $owlCurrentSlide.html(this.currentItem + 1);
                $owlTotalItem.html(this.itemsAmount);
              }
              setCarrouselControl($c);
            },
            afterMove: function () {
              var $owlCurrentSlide = getElm('[data-js-el="owl-current-slide"]');

              if ($owlCurrentSlide.length) {
                // Update the current pagination number
                $owlCurrentSlide.html(this.currentItem + 1);
              }
              setTimeout(function () {
                $c.find('.owl-item.active a').focus();
              }, 500);

            }
          });
          break;

        case 'news':
          $.extend(opts, {
            items: 1,
            itemsDesktopSmall: false,
            itemsTabletSmall: false,
            autoHeight: true
          });
          break;

        case 'lifestyle':
          $.extend(opts, {
            items: 1,
            itemsDesktopSmall: false,
            itemsTabletSmall: false,
            autoHeight: true,
            autoPlay: true,
            stopOnHover: false,
            afterInit: function (elem) {
              var $body = $("body"),
                isHomepage = $body.hasClass("front");
              if (isHomepage) {
                $(elem).find(".owl-wrapper-outer .owl-item .lifestyle-snail a").click(function () {
                  var link = $(this).attr("href");
                  dataLayer.push({
                    'event': 'carrousel_accueil_' + Utils.getLang(),
                    'carrousel_promotion': link
                  });
                });
              }
              setCarrouselControl($c);
            }
          });

          break;
        case 'media':
          $.extend(opts, {
            items: 3,
            itemsDesktop: false,
            itemsTablet: false,
            itemsMobile: false,
            itemsDesktopSmall: false,
            itemsTabletSmall: false,
            autoHeight: true,
            itemsScaleUp: false,
            afterInit: function (elem) {
              $c.addClass('loaded');

              /* More Btn */
              $('a.btn-action', $c.next('.more')).bind('click', function (evt) {
                evt.preventDefault();
                /* Open first gallery image */
                $('.owl-item').eq(3).find("a").trigger('click');
                return false;
              });
              setCarrouselControl($c);
            }
          });
          break;
        case 'warning':

          var $warning;
          $warning = $('.region-warnings').detach();
          $("header .nav").prepend($warning);

          eventEmitter.addListener('plaformChanged', function () {
            $warning = $('.region-warnings').detach();
            $("header .nav").prepend($warning);
          });

          $.extend(opts, {
            items: 1,
            itemsDesktopSmall: false,
            itemsTabletSmall: false,
            navigation: false,
            autoHeight: false,
            touchDrag: false,
            mouseDrag: false,
            afterMove: function () {
              setTimeout(function () {
                $c.find('.owl-item.active a').focus();
              }, 500);
            },
            afterInit: function () {
              var firstBlockSubNav = $('.region-sub-nav .block:first');
              var notifOpen = false;
              var popNav;
              var nav = $("header .nav");
              var notificationsCtn = $('.region-warnings');

              var notificationsLength = notificationsCtn.find('.owl-wrapper .owl-item');
              var nbNotifications = notificationsLength.length.toString();
              var btnCloseA11yLabel = notificationsCtn.attr('data-a11y-button-label').replace('%nbNotifications%', nbNotifications);

              var newBtnClose = '<div id="block-btn-warning"><button aria-expanded="false" aria-label="' + btnCloseA11yLabel + '"><span class="icon icon-alerte"></span></button></div>';
              var notificationsTmpl = '<div class="notification-count" aria-hidden="true">' + nbNotifications + '</div>';
              firstBlockSubNav.after(newBtnClose);

              var btnClose = $('#block-btn-warning');
              btnClose.prepend(notificationsTmpl);

              var notificationsNumber = $('.notification-count');
              var showHideAnimTransition = null;

              function show_hide_notif(show) {
                var showHideAnimDuration = 400;
                var $warning = $('.region-warnings');

                if (showHideAnimTransition) {
                  clearTimeout(showHideAnimTransition);
                }

                update_bkg();
                btnClose.find('button').attr('aria-expanded', show);

                if (show) {
                  // Add focus for a11y
                  $warning.css('display', 'block');

                  showHideAnimTransition = setTimeout(function () {
                    nav.addClass('warning-visible');
                  }, 100);
                } else {
                  nav.removeClass('warning-visible');

                  showHideAnimTransition = setTimeout(function () {
                    // Remove focus for a11y
                    $warning.css('display', 'none');
                  }, showHideAnimDuration);
                }
              }

              setCarrouselControl($c);

              setTimeout(function () {
                if (Utils.getPlatform() !== "mobile") {
                  //Hide notifications if user already closed them
                  if ($.cookie('cookie_user_closed')) {
                    show_hide_notif(false, cb);
                  }
                  //Show notifications with ANIMATION if first time visit
                  else if ($.cookie('cookie_user_closed') == undefined && $.cookie('notif_anim_played') == undefined) {
                    var cb = function () {
                      notificationsCtn.addClass("pulse");
                      notifOpen = true;
                      $.cookie('notif_anim_played', 'true', { expires: 2 });
                    };

                    show_hide_notif(true, cb);
                  }
                  //For every other page, juste show the notifications in static version
                  else if ($.cookie('notif_anim_played')) {
                    show_hide_notif(true);
                  }
                }

                /* Cookies : Need to know which notifications were shown (and detect if there is a new one added
                    * before 48h). So we use the id on each notification to write it down and compare. */
                $('.owl-item div').each(function () {
                  var cookie_notif = "notif_closed_" + this.id;

                  //Create cookie if it still doesn't exist and show notification
                  if ($.cookie(cookie_notif) == null) {
                    $.cookie(cookie_notif, this.id, { expires: 2 });
                    show_hide_notif(true);
                  }

                });

                if (!notifOpen) {
                  notificationsNumber.addClass('active');
                }
              }, 300);

              popNav = function (e) {
                switch (e) {
                  case 'open':
                    notificationsNumber.removeClass('active');
                    show_hide_notif(true);
                    notifBarOpen = true;
                    return false;

                  case 'close':
                    $.cookie('cookie_user_closed', true, { expires: 2 });
                    notificationsNumber.addClass('active');
                    show_hide_notif(false);
                    notifBarOpen = false;
                    return false;
                }
              };

              btnClose.on('click keydown', function (e) {
                if (e.type === 'click' || e.keyCode === 32 || e.keyCode === 13) {
                  e.preventDefault();
                  if (nav.hasClass("warning-visible")) {
                    popNav('close');
                    setTimeout(function () {
                      btnClose.focus();
                    }, 500);
                  } else {
                    var $activeItem = $c.find('.owl-item.active a');
                    popNav('open');
                    setTimeout(function () {
                      $activeItem.focus();
                    }, 500);
                  }
                  return false;
                }
              });
            }
          });
          break;
        case 'header':
          $.extend(opts, {
            items: 1,
            itemsDesktopSmall: false,
            itemsTabletSmall: false,
            autoHeight: true,
            pagination: false
          });
          break;
      }
    }

    $c.owlCarousel(opts);

    // Get carousel instance data
    var owl = $c.data('owlCarousel');
    bindCarrouselEvents($c, owl, opts);
    if (opts && opts.autoPlay) {
      setCarrouselPlayPause($c, owl);
    }


    owl.$owlItems.on('focus', '*', function (event) {
      event.stopPropagation(); // Only one event called

      var $item = $(this).parents('.owl-item');
      var index = owl.$owlItems.index($item);

      // Remove translation of the slide by the focus
      owl.wrapperOuter.scrollLeft(0);

      // If needed, let the slideshow move the slide for the focus
      if ($item.hasClass('active') === false) {
        owl.goTo(index, 200);
      }
    });
  };

  var Module = {
    init: function ($context) {
      eventEmitter = ADM.eventEmitter;
      $context.each(function (i, elt) {
        new Carousel($(elt));
      });
    }
  };

  //This function is necessary because the backend can not provide the right bkg class
  // on the container of the caroussel, only the item element
  function update_bkg() {
    var carousel_class = $('.owl-item.active div').attr('class'),
      carousel_wrapper = $('.owl-item.active').parents('.newsFeedCarrousel-wrapper'),
      notificationIcon = $('#block-btn-warning .icon-star'),
      notificationBtn = $('#block-btn-warning a'),
      notificationCtn = $('.region-warnings:visible');

    carousel_wrapper.attr('data-bkgcolor', carousel_class);

    //If it is the X close button that is visible, and not the little bell + check for warning bloc if is visible
    //it seems that the owl caroussel continue firing event even if not visible
    if (notificationIcon && notificationCtn.css('display') == 'block') {
      notificationBtn.removeClass();
      notificationBtn.addClass(carousel_class);
    }

  }

  return Module;
});

define('widgets/ajaxFormDrupalized', [
  'jquery',
  'UTILS',
  'UTILS_PRELOADER',
  'mask'
], function ($, Utils, Preloader) {

  var eventEmitter;
  var format = "";
  /* Form Helpers */
  var Helpers = (function () {
    /* Pseudo Placeholder text */
    var _PlaceHolder = function ($c, opts) {
      var defaultOpts = {
        selectors: {
          text: 'alternatePlaceHolder',
          focus: 'focus',
          field: 'input[type=text]'
        }
      };

      /* Instance Options */
      this.opts = $.extend({}, defaultOpts, opts);

      var s = this.opts.selectors;
      /* HTML Elements */
      this.wrapper = $c;
      this.container = $('.' + s.text, this.wrapper);
      this.text = this.container.text();
      this.field = $(s.field + ':first', this.wrapper);

      return this.init();
    };

    $.extend(_PlaceHolder.prototype, {
      init: function () {
        var self = this
          , f = self.field
          , w = self.wrapper
          , s = self.opts.selectors;

        f.bind('focus', function () {
          w.addClass(s.focus);
        }).bind('blur', function () {
          w.removeClass(s.focus);
        }).bind('keyup', function () {
          self.refresh();
        });

        self.container.bind('click', function () {
          if (f.length) {
            f[0].focus();
          }
        });

        return this.refresh();
      },

      refresh: function () {
        var val = this.field.val()
          , p = (!val.length) ? 'block' : 'none';

        this.container.css({ display: p });
        return this;
      }
    });

    var _PhoneFormat = function ($c, opts) {

      var defaultOpts = {
        'pattern': '(000) 000-0000'
      };

      /* Instance Options */
      this.opts = $.extend({}, defaultOpts, opts);
      this.field = $($c);

      return this.init();
    };

    $.extend(_PhoneFormat.prototype, {
      init: function () {
        window.onerror = function (error) {
          alert(error);
        };
        if (this.field.length) {
          var self = this
            , f = self.field;
          if (format != "") {
            $(f).mask(format);

            if ($('.countrySelector').size() > 0) {
              if ($('.countrySelector').val().split('|')[0] == '1') {
                $(f).parent().find(".phd2").addClass("hidden");
                $(f).parent().find(".phd1").removeClass("hidden");
              } else {
                $(f).parent().find(".phd1").addClass("hidden");
                $(f).parent().find(".phd2").removeClass("hidden");
              }
            }
          }
          else {
            $(f).mask(this.opts.pattern);
          }


          $('.countrySelector').change(function (elt) {


            var dataCountry = $('.countrySelector').val().split('|');

            var regionalCode = dataCountry[0];
            var countryImage = dataCountry[1];


            if (regionalCode == '1') {
              format = "1 (000) 000-0000";
              $(f).parent().find(".phd2").addClass("hidden");
              $(f).parent().find(".phd1").removeClass("hidden");
            }
            else {
              $(f).parent().find(".phd1").addClass("hidden");
              $(f).parent().find(".phd2").removeClass("hidden");
              switch (regionalCode.length) {
                case 1:
                  format = regionalCode + " 00000000000000";
                  break;
                case 2:
                  format = regionalCode + " 0000000000000";
                  break;
                case 3:
                  format = regionalCode + " 000000000000";
                  break;
                case 4:
                  format = regionalCode + " 00000000000";
                  break;
                default:
                  format = regionalCode + " 000000000000000";


              }
            }
            $(f).mask(format);

            $(".countrySelector").siblings().find('.labelFlag').remove();
            $(".countrySelector").siblings().prepend('<span class="labelFlag"><img src="/sites/all/themes/custom/angani/images/flags/' + countryImage.toLowerCase() + '"/></span>');

            //parent.prepend('<span class="label"><img src="/sites/all/themes/custom/angani/images/flags/canada.png"</span>');
          })
          f.bind('blur', function () {
            self.clear();
            return;
          });

        }

        return this.clear();

      },

      clear: function () {
        var f = this.field
          , val = f.val()
          , regExp = /\d/i;

        if (!regExp.test(val)) {
          f.val('');
        }

        return this;
      }

    });

    var _Error = function ($c, opts, i) {
      var defaultOpts = {
        css: {
          wrapper: 'field',
          msg: 'msg',
          error: 'error',
          customSelectContainer: 'customselect-container'
        }
      };

      this.opts = $.extend({}, defaultOpts, opts);
      this.field = $($c);
      this.wrapper = this.field.parents('.' + this.opts.css.wrapper + ':first');
      this.msg = $('.' + this.opts.css.msg, this.wrapper);
      this.isCustomSelect = false;
      this.index = i;
      return this.init();
    };

    $.extend(_Error.prototype, {
      init: function () {
        var self = this
          , o = self.opts
          , f = self.field
          , w = self.wrapper
          , c = o.css
          , v = f.attr('value');

        f.bind('focus', function () {
          f.data('value', f.attr('value'));
          if (w.hasClass(c.error)) {
            self.show();
          }
        }).bind('blur', function () {
          self.hide();
          var val = f.attr('value');
          if (f.data('value') != val) {
            f.trigger('placeholder:change');
          }
        }).bind('placeholder:change', function () {
          var val = f.attr('value');
          if (val != v) {
            self.reset();
          }
        });

        if (f.hasClass(c.error)) {
          self.set();
        }

        if (f.is('select') && f.data('enhance') == 'customSelect') {
          this.isCustomSelect = true;
        }

        if (this.index == 0) {
          self.show();
        }
        return this;
      },

      set: function () {
        var o = this.opts.css
          , c = o.error;

        this.wrapper.addClass(c);
        this.field.removeClass(c);
        if (this.isCustomSelect) {
          var $wrapper = this.field.parents('.' + o.customSelectContainer + ':first');
          if ($wrapper.length) {
            $wrapper.addClass(c);
          }
        }

        return this;
      },

      reset: function () {
        var o = this.opts.css
          , c = o.error;

        this.wrapper.removeClass(c);
        if (this.isCustomSelect) {
          var $wrapper = this.field.parents('.' + o.customSelectContainer + ':first');
          if ($wrapper.length) {
            $wrapper.removeClass(c);
          }
        }
        return this;
      },

      hide: function () {
        this.msg.css({ display: 'none' });
        return this;
      },

      show: function () {
        this.msg.css({ display: 'block' });
        return this;
      }
    });

    return {
      PlaceHolder: function ($c, opts) {
        return new _PlaceHolder($c, opts);
      },

      PhoneFormat: function ($f, opts) {
        return new _PhoneFormat($f, opts);
      },

      Errors: function ($f, opts, i) {
        return new _Error($f, opts, i);
      }
    }
  })();

  var opts = {
    selectors: {
      placeHolders: 'placeHolder-wrapper',
      phoneFormatter: 'data-helper="phone-formatter"',
      errors: ['select', 'input[type=text]', 'input[type=phone]', 'input[type=email]', 'input[type=password]']
    },
    css: {
      error: 'error'
    }
  };

  var _enhancement = 'ajaxFormDrupalized';

  var Module = {
    init: function (context, reloaded) {
      eventEmitter = ADM.eventEmitter;

      $(context).each(function (i, elt) {
        var $context = $(elt);
        if ($context.is('form')) {
          var s = opts.selectors
            , error = opts.css.error;

          /* Select */
          if (reloaded) {

            var attr = 'data-enhance'
              , enhance = $('body').attr(attr) + ' ' + $context.attr(attr);
            $context.attr(attr, enhance).enhance();

            /* Display errors */
            var $errors = $('.error.error-wrapper', $context);
            if ($errors.length) {
              $errors.css({ display: 'block' });
            }

            /* Display success feedback */
            var $success = $('.success.success-wrapper', $context);
            if ($success.length) {
              $success.css({ display: 'block' });
            }

          } else {
            /* Place Holders */
            $('.' + s.placeHolders, $context).each(function (i, elt) {
              Helpers.PlaceHolder($(elt), {});
            });



            $('input[' + s.phoneFormatter + ']', $context).each(function (i, elt) {

              var format = "1 (000) 000-0000";
              Helpers.PhoneFormat($(elt), { 'pattern': format, 'persistent': false });
            });
            /*
        $('#edit-lipso-se-country').change(function(elt){
          
            
          var regionalCode = $('#edit-lipso-se-country').val();
 
              var format;
              if(regionalCode == '1' || regionalCode == '2'){
                format = "1(000) 000-0000"
              }
              else{
                format = regionalCode+"0000000000000000000";
              }
              Helpers.PhoneFormat($('#edit-cellnumber'), {'pattern': format, 'persistent': false});
        })
*/
            /* Errors msg display */
            $('.' + error, $context).filter(s.errors.join(', ')).each(function (i, elt) {
              Helpers.Errors($(elt), {}, i);
            });

            /* Preloader */
            $context.bind('ajax-progress-started', function (evt, element) {
              var preloader = new Preloader({
                diameter: 20,
                $ctn: $('.throbber', element),
                color: '#ffffff',
                position: 'absolute'
              });

              preloader.show();
            });

          }
        }
      });
    }
  };

  jQuery.fn.extend({
    ajaxFormDrupalizedInit: function (fid) {
      var $context = $('#' + fid);
      if ($context.attr('data-enhance') == _enhancement) {
        Module.init($('#' + fid), eventEmitter, true);

      }

      var lang = $context.find("[name='lang']").val() || Utils.getLang();
      var success = false;
      if ($context.find("div.success .msg").length > 0) {
        success = true;
      }
      // analytics
      if (fid === "lipso-fa-form") {
        if (success) {
          dataLayer.push({
            'event': 'alertesms_success_' + lang,
            'alertesms_lang': lang,
            'alertesms_vol': $context.find("[name='flightNumber']").val()
          });
        } else {
          dataLayer.push({
            'event': 'alertesms_error_' + lang,
            'alertesms_lang': lang,
            'alertesms_vol': $context.find("[name='flightNumber']").val()
          });
        }

      }

      if (fid === "lipso-se-form") {
        var nbPersonne = $context.find("[name='number']").val();
        if (success) {
          dataLayer.push({
            'event': 'securxpress_success_' + lang,
            'securxpress_lang': lang,
            'securxpress_vol': $context.find("[name='flightNumber']").val(),
            'securxpress_nombre': nbPersonne
          });
        } else {
          dataLayer.push({
            'event': 'securxpress_error_' + lang,
            'securxpress_lang': lang,
            'securxpress_vol': $context.find("[name='flightNumber']").val(),
            'securxpress_nombre': nbPersonne
          });

        }

      }
      return;
    }
  });

  return Module;
});
define('widgets/compatibilityAlert', [
  'jquery',
  'UTILS',
  'settings',
  'uiTools/modals',
  'foundation',
  'interchange'
], function ($, Utils, Settings, Modals) {


  var CompatilityAlert = {
    init: function (context) {

      if (!Utils.compatibilityTest()) {
        var $wrapper = $(Settings.compatibility.modal.settings.items.src);
        var $elems = $('[data-src]', $wrapper);
        $elems.each(function (i, item) {
          var $this = $(item);
          $this.attr('src', $this.attr('data-src')).removeAttr('data-src');
        });

        Modals.call($(Settings.compatibility.modal.settings.items.src), Settings.compatibility.modal.settings);

      }
    }
  };

  return CompatilityAlert;
});


/**
* Add styles when element is visible in window (IntersectionObserver)
*
* @example:
* <div class="enhance"
*      data-enhance="addStylesOnIntersection"
*      data-styles-on-intersection='{"width": "20%"}'
*      data-styles-on-intersection-opts='{"rootMargin": "0px 0px 20% 0px"}'></div>
*/
define('widgets/addStylesOnIntersection', [
  'jquery',
  'i18n_general'
], function ($, GeneralI18n) {

  var AddStylesOnIntersection = {
    init: function (context) {
      var $context = $(context);

      $context.each(function () {
        var _this = $(this);
        var styles = _this.data("stylesOnIntersection");

        if (styles) {
          var stylesOutput = "";
          var categoryLow = GeneralI18n.priorityLow;
          var categoryMedium = GeneralI18n.priorityMedium;
          var categoryHigh = GeneralI18n.priorityHigh;
          var currentInlineStyle = _this.attr("style") ? _this.attr("style") : "";
          var currentCategory = _this.attr("aria-label") ? _this.attr("aria-label") : "";
          var onIntersectionOpts = _this.data("stylesOnIntersectionOpts") ? JSON.parse(JSON.stringify(_this.data("stylesOnIntersectionOpts"))) : {};

          var options = $.extend(onIntersectionOpts, {
            rootMargin: '0px',
            threshold: 1
          });

          var onIntersection = function (element, self) {
            element.forEach(function (elm) {
              if (elm.isIntersecting) {

                // Add style(s) to element
                _this.attr("style", currentInlineStyle + " " + stylesOutput);
                _this.attr("role", "img");

                switch (true) {
                  case _this.hasClass("theme-green"):
                    _this.attr("aria-label", categoryLow);
                    break;

                  case _this.hasClass("theme-yellow"):
                    _this.attr("aria-label", categoryMedium);
                    break;

                  case _this.hasClass("theme-red"):
                    _this.attr("aria-label", categoryHigh);
                    break;

                  default:
                    _this.attr("aria-label", "");
                    break;
                }

                self.unobserve(elm.target);
              }
            });
          };

          var observer = new IntersectionObserver(onIntersection, options);

          //styles = JSON.parse(JSON.stringify(styles));
          styles = JSON.parse(JSON.stringify(styles));

          Object.keys(styles).forEach(function (key) {
            stylesOutput += key + ":" + styles[key] + ";";
          });

          observer.observe(_this[0]);
        }
      });
    }
  };

  return AddStylesOnIntersection;
});

/**
* Show the parking occupancy data.
*
* @example: 
* Response of the DataProvider.parkingOccupancy():
* {
* "info":{
*    "language":"fr",
*    "timing":{
*       "last":1575918805,
*       "next":1581966805
*    },
*    "overdue":false,
*    "count":6,
*    "timequery":0,
*    "hashdata":"9fdc057e99f7e52d9e188605208e3194a895c780"
* },
* "data":[
*    {
*       "title":"EconoParc P8-P9",
*       "percentage":"3%",
*       "className":"theme-green",
*       "maxCapacity": 508,
*       "currentLevel": 50
*    },
*    {
*       "title":"AeroParc",
*       "percentage":"15%",
*       "className":"theme-green",
*       "maxCapacity": 508,
*       "currentLevel": 50
*    },
*    {
*       "title":"A\u00e9rogare",
*       "percentage":"35%",
*       "className":"theme-green",
*       "maxCapacity": 508,
*       "currentLevel": 50
*    },
*    {
*       "title":"EconoParc P6",
*       "percentage":"62%",
*       "className":"theme-yellow",
*       "maxCapacity": 508,
*       "currentLevel": 50
*    },
*    {
*       "title":"EconoParc P5",
*       "percentage":"75%",
*       "className":"theme-yellow",
*       "maxCapacity": 508,
*       "currentLevel": 50
*    },
*    {
*       "title":"ValetParc",
*       "percentage":"91%",
*       "className":"theme-red",
*       "maxCapacity": 508,
*       "currentLevel": 50
*    }
*   ]
* }
*/
define('widgets/parkingOccupancy', [
  'jquery',
  'dataprovider',
  'i18n_general',
  'moment',

  'jsrender'
], function ($, DataProvider, GeneralI18n, moment) {

  function setData(callback, callbackErrors) {
    DataProvider.parkingOccupancy({}, function (statusCode, data) {
      switch (statusCode) {
        case 200:
          callback(data);
          break;

        default:
          callbackErrors();
          break;
      }
    });
  }

  var _ParkingOccupancy = function (elt) {
    this.elt = $(elt);
    this.opts = { templateSelector: "#" + $(elt).attr("data-template") };
    this.template = $.templates(this.opts.templateSelector);

    return this.init();
  };

  _ParkingOccupancy.prototype = {
    init: function () {
      var _this = this;

      var buildPanel = function (data) {
        _this.innerMarkup = _this.template.render(data);

        _this.elt.html(_this.innerMarkup);

        // Apply event on slider
        _this.elt.enhance();
      };

      var CONFIG = {
        receiverEvent: _this.elt.data("automaticupdate-receiverevent") || null,
        triggeredEvent: _this.elt.data("automaticupdate-triggeredevent") || null
      };

      var $errorPanel = null;

      // Use to compare data to prevent same render
      var previousData = {};
      var currentData = {};

      var loadData = function () {

        if ($errorPanel) {
          $errorPanel.remove();
        }

        setData(function (data) {
          currentData = data.data;

          if (JSON.stringify(currentData) != JSON.stringify(previousData)) {
            previousData = data.data;
            buildPanel(data);
            isFirst = false;
          }

          ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["updatedCompleted", {
            server: {
              now: moment().format("X"),
              next: moment().add(120, 's').format("X")
            }, client: { now: moment().format("X") }
          }]);

        }, function () {
          // Show Errors
          $errorPanel = $("<div class='parking-occupancy-errors'><span class='icon icon-attention'></span><span class='parking-occupancy-label'>" + GeneralI18n.ErrorAjaxGlobal + "</span></div>");
          _this.elt.before($errorPanel);
          ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["updatedError", { server: { now: moment().format("X") } }]);
        });
      };

      ADM.eventEmitter.addListener(CONFIG.triggeredEvent, function () {
        loadData();
      });

      ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["start", {
        server: {
          now: moment().format("X"),
          next: moment().add(10, 's').format("X")
        }, client: { now: moment().format("X") }
      }]);

      loadData();
    }
  };

  var ParkingOccupancy = {
    init: function (context) {
      $(context).each(function () {
        var parkingOccupancyTimePanel = new _ParkingOccupancy($(this));
      });
    }
  };

  return ParkingOccupancy;
});

/**
* Show the parking occupancy data.
*
* @example: 
* Response of the DataProvider.taxiWaitingTime():
* {
* "data":
* {
*      "taxi_waiting_time":"10",
*      "start_date":"14:00",
*      "end_date":"16:00",
*      "punctual_time_is_active":true}}
*/
define('widgets/taxiWaitingTime', [
  'jquery',
  'dataprovider',
  'i18n_general',
  'moment',
  'jsrender'
], function ($, DataProvider, GeneralI18n, moment) {
  function setData(callback, callbackErrors) {
    DataProvider.taxiWaitingTime({}, function (statusCode, data) {
      switch (statusCode) {
        case 200:
          callback(data);
          break;

        default:
          callbackErrors();
          break;
      }
    });
  }

  var _taxiWaitingTime = function (elt) {
    this.elt = $(elt);
    this.opts = { templateSelector: "#" + $(elt).attr("data-template") };
    this.template = $.templates(this.opts.templateSelector);

    return this.init();
  };

  _taxiWaitingTime.prototype = {
    init: function () {
      var _this = this;

      var buildPanel = function (data) {
        _this.innerMarkup = _this.template.render(data);

        _this.elt.html(_this.innerMarkup);

        // Apply event on slider
        _this.elt.enhance();
      };

      var CONFIG = {
        receiverEvent: _this.elt.data("automaticupdate-receiverevent") || null,
        triggeredEvent: _this.elt.data("automaticupdate-triggeredevent") || null
      };

      var $errorPanel = null;

      // Use to compare data to prevent same render
      var previousData = {};
      var currentData = {};

      var loadData = function () {

        if ($errorPanel) {
          $errorPanel.remove();
        }

        setData(function (data) {
          currentData = data.data;

          if (JSON.stringify(currentData) != JSON.stringify(previousData)) {
            previousData = data.data;
            buildPanel(data);
            isFirst = false;
          }

          ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["updatedCompleted", {
            server: {
              now: moment().format("X"),
              next: moment().add(120, 's').format("X")
            }, client: { now: moment().format("X") }
          }]);

        }, function () {
          // Show Errors
          $errorPanel = $("<div class='taxi-waiting-time-errors'><span class='icon icon-attention'></span><span class='taxi-waiting-time-label'>" + GeneralI18n.ErrorAjaxGlobal + "</span></div>");
          _this.elt.after($errorPanel);
          ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["updatedError", { server: { now: moment().format("X") } }]);
        });
      };

      ADM.eventEmitter.addListener(CONFIG.triggeredEvent, function () {
        loadData();
      });

      ADM.eventEmitter.emitEvent(CONFIG.receiverEvent, ["start", {
        server: {
          now: moment().format("X"),
          next: moment().add(10, 's').format("X")
        }, client: { now: moment().format("X") }
      }]);

      loadData();
    }
  };

  var TaxiWaitingTime = {
    init: function (context) {
      $(context).each(function () {
        var taxiWaintingTimePanel = new _taxiWaitingTime($(this));
      });
    }
  };

  return TaxiWaitingTime;
});

/**
* This script modifies the height of specific elements so they are better aligned (same height).
* The fix is applied in javascript because they are to many variables to take into
* account to handle everything in css.
*
* @example
* <pre>
*  <div class="enhance"
*      data-enhance="globalHeightLayout">
*      <div data-js-el="js-adjust-line">
*          <div data-js-el="js-adjust-1"></div>
*          <div data-js-el="js-adjust-1"></div>
*      </div>
*  </div>
* </pre>
*/
define('widgets/globalHeightLayout', [
  'jquery',
  'enquire',

  'debounce'
], function ($, enquire) {

  var _this;

  var _GlobalHeightLayout = function (elt) {
    this.elt = $(elt);
    this.window = $(window);

    return this.init();
  };

  _GlobalHeightLayout.prototype = {
    init: function () {
      _this = this;

      // GLOBAL VARS
      // ==============================================================

      /**
       * The current element
       *
       * @type {*|jQuery|HTMLElement}
       */
      var element = this.elt;

      /**
       * The DOM selectors name
       *
       * @type {Array}
       */
      var standarizeSelectors = [];

      /**
       * Media queries css resizing item width.
       * Above this mediaquery, we will remove all inline css.
       *
       * @type {string[]}
       */
      var mediaQueries = [
        'only screen and (min-width : 1030px)'
      ];

      /**
       * Debounce rate-limit to update the height size.
       */
      var debounced = $.debounce(250, resizeHandler);

      // SET SELECTOR NAME
      // ==============================================================
      for (var i = 1; i <= 5; i++) {
        standarizeSelectors.push('[data-js-el="js-adjust-' + i + '"]');
      }

      // FUNCTIONS
      // ==============================================================

      /**
       * Is the current DOM element is hidden.
       * Ths offsetParent returns null when the element has style.display set to "none".
       *
       * @param {object} p_element element
       * @returns {boolean} Is the element is Hidden.
       */
      function isHidden(p_element) {
        return p_element.offsetParent === null;
      }

      /**
       * Get the visible DOM elements only.
       *
       * @param {object} p_arrayElement The array of DOM elements.
       * @returns {Array} Array with all visible DOM elements.
       */
      function getVisibleElements(p_arrayElements) {
        var linesVisible = [];

        for (var i = 0; i < p_arrayElements.length; i++) {
          var item = p_arrayElements[i];

          if (!isHidden(item)) {
            linesVisible.push(item);
          }
        }

        return linesVisible;
      }

      /**
       * Get height of all elements.
       *
       * @param {Array} p_arrayElements The array of DOM elements.
       * @returns {Array} Array with all height size.
       */
      function getHeightAttributes(p_arrayElements) {
        // The following code takes an array of objects and creates
        // a new array containing the newly reformatted objects.
        //
        // I called Array.prototype.map on the NodeList returned from querySelectorAll because
        // querySelectorAll doesn't return an array but a NodeList.
        var reformattedArray = Array.prototype.map.call(p_arrayElements, function (el) {
          return el.offsetHeight;
        });

        return reformattedArray;
      }

      /**
       * Set height of all elements.
       *
       * @param {Array} p_arrayElements The array of all lines where to find selector (".js-adjust-1").
       */
      function setHeightAttributes(p_lines) {
        for (var x = 0; x < p_lines.length; x++) {
          var line = p_lines[x];

          // Class name to identify that the element is already processed.
          line.classList.add("js-adjust-applied");

          for (var y = 0; y < standarizeSelectors.length; y++) {
            var selector = standarizeSelectors[y];
            var adjustObjects = line.querySelectorAll(selector);

            // Get visible element only.
            adjustObjects = getVisibleElements(adjustObjects);

            if (adjustObjects.length > 1) {
              for (var i = 0; i < adjustObjects.length; i++) {
                var element = adjustObjects[i];

                element.style.display = "block";
                element.style.height = "auto";

                // Must be set otherwise IE does a miscalculation on page load
                element.style.minHeight = "1px";
              }

              var heights = getHeightAttributes(adjustObjects);

              // Using `.apply` so when we call `Math.max` each array
              // value is passed has a parameter.
              // `Math.max.apply(Math,[10,20,40,32])` is equivalent of
              // `Math.max(10,20,40,32)`;
              for (var j = 0; j < adjustObjects.length; j++) {
                var element = adjustObjects[j];

                element.style.minHeight = Math.max.apply(Math, heights) + "px";
              }
            }
          }
        }
      }

      /**
       * Window resize event handler
       */
      function resizeHandler() {
        var lines = document.querySelectorAll('[data-js-el="js-adjust-line"]');

        // Get visible element only.
        lines = getVisibleElements(lines);

        setHeightAttributes(lines);
      }

      /**
       * Initialize the directive/component after Angular first displays the data-bound
       * properties and sets the directive/component's input properties.
       *
       * @param {boolean} isAjax Is Ajax call render.
       */
      function updateLayout() {
        // First process and the timeout is to optimize slower device.
        setTimeout(function () {
          resizeHandler();
        }, 2000);

        _this.window.on('resize', debounced);
      }

      /**
       * Reverse the code (used to reset all element for mobile device).
       */
      function disableLayout() {
        for (var i = 0; i < standarizeSelectors.length; i++) {
          var adjustObjects = element[0].querySelectorAll(standarizeSelectors[i]);

          // Get visible element only.
          var visibleObjects = getVisibleElements(adjustObjects);

          if (visibleObjects.length > 1) {
            for (var j = 0; j < visibleObjects.length; j++) {
              var item = visibleObjects[j];

              item.style.display = "";
              item.style.height = "";
              item.style.minHeight = "";
            }
          }
        }

        _this.window.off('resize', debounced);
      }

      // APPLICATION MEDIAS QUERIES
      // ==============================================================
      for (var z = 0; z < mediaQueries.length; z++) {
        (function (q) {
          enquire.register(q, {
            match: function () {
              updateLayout();
            },
            unmatch: function () {
              disableLayout();
            }
          });
        })(mediaQueries[z]);
      }
    }
  };

  var GlobalHeightLayout = {
    init: function (context) {
      $(context).each(function () {
        var globalHeightLayoutPanel = new _GlobalHeightLayout($(this));
      });
    }
  };

  return GlobalHeightLayout;
});

define('widgets/widgets', [
  'jquery',
  'UTILS',
  'widgets/delaysBoard',
  'widgets/automaticUpdate',
  'widgets/searchFlightAutocomplete',
  'widgets/globalSearchWidget',
  'widgets/stationnement',
  'widgets/guidePerso',
  'stickyElement',
  'buttonGroup',
  'widgets/bannersCarousel',
  'widgets/ajaxFormDrupalized',
  'widgets/compatibilityAlert',
  'sharingTools',
  'widgets/accessForm',
  'widgets/services',
  'widgets/iab-ads',
  'widgets/stationnementMap',
  'widgets/commentsForm',
  'widgets/convertHomeNews',
  'widgets/imagePrint',
  'widgets/mfp',
  'widgets/addStylesOnIntersection',
  'widgets/parkingOccupancy',
  'widgets/taxiWaitingTime',
  'widgets/globalHeightLayout',
  'gsap'

], function ($,
  Utils,
  DelaysBoard,
  AutomaticUpdate,
  SearchFlightAutocomplete,
  GlobalSearchWidget,
  Stationnement,
  FormGuidePerso,
  StickySubNav,
  BoutonsGroup,
  bannersCarousel,
  ajaxFormDrupalized,
  CompatibilityAlert,
  SharingTools,
  AccessForm,
  Services,
  IABAds,
  StationnementMap,
  CommentsForm,
  ConvertHomeNews,
  ImagePrint,
  mfp,
  AddStylesOnIntersection,
  ParkingOccupancy,
  TaxiWaitingTime,
  GlobalHeightLayout) {

  var Widgets = {
    delaysBoard: function (context) {
      DelaysBoard.init(Utils.removeHighlightedCodeFromContext(context));
    },
    automaticUpdate: function (context) {
      AutomaticUpdate.init(Utils.removeHighlightedCodeFromContext(context));
    },
    searchFlightAutocomplete: function (context) {
      SearchFlightAutocomplete.init(Utils.removeHighlightedCodeFromContext(context));
    },
    globalSearchWidget: function (context) {
      GlobalSearchWidget.init(Utils.removeHighlightedCodeFromContext(context));
    },
    stationnement: function (context) {
      Stationnement.init(Utils.removeHighlightedCodeFromContext(context));
    },
    formGuidePerso: function (context) {
      FormGuidePerso.init(Utils.removeHighlightedCodeFromContext(context));
    },
    stickyElement: function (context) {
      StickySubNav.init(context);
    },
    buttonsGroup: function (context) {
      BoutonsGroup.init(context);
    },
    bannersCarousel: function (context) {
      bannersCarousel.init(context);
    },
    ajaxFormDrupalized: function (context) {
      ajaxFormDrupalized.init(context);
    },
    compatibilityAlert: function (context) {
      CompatibilityAlert.init(context);
    },
    sharingTools: function (context) {
      SharingTools.init(context);
    },
    accessForm: function (context) {
      AccessForm.init(context);
    },
    services: function (context) {
      Services.init(context);
    },
    iabads: function (context) {
      IABAds.init(context);
    },
    stationnementMap: function (context) {
      StationnementMap.init(context);
    },
    commentsForm: function (context) {
      CommentsForm.init(context);
    },
    convertHomeNews: function (context) {
      ConvertHomeNews.init(context);
    },
    imagePrint: function (context) {
      ImagePrint.init(context);
    },
    mfp: function (context) {
      mfp.init(context);
    },
    addStylesOnIntersection: function (context) {
      AddStylesOnIntersection.init(context);
    },
    parkingOccupancy: function (context) {
      ParkingOccupancy.init(Utils.removeHighlightedCodeFromContext(context));
    },
    taxiWaitingTime: function (context) {
      TaxiWaitingTime.init(Utils.removeHighlightedCodeFromContext(context));
    },
    globalHeightLayout: function (context) {
      GlobalHeightLayout.init(context);
    }
  };

  return Widgets;
});

var ADM = window.ADM || {};

define('utils/urlparser', [
  'jquery'
], function ($) {

  //====================================
  // A function to get the qs params
  //====================================
  //====================================
  // Get object of URL parameters
  //
  // 2 availables fonctionalities
  //      #1- no url param value : return params of window.location
  //      #2- with url param value : return params of the specific url string
  //
  //  Exemple #1
  //  var allParams = UrlParser.init();
  //
  //  Exemple #2
  //  var allParams = UrlParser.init(url);
  //
  // This URL:
  //  //www.example.com/?me=myValue&name2=SomeOtherValue
  //
  // Will return this following array:
  //  { "name1" : "myValue1", "name2" : "myValue2" }
  //====================================
  //====================================
  // Getting URL var by its name
  //
  //  Exemple #1
  //  var byName = UrlParser.init()['name1'];
  //
  //  Exemple #2
  //  var byName = UrlParser.init(url)['name1'];
  //
  //  Result : "myValue1"
  //====================================

  var UrlParser = {
    init: function (url) {
      var eventEmitter = ADM.eventEmitter;

      //Define Global variables
      var params = [], hash, hashes;

      if (url && url.length > 0) {
        hashes = url.slice(url.indexOf('?') + 1).split('&');
      } else {
        hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
      }

      for (var i = 0; i < hashes.length; i++) {
        hash = hashes[i].split('=');
        params.push(hash[0]);
        params[hash[0]] = hash[1];
      }

      return params;
    }
  };

  return UrlParser;
});
var ADM = window.ADM || {};

define('interactivemap/direction', [
  'jquery',
  'settings',
  'UTILS',
  'googlemap/adresseAutoComplete'
], function ($, Settings, Utils, AdresseAutoComplete) {

  var InteractiveMapDirection = {
    airportLatLng: Settings.map.airportLatLng,
    init: function ($directionContainer, mapObject, options, directionParams) {

      //====================================
      // INIT GLOBAL VARS
      //====================================

      //The Current Google Map Object
      var map = mapObject.map,
        eventEmitter = ADM.eventEmitter,

        //Direction fields
        $inputStart = $("input:eq(0)", $directionContainer),
        $inputEnd = $("input:eq(1)", $directionContainer),

        $inputStartParent = $inputStart.parent("div"),
        $inputEndParent = $inputEnd.parent("div"),

        //Reverse Direction arrow button
        $reverseDirectionButton = $(".reverse", $directionContainer),

        //Direction button
        $directionButton = $(".get-direction", $directionContainer),

        //Travel Mode button (DRIVING, TRANSIT)
        $travelModes = $(".travel-modes", $directionContainer),
        $travelModesLinks = $("a", $travelModes),

        //Directions Google Map Object
        directionsDisplay = null,
        directionsService = new google.maps.DirectionsService(),
        $directionResults = $(".direction-results", $directionContainer),

        // It's use to know the trigger on Map button on the toolbar (Specific Init Point)
        isSpecificCenterPoint = false,
        centerPoint = "",
        centerPointZoom = "";

      //====================================
      // Input value (start/end) position
      //====================================

      //If fields is not empty, activated the main click button to displaying the Directions Result
      var validateInputLength = function (target) {
        if (target && target.val().length > 0) {
          setDirectionButton(true);

          //Clear error classname on input parent element if available
          clearDirectionError();
        } else {
          setDirectionButton(false);

          //Clear Map and Direction Results if previous available data
          $directionContainer.trigger('removeDirection.INTERACTIVEMAP', [{ clearall: true }]);
        }
      }

      // When user click enter in input field
      function keydown(e) {
        if (e.keyCode == '13') {
          e.preventDefault();
          $directionButton.focus().click();
        }
      };
      function keyup(e) {
        validateInputLength($(this));
      };
      $inputStart.bind("keydown", keydown).bind("keyup", keyup);
      $inputEnd.bind("keydown", keydown).bind("keyup", keyup);

      //====================================
      // Reverse Direction Button Link - Switch Input value
      //====================================

      $reverseDirectionButton.click(function (e) {
        e.preventDefault();


        //Get Value
        inputValueStart = $inputStart.val();
        inputValueEnd = $inputEnd.val();

        //Set New Value
        $inputStart.val(inputValueEnd)
        $inputEnd.val(inputValueStart)

        //Disable/enable input to prevent to change airport adress
        var _updateInput = function (target) {
          if (target) {
            if (target.attr("disabled") == "disabled") {
              target.removeAttr("disabled")
            } else {
              target.attr("disabled", "disabled");
            }
          }
        }

        _updateInput($inputStart);
        _updateInput($inputEnd);

        //Trigger the direction button
        $directionButton.trigger("click");
      });

      //====================================
      // Reverse Direction Button Link - Switch Input value
      //====================================

      $directionButton.click(function (e) {
        e.preventDefault();

        if (!$directionButton.hasClass("disabled")) {
          //Call the Google Map API to set the direction
          setMapDirection();
        } else {
          //Empty Fields
        }
      });

      var setDirectionButton = function (state) {
        if (state) {
          $directionButton.removeClass("disabled");
        } else {
          $directionButton.addClass("disabled");
        }
      }

      //====================================
      // Travel modes in directions
      //====================================

      $travelModesLinks.click(function (e) {
        e.preventDefault();

        //Removed all selected element
        $travelModesLinks.removeClass("selected");

        //Selected the current target
        $(this).addClass("selected");

        //Trigger the direction button
        $directionButton.trigger("click");
      });

      //====================================
      // Direction Error
      //====================================

      //Clear error classname on input parent element
      function clearDirectionError() {
        $inputStartParent.removeClass("error");
        $inputEndParent.removeClass("error");
      };

      //Add error classname on current error input parent element
      function addDirectionError() {

        //Clear error class
        clearDirectionError();

        //Show error message
        if ($inputStart.attr("disabled") != "disabled") {
          $inputStartParent.addClass("error");
        } else {
          $inputEndParent.addClass("error");
        }

        //Clear Map and Direction Results
        $directionContainer.trigger('removeDirection.INTERACTIVEMAP', [{ clearall: true }]);
      };

      //====================================
      // Displaying the Directions Result
      //====================================

      function setMapDirection() {

        //Clear Error if available
        clearDirectionError();

        //Directions Google Map Object
        directionsDisplay = (directionsDisplay == null) ? new google.maps.DirectionsRenderer() : directionsDisplay;

        //Optimization : In Mobile device, we executes the "directionsDisplay" function only when we click on the map button. (interactivemap.js)
        if (Utils.getPlatform() != "mobile") {
          //Directions Display
          directionsDisplay.setMap(map);
        }

        // Displaying text directions
        directionsDisplay.setPanel($directionResults[0]);

        //Get Value
        inputValueStart = $inputStart.val();
        inputValueEnd = $inputEnd.val();

        //Get the Travel modes in directions
        var selectedMode = "DRIVING",
          currentSelectedMode;

        if ($travelModes) {
          currentSelectedMode = $travelModes.find(".selected").data("travelmodes");
          selectedMode = (currentSelectedMode.length > 0) ? currentSelectedMode : selectedMode;
        }

        var start = inputValueStart,
          end = inputValueEnd,
          request = {
            origin: start,
            destination: end,
            travelMode: google.maps.TravelMode[selectedMode]
          };



        dataLayer.push({
          'event': 'map_itinerary_submit',
          'itinerary_lang': Utils.getLang(),
          'from': start,
          'to': end
        });

        directionsService.route(request, function (result, status) {

          if (status == google.maps.DirectionsStatus.OK) {
            directionsDisplay.setDirections(result);

            //Show Direction Panel Result
            $directionResults.show();

            //Set the share link for the footer tools
            var links = "https://maps.google.com/maps?",
              routes = result.routes[0].legs[0],
              lang = $('html').attr('lang'),
              travelModes = $(".travel-modes .selected").data("travelmodes");
            dirflg = "",
              mapZoom = map.getZoom().toString();

            //Set the route that will be planned
            if (travelModes == "DRIVING") {
              dirflg = "d";
            } else if (travelModes == "TRANSIT") {
              dirflg = "r";
            } else {
              dirflg = "d";
            }

            //====================================
            //  Google Maps' Parameters
            //
            //  saddr = Sets the starting point for directions searches.
            //  daddr = Sets the end point for directions searches
            //  hl = language (fr, en)
            //  ie = character encoding (UTF8)
            //  dirflg = route that will be planned ("d" for car, "h" for no motorways, "r" for public transport only, "w" for walking directions)
            //  z = zoom level (1-20)
            //  t = map type ("m" map, "k" satellite, "h" hybrid, "p" terrain, "e" GoogleEarth)
            //  pw= Sets print mode ("0" not print, "1" print)
            //====================================

            //With Google Map Return Address
            links = links + "saddr=" + routes.start_address + "&daddr=" + routes.end_address + "&dirflg=" + dirflg + "&hl=" + lang + "&ie=UTF8&t=m";

            //Transform Url Encode
            links = encodeURI(links);

            $directionContainer.trigger("setShareLink.INTERACTIVEMAP", [links]);
            $directionContainer.trigger("setPrintLink.INTERACTIVEMAP", [{ direction: links + "&pw=1", windowPrint: false }]);

          } else {
            addDirectionError();
          }
        });
      }

      //Event to reset the direction (clear map and result)
      $directionContainer.on('removeDirection.INTERACTIVEMAP', function (e, params) {
        if (directionsDisplay != null) {
          //Clear Map direction
          directionsDisplay.suppressMarkers = true;
          directionsDisplay.setMap(null);

          if (params && params.clearall == true) {

            //Hide Direction Panel Result
            $directionResults.hide();

            //Remove all Google Content direction
            $directionResults.html("");

            //Reset the Directions Google Map Object
            directionsDisplay = null;
          }
        }
      });

      $directionContainer.on('directionsDisplay.INTERACTIVEMAP', function (e, params) {
        if (directionsDisplay != null) {
          //Directions Display
          directionsDisplay.setMap(map);

        } else {

          // Center the Airport - Optimise mobile or desktop/tablet
          if (Utils.getPlatform() == "mobile") {

            if (!isSpecificCenterPoint) {
              //Set to the Airport Center
              map.setZoom(16);

              //Go now to the point...
              map.setCenter(InteractiveMapDirection.airportLatLng);

            } else {
              //Set Specific Point
              setSpecificPoint(centerPoint, centerPointZoom);

              //This value is reset because we will not show this point the second time. (rules)
              isSpecificCenterPoint = false;
            }
          } else {
            //Set to the Airport Center
            map.setZoom(16);

            //Smoothly translation animation
            map.panTo(InteractiveMapDirection.airportLatLng);
          }
        }
      });

      //====================================
      // Adresse Autocomplete
      //====================================

      // Arg : input start (jquery element), input end (jquery element), interactivMapContext (bool)
      AdresseAutoComplete.init($inputStart, $inputEnd, true);

      // ====================================================================================
      // Init Direction On First Load (Trigger Events by url)
      // ====================================================================================

      // Set specific point on init without direction
      function setSpecificPoint(point, zoom) {

        // Convert to {lat,lng}
        var points = point.split(","),

          // Get the current position (lat,lng)
          pCenter = new google.maps.LatLng(points[0], points[1]);

        // Center the map
        map.setCenter(pCenter);

        // Set Zoom
        map.setZoom(parseInt(zoom));
      };

      // Set and active direction result
      function activateDirection() {
        //Activated the main click button to displaying the Directions Result
        setDirectionButton(true);

        //Trigger the direction button to show direction
        $directionButton.click();
      };

      var setInitialState = function () {
        var paramsStart = directionParams.directionStart,
          paramsEnd = directionParams.directionEnd,
          paramsCenterPoint = directionParams.directionCenterPoint,
          paramsZoom = directionParams.directionCenterZoom,
          mobileDirectToMap = directionParams.mobileDirectToMap,
          pStart = "",
          pEnd = "";

        if (paramsStart && paramsStart.length > 0) {
          pStart = decodeURI(paramsStart);

          //Set Start value
          $inputStart.val(pStart);

          //Call Direction
          activateDirection();

        } else if (paramsEnd && paramsEnd.length > 0) {
          pEnd = decodeURI(paramsEnd);

          //Reverse the input value
          $reverseDirectionButton.trigger("click");

          //Set End value
          $inputEnd.val(pEnd);

          //Call Direction
          activateDirection();

        } else if (paramsCenterPoint && paramsZoom && paramsCenterPoint.length > 0 && $.isNumeric(paramsZoom)) {

          // It's use to know condition when we will trigger the Map button on the toolbar
          isSpecificCenterPoint = true;

          //Set general value for these 2 global vars (it's use in the directionsDisplay.INTERACTIVEMAP)
          centerPoint = paramsCenterPoint;
          centerPointZoom = paramsZoom;

          // Set specific point without direction
          setSpecificPoint(centerPoint, centerPointZoom);

          // Activated the map panel
          if (Utils.getPlatform() == "mobile") {
            $directionContainer.trigger('showMap.INTERACTIVEMAP');
          }

        } else {
          //init at first load
          validateInputLength($inputStart);
        }
        if (mobileDirectToMap) {
          if (Utils.getPlatform() == "mobile") {
            $directionContainer.trigger('showMap.INTERACTIVEMAP');
          }
        }

      };
      setInitialState();

    }
  };

  return InteractiveMapDirection;
});
define('googlemap/libs/infobox_packed', [
  'jquery'
], function ($) {

  var infoCustomWindow = {
    init: function () {

      var load = function () {
        eval(function (p, a, c, k, e, r) { e = function (c) { return (c < a ? '' : e(parseInt(c / a))) + ((c = c % a) > 35 ? String.fromCharCode(c + 29) : c.toString(36)) }; if (!''.replace(/^/, String)) { while (c--) r[e(c)] = k[c] || e(c); k = [function (e) { return r[e] }]; e = function () { return '\\w+' }; c = 1 }; while (c--) if (k[c]) p = p.replace(new RegExp('\\b' + e(c) + '\\b', 'g'), k[c]); return p }('7 p(a){a=a||{};5.8.1N.2h(2,32);2.L=a.1u||"";2.1D=a.1q||H;2.P=a.1H||0;2.E=a.1B||1f 5.8.1U(0,0);2.B=a.W||1f 5.8.2t(0,0);2.S=a.11||q;2.1n=a.1l||"28";2.1k=a.D||{};2.1G=a.1E||"34";2.M=a.19||"2W://2Q.5.2L/2I/2G/2F/1v.2z";3(a.19===""){2.M=""}2.1i=a.1r||1f 5.8.1U(1,1);2.Y=a.1s||H;2.1a=a.1p||H;2.1K=a.2k||"2g";2.17=a.1m||H;2.4=q;2.w=q;2.X=q;2.16=q;2.15=q;2.13=q;2.12=q;2.O=q}p.r=1f 5.8.1N();p.r.22=7(){6 a;6 d=2;6 c=7(e){e.1Z=U;3(e.18){e.18()}};6 b=7(e){e.2S=H;3(e.1Y){e.1Y()}3(!d.17){c(e)}};3(!2.4){2.4=1g.2K("2J");2.1d();3(t 2.L.1w==="u"){2.4.J=2.F()+2.L}v{2.4.J=2.F();2.4.1b(2.L)}2.2y()[2.1K].1b(2.4);2.1F();3(2.4.9.A){2.O=U}v{3(2.P!==0&&2.4.Z>2.P){2.4.9.A=2.P;2.4.9.2u="2s";2.O=U}v{a=2.24();2.4.9.A=(2.4.Z-a.14-a.T)+"R";2.O=H}}2.1t(2.1D);3(!2.17){2.X=5.8.s.I(2.4,"2n",c);2.16=5.8.s.I(2.4,"1L",c);2.15=5.8.s.I(2.4,"2m",c);2.1o=5.8.s.I(2.4,"2l",7(e){2.9.1J="2j"})}2.12=5.8.s.I(2.4,"2i",b);5.8.s.Q(2,"2f")}};p.r.F=7(){6 a="";3(2.M!==""){a="<2e";a+=" 2d=\'"+2.M+"\'";a+=" 2c=T";a+=" 9=\'";a+=" W: 2b;";a+=" 1J: 2a;";a+=" 29: "+2.1G+";";a+="\'>"}N a};p.r.1F=7(){6 a;3(2.M!==""){a=2.4.27;2.w=5.8.s.I(a,\'1L\',2.1I())}v{2.w=q}};p.r.1I=7(){6 a=2;N 7(e){e.1Z=U;3(e.18){e.18()}a.1v();5.8.s.Q(a,"26")}};p.r.1t=7(d){6 m;6 n;6 e=0,G=0;3(!d){m=2.25();3(m 39 5.8.38){3(!m.23().37(2.B)){m.36(2.B)}n=m.23();6 a=m.35();6 h=a.Z;6 f=a.21;6 k=2.E.A;6 l=2.E.1j;6 g=2.4.Z;6 b=2.4.21;6 i=2.1i.A;6 j=2.1i.1j;6 o=2.20().31(2.B);3(o.x<(-k+i)){e=o.x+k-i}v 3((o.x+g+k+i)>h){e=o.x+g+k+i-h}3(2.1a){3(o.y<(-l+j+b)){G=o.y+l-j-b}v 3((o.y+l+j)>f){G=o.y+l+j-f}}v{3(o.y<(-l+j)){G=o.y+l-j}v 3((o.y+b+l+j)>f){G=o.y+b+l+j-f}}3(!(e===0&&G===0)){6 c=m.30();m.2Z(e,G)}}}};p.r.1d=7(){6 i,D;3(2.4){2.4.2Y=2.1n;2.4.9.2X="";D=2.1k;2V(i 2U D){3(D.2R(i)){2.4.9[i]=D[i]}}3(t 2.4.9.1h!=="u"&&2.4.9.1h!==""){2.4.9.2P="2O(1h="+(2.4.9.1h*2N)+")"}2.4.9.W="2M";2.4.9.V=\'1y\';3(2.S!==q){2.4.9.11=2.S}}};p.r.24=7(){6 c;6 a={1e:0,1c:0,14:0,T:0};6 b=2.4;3(1g.1x&&1g.1x.1V){c=b.2H.1x.1V(b,"");3(c){a.1e=C(c.1T,10)||0;a.1c=C(c.1S,10)||0;a.14=C(c.1R,10)||0;a.T=C(c.1W,10)||0}}v 3(1g.2E.K){3(b.K){a.1e=C(b.K.1T,10)||0;a.1c=C(b.K.1S,10)||0;a.14=C(b.K.1R,10)||0;a.T=C(b.K.1W,10)||0}}N a};p.r.2D=7(){3(2.4){2.4.2C.2B(2.4);2.4=q}};p.r.1A=7(){2.22();6 a=2.20().2A(2.B);2.4.9.14=(a.x+2.E.A)+"R";3(2.1a){2.4.9.1c=-(a.y+2.E.1j)+"R"}v{2.4.9.1e=(a.y+2.E.1j)+"R"}3(2.Y){2.4.9.V=\'1y\'}v{2.4.9.V="1X"}};p.r.2T=7(a){3(t a.1l!=="u"){2.1n=a.1l;2.1d()}3(t a.D!=="u"){2.1k=a.D;2.1d()}3(t a.1u!=="u"){2.1Q(a.1u)}3(t a.1q!=="u"){2.1D=a.1q}3(t a.1H!=="u"){2.P=a.1H}3(t a.1B!=="u"){2.E=a.1B}3(t a.1p!=="u"){2.1a=a.1p}3(t a.W!=="u"){2.1z(a.W)}3(t a.11!=="u"){2.1P(a.11)}3(t a.1E!=="u"){2.1G=a.1E}3(t a.19!=="u"){2.M=a.19}3(t a.1r!=="u"){2.1i=a.1r}3(t a.1s!=="u"){2.Y=a.1s}3(t a.1m!=="u"){2.17=a.1m}3(2.4){2.1A()}};p.r.1Q=7(a){2.L=a;3(2.4){3(2.w){5.8.s.z(2.w);2.w=q}3(!2.O){2.4.9.A=""}3(t a.1w==="u"){2.4.J=2.F()+a}v{2.4.J=2.F();2.4.1b(a)}3(!2.O){2.4.9.A=2.4.Z+"R";3(t a.1w==="u"){2.4.J=2.F()+a}v{2.4.J=2.F();2.4.1b(a)}}2.1F()}5.8.s.Q(2,"2x")};p.r.1z=7(a){2.B=a;3(2.4){2.1A()}5.8.s.Q(2,"1O")};p.r.1P=7(a){2.S=a;3(2.4){2.4.9.11=a}5.8.s.Q(2,"2w")};p.r.2v=7(){N 2.L};p.r.1C=7(){N 2.B};p.r.33=7(){N 2.S};p.r.2r=7(){2.Y=H;3(2.4){2.4.9.V="1X"}};p.r.2q=7(){2.Y=U;3(2.4){2.4.9.V="1y"}};p.r.2p=7(c,b){6 a=2;3(b){2.B=b.1C();2.13=5.8.s.2o(b,"1O",7(){a.1z(2.1C())})}2.1M(c);3(2.4){2.1t()}};p.r.1v=7(){3(2.w){5.8.s.z(2.w);2.w=q}3(2.X){5.8.s.z(2.X);5.8.s.z(2.16);5.8.s.z(2.15);5.8.s.z(2.1o);2.X=q;2.16=q;2.15=q;2.1o=q}3(2.13){5.8.s.z(2.13);2.13=q}3(2.12){5.8.s.z(2.12);2.12=q}2.1M(q)};', 62, 196, '||this|if|div_|google|var|function|maps|style||||||||||||||||InfoBox|null|prototype|event|typeof|undefined|else|closeListener_|||removeListener|width|position_|parseInt|boxStyle|pixelOffset_|getCloseBoxImg_|yOffset|false|addDomListener|innerHTML|currentStyle|content_|closeBoxURL_|return|fixedWidthSet_|maxWidth_|trigger|px|zIndex_|right|true|visibility|position|eventListener1_|isHidden_|offsetWidth||zIndex|contextListener_|moveListener_|left|eventListener3_|eventListener2_|enableEventPropagation_|stopPropagation|closeBoxURL|alignBottom_|appendChild|bottom|setBoxStyle_|top|new|document|opacity|infoBoxClearance_|height|boxStyle_|boxClass|enableEventPropagation|boxClass_|eventListener4_|alignBottom|disableAutoPan|infoBoxClearance|isHidden|panBox_|content|close|nodeType|defaultView|hidden|setPosition|draw|pixelOffset|getPosition|disableAutoPan_|closeBoxMargin|addClickHandler_|closeBoxMargin_|maxWidth|getCloseClickHandler_|cursor|pane_|click|setMap|OverlayView|position_changed|setZIndex|setContent|borderLeftWidth|borderBottomWidth|borderTopWidth|Size|getComputedStyle|borderRightWidth|visible|preventDefault|cancelBubble|getProjection|offsetHeight|createInfoBoxDiv_|getBounds|getBoxWidths_|getMap|closeclick|firstChild|infoBox|margin|pointer|relative|align|src|img|domready|floatPane|apply|contextmenu|default|pane|mouseover|dblclick|mousedown|addListener|open|hide|show|auto|LatLng|overflow|getContent|zindex_changed|content_changed|getPanes|gif|fromLatLngToDivPixel|removeChild|parentNode|onRemove|documentElement|mapfiles|en_us|ownerDocument|intl|div|createElement|com|absolute|100|alpha|filter|www|hasOwnProperty|returnValue|setOptions|in|for|http|cssText|className|panBy|getCenter|fromLatLngToContainerPixel|arguments|getZIndex|2px|getDiv|setCenter|contains|Map|instanceof'.split('|'), 0, {}))
        window.InfoBox = InfoBox;
      };

      /* Check if the google map script is ready */
      if (ADM.googleMapScriptLoadState === 2) {
        load();
      } else {
        var eventEmitter = ADM.eventEmitter;
        eventEmitter.addListener('googleMapScriptLoaded', function () {
          load();
        });
      }
    }
  };

  // ============================
  // Public Object
  // ============================
  return infoCustomWindow;
});
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function () {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push = ArrayProto.push,
    slice = ArrayProto.slice,
    concat = ArrayProto.concat,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach = ArrayProto.forEach,
    nativeMap = ArrayProto.map,
    nativeReduce = ArrayProto.reduce,
    nativeReduceRight = ArrayProto.reduceRight,
    nativeFilter = ArrayProto.filter,
    nativeEvery = ArrayProto.every,
    nativeSome = ArrayProto.some,
    nativeIndexOf = ArrayProto.indexOf,
    nativeLastIndexOf = ArrayProto.lastIndexOf,
    nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeBind = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function (obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function (obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function (obj, predicate, context) {
    var result;
    any(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, function (value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function (obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function (value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function (obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function (value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function (obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function (value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function (obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function (behavior) {
    return function (obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function (value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function (result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function (result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function (result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function (obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function (array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function (input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function (value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function (array, predicate, context) {
    predicate = lookupIterator(predicate);
    var pass = [], fail = [];
    each(array, function (elem) {
      (predicate.call(context, elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function () {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) { return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function () {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function (list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function (array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function (array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while (idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function () { };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function (func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function () {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);
    return function () {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function (f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () { return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function (func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function () {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function () {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function (func) {
    var ran = false, memo;
    return function () {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function (obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

  // Return a copy of the object without the blacklisted properties.
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function (a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
      _.isFunction(bCtor) && (bCtor instanceof bCtor))
      && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function (obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function (obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function (obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function (value) {
    return value;
  };

  _.constant = function (value) {
    return function () {
      return value;
    };
  };

  _.property = function (key) {
    return function (obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function (attrs) {
    return function (obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function () { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function (method) {
    _[method] = function (string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function (object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function (match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function (obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function () {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function () {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function () {
      return _;
    });
  }
}).call(this);
var ADM = window.ADM || {};

define('interactivemap/filters', [
  'jquery',
  'settings',
  'UTILS',
  'googlemap/spriteMarker',
  'googlemap/libs/infobox_packed',

  'jsrender',
  'underscore',
  'enhance'
], function ($, Settings, Utils, SMarker, GInfoWindow) {

  var InteractiveMapFilters = {
    effects: {
      easing: "easeOutExpo",
      duration: 400
    },
    iconsClassName: {
      up: "icon-arrow-up",
      right: "icon-arrow-right",
      left: "icon-arrow-left",
      down: "icon-arrow-down"
    },
    arrowClassName: {
      right: "arrow-right",
      left: "arrow-left"
    },
    airportLatLng: Settings.map.airportLatLng,
    init: function ($filtersContainer, mapObject, options, filtersParams) {



      //====================================
      // INIT GLOBAL VARS
      //====================================

      //The Current Google Map Object
      var map = mapObject.map,
        eventEmitter = ADM.eventEmitter,

        /*
         *   Array that contains all the markers that matches the filters on the map
         *   trigger by checkbox and zone changed
         */
        markersOnMap = [],

        // Level
        $pnlLevel = $(".pnl-niveau", $filtersContainer),
        $levelButtons = $(".btn-action", $pnlLevel),
        $levelDeparture = $(".level-departure", $filtersContainer),
        $levelArrival = $(".level-arrival", $filtersContainer),
        //true: clear All - false: update zones and filters (markers)
        clearMarkerLevel = false,

        // Zones
        $pnlZones = $(".pnl-zones", $filtersContainer),
        $zonesSelect = $("select", $pnlZones),

        // Overlay (Info Window)
        previousInfoWindow = "",
        currentInfoWindow = "",

        // Filters Results
        $filtersResults = $(".filters-results .results", $filtersContainer),
        $filtersHasResults = $(".container-filters .total-results", $filtersContainer),
        $filtersNumber = $(".number", $filtersHasResults),
        //Note: There are 2 elements in DOM (mobile only)
        $filtersNoResults = $(".scrollable .no-results", $filtersContainer),

        // Get the markup for the Result template (script tag - x-jsrender)
        myResultTemplate = $.templates("#admFiltersResultsRender"),

        // Get the markup for the Filters template (script tag - x-jsrender)
        myFiltersTemplate = $.templates("#admFiltersRender"),

        /*
         *   CheckBounds
         *   First Load Map :
         *      We need this condition because we do not want error in mobile.
         *      The container of the map isn't good in the first load of the page.
         */
        firstCheckBoundsLoad = false,

        //Use for the "Clear" method
        $allCheckBox = [],
        $allShowAllBtn = [],
        $mergeAllCheckBox = [],
        $allCatBtn = [],

        // Clear Filters Button Link
        $clearFiltersBtn = $(".filters-renew", $filtersContainer);

      //====================================
      // Init InfoWindow JS Module
      //====================================
      GInfoWindow.init();

      //====================================
      // Render a template (Categories and filters)
      //====================================

      // Get Options
      var app = {
        admMapFilters: options.mapOptions,
        admMapMarkers: options.markers
      },

        // To build the Categories
        filtersList = app.admMapFilters,

        // To Get all markers
        markersList = app.admMapMarkers,

        // Add the render HTML
        filtersHtml = myFiltersTemplate.render(filtersList);
      $(".filters", $filtersContainer).html(filtersHtml);
      $(".filters", $filtersContainer).enhance();

      //====================================
      // Set the Filter 'level' (Niveau) and Update the Map
      //====================================

      //Get and return the current level
      var getCurrentLevel = function () {
        var level;
        $.each($levelButtons, function () {
          var $this = $(this);
          if ($this.hasClass("interactivemap-selected")) {
            level = $this.data("interactivemap-level");
            return false;
          }
        });
        return level;
      };

      InteractiveMapFilters.getCurrentLevel = getCurrentLevel;

      //Set Level
      var setCurrentLevel = function (level) {
        //Set the new level to trigger the good button
        if (level == "arrival") {
          $levelArrival.trigger("click");
        } else if (level == "departure") {
          $levelDeparture.trigger("click");
        } else {
          $levelDeparture.trigger("click");
        }
      };

      var levelsUpdate = function (container, target) {

        if (target) {

          // Update Filter 'level' (Niveau) and Update the Map

          //Get the current level name
          var interactivemapLevel = target.data("interactivemap-level");

          //prevent double click event
          if (!target.hasClass("interactivemap-selected")) {

            //Remove all selected class
            $levelButtons.removeClass("interactivemap-selected");

            //Set the current selected element
            target.addClass("interactivemap-selected");

            //Set or update the Map Level shape
            if (interactivemapLevel) {
              //Method is in the "admMap.js"
              mapObject.setLevel(interactivemapLevel);
            }

            if (clearMarkerLevel) {
              // Clear Filters and Update the Map
              clearFilters();
            } else {
              //Trigger the Zone Change to Update Marker on Map
              $zonesSelect.trigger("change");
            }
          }
        }
      };

      //====================================
      // Set the Filter 'zones' (Zones) and Update the Map
      //====================================

      //Change event on select element
      $zonesSelect.change(function () {
        //Update Marker on Map with new zones value
        updateMarker();
      });

      //Get and return the current zones
      var getCurrentZones = function () {
        //Get the zones
        var zones = $zonesSelect.val();

        return zones
      };

      InteractiveMapFilters.getCurrentZones = getCurrentZones;


      //Set Zones
      var setCurrentZones = function (zones) {

        //Set the new zones
        $zonesSelect.val(zones);

        //Trigger the change select to update the select display name
        $zonesSelect.trigger("change");
      };

      var zonesUpdate = function (container, target) {
        if (target) {
          // Update Filter 'level' (Niveau) and Update the Map

          //Get the current level name
          var interactivemapLevel = target.val();

          //Set or update the Map Zones shape
          if (interactivemapLevel) {
            //Method is in the "admMap.js"
            mapObject.setAreas(interactivemapLevel);
          }
        }
      };

      var getCurrentFilters = function () {
        var $filters = $('input[type=checkbox]:checked', $filtersContainer);
        var filtersIdArray = [];
        $filters.each(function () {
          filtersIdArray.push($(this).attr("id"));
        });

        return filtersIdArray;
      };
      InteractiveMapFilters.getCurrentFilters = getCurrentFilters;

      // ============================
      // Listen Trigger Event
      // ============================

      /*
       * Level Update Method : to update the level
       * Call by the Main Btn ($levelDeparture, $levelArrival)
       */
      eventEmitter.addListener("interactivemap-levelsupdate", levelsUpdate);

      /*
       * Zones Update Method : to update the zones
       * Call by the Main Btn ($zonesSelect)
       */
      eventEmitter.addListener("interactivemap-zonesoption", zonesUpdate);

      //====================================
      // Get Marker Icon Name (find in categories list)
      //====================================
      var getMarkerIconName = function (filterId) {

        //Get the current marker icon associated by the category
        var filters, filter, icon;

        $.each(filtersList, function (key, data) {

          //All filters List associated by the Category
          filters = data.Filters;

          for (i = 0; i < filters.length; i++) {

            //Specific Filter
            filter = filters[i].Filter;

            //Find the marker icon name
            if (filterId == filter.Filter_Id) {
              icon = filter.Icon;
              break;
            }
          };
        });

        return icon;
      };

      //====================================
      // Created Markers And Overlay (Info Window)
      //====================================

      // Created Info Window (marker overlay)
      // - API Reference (InfoBox)
      // - //code.google.com/p/google-maps-utility-library-v3/source/browse/trunk/infobox/src/infobox.js?r=413&spec=svn459
      // - //google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/1.1.5/docs/reference.html
      var infowindow = new InfoBox({
        content: "",
        disableAutoPan: false,
        pixelOffset: new google.maps.Size(25, -25),
        zIndex: 99999999999,
        closeBoxMargin: "0px",
        closeBoxURL: "",
        infoBoxClearance: new google.maps.Size(0, 0)
      });

      $.each(markersList, function (key, data) {

        var markerInfos = data,
          id = markerInfos.Marker_Id,
          filterId = markerInfos.Filters_Id,
          lat = markerInfos.Latitude,
          lng = markerInfos.Longitude,
          infoWindow = markerInfos.Info_Window,
          hasLink = true,
          hasDescription = false,
          markerHasShowOnMap = false;

        //Create Array with values
        filterId = filterId.split(",");

        //Get the good icon name
        var icon = getMarkerIconName(filterId[0]);

        //Overlay has link or not
        if (infoWindow.Url === "" || infoWindow.Url === undefined || infoWindow.Url === null || infoWindow.Url === "null") {
          hasLink = false;
        }

        //Overlay has link or not
        if (infoWindow.Description !== "") {
          hasDescription = true;
        }

        //Marker Options
        var markerOptions = {
          lat: lat,
          lng: lng,
          map: null,
          clickable: true,
          hasLink: hasLink
        },
          markerClickableOptions = {};

        if (Utils.getPlatform() !== "mobile") {
          markerClickableOptions.animation = google.maps.Animation.DROP
        }

        $.extend(markerOptions, markerClickableOptions)

        //The Marker
        var marker = SMarker.getInstance(icon, map, markerOptions),

          //Info Window HTML
          infowindowHtmlTitle = "<p class=\"infobox-title\">" + infoWindow.Title + "</p>",
          infowindowWithLinkHtml = "<p class=\"infobox-title\"><a href=" + infoWindow.Url + " target=" + infoWindow.Target + ">" + infoWindow.Title + "</a></p>";

        if (infoWindow.Url === "" || infoWindow.Url === undefined || infoWindow.Url === "null" || infoWindow.Url === null) {
          infowindowWithLinkHtml = "<p class=\"infobox-title\">" + infoWindow.Title + "</p>";
        }
        var infowindowWithLinkPartialDesc = "<p class=\"infobox-details\">" + infoWindow.Description + "</p>";
        var infowindowWithLinkPartialLink = "<p class=\"infobox-details\"><a href='" + infoWindow.Url + "'>" + ADM.i18n.interactivemap.moreinfo + "</a></p>";

        if (infoWindow.Description === "" || infoWindow.Description === undefined || infoWindow.Description === "null" || infoWindow.Description === null) {
          infowindowWithLinkPartialDesc = "";
        }
        //console.log("infoWindow.Description", infoWindow.Description, "/", infoWindow.Title,  "/", infowindowWithLinkPartialDesc);

        if (infoWindow.Url === "" || infoWindow.Url === undefined || infoWindow.Url === "null" || infoWindow.Url === null) {
          infowindowWithLinkPartialLink = "";
        }
        //console.log("infoWindow.Url", infoWindow.Url, "/", infoWindow.Title,  "/", infowindowWithLinkPartialLink, infowindowWithLinkHtml);

        var infowindowWithLinkDescHtml = "<p class=\"infobox-title\"><a href=" + infoWindow.Url + " target=" + infoWindow.Target + ">" + infoWindow.Title + "</a></p>" + infowindowWithLinkPartialDesc + infowindowWithLinkPartialLink;

        var infowindowWithNoLinkDescHtml = "<p class=\"infobox-title\">" + infoWindow.Title + "</p><p class=\"infobox-details\">" + infoWindow.Description + "</p>";

        //Open the Info Window
        google.maps.event.addListener(marker, "click", function () {

          if (marker.hasLink && hasDescription) {
            //With url link and description
            infowindow.setContent(infowindowWithLinkDescHtml);
          } else if (marker.hasLink && !hasDescription) {
            //With url link and no description
            infowindow.setContent(infowindowWithLinkHtml);
          } else if (!marker.hasLink && hasDescription) {
            //With no url link and with description
            infowindow.setContent(infowindowWithNoLinkDescHtml);
          } else {
            //With title only
            infowindow.setContent(infowindowHtmlTitle);
          }

          //Set the Current Open InfoWindow
          currentInfoWindow = id;

          //Close InfoWindow if it's already open by the same marker
          if (previousInfoWindow == currentInfoWindow) {
            previousInfoWindow = "";
            infowindow.close();
          } else {
            previousInfoWindow = currentInfoWindow;
            infowindow.open(map, marker);
          }
        });

        //Closed all Info Window when the user click on map
        google.maps.event.addListener(map, "click", function () {
          if (infowindow) {
            //Reset
            previousInfoWindow = currentInfoWindow = "";
            //Close
            infowindow.close();
            //Remove marker bounce (Fix iOS - tablet)
            marker.setAnimation(null);
          }
        });

        //Added Google Marker in the current marker properties object to in use in filter condition
        markersList[key].Marker_Map = marker;

        //Add Google InfoWindow in the current marker properties object
        markersList[key].Info_Window.Info_Window_Map = infowindow;
      });

      // ====================================================================================
      // ====================================================================================
      // Filters Interactive Events (checkbox)
      // ====================================================================================
      // ====================================================================================

      //====================================
      // Return boolean if the markers contains one of these conditions by level and zone
      //====================================
      var isFiltersMarkerCondition = function (cLevel, cZone, mLevel, mZones) {

        var boolean = (
          cLevel == "all" && cZone == mZones ||
          cLevel == mLevel && cZone == "all" ||
          mLevel == "all" && mZones == "all" ||
          cLevel == mLevel && cZone == mZones ||
          mLevel == "all" && cZone == mZones ||
          cLevel == mLevel && mZones == "all");

        /*console.log("1 = ", (cLevel == "all" && cZone == mZones));
         console.log("2 = ", (cLevel == mLevel && cZone == "all"));
         console.log("3 = ", (mLevel == "all" && mZones == "all"));
         console.log("4 = ", (cLevel == mLevel && cZone == mZones));
         console.log("5 = ", (cLevel == "all" && cZone == mZones));
         console.log("6 = ", (cLevel == mLevel && mZones == "all"));

         console.log("cLevel = ", cLevel);
         console.log("cZone = ", cZone);
         console.log("mLevel = ", mLevel);
         console.log("mZones = ", mZones);*/

        return boolean;
      };

      // ====================================================================================
      // Filters Results
      // ====================================================================================

      //====================================
      // Add Results Links Marker Events
      //
      // Set 'mouseenter', 'mouseleave' and 'click' on links element to :
      //      - Set Center Marker on map
      //      - Bound the good associated marker
      //      - Open the InfoWindow
      //
      // link : the current button link [object]
      // markerMap : the current marker available on map [object]
      //====================================
      var setResultsLinksMarkerEvents = function (link, marker) {

        //The Marker on map
        var markerMap = marker.Marker_Map;

        if (typeof markerMap === 'object') {

          // Add marker in bounds to get new center
          var bounds = new google.maps.LatLngBounds();
          bounds.extend(markerMap.getPosition());

          // Get Marker Center
          var markerCenter = bounds.getCenter();

          // The current button link
          link.bind('mouseenter', function (e) {
            e.preventDefault();

            // Get the current marker position
            var getPosition = new google.maps.LatLng(markerCenter.lat(), markerCenter.lng());

            // Center the marker point
            centerMap(getPosition);

            // Make bounce a marker if bouncing is possible
            if (Utils.getPlatform() !== "mobile") {
              var currentZoomLevel = map.getZoom(),
                minZoom = 15;

              if (currentZoomLevel >= minZoom) {
                markerMap.setAnimation(google.maps.Animation.BOUNCE);
              }
            }

          }).bind('mouseleave', function (e) {
            e.preventDefault();

            // Remove marker bounce
            markerMap.setAnimation(null);
          })
            .bind('click', function (e) {
              e.preventDefault();

              // Click only if the property clickable to the marker is true
              if (markerMap.clickable) {

                var id = marker.Marker_Id;

                //Set the Current Open InfoWindow
                currentInfoWindow = id;

                //Keep InfoWindow open if it's already open by the same marker
                if (previousInfoWindow != currentInfoWindow) {
                  google.maps.event.trigger(markerMap, 'click');
                }

                //Trigger click event on the show map button to show the current infowindow on map
                if (Utils.getPlatform() == "mobile") {
                  $filtersContainer.trigger('showMap.INTERACTIVEMAP');
                }
              }
            });
        }
      };

      //====================================
      // Get Complete Display Name for result's
      //====================================

      // Zone's names allowed to use
      var allowedZones = ['all', 'domestic', 'transborder', 'public', 'international'],

        // Level's names allowed to use
        allowedLevel = ['all', 'arrival', 'departure'],

        // Available Zone's Text
        contentZones = {
          all: 'all',
          domestic: $("option[value='domestic']", $zonesSelect).text(),
          transborder: $("option[value='transborder']", $zonesSelect).text(),
          public: $("option[value='public']", $zonesSelect).text(),
          international: $("option[value='international']", $zonesSelect).text()
        },

        // Available Level's Text
        contentLevel = {
          all: 'all',
          departure: $(".label", $levelDeparture).html(),
          arrival: $(".label", $levelArrival).html()
        },

        getCompleteDisplayName = function (markerLevel, markerZones, markerDisplayName) {
          var text = "",
            levelText = "";
          zoneText = "";

          //Prevent Error if values change...
          if ($.inArray(markerLevel, allowedLevel) != -1) {
            levelText = contentLevel[markerLevel];
          }
          if ($.inArray(markerZones, allowedZones) != -1) {
            zoneText = contentZones[markerZones];
          }

          if (markerLevel != "all" && markerZones != "all") {
            text = levelText + ", " + zoneText + ", " + markerDisplayName;
          } else if (markerLevel != "all" && markerZones == "all") {
            text = levelText + ", " + markerDisplayName;
          } else if (markerLevel == "all" && markerZones != "all") {
            text = zoneText + ", " + markerDisplayName;
          } else if (markerLevel == "all" && markerZones == "all") {
            text = markerDisplayName;
          }

          return text;
        };

      //====================================
      // Clear Filters Results
      //====================================
      var clearFiltersResults = function () {
        $filtersResults.hide();
        $filtersResults.empty();

        $filtersHasResults.hide();
        $filtersNoResults.show();
      };

      //====================================
      // Add Filters Results
      //====================================
      var setFiltersResults = function (markers) {

        /*
         * Format Results Data Json for jsview render
         */
        var mResults = [],
          loopCategory = 0,
          markersTotalAvailableNumber = 0,

          //Get the current Level and Zones
          currentLevel = getCurrentLevel(),
          currentZone = getCurrentZones();

        /*
         * Created the Category array
         * id : It's the current filter ID (provide by the input checked) [number]
         */
        var createCategoryItem = function (id) {

          $.each(filtersList, function (key, data) {

            //All filters List associated by the Category
            filters = data.Filters;

            $.each(filters, function (key, data) {

              //Specific Filter
              filter = data.Filter;

              //Filter Id
              filterId = filter.Filter_Id;

              if (filterId == id) {

                //Filter available - Create new item in the array
                mResults.push({});

                mResults[loopCategory].Filter_Id = filter.Filter_Id;
                mResults[loopCategory].Filter_Label = filter.Label;
                mResults[loopCategory].Icon_ClassName = filter.Icon_ClassName;
                mResults[loopCategory].Marker_Map = [];

                loopCategory++;
                return false;
              }

            });
          });
        };

        //Create New Result Array
        $.each($mergeAllCheckBox, function (key, data) {

          //Get items that are "checked" before create and push value in the results array.
          var id = data.id,
            markerAvailable = false,
            categoryProcess = true,
            loopMarkerMap = 0,
            sizeNumberList = 0,

            //Find the current checkbox (input)
            $input = $("#" + id, $filtersContainer);

          if ($input && $input.attr('checked')) {

            $.each(markersList, function (key, data) {

              var marker = data,
                filtersId = marker.Filters_Id;

              //Create Array with values
              filtersId = filtersId.split(",");

              //IF the input id is available in the marker point
              var isInArrayPos = $.inArray(id, filtersId);

              if (isInArrayPos > -1) {

                var markerLevel = marker.Level,
                  markerZones = marker.Zones,
                  isValid = isFiltersMarkerCondition(currentLevel, currentZone, markerLevel, markerZones);

                if (isValid) {

                  if (categoryProcess) {
                    createCategoryItem(id);
                    categoryProcess = false;
                  }

                  sizeNumberList = _.size(mResults) - 1;
                  mResults[sizeNumberList].Marker_Map[loopMarkerMap] = marker;

                  loopMarkerMap++;
                  markersTotalAvailableNumber++;
                  markerAvailable = true;
                }
              }
            });

            //Add the marker available number
            //To prevent error when the checkbox doesn't have any marker available
            if (markerAvailable) {
              mResults[sizeNumberList].Markers_Available_Number = loopMarkerMap;
            }
          }
        });

        if (mResults.length > 0) {

          //Sorting Array by A to Z
          mResults = _.sortBy(mResults, "Filter_Label");

          //====================================
          // Render a template
          //====================================
          var appResult = {
            admMapFiltersResults: mResults
          };

          // To build the Results List
          var filtersResultsList = appResult.admMapFiltersResults,
            filtersResultsListHtml = myResultTemplate.render(filtersResultsList);

          //Show main box
          $filtersResults.html(filtersResultsListHtml).show();

          //Show results box
          $filtersHasResults.show();

          //Set the total results
          $filtersNumber.html(markersTotalAvailableNumber);

          //Hide no results text box
          $filtersNoResults.hide();

          // ============================
          // Filter Results Button Link
          // ============================

          //Add Event on anhor link to trigger marker interactivity on map
          var $filtersResultsLinks = $("a", $filtersResults);

          $filtersResultsLinks.each(function () {

            var $this = $(this),
              markerId = $this.data("marker-id"),
              theMarker = [];

            //Find the marker on map object
            theMarker = _.filter(markersList, function (item) {
              return item["Marker_Id"] == markerId;
            });

            if (theMarker.length > 0) {
              //Set mouse event on links element and bound the good associated marker (theMarker[0])
              //Marker_Id is unique so, take the first position
              setResultsLinksMarkerEvents($this, theMarker[0]);
            } else {
              //To prevent error, we remove the anchor link and replace by span
              $this.replaceWith("<span>" + $this.text() + "</span>");
            }
          });

        } else {
          clearFiltersResults();
        }
      };

      // ====================================================================================
      // Markers Events
      // ====================================================================================

      // ============================
      // Remove Marker on map, close the InfoWindow and returns those remaining (markersOnMap)
      // ============================
      var removeMarker = function (elt, markersOnMap) {

        //Remove marker on map
        elt.Marker_Map.setMap(null);

        //Remove the current infowindow if it's open
        elt.Info_Window.Info_Window_Map.close();

        //Remove marker in the array
        markersOnMap = _.without(markersOnMap, elt);

        return markersOnMap;
      };

      // ============================
      // Update Marker on map and active the Results panel trigger by the select zone
      // Trigger by zones changed
      // ============================
      var updateMarker = function () {


        // Trigger to update marker on map
        $('input[type=checkbox]:checked', $filtersContainer).trigger('zoneChanged.INTERACTIVEMAP');

        if (markersOnMap.length > 0) {

          //Get the current Level and Zones
          var currentLevel = getCurrentLevel(),
            currentZone = getCurrentZones();

          $.each(markersOnMap, function (key, data) {

            var $marker = data,//The Marker
              markerLevel = $marker.Level,
              markerZones = $marker.Zones,
              isValid = isFiltersMarkerCondition(currentLevel, currentZone, markerLevel, markerZones);

            if (isValid) {
              // Add marker on map

              console.log("$marker", $marker);
              $marker.Marker_Map.setMap(map);
            } else {
              // Remove marker in the array
              markersOnMap = removeMarker($marker, markersOnMap);
            }
          });

          //Trigger Event to Set the markers results and the check bounds marker on map.
          $filtersContainer.trigger('lazyResults.INTERACTIVEMAP');
        }
      };

      // ============================
      // Center the marker point on the map - Optimise mobile or desktop/tablet
      // ============================
      var centerMap = function (position) {
        // Center the marker point - Optimise mobile or desktop/tablet
        if (Utils.getPlatform() == "mobile") {
          //Go now to the point...
          map.setCenter(position);
        } else {
          //Smoothly translation animation
          map.panTo(position);
        }
      };

      // ============================
      // Make sure markers are visible on the map, if not, zoom out the map until they are visible
      // ============================
      var FitMarkers = function () {
        if (!map.getBounds()) return;

        var nbNotVisible = 0,
          minZoom = 2;

        for (var i = 0; i < markersOnMap.length; i++) {
          var isContains = map.getBounds().contains(markersOnMap[i].Marker_Map.getPosition());
          if (!isContains) {
            nbNotVisible++;
          }
        }

        //We will zoom out to show the marker
        if (nbNotVisible > 0) {
          map.setZoom(map.zoom - 1);
          FitMarkers();
        }
      };

      // ============================
      // Make sure markers are visible on the map, if not, zoom out the map until they are visible
      // ============================
      var checkBounds = function () {

        // Create a new viewpoint bound
        var bounds = new google.maps.LatLngBounds(),
          ml = markersOnMap.length;

        //Add bounds to take all points available on map
        for (i = 0; i < ml; i++) {
          bounds.extend(markersOnMap[i].Marker_Map.getPosition());
        }

        if (ml == 0) {
          //Set to the Airport Center
          map.setZoom(16);

          //Center position Map
          centerMap(InteractiveMapFilters.airportLatLng);
        } else {

          // Get the current marker position
          var getPosition = bounds.getCenter();

          // Center position Map
          centerMap(getPosition);

          if (firstCheckBoundsLoad) {
            // Set the zoom out to show all markers available on map
            // NOTE: We do this because the fitbouds causes a flicker on the polygons on map
            FitMarkers();
          }
          firstCheckBoundsLoad = true;

          /*
           * Restore the good zoom level after the map is done scaling to show all markers (panning or zooming)
           */
          var minZoom = 16,
            maxZoom = 17,
            currentZoom = map.zoom;

          //To prevent too close zoom so, we will zoom out to specific max zoom
          if (currentZoom > maxZoom) {
            map.setZoom(maxZoom);
            currentZoom = map.zoom;
          }

          //To prevent too far zoom so, we will zoom in to specific min zoom
          if (currentZoom < minZoom) {
            map.setZoom(minZoom);
          }
        }
      };

      // ============================
      // Verified if element before the current filter is checked (input) to get icon
      // If it's check, this element has a higher icon priority
      // Note:
      //      In the json, the first element in the "Filters_Id" is a priority
      // Callback :
      //      To know if the marker is available in another filters (true, false)
      // ============================
      var updateIconPriority = function (elem, currentFilterId, filtersId) {

        var filterId = "",
          mAvailable = false;

        $.each(filtersId, function (key, data) {
          var filtersIdPriority = data,
            $input = $("#" + filtersIdPriority, $filtersContainer);

          if ($input) {
            if ($input.attr('checked')) {
              filterId = filtersIdPriority;
              mAvailable = true;
              return false;
            }
          }
        });

        currentFilterId = (filterId != "") ? filterId : currentFilterId;

        // Update Marker Type with the icon priority (it's for overright icon)
        icon = getMarkerIconName(currentFilterId);
        SMarker.setType(elem.Marker_Map, icon);

        return mAvailable;
      };

      // ============================
      // Set Marker on map and active the Results panel (trigger by checkbox)
      //
      // params:
      //      elt = current checkbox [object]
      // ============================
      var setMarkersOnMap = function (elt) {

        //Get the current Level and Zones
        var currentLevel = getCurrentLevel(),
          currentZone = getCurrentZones(),

          //Current input (checkBox)
          $currentCheckBox = elt,

          //Get the marker id to load
          currentFilterId = $currentCheckBox.val().toString();

        // Remove all whitespace with RegEx to prevent wrong manipulation
        currentFilterId = currentFilterId.replace(/\s+/g, '');

        if (currentFilterId != "") {

          //Find all markers contain the same 'Filter Id' in the main 'MarkersList'
          for (j = 0; j < markersList.length; j++) {
            var elem = markersList[j],
              filtersId = elem.Filters_Id,
              icon = "";

            //Create Array with values
            filtersId = filtersId.split(",");

            var isInArrayPos = $.inArray(currentFilterId, filtersId);

            if (isInArrayPos > -1) {

              if ($currentCheckBox.attr('checked')) {

                var markerLevel = elem.Level,
                  markerZones = elem.Zones,
                  isValid = isFiltersMarkerCondition(currentLevel, currentZone, markerLevel, markerZones);

                if (isValid) {

                  // Is marker is already on map
                  var isMarkerOnAlreadyOnMap = elem.Marker_Map.getMap();
                  isMarkerOnAlreadyOnMap = (isMarkerOnAlreadyOnMap == null) ? true : false;

                  //To prevent duplicate when we change the zone
                  if (isMarkerOnAlreadyOnMap) {

                    // Add marker on map
                    elem.Marker_Map.setMap(map);

                    //Set Icon Marker
                    updateIconPriority(elem, currentFilterId, filtersId);

                    //Reset and set the Complete Display Name
                    elem.Display_Name_Complete = "";
                    elem.Display_Name_Complete = getCompleteDisplayName(markerLevel, markerZones, elem.Display_Name);

                    // Add new structure marker in the array
                    markersOnMap.push(elem);

                  } else {
                    //Set Icon Marker
                    updateIconPriority(elem, currentFilterId, filtersId);
                  }
                } else {
                  // Remove marker in the array
                  markersOnMap = removeMarker(elem, markersOnMap);
                }
              } else {
                // ============================
                // Verified if another filter is "checked" to prevent to remove the marker
                // ============================
                // Set Icon Marker
                // Get the "callback" to know if the marker is available in another filters (true, false)
                var isMarkerAvailable = updateIconPriority(elem, currentFilterId, filtersId);

                if (!isMarkerAvailable) {
                  // Remove marker in the array
                  markersOnMap = removeMarker(elem, markersOnMap);
                }
              }
            }
          }

          //Trigger Event to Set the markers results and the check bounds marker on map.
          $filtersContainer.trigger('lazyResults.INTERACTIVEMAP');
        }
      };

      // ============================
      // Initialize CheckBox Event, Categories Label Event and the Show All Button
      // ============================
      var initCheckBox = function () {
        $(".filters .list-item", $filtersContainer).each(function () {

          var $filterList = $(this),
            $catBtn = $(".cat .filter-name", $filterList),
            $target = $(".list-item-check", $filterList),
            $catAllCheckBox = $("input", $target),
            $showAllBtn = $(".show-all-btn", $filterList);

          // Add all category button in one group array
          $allCatBtn.push($catBtn);

          // Add all checkBox in one group array
          $allCheckBox.push($catAllCheckBox);

          // Add all 'show all' button in one group array
          $allShowAllBtn.push($showAllBtn);

          // Add click event in current checkBox and
          $catAllCheckBox.click(function (e) {
            setMarkersOnMap($(this));

            //Set the status (active or not) of the Show All Button
            setShowAllBtn($showAllBtn, $catAllCheckBox);

          }).bind('zoneChanged.INTERACTIVEMAP', function (e) {
            setMarkersOnMap($(this));
          });

          // Set Category filter Button
          setCategory($catBtn, $target);

          // Set the Show All Button Click
          setShowAllFiltersBtn($showAllBtn, $catAllCheckBox);

        });

        //Merge object into new array
        $.each($allCheckBox, function (key, data) {
          $mergeAllCheckBox = $.merge($mergeAllCheckBox, data)
        });
      };

      // ====================================================================================
      // Categories Events
      // ====================================================================================

      // ============================
      // Open automatic category panel if it's close (call by checkbox only)
      // Params:
      //      els = element that was clicked :object
      //      status = it's for open or close the filter panel :string
      // ============================
      var setCategoryPanel = function (els, status) {
        var $that = els;

        if (status = "open") {
          var $target = $that.parents(".list-item").find(".cat .filter-name");
          if ($target.length > 0) {
            if (!$target.hasClass("ui-open")) {
              $target.delay(500).trigger("click");
            }
          }
        }
      };

      // ============================
      // Close automatic category panel if it's open
      // Params:
      //      els = all category button
      // ============================
      var closeCategoriesPanel = function (els) {
        $.each(els, function (key, data) {
          if (data.hasClass("ui-open")) {
            data.delay(500).trigger("click");
          }
        });
      };

      // ============================
      // Category filter Button Click : Open or close the panel
      // Params:
      //      elt = the category filter name (.filter-name) :object
      //      $target = the filter panel to open (.list-item-check) :object
      // ============================
      var setCategory = function (elt, $target) {
        $(elt).click(function (e) {
          e.preventDefault();

          var $this = $(this),
            $icon = $(".icon", $this);
          if ($this.hasClass("ui-open")) {
            $target.slideUp(InteractiveMapFilters.effects.easing);
            $this.removeClass("ui-open");
            $icon.removeClass(InteractiveMapFilters.iconsClassName.down).addClass(InteractiveMapFilters.iconsClassName.left);
          } else {
            $target.slideDown(InteractiveMapFilters.effects.easing);
            $this.addClass("ui-open");
            $icon.removeClass(InteractiveMapFilters.iconsClassName.left).addClass(InteractiveMapFilters.iconsClassName.down);
          }
        });
      };

      // ====================================================================================
      // Show All Button Events
      // ====================================================================================

      // ============================
      // Show All Button Click : Check all the check input
      // ============================
      var setShowAllFiltersBtn = function ($showAllBtn, $checkBox) {

        $showAllBtn.click(function (e) {
          e.preventDefault();
          var $this = $(this);

          if ($this.hasClass("ui-active")) {
            $this.removeClass("ui-active");
            setCheckBox($checkBox, false);
          } else {
            //$this.addClass("ui-active");
            setCheckBox($checkBox, true);
            setCategoryPanel($this, "open");
          }
        });
      };

      // ============================
      // Set the Show All Button Click : set the satus (active or not)
      // params :
      //      btn = show all btn :object
      //      checkbox = all check box :object
      // ============================
      var setShowAllBtn = function (btn, checkbox) {

        var $checkbox = checkbox,//$checkBox
          length = $checkbox.length,//$checkBoxLength
          $btn = btn;//$showAllBtn

        if ($checkbox && length > 0 && $btn) {
          if ($btn.hasClass("ui-active")) {
            $btn.removeClass("ui-active");
          } else {
            var array = [];
            $.each($checkbox, function () {
              if ($(this).attr('checked')) {
                array.push("check");
              }
            });
            //Add Active class when all checkbox are checked
            if (array.length == length) {
              $btn.addClass("ui-active");
            }
          }
        }
      };

      // ============================
      // Check or Uncheck all specific filters (input) - Trigger by 'setShowAllFiltersBtn' method
      // ============================
      var setCheckBox = function (els, status) {
        var $that = els;

        if ($that.length > 0) {

          $.each($that, function () {
            var $this = $(this);

            //trigger click to add marker on map and results
            if (status) {
              if (!$this.attr('checked')) {
                $this.trigger("click");
              }
            } else {
              if ($this.attr('checked')) {
                $this.trigger("click");
              }
            }
          });
        }
      };

      // ====================================================================================
      // Globals Events
      // markersOnMap : Array that contains all the markers that matches the filters on the map
      // ====================================================================================

      // On mobile device, we center the infowindow if it's available on map (trigger by the showMap btn - interactivemap.js)
      $filtersContainer.on('setInfoWindow.INTERACTIVEMAP', function (e, params) {
        var getPosition = infowindow.getPosition(),
          isInfoWindowAvailable = infowindow.getMap();

        //If the infowindow is on map we will center the marker point
        if (isInfoWindowAvailable) {
          centerMap(getPosition);
        }
      });

      // Make sure markers are visible on the map with the new resize (trigger by the showMap and the panelUpadte method - interactivemap.js)
      $filtersContainer.on('checkBounds.INTERACTIVEMAP', checkBounds);

      // Event to remove the filters (clear map and result) with help of the "markersOnMap" data
      $filtersContainer.on('removeFilters.INTERACTIVEMAP', function (e, params) {

        //Clear Map markers
        $.each(markersOnMap, function (key, data) {

          //Remove marker on map
          data.Marker_Map.setMap(null);

          //Remove the current infowindow if it's open
          data.Info_Window.Info_Window_Map.close();
        });

        //Removed the current selected zones - shape on map
        mapObject.setAreas(null);
      });

      // Event to reset the filters only with help of the "markersOnMap" data
      $filtersContainer.on('resetFilters.INTERACTIVEMAP', function (e, params) {

        // Get the current Level and Zones
        var currentZone = getCurrentZones();

        // Set the current selected zones - shape on map
        mapObject.setAreas(currentZone);

        // Redo marker on map
        $.each(markersOnMap, function (key, data) {
          data.Marker_Map.setMap(map);
        });
      });

      // To prevent too much loop, we will fire event of checkBounds and setFiltersResults once
      $filtersContainer.on('lazyResults.INTERACTIVEMAP', _.debounce(function () {

        //Optimization : In Mobile device, we executes the "CheckBounds" function only when we click on the map button. (interactivemap.js)
        if (Utils.getPlatform() != "mobile") {
          //Make sure markers are visible on the map (zoom)
          checkBounds();
        }

        //Add Filters Results
        setFiltersResults(markersOnMap);
      }, 500));

      // ====================================================================================
      // Clear Filters
      // ====================================================================================

      // ============================
      // Uncheck all input check box, update the map and clear the Filter Results value
      // ============================
      var clearFilters = function () {

        //Remove all markers on map
        $filtersContainer.trigger('removeFilters.INTERACTIVEMAP');

        //Empty All Array
        markersOnMap = [];

        //Unchecked all Filters (checkbox)
        $.each($allCheckBox, function (key, value) {
          $(value).attr('checked', false);
        });

        //Remove the Show All Button active class
        $.each($allShowAllBtn, function (key, value) {
          $(value).removeClass("ui-active");
        });

        //Close automatic category panel if it's open
        closeCategoriesPanel($allCatBtn);

        //Clear Filters Results
        clearFiltersResults();

        //Set zones to "all" (show all zones)
        setCurrentZones("all");
      };

      // ============================
      // Clear Filters Button Link
      // ============================
      $clearFiltersBtn.click(function (e) {
        e.preventDefault();
        clearFilters();
      });

      // ====================================================================================
      // Init Filters On First Load (Trigger Events by url)
      // ====================================================================================
      var initFiltersLoad = function () {
        var paramsLevel = filtersParams.level,
          paramsZones = filtersParams.zones,
          paramsFiltersId = filtersParams.filtersId,
          paramsPanel = filtersParams.panel;

        //Active Level
        setCurrentLevel(paramsLevel);

        //Active Zones
        setCurrentZones(paramsZones);

        //Active filters Checkbox
        if (paramsFiltersId.length > 0) {

          paramsFiltersId = paramsFiltersId.split(",");

          //Active filters
          $.each($mergeAllCheckBox, function (key, data) {
            //Current Checkbox
            var $this = $(data);

            if ($.inArray($this.val(), paramsFiltersId) > -1) {
              //Trigger the ckeckbox input to activate theirs markers
              $this.trigger("click");

              //Open the category that contains the Checkbox
              setCategoryPanel($this, "open");
            }
          });
        }

        //Removed the current selected zones - shape on map if it's 'direction' panel target first
        if (paramsPanel == "direction") {
          mapObject.setAreas(null);
        }
      };

      //Init
      initCheckBox();
      initFiltersLoad();

      if (Utils.getPlatform() == "mobile" && options.mobileDirectToMap) {
        $filtersContainer.trigger('showMap.INTERACTIVEMAP');
      }

    },
    //Use for the GeoLocation (trigger in the  InteractiveMap.geoLocalisation)
    setGeoLocMarker: function (map, position, icon) {

      //Icon marker
      var icon = icon;

      //Marker Options
      var markerOptions = {
        lat: position.lat,
        lng: position.lng,
        map: null,
        clickable: false,
        animation: google.maps.Animation.DROP
      };

      //The Marker
      var marker = SMarker.getInstance(icon, map, markerOptions);

      // Get the current marker position
      var center = new google.maps.LatLng(markerOptions.lat, markerOptions.lng);

      return { marker: marker, center: center };
    }
  };

  return InteractiveMapFilters;
});
define('interactivemap/links', [
  'jquery',
  'uiTools/modals'
], function ($, Modals) {

  // This is to simplify implementation of popup links to interactive map in hard backend context (menu) to make it append with only a class
  var interactivemapMenuLinks = {
    init: function (context) {
      // context is the body

      var $body = $(context);
      var $context = $body.find(".interactivemaplink");

      $context.each(function () {
        Modals.init($(this), "interactivemap");
      });
    }
  };

  return interactivemapMenuLinks;
});
/*!
* VERSION: beta 1.10.3
* DATE: 2013-09-02
* UPDATES AND DOCS AT: http://www.greensock.com
* 
* Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
*
* @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
* This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
* Club GreenSock members, the software agreement that was issued with your membership.
* 
* @author: Jack Doyle, jack@greensock.com
**/
(window._gsQueue || (window._gsQueue = [])).push(function () {
  "use strict"; window._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) { var s = [].slice, r = function (t, e, s) { i.call(this, t, e, s), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = r.prototype.render }, n = function (t) { return t.jquery || t.length && t !== window && t[0] && (t[0] === window || t[0].nodeType && t[0].style && !t.nodeType) }, a = r.prototype = i.to({}, .1, {}), o = []; r.version = "1.10.3", a.constructor = r, a.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = i.killTweensOf, r.getTweensOf = i.getTweensOf, r.ticker = i.ticker, a.invalidate = function () { return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this) }, a.updateTo = function (t, e) { var s, r = this.ratio; e && this.timeline && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)); for (s in t) this.vars[s] = t[s]; if (this._initted) if (e) this._initted = !1; else if (this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) { var n = this._time; this.render(0, !0, !1), this._initted = !1, this.render(n, !0, !1) } else if (this._time > 0) { this._initted = !1, this._init(); for (var a, o = 1 / (1 - r), h = this._firstPT; h;)a = h.s + h.c, h.c *= o, h.s = a - h.c, h = h._next } return this }, a.render = function (t, e, i) { var s, r, n, a, h, l, _, u = this._dirty ? this.totalDuration() : this._totalDuration, p = this._time, f = this._totalTime, c = this._cycle; if (t >= u ? (this._totalTime = u, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = this._duration, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (s = !0, r = "onComplete"), 0 === this._duration && ((0 === t || 0 > this._rawPrevTime) && this._rawPrevTime !== t && (i = !0, this._rawPrevTime > 0 && (r = "onReverseComplete", e && (t = -1))), this._rawPrevTime = t)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== f || 0 === this._duration && this._rawPrevTime > 0) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === this._duration && (this._rawPrevTime >= 0 && (i = !0), this._rawPrevTime = t)) : this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (a = this._duration + this._repeatDelay, this._cycle = this._totalTime / a >> 0, 0 !== this._cycle && this._cycle === this._totalTime / a && this._cycle--, this._time = this._totalTime - this._cycle * a, this._yoyo && 0 !== (1 & this._cycle) && (this._time = this._duration - this._time), this._time > this._duration ? this._time = this._duration : 0 > this._time && (this._time = 0)), this._easeType ? (h = this._time / this._duration, l = this._easeType, _ = this._easePower, (1 === l || 3 === l && h >= .5) && (h = 1 - h), 3 === l && (h *= 2), 1 === _ ? h *= h : 2 === _ ? h *= h * h : 3 === _ ? h *= h * h * h : 4 === _ && (h *= h * h * h * h), this.ratio = 1 === l ? 1 - h : 2 === l ? h : .5 > this._time / this._duration ? h / 2 : 1 - h / 2) : this.ratio = this._ease.getRatio(this._time / this._duration)), p === this._time && !i) return f !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || o)), void 0; if (!this._initted) { if (this._init(), !this._initted) return; this._time && !s ? this.ratio = this._ease.getRatio(this._time / this._duration) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (this._active || !this._paused && this._time !== p && t >= 0 && (this._active = !0), 0 === f && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === this._duration) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || o))), n = this._firstPT; n;)n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next; this._onUpdate && (0 > t && this._startAt && this._startAt.render(t, e, i), e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || o)), this._cycle !== c && (e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || o)), r && (this._gc || (0 > t && this._startAt && !this._onUpdate && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || o))) }, r.to = function (t, e, i) { return new r(t, e, i) }, r.from = function (t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new r(t, e, i) }, r.fromTo = function (t, e, i, s) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new r(t, e, s) }, r.staggerTo = r.allTo = function (t, e, a, h, l, _, u) { h = h || 0; var p, f, c, m, d = a.delay || 0, g = [], v = function () { a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), l.apply(u || this, _ || o) }; for (t instanceof Array || ("string" == typeof t && (t = i.selector(t) || t), n(t) && (t = s.call(t, 0))), p = t.length, c = 0; p > c; c++) { f = {}; for (m in a) f[m] = a[m]; f.delay = d, c === p - 1 && l && (f.onComplete = v), g[c] = new r(t[c], e, f), d += h } return g }, r.staggerFrom = r.allFrom = function (t, e, i, s, n, a, o) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, r.staggerTo(t, e, i, s, n, a, o) }, r.staggerFromTo = r.allFromTo = function (t, e, i, s, n, a, o, h) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, r.staggerTo(t, e, s, n, a, o, h) }, r.delayedCall = function (t, e, i, s, n) { return new r(e, 0, { delay: t, onComplete: e, onCompleteParams: i, onCompleteScope: s, onReverseComplete: e, onReverseCompleteParams: i, onReverseCompleteScope: s, immediateRender: !1, useFrames: n, overwrite: 0 }) }, r.set = function (t, e) { return new r(t, 0, e) }, r.isTweening = function (t) { for (var e, s = i.getTweensOf(t), r = s.length; --r > -1;)if (e = s[r], e._active || e._startTime === e._timeline._time && e._timeline._active) return !0; return !1 }; var h = function (t, e) { for (var s = [], r = 0, n = t._first; n;)n instanceof i ? s[r++] = n : (e && (s[r++] = n), s = s.concat(h(n, e)), r = s.length), n = n._next; return s }, l = r.getAllTweens = function (e) { return h(t._rootTimeline, e).concat(h(t._rootFramesTimeline, e)) }; r.killAll = function (t, i, s, r) { null == i && (i = !0), null == s && (s = !0); var n, a, o, h = l(0 != r), _ = h.length, u = i && s && r; for (o = 0; _ > o; o++)a = h[o], (u || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && (t ? a.totalTime(a.totalDuration()) : a._enabled(!1, !1)) }, r.killChildTweensOf = function (t, e) { if (null != t) { var a, o, h, l, _, u = i._tweenLookup; if ("string" == typeof t && (t = i.selector(t) || t), n(t) && (t = s(t, 0)), t instanceof Array) for (l = t.length; --l > -1;)r.killChildTweensOf(t[l], e); else { a = []; for (h in u) for (o = u[h].target.parentNode; o;)o === t && (a = a.concat(u[h].tweens)), o = o.parentNode; for (_ = a.length, l = 0; _ > l; l++)e && a[l].totalTime(a[l].totalDuration()), a[l]._enabled(!1, !1) } } }; var _ = function (t, i, s, r) { i = i !== !1, s = s !== !1, r = r !== !1; for (var n, a, o = l(r), h = i && s && r, _ = o.length; --_ > -1;)a = o[_], (h || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && a.paused(t) }; return r.pauseAll = function (t, e, i) { _(!0, t, e, i) }, r.resumeAll = function (t, e, i) { _(!1, t, e, i) }, r.globalTimeScale = function (e) { var s = t._rootTimeline, r = i.ticker.time; return arguments.length ? (e = e || 1e-6, s._startTime = r - (r - s._startTime) * s._timeScale / e, s = t._rootFramesTimeline, r = i.ticker.frame, s._startTime = r - (r - s._startTime) * s._timeScale / e, s._timeScale = t._rootTimeline._timeScale = e, e) : s._timeScale }, a.progress = function (t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration() }, a.totalProgress = function (t) { return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration() }, a.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, a.duration = function (e) { return arguments.length ? t.prototype.duration.call(this, e) : this._duration }, a.totalDuration = function (t) { return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, a.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, a.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, a.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, r }, !0), window._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) { var s = function (t) { e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate; var i, s, r = this.vars; for (s in r) i = r[s], i instanceof Array && -1 !== i.join("").indexOf("{self}") && (r[s] = this._swapSelfInParams(i)); r.tweens instanceof Array && this.add(r.tweens, 0, r.align, r.stagger) }, r = [], n = function (t) { var e, i = {}; for (e in t) i[e] = t[e]; return i }, a = function (t, e, i, s) { t._timeline.pause(t._startTime), e && e.apply(s || t._timeline, i || r) }, o = r.slice, h = s.prototype = new e; return s.version = "1.10.3", h.constructor = s, h.kill()._gc = !1, h.to = function (t, e, s, r) { return e ? this.add(new i(t, e, s), r) : this.set(t, s, r) }, h.from = function (t, e, s, r) { return this.add(i.from(t, e, s), r) }, h.fromTo = function (t, e, s, r, n) { return e ? this.add(i.fromTo(t, e, s, r), n) : this.set(t, r, n) }, h.staggerTo = function (t, e, r, a, h, l, _, u) { var p, f = new s({ onComplete: l, onCompleteParams: _, onCompleteScope: u }); for ("string" == typeof t && (t = i.selector(t) || t), !(t instanceof Array) && t.length && t !== window && t[0] && (t[0] === window || t[0].nodeType && t[0].style && !t.nodeType) && (t = o.call(t, 0)), a = a || 0, p = 0; t.length > p; p++)r.startAt && (r.startAt = n(r.startAt)), f.to(t[p], e, n(r), p * a); return this.add(f, h) }, h.staggerFrom = function (t, e, i, s, r, n, a, o) { return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, s, r, n, a, o) }, h.staggerFromTo = function (t, e, i, s, r, n, a, o, h) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, s, r, n, a, o, h) }, h.call = function (t, e, s, r) { return this.add(i.delayedCall(0, t, e, s), r) }, h.set = function (t, e, s) { return s = this._parseTimeOrLabel(s, 0, !0), null == e.immediateRender && (e.immediateRender = s === this._time && !this._paused), this.add(new i(t, 0, e), s) }, s.exportRoot = function (t, e) { t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0); var r, n, a = new s(t), o = a._timeline; for (null == e && (e = !0), o._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._first; r;)n = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = n; return o.add(a, 0), a }, h.add = function (r, n, a, o) { var h, l, _, u, p, f; if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, r)), !(r instanceof t)) { if (r instanceof Array) { for (a = a || "normal", o = o || 0, h = n, l = r.length, _ = 0; l > _; _++)(u = r[_]) instanceof Array && (u = new s({ tweens: u })), this.add(u, h), "string" != typeof u && "function" != typeof u && ("sequence" === a ? h = u._startTime + u.totalDuration() / u._timeScale : "start" === a && (u._startTime -= u.delay())), h += o; return this._uncache(!0) } if ("string" == typeof r) return this.addLabel(r, n); if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string."; r = i.delayedCall(0, r) } if (e.prototype.add.call(this, r, n), this._gc && !this._paused && this._duration < this.duration()) for (p = this, f = p.rawTime() > r._startTime; p._gc && p._timeline;)p._timeline.smoothChildTiming && f ? p.totalTime(p._totalTime, !0) : p._enabled(!0, !1), p = p._timeline; return this }, h.remove = function (e) { if (e instanceof t) return this._remove(e, !1); if (e instanceof Array) { for (var i = e.length; --i > -1;)this.remove(e[i]); return this } return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e) }, h._remove = function (t, i) { return e.prototype._remove.call(this, t, i), this._last ? this._time > this._last._startTime && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = 0, this }, h.append = function (t, e) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t)) }, h.insert = h.insertMultiple = function (t, e, i, s) { return this.add(t, e || 0, i, s) }, h.appendMultiple = function (t, e, i, s) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, s) }, h.addLabel = function (t, e) { return this._labels[t] = this._parseTimeOrLabel(e), this }, h.addPause = function (t, e, i, s) { return this.call(a, ["{self}", e, i, s], this, t) }, h.removeLabel = function (t) { return delete this._labels[t], this }, h.getLabelTime = function (t) { return null != this._labels[t] ? this._labels[t] : -1 }, h._parseTimeOrLabel = function (e, i, s, r) { var n; if (r instanceof t && r.timeline === this) this.remove(r); else if (r instanceof Array) for (n = r.length; --n > -1;)r[n] instanceof t && r[n].timeline === this && this.remove(r[n]); if ("string" == typeof i) return this._parseTimeOrLabel(i, s && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, s); if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration()); else { if (n = e.indexOf("="), -1 === n) return null == this._labels[e] ? s ? this._labels[e] = this.duration() + i : i : this._labels[e] + i; i = parseInt(e.charAt(n - 1) + "1", 10) * Number(e.substr(n + 1)), e = n > 1 ? this._parseTimeOrLabel(e.substr(0, n - 1), 0, s) : this.duration() } return Number(e) + i }, h.seek = function (t, e) { return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1) }, h.stop = function () { return this.paused(!0) }, h.gotoAndPlay = function (t, e) { return this.play(t, e) }, h.gotoAndStop = function (t, e) { return this.pause(t, e) }, h.render = function (t, e, i) { this._gc && this._enabled(!0, !1); var s, n, a, o, h, l = this._dirty ? this.totalDuration() : this._totalDuration, _ = this._time, u = this._startTime, p = this._timeScale, f = this._paused; if (t >= l ? (this._totalTime = this._time = l, this._reversed || this._hasPausedChild() || (n = !0, o = "onComplete", 0 === this._duration && (0 === t || 0 > this._rawPrevTime) && this._rawPrevTime !== t && this._first && (h = !0, this._rawPrevTime > 0 && (o = "onReverseComplete"))), this._rawPrevTime = t, t = l + 1e-6) : 1e-7 > t ? (this._totalTime = this._time = 0, (0 !== _ || 0 === this._duration && this._rawPrevTime > 0) && (o = "onReverseComplete", n = this._reversed), 0 > t ? (this._active = !1, 0 === this._duration && this._rawPrevTime >= 0 && this._first && (h = !0), this._rawPrevTime = t) : (this._rawPrevTime = t, t = 0, this._initted || (h = !0))) : this._totalTime = this._time = this._rawPrevTime = t, this._time !== _ && this._first || i || h) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== _ && t > 0 && (this._active = !0), 0 === _ && this.vars.onStart && 0 !== this._time && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || r)), this._time >= _) for (s = this._first; s && (a = s._next, !this._paused || f);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a; else for (s = this._last; s && (a = s._prev, !this._paused || f);)(s._active || _ >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a; this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || r)), o && (this._gc || (u === this._startTime || p !== this._timeScale) && (0 === this._time || l >= this.totalDuration()) && (n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this.vars[o].apply(this.vars[o + "Scope"] || this, this.vars[o + "Params"] || r))) } }, h._hasPausedChild = function () { for (var t = this._first; t;) { if (t._paused || t instanceof s && t._hasPausedChild()) return !0; t = t._next } return !1 }, h.getChildren = function (t, e, s, r) { r = r || -9999999999; for (var n = [], a = this._first, o = 0; a;)r > a._startTime || (a instanceof i ? e !== !1 && (n[o++] = a) : (s !== !1 && (n[o++] = a), t !== !1 && (n = n.concat(a.getChildren(!0, e, s)), o = n.length))), a = a._next; return n }, h.getTweensOf = function (t, e) { for (var s = i.getTweensOf(t), r = s.length, n = [], a = 0; --r > -1;)(s[r].timeline === this || e && this._contains(s[r])) && (n[a++] = s[r]); return n }, h._contains = function (t) { for (var e = t.timeline; e;) { if (e === this) return !0; e = e.timeline } return !1 }, h.shiftChildren = function (t, e, i) { i = i || 0; for (var s, r = this._first, n = this._labels; r;)r._startTime >= i && (r._startTime += t), r = r._next; if (e) for (s in n) n[s] >= i && (n[s] += t); return this._uncache(!0) }, h._kill = function (t, e) { if (!t && !e) return this._enabled(!1, !1); for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), s = i.length, r = !1; --s > -1;)i[s]._kill(t, e) && (r = !0); return r }, h.clear = function (t) { var e = this.getChildren(!1, !0, !0), i = e.length; for (this._time = this._totalTime = 0; --i > -1;)e[i]._enabled(!1, !1); return t !== !1 && (this._labels = {}), this._uncache(!0) }, h.invalidate = function () { for (var t = this._first; t;)t.invalidate(), t = t._next; return this }, h._enabled = function (t, i) { if (t === this._gc) for (var s = this._first; s;)s._enabled(t, !0), s = s._next; return e.prototype._enabled.call(this, t, i) }, h.progress = function (t) { return arguments.length ? this.totalTime(this.duration() * t, !1) : this._time / this.duration() }, h.duration = function (t) { return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration) }, h.totalDuration = function (t) { if (!arguments.length) { if (this._dirty) { for (var e, i, s = 0, r = this._last, n = 999999999999; r;)e = r._prev, r._dirty && r.totalDuration(), r._startTime > n && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : n = r._startTime, 0 > r._startTime && !r._paused && (s -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i > s && (s = i), r = e; this._duration = this._totalDuration = s, this._dirty = !1 } return this._totalDuration } return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this }, h.usesFrames = function () { for (var e = this._timeline; e._timeline;)e = e._timeline; return e === t._rootFramesTimeline }, h.rawTime = function () { return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale }, s }, !0), window._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (t, e, i) { var s = function (e) { t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0 }, r = [], n = new i(null, null, 1, 0), a = function (t) { for (; t;) { if (t._paused) return !0; t = t._timeline } return !1 }, o = s.prototype = new t; return o.constructor = s, o.kill()._gc = !1, s.version = "1.10.3", o.invalidate = function () { return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this) }, o.addCallback = function (t, i, s, r) { return this.add(e.delayedCall(0, t, s, r), i) }, o.removeCallback = function (t, e) { if (t) if (null == e) this._kill(null, t); else for (var i = this.getTweensOf(t, !1), s = i.length, r = this._parseTimeOrLabel(e); --s > -1;)i[s]._startTime === r && i[s]._enabled(!1, !1); return this }, o.tweenTo = function (t, i) { i = i || {}; var s, a, o = { ease: n, overwrite: 2, useFrames: this.usesFrames(), immediateRender: !1 }; for (s in i) o[s] = i[s]; return o.time = this._parseTimeOrLabel(t), a = new e(this, Math.abs(Number(o.time) - this._time) / this._timeScale || .001, o), o.onStart = function () { a.target.paused(!0), a.vars.time !== a.target.time() && a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale), i.onStart && i.onStart.apply(i.onStartScope || a, i.onStartParams || r) }, a }, o.tweenFromTo = function (t, e, i) { i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = { onComplete: this.seek, onCompleteParams: [t], onCompleteScope: this }, i.immediateRender = i.immediateRender !== !1; var s = this.tweenTo(e, i); return s.duration(Math.abs(s.vars.time - t) / this._timeScale || .001) }, o.render = function (t, e, i) { this._gc && this._enabled(!0, !1); var s, n, a, o, h, l, _ = this._dirty ? this.totalDuration() : this._totalDuration, u = this._duration, p = this._time, f = this._totalTime, c = this._startTime, m = this._timeScale, d = this._rawPrevTime, g = this._paused, v = this._cycle; if (t >= _ ? (this._locked || (this._totalTime = _, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (n = !0, o = "onComplete", 0 === u && (0 === t || 0 > this._rawPrevTime) && this._rawPrevTime !== t && this._first && (h = !0, this._rawPrevTime > 0 && (o = "onReverseComplete"))), this._rawPrevTime = t, this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = u, t = u + 1e-6)) : 1e-7 > t ? (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === u && this._rawPrevTime > 0 && !this._locked) && (o = "onReverseComplete", n = this._reversed), 0 > t ? (this._active = !1, 0 === u && this._rawPrevTime >= 0 && this._first && (h = !0), this._rawPrevTime = t) : (this._rawPrevTime = t, t = 0, this._initted || (h = !0))) : (this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (l = u + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 !== (1 & this._cycle) && (this._time = u - this._time), this._time > u ? (this._time = u, t = u + 1e-6) : 0 > this._time ? this._time = t = 0 : t = this._time))), this._cycle !== v && !this._locked) { var y = this._yoyo && 0 !== (1 & v), T = y === (this._yoyo && 0 !== (1 & this._cycle)), w = this._totalTime, x = this._cycle, b = this._rawPrevTime, P = this._time; if (this._totalTime = v * u, v > this._cycle ? y = !y : this._totalTime += u, this._time = p, this._rawPrevTime = 0 === u ? d - 1e-5 : d, this._cycle = v, this._locked = !0, p = y ? 0 : u, this.render(p, e, 0 === u), e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || r), T && (p = y ? u + 1e-6 : -1e-6, this.render(p, !0, !1)), this._locked = !1, this._paused && !g) return; this._time = P, this._totalTime = w, this._cycle = x, this._rawPrevTime = b } if (!(this._time !== p && this._first || i || h)) return f !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || r)), void 0; if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== f && t > 0 && (this._active = !0), 0 === f && this.vars.onStart && 0 !== this._totalTime && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || r)), this._time >= p) for (s = this._first; s && (a = s._next, !this._paused || g);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a; else for (s = this._last; s && (a = s._prev, !this._paused || g);)(s._active || p >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a; this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || r)), o && (this._locked || this._gc || (c === this._startTime || m !== this._timeScale) && (0 === this._time || _ >= this.totalDuration()) && (n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this.vars[o].apply(this.vars[o + "Scope"] || this, this.vars[o + "Params"] || r))) }, o.getActive = function (t, e, i) { null == t && (t = !0), null == e && (e = !0), null == i && (i = !1); var s, r, n = [], o = this.getChildren(t, e, i), h = 0, l = o.length; for (s = 0; l > s; s++)r = o[s], r._paused || r._timeline._time >= r._startTime && r._timeline._time < r._startTime + r._totalDuration / r._timeScale && (a(r._timeline) || (n[h++] = r)); return n }, o.getLabelAfter = function (t) { t || 0 !== t && (t = this._time); var e, i = this.getLabelsArray(), s = i.length; for (e = 0; s > e; e++)if (i[e].time > t) return i[e].name; return null }, o.getLabelBefore = function (t) { null == t && (t = this._time); for (var e = this.getLabelsArray(), i = e.length; --i > -1;)if (t > e[i].time) return e[i].name; return null }, o.getLabelsArray = function () { var t, e = [], i = 0; for (t in this._labels) e[i++] = { time: this._labels[t], name: t }; return e.sort(function (t, e) { return t.time - e.time }), e }, o.progress = function (t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration() }, o.totalProgress = function (t) { return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration() }, o.totalDuration = function (e) { return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, o.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, o.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, o.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, o.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, o.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8) }, s }, !0), function () {
    var t = 180 / Math.PI, e = Math.PI / 180, i = [], s = [], r = [], n = {}, a = function (t, e, i, s) { this.a = t, this.b = e, this.c = i, this.d = s, this.da = s - t, this.ca = i - t, this.ba = e - t }, o = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", h = function (t, e, i, s) { var r = { a: t }, n = {}, a = {}, o = { c: s }, h = (t + e) / 2, l = (e + i) / 2, _ = (i + s) / 2, u = (h + l) / 2, p = (l + _) / 2, f = (p - u) / 8; return r.b = h + (t - h) / 4, n.b = u + f, r.c = n.a = (r.b + n.b) / 2, n.c = a.a = (u + p) / 2, a.b = p - f, o.b = _ + (s - _) / 4, a.c = o.a = (a.b + o.b) / 2, [r, n, a, o] }, l = function (t, e, n, a, o) { var l, _, u, p, f, c, m, d, g, v, y, T, w, x = t.length - 1, b = 0, P = t[0].a; for (l = 0; x > l; l++)f = t[b], _ = f.a, u = f.d, p = t[b + 1].d, o ? (y = i[l], T = s[l], w = .25 * (T + y) * e / (a ? .5 : r[l] || .5), c = u - (u - _) * (a ? .5 * e : 0 !== y ? w / y : 0), m = u + (p - u) * (a ? .5 * e : 0 !== T ? w / T : 0), d = u - (c + ((m - c) * (3 * y / (y + T) + .5) / 4 || 0))) : (c = u - .5 * (u - _) * e, m = u + .5 * (p - u) * e, d = u - (c + m) / 2), c += d, m += d, f.c = g = c, f.b = 0 !== l ? P : P = f.a + .6 * (f.c - f.a), f.da = u - _, f.ca = g - _, f.ba = P - _, n ? (v = h(_, P, g, u), t.splice(b, 1, v[0], v[1], v[2], v[3]), b += 4) : b++, P = m; f = t[b], f.b = P, f.c = P + .4 * (f.d - P), f.da = f.d - f.a, f.ca = f.c - f.a, f.ba = P - f.a, n && (v = h(f.a, P, f.c, f.d), t.splice(b, 1, v[0], v[1], v[2], v[3])) }, _ = function (t, e, r, n) { var o, h, l, _, u, p, f = []; if (n) for (t = [n].concat(t), h = t.length; --h > -1;)"string" == typeof (p = t[h][e]) && "=" === p.charAt(1) && (t[h][e] = n[e] + Number(p.charAt(0) + p.substr(2))); if (o = t.length - 2, 0 > o) return f[0] = new a(t[0][e], 0, 0, t[-1 > o ? 0 : 1][e]), f; for (h = 0; o > h; h++)l = t[h][e], _ = t[h + 1][e], f[h] = new a(l, 0, 0, _), r && (u = t[h + 2][e], i[h] = (i[h] || 0) + (_ - l) * (_ - l), s[h] = (s[h] || 0) + (u - _) * (u - _)); return f[h] = new a(t[h][e], 0, 0, t[h + 1][e]), f }, u = function (t, e, a, h, u, p) { var f, c, m, d, g, v, y, T, w = {}, x = [], b = p || t[0]; u = "string" == typeof u ? "," + u + "," : o, null == e && (e = 1); for (c in t[0]) x.push(c); if (t.length > 1) { for (T = t[t.length - 1], y = !0, f = x.length; --f > -1;)if (c = x[f], Math.abs(b[c] - T[c]) > .05) { y = !1; break } y && (t = t.concat(), p && t.unshift(p), t.push(t[1]), p = t[t.length - 3]) } for (i.length = s.length = r.length = 0, f = x.length; --f > -1;)c = x[f], n[c] = -1 !== u.indexOf("," + c + ","), w[c] = _(t, c, n[c], p); for (f = i.length; --f > -1;)i[f] = Math.sqrt(i[f]), s[f] = Math.sqrt(s[f]); if (!h) { for (f = x.length; --f > -1;)if (n[c]) for (m = w[x[f]], v = m.length - 1, d = 0; v > d; d++)g = m[d + 1].da / s[d] + m[d].da / i[d], r[d] = (r[d] || 0) + g * g; for (f = r.length; --f > -1;)r[f] = Math.sqrt(r[f]) } for (f = x.length, d = a ? 4 : 1; --f > -1;)c = x[f], m = w[c], l(m, e, a, h, n[c]), y && (m.splice(0, d), m.splice(m.length - d, d)); return w }, p = function (t, e, i) { e = e || "soft"; var s, r, n, o, h, l, _, u, p, f, c, m = {}, d = "cubic" === e ? 3 : 2, g = "soft" === e, v = []; if (g && i && (t = [i].concat(t)), null == t || d + 1 > t.length) throw "invalid Bezier data"; for (p in t[0]) v.push(p); for (l = v.length; --l > -1;) { for (p = v[l], m[p] = h = [], f = 0, u = t.length, _ = 0; u > _; _++)s = null == i ? t[_][p] : "string" == typeof (c = t[_][p]) && "=" === c.charAt(1) ? i[p] + Number(c.charAt(0) + c.substr(2)) : Number(c), g && _ > 1 && u - 1 > _ && (h[f++] = (s + h[f - 2]) / 2), h[f++] = s; for (u = f - d + 1, f = 0, _ = 0; u > _; _ += d)s = h[_], r = h[_ + 1], n = h[_ + 2], o = 2 === d ? 0 : h[_ + 3], h[f++] = c = 3 === d ? new a(s, r, n, o) : new a(s, (2 * r + s) / 3, (2 * r + n) / 3, n); h.length = f } return m }, f = function (t, e, i) { for (var s, r, n, a, o, h, l, _, u, p, f, c = 1 / i, m = t.length; --m > -1;)for (p = t[m], n = p.a, a = p.d - n, o = p.c - n, h = p.b - n, s = r = 0, _ = 1; i >= _; _++)l = c * _, u = 1 - l, s = r - (r = (l * l * a + 3 * u * (l * o + u * h)) * l), f = m * i + _ - 1, e[f] = (e[f] || 0) + s * s }, c = function (t, e) { e = e >> 0 || 6; var i, s, r, n, a = [], o = [], h = 0, l = 0, _ = e - 1, u = [], p = []; for (i in t) f(t[i], a, e); for (r = a.length, s = 0; r > s; s++)h += Math.sqrt(a[s]), n = s % e, p[n] = h, n === _ && (l += h, n = s / e >> 0, u[n] = p, o[n] = l, h = 0, p = []); return { length: l, lengths: o, segments: u } }, m = window._gsDefine.plugin({ propName: "bezier", priority: -1, API: 2, global: !0, init: function (t, e, i) { this._target = t, e instanceof Array && (e = { values: e }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10); var s, r, n, a, o, h = e.values || [], l = {}, _ = h[0], f = e.autoRotate || i.vars.orientToBezier; this._autoRotate = f ? f instanceof Array ? f : [["x", "y", "rotation", f === !0 ? 0 : Number(f) || 0]] : null; for (s in _) this._props.push(s); for (n = this._props.length; --n > -1;)s = this._props[n], this._overwriteProps.push(s), r = this._func[s] = "function" == typeof t[s], l[s] = r ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), o || l[s] !== h[0][s] && (o = l); if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : p(h, e.type, l), this._segCount = this._beziers[s].length, this._timeRes) { var m = c(this._beziers, this._timeRes); this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (f = this._autoRotate) for (f[0] instanceof Array || (this._autoRotate = f = [f]), n = f.length; --n > -1;)for (a = 0; 3 > a; a++)s = f[n][a], this._func[s] = "function" == typeof t[s] ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)] : !1; return !0 }, set: function (e) { var i, s, r, n, a, o, h, l, _, u, p = this._segCount, f = this._func, c = this._target; if (this._timeRes) { if (_ = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && p - 1 > r) { for (l = p - 1; l > r && e >= (this._l2 = _[++r]);); this._l1 = _[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0] } else if (this._l1 > e && r > 0) { for (; r > 0 && (this._l1 = _[--r]) >= e;); 0 === r && this._l1 > e ? this._l1 = 0 : r++, this._l2 = _[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si] } if (i = r, e -= this._l1, r = this._si, e > this._s2 && u.length - 1 > r) { for (l = u.length - 1; l > r && e >= (this._s2 = u[++r]);); this._s1 = u[r - 1], this._si = r } else if (this._s1 > e && r > 0) { for (; r > 0 && (this._s1 = u[--r]) >= e;); 0 === r && this._s1 > e ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r } o = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec } else i = 0 > e ? 0 : e >= 1 ? p - 1 : p * e >> 0, o = (e - i * (1 / p)) * p; for (s = 1 - o, r = this._props.length; --r > -1;)n = this._props[r], a = this._beziers[n][i], h = (o * o * a.da + 3 * s * (o * a.ca + s * a.ba)) * o + a.a, this._round[n] && (h = h + (h > 0 ? .5 : -.5) >> 0), f[n] ? c[n](h) : c[n] = h; if (this._autoRotate) { var m, d, g, v, y, T, w, x = this._autoRotate; for (r = x.length; --r > -1;)n = x[r][2], T = x[r][3] || 0, w = x[r][4] === !0 ? 1 : t, a = this._beziers[x[r][0]], m = this._beziers[x[r][1]], a && m && (a = a[i], m = m[i], d = a.a + (a.b - a.a) * o, v = a.b + (a.c - a.b) * o, d += (v - d) * o, v += (a.c + (a.d - a.c) * o - v) * o, g = m.a + (m.b - m.a) * o, y = m.b + (m.c - m.b) * o, g += (y - g) * o, y += (m.c + (m.d - m.c) * o - y) * o, h = Math.atan2(y - g, v - d) * w + T, f[n] ? c[n](h) : c[n] = h) } } }), d = m.prototype; m.bezierThrough = u, m.cubicToQuadratic = h, m._autoCSS = !0, m.quadraticToCubic = function (t, e, i) { return new a(t, (2 * e + t) / 3, (2 * e + i) / 3, i) }, m._cssRegister = function () {
      var t = window._gsDefine.globals.CSSPlugin; if (t) {
        var i = t._internals, s = i._parseToProxy, r = i._setPluginRatio, n = i.CSSPropTween; i._registerComplexSpecialProp("bezier", {
          parser: function (t, i, a, o, h, l) {
            i instanceof Array && (i = { values: i }), l = new m; var _, u, p, f = i.values, c = f.length - 1, d = [], g = {}; if (0 > c) return h; for (_ = 0; c >= _; _++)p = s(t, f[_], o, h, l, c !== _), d[_] = p.end; for (u in i) g[u] = i[u]; return g.values = d, h = new n(t, "bezier", 0, 0, p.pt, 2), h.data = p, h.plugin = l, h.setRatio = r, 0 === g.autoRotate && (g.autoRotate = !0), !g.autoRotate || g.autoRotate instanceof Array || (_ = g.autoRotate === !0 ? 0 : Number(g.autoRotate) * e, g.autoRotate = null != p.end.left ? [["left", "top", "rotation", _, !0]] : null != p.end.x ? [["x", "y", "rotation", _, !0]] : !1), g.autoRotate && (o._transform || o._enableTransforms(!1), p.autoRotate = o._target._gsTransform), l._onInitTween(p.proxy, g, o._tween), h
          }
        })
      }
    }, d._roundProps = function (t, e) { for (var i = this._overwriteProps, s = i.length; --s > -1;)(t[i[s]] || t.bezier || t.bezierThrough) && (this._round[i[s]] = e) }, d._kill = function (t) { var e, i, s = this._props; for (e in this._beziers) if (e in t) for (delete this._beziers[e], delete this._func[e], i = s.length; --i > -1;)s[i] === e && s.splice(i, 1); return this._super._kill.call(this, t) }
  }(), window._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) { var i, s, r, n, a = function () { t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio }, o = {}, h = a.prototype = new t("css"); h.constructor = a, a.version = "1.10.3", a.API = 2, a.defaultTransformPerspective = 0, h = "px", a.suffixMap = { top: h, right: h, bottom: h, left: h, width: h, height: h, fontSize: h, padding: h, margin: h, perspective: h }; var l, _, u, p, f, c, m = /(?:\d|\-\d|\.\d|\-\.\d)+/g, d = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, v = /[^\d\-\.]/g, y = /(?:\d|\-|\+|=|#|\.)*/g, T = /opacity *= *([^)]*)/, w = /opacity:([^;]*)/, x = /alpha\(opacity *=.+?\)/i, b = /^(rgb|hsl)/, P = /([A-Z])/g, k = /-([a-z])/gi, S = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, R = function (t, e) { return e.toUpperCase() }, A = /(?:Left|Right|Width)/i, C = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, D = /,(?=[^\)]*(?:\(|$))/gi, M = Math.PI / 180, I = 180 / Math.PI, F = {}, E = document, N = E.createElement("div"), L = E.createElement("img"), X = a._internals = { _specialProps: o }, z = navigator.userAgent, U = function () { var t, e = z.indexOf("Android"), i = E.createElement("div"); return u = -1 !== z.indexOf("Safari") && -1 === z.indexOf("Chrome") && (-1 === e || Number(z.substr(e + 8, 1)) > 3), f = u && 6 > Number(z.substr(z.indexOf("Version/") + 8, 1)), p = -1 !== z.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(z), c = parseFloat(RegExp.$1), i.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", t = i.getElementsByTagName("a")[0], t ? /^0.55/.test(t.style.opacity) : !1 }(), Y = function (t) { return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 }, j = function (t) { window.console && console.log(t) }, B = "", q = "", V = function (t, e) { e = e || N; var i, s, r = e.style; if (void 0 !== r[t]) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], s = 5; --s > -1 && void 0 === r[i[s] + t];); return s >= 0 ? (q = 3 === s ? "ms" : i[s], B = "-" + q.toLowerCase() + "-", q + t) : null }, Z = E.defaultView ? E.defaultView.getComputedStyle : function () { }, G = a.getStyle = function (t, e, i, s, r) { var n; return U || "opacity" !== e ? (!s && t.style[e] ? n = t.style[e] : (i = i || Z(t, null)) ? (t = i.getPropertyValue(e.replace(P, "-$1").toLowerCase()), n = t || i.length ? t : i[e]) : t.currentStyle && (n = t.currentStyle[e]), null == r || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : r) : Y(t) }, $ = function (t, e, i, s, r) { if ("px" === s || !s) return i; if ("auto" === s || !i) return 0; var n, a = A.test(e), o = t, h = N.style, l = 0 > i; return l && (i = -i), "%" === s && -1 !== e.indexOf("border") ? n = i / 100 * (a ? t.clientWidth : t.clientHeight) : (h.cssText = "border-style:solid;border-width:0;position:absolute;line-height:0;", "%" !== s && o.appendChild ? h[a ? "borderLeftWidth" : "borderTopWidth"] = i + s : (o = t.parentNode || E.body, h[a ? "width" : "height"] = i + s), o.appendChild(N), n = parseFloat(N[a ? "offsetWidth" : "offsetHeight"]), o.removeChild(N), 0 !== n || r || (n = $(t, e, i, s, !0))), l ? -n : n }, Q = function (t, e, i) { if ("absolute" !== G(t, "position", i)) return 0; var s = "left" === e ? "Left" : "Top", r = G(t, "margin" + s, i); return t["offset" + s] - ($(t, e, parseFloat(r), r.replace(y, "")) || 0) }, W = function (t, e) { var i, s, r = {}; if (e = e || Z(t, null)) if (i = e.length) for (; --i > -1;)r[e[i].replace(k, R)] = e.getPropertyValue(e[i]); else for (i in e) r[i] = e[i]; else if (e = t.currentStyle || t.style) for (i in e) r[i.replace(k, R)] = e[i]; return U || (r.opacity = Y(t)), s = be(t, e, !1), r.rotation = s.rotation * I, r.skewX = s.skewX * I, r.scaleX = s.scaleX, r.scaleY = s.scaleY, r.x = s.x, r.y = s.y, xe && (r.z = s.z, r.rotationX = s.rotationX * I, r.rotationY = s.rotationY * I, r.scaleZ = s.scaleZ), r.filters && delete r.filters, r }, H = function (t, e, i, s, r) { var n, a, o, h = {}, l = t.style; for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (h[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(v, "") ? n : 0 : Q(t, a), void 0 !== l[a] && (o = new ue(l, a, l[a], o))); if (s) for (a in s) "className" !== a && (h[a] = s[a]); return { difs: h, firstMPT: o } }, K = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, J = ["marginLeft", "marginRight", "marginTop", "marginBottom"], te = function (t, e, i) { var s = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight), r = K[e], n = r.length; for (i = i || Z(t, null); --n > -1;)s -= parseFloat(G(t, "padding" + r[n], i, !0)) || 0, s -= parseFloat(G(t, "border" + r[n] + "Width", i, !0)) || 0; return s }, ee = function (t, e) { (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0"); var i = t.split(" "), s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0], r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1]; return null == r ? r = "0" : "center" === r && (r = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(s.replace(v, "")), e.oy = parseFloat(r.replace(v, ""))), s + " " + r + (i.length > 2 ? " " + i[2] : "") }, ie = function (t, e) { return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) }, se = function (t, e) { return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * Number(t.substr(2)) + e : parseFloat(t) }, re = function (t, e, i, s) { var r, n, a, o, h = 1e-6; return null == t ? o = e : "number" == typeof t ? o = t * M : (r = 2 * Math.PI, n = t.split("_"), a = Number(n[0].replace(v, "")) * (-1 === t.indexOf("rad") ? M : 1) - ("=" === t.charAt(1) ? 0 : e), n.length && (s && (s[i] = e + a), -1 !== t.indexOf("short") && (a %= r, a !== a % (r / 2) && (a = 0 > a ? a + r : a - r)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * r) % r - (0 | a / r) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (0 | a / r) * r)), o = e + a), h > o && o > -h && (o = 0), o }, ne = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, ae = function (t, e, i) { return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5 }, oe = function (t) { var e, i, s, r, n, a; return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ne[t] ? ne[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), s = t.charAt(3), t = "#" + e + e + i + i + s + s), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(m), r = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = ae(r + 1 / 3, e, i), t[1] = ae(r, e, i), t[2] = ae(r - 1 / 3, e, i), t) : (t = t.match(m) || ne.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : ne.black }, he = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; for (h in ne) he += "|" + h + "\\b"; he = RegExp(he + ")", "gi"); var le = function (t, e, i, s) { if (null == t) return function (t) { return t }; var r, n = e ? (t.match(he) || [""])[0] : "", a = t.split(n).join("").match(g) || [], o = t.substr(0, t.indexOf(a[0])), h = ")" === t.charAt(t.length - 1) ? ")" : "", l = -1 !== t.indexOf(" ") ? " " : ",", _ = a.length, u = _ > 0 ? a[0].replace(m, "") : ""; return _ ? r = e ? function (t) { var e, p, f, c; if ("number" == typeof t) t += u; else if (s && D.test(t)) { for (c = t.replace(D, "|").split("|"), f = 0; c.length > f; f++)c[f] = r(c[f]); return c.join(",") } if (e = (t.match(he) || [n])[0], p = t.split(e).join("").match(g) || [], f = p.length, _ > f--) for (; _ > ++f;)p[f] = i ? p[0 | (f - 1) / 2] : a[f]; return o + p.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "") } : function (t) { var e, n, p; if ("number" == typeof t) t += u; else if (s && D.test(t)) { for (n = t.replace(D, "|").split("|"), p = 0; n.length > p; p++)n[p] = r(n[p]); return n.join(",") } if (e = t.match(g) || [], p = e.length, _ > p--) for (; _ > ++p;)e[p] = i ? e[0 | (p - 1) / 2] : a[p]; return o + e.join(l) + h } : function (t) { return t } }, _e = function (t) { return t = t.split(","), function (e, i, s, r, n, a, o) { var h, l = (i + "").split(" "); for (o = {}, h = 0; 4 > h; h++)o[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0]; return r.parse(e, o, n, a) } }, ue = (X._setPluginRatio = function (t) { this.plugin.setRatio(t); for (var e, i, s, r, n = this.data, a = n.proxy, o = n.firstMPT, h = 1e-6; o;)e = a[o.v], o.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : h > e && e > -h && (e = 0), o.t[o.p] = e, o = o._next; if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t) for (o = n.firstMPT; o;) { if (i = o.t, i.type) { if (1 === i.type) { for (r = i.xs0 + i.s + i.xs1, s = 1; i.l > s; s++)r += i["xn" + s] + i["xs" + (s + 1)]; i.e = r } } else i.e = i.s + i.xs0; o = o._next } }, function (t, e, i, s, r) { this.t = t, this.p = e, this.v = i, this.r = r, s && (s._prev = this, this._next = s) }), pe = (X._parseToProxy = function (t, e, i, s, r, n) { var a, o, h, l, _, u = s, p = {}, f = {}, c = i._transform, m = F; for (i._transform = null, F = e, s = _ = i.parse(t, e, s, r), F = m, n && (i._transform = c, u && (u._prev = null, u._prev && (u._prev._next = null))); s && s !== u;) { if (1 >= s.type && (o = s.p, f[o] = s.s + s.c, p[o] = s.s, n || (l = new ue(s, "s", o, l, s.r), s.c = 0), 1 === s.type)) for (a = s.l; --a > 0;)h = "xn" + a, o = s.p + "_" + h, f[o] = s.data[h], p[o] = s[h], n || (l = new ue(s, h, o, l, s.rxp[h])); s = s._next } return { proxy: p, end: f, firstMPT: l, pt: _ } }, X.CSSPropTween = function (t, e, s, r, a, o, h, l, _, u, p) { this.t = t, this.p = e, this.s = s, this.c = r, this.n = h || e, t instanceof pe || n.push(this.n), this.r = l, this.type = o || 0, _ && (this.pr = _, i = !0), this.b = void 0 === u ? s : u, this.e = void 0 === p ? s + r : p, a && (this._next = a, a._prev = this) }), fe = a.parseComplex = function (t, e, i, s, r, n, a, o, h, _) { i = i || n || "", a = new pe(t, e, 0, 0, a, _ ? 2 : 1, null, !1, o, i, s), s += ""; var u, p, f, c, g, v, y, T, w, x, P, k, S = i.split(", ").join(",").split(" "), R = s.split(", ").join(",").split(" "), A = S.length, C = l !== !1; for ((-1 !== s.indexOf(",") || -1 !== i.indexOf(",")) && (S = S.join(" ").replace(D, ", ").split(" "), R = R.join(" ").replace(D, ", ").split(" "), A = S.length), A !== R.length && (S = (n || "").split(" "), A = S.length), a.plugin = h, a.setRatio = _, u = 0; A > u; u++)if (c = S[u], g = R[u], T = parseFloat(c), T || 0 === T) a.appendXtra("", T, ie(g, T), g.replace(d, ""), C && -1 !== g.indexOf("px"), !0); else if (r && ("#" === c.charAt(0) || ne[c] || b.test(c))) k = "," === g.charAt(g.length - 1) ? ")," : ")", c = oe(c), g = oe(g), w = c.length + g.length > 6, w && !U && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[u]).join("transparent")) : (U || (w = !1), a.appendXtra(w ? "rgba(" : "rgb(", c[0], g[0] - c[0], ",", !0, !0).appendXtra("", c[1], g[1] - c[1], ",", !0).appendXtra("", c[2], g[2] - c[2], w ? "," : k, !0), w && (c = 4 > c.length ? 1 : c[3], a.appendXtra("", c, (4 > g.length ? 1 : g[3]) - c, k, !1))); else if (v = c.match(m)) { if (y = g.match(d), !y || y.length !== v.length) return a; for (f = 0, p = 0; v.length > p; p++)P = v[p], x = c.indexOf(P, f), a.appendXtra(c.substr(f, x - f), Number(P), ie(y[p], P), "", C && "px" === c.substr(x + P.length, 2), 0 === p), f = x + P.length; a["xs" + a.l] += c.substr(f) } else a["xs" + a.l] += a.l ? " " + c : c; if (-1 !== s.indexOf("=") && a.data) { for (k = a.xs0 + a.data.s, u = 1; a.l > u; u++)k += a["xs" + u] + a.data["xn" + u]; a.e = k + a["xs" + u] } return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a }, ce = 9; for (h = pe.prototype, h.l = h.pr = 0; --ce > 0;)h["xn" + ce] = 0, h["xs" + ce] = ""; h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function (t, e, i, s, r, n) { var a = this, o = a.l; return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = s || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new pe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = { s: e + i }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (s || ""), a) }; var me = function (t, e) { e = e || {}, this.p = e.prefix ? V(t) || t : t, o[t] = o[this.p] = this, this.format = e.formatter || le(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0 }, de = X._registerComplexSpecialProp = function (t, e, i) { "object" != typeof e && (e = { parser: i }); var s, r, n = t.split(","), a = e.defaultValue; for (i = i || [a], s = 0; n.length > s; s++)e.prefix = 0 === s && e.prefix, e.defaultValue = i[s] || a, r = new me(n[s], e) }, ge = function (t) { if (!o[t]) { var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin"; de(t, { parser: function (t, i, s, r, n, a, h) { var l = (window.GreenSockGlobals || window).com.greensock.plugins[e]; return l ? (l._cssRegister(), o[s].parse(t, i, s, r, n, a, h)) : (j("Error: " + e + " js file not loaded."), n) } }) } }; h = me.prototype, h.parseComplex = function (t, e, i, s, r, n) { var a, o, h, l, _, u, p = this.keyword; if (this.multi && (D.test(i) || D.test(e) ? (o = e.replace(D, "|").split("|"), h = i.replace(D, "|").split("|")) : p && (o = [e], h = [i])), h) { for (l = h.length > o.length ? h.length : o.length, a = 0; l > a; a++)e = o[a] = o[a] || this.dflt, i = h[a] = h[a] || this.dflt, p && (_ = e.indexOf(p), u = i.indexOf(p), _ !== u && (i = -1 === u ? h : o, i[a] += " " + p)); e = o.join(", "), i = h.join(", ") } return fe(t, this.p, e, i, this.clrs, this.dflt, s, this.pr, r, n) }, h.parse = function (t, e, i, s, n, a) { return this.parseComplex(t.style, this.format(G(t, this.p, r, !1, this.dflt)), this.format(e), n, a) }, a.registerSpecialProp = function (t, e, i) { de(t, { parser: function (t, s, r, n, a, o) { var h = new pe(t, r, 0, 0, a, 2, r, !1, i); return h.plugin = o, h.setRatio = e(t, s, n._tween, r), h }, priority: i }) }; var ve = "scaleX,scaleY,scaleZ,x,y,z,skewX,rotation,rotationX,rotationY,perspective".split(","), ye = V("transform"), Te = B + "transform", we = V("transformOrigin"), xe = null !== V("perspective"), be = function (t, e, i, s) { if (t._gsTransform && i && !s) return t._gsTransform; var r, n, o, h, l, _, u, p, f, c, m, d, g, v = i ? t._gsTransform || { skewY: 0 } : { skewY: 0 }, y = 0 > v.scaleX, T = 2e-5, w = 1e5, x = -Math.PI + 1e-4, b = Math.PI - 1e-4, P = xe ? parseFloat(G(t, we, e, !1, "0 0 0").split(" ")[2]) || v.zOrigin || 0 : 0; for (ye ? r = G(t, Te, e, !0) : t.currentStyle && (r = t.currentStyle.filter.match(C), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), v.x || 0, v.y || 0].join(",") : ""), n = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], o = n.length; --o > -1;)h = Number(n[o]), n[o] = (l = h - (h |= 0)) ? (0 | l * w + (0 > l ? -.5 : .5)) / w + h : h; if (16 === n.length) { var k = n[8], S = n[9], R = n[10], A = n[12], O = n[13], D = n[14]; if (v.zOrigin && (D = -v.zOrigin, A = k * D - n[12], O = S * D - n[13], D = R * D + v.zOrigin - n[14]), !i || s || null == v.rotationX) { var M, I, F, E, N, L, X, z = n[0], U = n[1], Y = n[2], j = n[3], B = n[4], q = n[5], V = n[6], Z = n[7], $ = n[11], Q = v.rotationX = Math.atan2(V, R), W = x > Q || Q > b; Q && (E = Math.cos(-Q), N = Math.sin(-Q), M = B * E + k * N, I = q * E + S * N, F = V * E + R * N, k = B * -N + k * E, S = q * -N + S * E, R = V * -N + R * E, $ = Z * -N + $ * E, B = M, q = I, V = F), Q = v.rotationY = Math.atan2(k, z), Q && (L = x > Q || Q > b, E = Math.cos(-Q), N = Math.sin(-Q), M = z * E - k * N, I = U * E - S * N, F = Y * E - R * N, S = U * N + S * E, R = Y * N + R * E, $ = j * N + $ * E, z = M, U = I, Y = F), Q = v.rotation = Math.atan2(U, q), Q && (X = x > Q || Q > b, E = Math.cos(-Q), N = Math.sin(-Q), z = z * E + B * N, I = U * E + q * N, q = U * -N + q * E, V = Y * -N + V * E, U = I), X && W ? v.rotation = v.rotationX = 0 : X && L ? v.rotation = v.rotationY = 0 : L && W && (v.rotationY = v.rotationX = 0), v.scaleX = (0 | Math.sqrt(z * z + U * U) * w + .5) / w, v.scaleY = (0 | Math.sqrt(q * q + S * S) * w + .5) / w, v.scaleZ = (0 | Math.sqrt(V * V + R * R) * w + .5) / w, v.skewX = 0, v.perspective = $ ? 1 / (0 > $ ? -$ : $) : 0, v.x = A, v.y = O, v.z = D } } else if (!(xe && !s && n.length && v.x === n[4] && v.y === n[5] && (v.rotationX || v.rotationY) || void 0 !== v.x && "none" === G(t, "display", e))) { var H = n.length >= 6, K = H ? n[0] : 1, J = n[1] || 0, te = n[2] || 0, ee = H ? n[3] : 1; v.x = n[4] || 0, v.y = n[5] || 0, _ = Math.sqrt(K * K + J * J), u = Math.sqrt(ee * ee + te * te), p = K || J ? Math.atan2(J, K) : v.rotation || 0, f = te || ee ? Math.atan2(te, ee) + p : v.skewX || 0, c = _ - Math.abs(v.scaleX || 0), m = u - Math.abs(v.scaleY || 0), Math.abs(f) > Math.PI / 2 && Math.abs(f) < 1.5 * Math.PI && (y ? (_ *= -1, f += 0 >= p ? Math.PI : -Math.PI, p += 0 >= p ? Math.PI : -Math.PI) : (u *= -1, f += 0 >= f ? Math.PI : -Math.PI)), d = (p - v.rotation) % Math.PI, g = (f - v.skewX) % Math.PI, (void 0 === v.skewX || c > T || -T > c || m > T || -T > m || d > x && b > d && false | d * w || g > x && b > g && false | g * w) && (v.scaleX = _, v.scaleY = u, v.rotation = p, v.skewX = f), xe && (v.rotationX = v.rotationY = v.z = 0, v.perspective = parseFloat(a.defaultTransformPerspective) || 0, v.scaleZ = 1) } v.zOrigin = P; for (o in v) T > v[o] && v[o] > -T && (v[o] = 0); return i && (t._gsTransform = v), v }, Pe = function (t) { var e, i, s = this.data, r = -s.rotation, n = r + s.skewX, a = 1e5, o = (0 | Math.cos(r) * s.scaleX * a) / a, h = (0 | Math.sin(r) * s.scaleX * a) / a, l = (0 | Math.sin(n) * -s.scaleY * a) / a, _ = (0 | Math.cos(n) * s.scaleY * a) / a, u = this.t.style, p = this.t.currentStyle; if (p) { i = h, h = -l, l = -i, e = p.filter, u.filter = ""; var f, m, d = this.t.offsetWidth, g = this.t.offsetHeight, v = "absolute" !== p.position, w = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + h + ", M21=" + l + ", M22=" + _, x = s.x, b = s.y; if (null != s.ox && (f = (s.oxp ? .01 * d * s.ox : s.ox) - d / 2, m = (s.oyp ? .01 * g * s.oy : s.oy) - g / 2, x += f - (f * o + m * h), b += m - (f * l + m * _)), v ? (f = d / 2, m = g / 2, w += ", Dx=" + (f - (f * o + m * h) + x) + ", Dy=" + (m - (f * l + m * _) + b) + ")") : w += ", sizingMethod='auto expand')", u.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(O, w) : w + " " + e, (0 === t || 1 === t) && 1 === o && 0 === h && 0 === l && 1 === _ && (v && -1 === w.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf("gradient(" && e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) { var P, k, S, R = 8 > c ? 1 : -1; for (f = s.ieOffsetX || 0, m = s.ieOffsetY || 0, s.ieOffsetX = Math.round((d - ((0 > o ? -o : o) * d + (0 > h ? -h : h) * g)) / 2 + x), s.ieOffsetY = Math.round((g - ((0 > _ ? -_ : _) * g + (0 > l ? -l : l) * d)) / 2 + b), ce = 0; 4 > ce; ce++)k = J[ce], P = p[k], i = -1 !== P.indexOf("px") ? parseFloat(P) : $(this.t, k, parseFloat(P), P.replace(y, "")) || 0, S = i !== s[k] ? 2 > ce ? -s.ieOffsetX : -s.ieOffsetY : 2 > ce ? f - s.ieOffsetX : m - s.ieOffsetY, u[k] = (s[k] = Math.round(i - S * (0 === ce || 2 === ce ? 1 : R))) + "px" } } }, ke = function () { var t, e, i, s, r, n, a, o, h, l, _, u, f, c, m, d, g, v, y, T, w, x, b, P, k, S, R = this.data, A = this.t.style, C = R.rotation, O = R.scaleX, D = R.scaleY, M = R.scaleZ, I = R.perspective; if (p && (P = A.top ? "top" : A.bottom ? "bottom" : parseFloat(G(this.t, "top", null, !1)) ? "bottom" : "top", T = G(this.t, P, null, !1), k = parseFloat(T) || 0, S = T.substr((k + "").length) || "px", R._ffFix = !R._ffFix, A[P] = (R._ffFix ? k + .05 : k - .05) + S), C || R.skewX) v = Math.cos(C), y = Math.sin(C), t = v, r = y, R.skewX && (C -= R.skewX, v = Math.cos(C), y = Math.sin(C)), e = -y, n = v; else { if (!(R.rotationY || R.rotationX || 1 !== M || I)) return A[ye] = "translate3d(" + R.x + "px," + R.y + "px," + R.z + "px)" + (1 !== O || 1 !== D ? " scale(" + O + "," + D + ")" : ""), void 0; t = n = 1, e = r = 0 } _ = 1, i = s = a = o = h = l = u = f = c = 0, m = I ? -1 / I : 0, d = R.zOrigin, g = 1e5, C = R.rotationY, C && (v = Math.cos(C), y = Math.sin(C), h = _ * -y, f = m * -y, i = t * y, a = r * y, _ *= v, m *= v, t *= v, r *= v), C = R.rotationX, C && (v = Math.cos(C), y = Math.sin(C), T = e * v + i * y, w = n * v + a * y, x = l * v + _ * y, b = c * v + m * y, i = e * -y + i * v, a = n * -y + a * v, _ = l * -y + _ * v, m = c * -y + m * v, e = T, n = w, l = x, c = b), 1 !== M && (i *= M, a *= M, _ *= M, m *= M), 1 !== D && (e *= D, n *= D, l *= D, c *= D), 1 !== O && (t *= O, r *= O, h *= O, f *= O), d && (u -= d, s = i * u, o = a * u, u = _ * u + d), s = (T = (s += R.x) - (s |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + s : s, o = (T = (o += R.y) - (o |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + o : o, u = (T = (u += R.z) - (u |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + u : u, A[ye] = "matrix3d(" + [(0 | t * g) / g, (0 | r * g) / g, (0 | h * g) / g, (0 | f * g) / g, (0 | e * g) / g, (0 | n * g) / g, (0 | l * g) / g, (0 | c * g) / g, (0 | i * g) / g, (0 | a * g) / g, (0 | _ * g) / g, (0 | m * g) / g, s, o, u, I ? 1 + -u / I : 1].join(",") + ")" }, Se = function () { var t, e, i, s, r, n, a, o, h, l = this.data, _ = this.t, u = _.style; p && (t = u.top ? "top" : u.bottom ? "bottom" : parseFloat(G(_, "top", null, !1)) ? "bottom" : "top", e = G(_, t, null, !1), i = parseFloat(e) || 0, s = e.substr((i + "").length) || "px", l._ffFix = !l._ffFix, u[t] = (l._ffFix ? i + .05 : i - .05) + s), l.rotation || l.skewX ? (r = l.rotation, n = r - l.skewX, a = 1e5, o = l.scaleX * a, h = l.scaleY * a, u[ye] = "matrix(" + (0 | Math.cos(r) * o) / a + "," + (0 | Math.sin(r) * o) / a + "," + (0 | Math.sin(n) * -h) / a + "," + (0 | Math.cos(n) * h) / a + "," + l.x + "," + l.y + ")") : u[ye] = "matrix(" + l.scaleX + ",0,0," + l.scaleY + "," + l.x + "," + l.y + ")" }; de("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D", { parser: function (t, e, i, s, n, a, o) { if (s._transform) return n; var h, l, _, u, p, f, c, m = s._transform = be(t, r, !0, o.parseTransform), d = t.style, g = 1e-6, v = ve.length, y = o, T = {}; if ("string" == typeof y.transform && ye) _ = d.cssText, d[ye] = y.transform, d.display = "block", h = be(t, null, !1), d.cssText = _; else if ("object" == typeof y) { if (h = { scaleX: se(null != y.scaleX ? y.scaleX : y.scale, m.scaleX), scaleY: se(null != y.scaleY ? y.scaleY : y.scale, m.scaleY), scaleZ: se(null != y.scaleZ ? y.scaleZ : y.scale, m.scaleZ), x: se(y.x, m.x), y: se(y.y, m.y), z: se(y.z, m.z), perspective: se(y.transformPerspective, m.perspective) }, c = y.directionalRotation, null != c) if ("object" == typeof c) for (_ in c) y[_] = c[_]; else y.rotation = c; h.rotation = re("rotation" in y ? y.rotation : "shortRotation" in y ? y.shortRotation + "_short" : "rotationZ" in y ? y.rotationZ : m.rotation * I, m.rotation, "rotation", T), xe && (h.rotationX = re("rotationX" in y ? y.rotationX : "shortRotationX" in y ? y.shortRotationX + "_short" : m.rotationX * I || 0, m.rotationX, "rotationX", T), h.rotationY = re("rotationY" in y ? y.rotationY : "shortRotationY" in y ? y.shortRotationY + "_short" : m.rotationY * I || 0, m.rotationY, "rotationY", T)), h.skewX = null == y.skewX ? m.skewX : re(y.skewX, m.skewX), h.skewY = null == y.skewY ? m.skewY : re(y.skewY, m.skewY), (l = h.skewY - m.skewY) && (h.skewX += l, h.rotation += l) } for (null != y.force3D && (m.force3D = y.force3D, f = !0), p = m.force3D || m.z || m.rotationX || m.rotationY || h.z || h.rotationX || h.rotationY || h.perspective, p || null == y.scale || (h.scaleZ = 1); --v > -1;)i = ve[v], u = h[i] - m[i], (u > g || -g > u || null != F[i]) && (f = !0, n = new pe(m, i, m[i], u, n), i in T && (n.e = T[i]), n.xs0 = 0, n.plugin = a, s._overwriteProps.push(n.n)); return u = y.transformOrigin, (u || xe && p && m.zOrigin) && (ye ? (f = !0, i = we, u = (u || G(t, i, r, !1, "50% 50%")) + "", n = new pe(d, i, 0, 0, n, -1, "transformOrigin"), n.b = d[i], n.plugin = a, xe ? (_ = m.zOrigin, u = u.split(" "), m.zOrigin = (u.length > 2 && (0 === _ || "0px" !== u[2]) ? parseFloat(u[2]) : _) || 0, n.xs0 = n.e = d[i] = u[0] + " " + (u[1] || "50%") + " 0px", n = new pe(m, "zOrigin", 0, 0, n, -1, n.n), n.b = _, n.xs0 = n.e = m.zOrigin) : n.xs0 = n.e = d[i] = u) : ee(u + "", m)), f && (s._transformType = p || 3 === this._transformType ? 3 : 2), n }, prefix: !0 }), de("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), de("borderRadius", { defaultValue: "0px", parser: function (t, e, i, n, a) { e = this.format(e); var o, h, l, _, u, p, f, c, m, d, g, v, y, T, w, x, b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], P = t.style; for (m = parseFloat(t.offsetWidth), d = parseFloat(t.offsetHeight), o = e.split(" "), h = 0; b.length > h; h++)this.p.indexOf("border") && (b[h] = V(b[h])), u = _ = G(t, b[h], r, !1, "0px"), -1 !== u.indexOf(" ") && (_ = u.split(" "), u = _[0], _ = _[1]), p = l = o[h], f = parseFloat(u), v = u.substr((f + "").length), y = "=" === p.charAt(1), y ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), g = p.substr((c + "").length - (0 > c ? 1 : 0)) || "") : (c = parseFloat(p), g = p.substr((c + "").length)), "" === g && (g = s[i] || v), g !== v && (T = $(t, "borderLeft", f, v), w = $(t, "borderTop", f, v), "%" === g ? (u = 100 * (T / m) + "%", _ = 100 * (w / d) + "%") : "em" === g ? (x = $(t, "borderLeft", 1, "em"), u = T / x + "em", _ = w / x + "em") : (u = T + "px", _ = w + "px"), y && (p = parseFloat(u) + c + g, l = parseFloat(_) + c + g)), a = fe(P, b[h], u + " " + _, p + " " + l, !1, "0px", a); return a }, prefix: !0, formatter: le("0px 0px 0px 0px", !1, !0) }), de("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, i, s, n, a) { var o, h, l, _, u, p, f = "background-position", m = r || Z(t, null), d = this.format((m ? c ? m.getPropertyValue(f + "-x") + " " + m.getPropertyValue(f + "-y") : m.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), g = this.format(e); if (-1 !== d.indexOf("%") != (-1 !== g.indexOf("%")) && (p = G(t, "backgroundImage").replace(S, ""), p && "none" !== p)) { for (o = d.split(" "), h = g.split(" "), L.setAttribute("src", p), l = 2; --l > -1;)d = o[l], _ = -1 !== d.indexOf("%"), _ !== (-1 !== h[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - L.width : t.offsetHeight - L.height, o[l] = _ ? parseFloat(d) / 100 * u + "px" : 100 * (parseFloat(d) / u) + "%"); d = o.join(" ") } return this.parseComplex(t.style, d, g, n, a) }, formatter: ee }), de("backgroundSize", { defaultValue: "0 0", formatter: ee }), de("perspective", { defaultValue: "0px", prefix: !0 }), de("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), de("transformStyle", { prefix: !0 }), de("backfaceVisibility", { prefix: !0 }), de("margin", { parser: _e("marginTop,marginRight,marginBottom,marginLeft") }), de("padding", { parser: _e("paddingTop,paddingRight,paddingBottom,paddingLeft") }), de("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, i, s, n, a) { var o, h, l; return 9 > c ? (h = t.currentStyle, l = 8 > c ? " " : ",", o = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (o = this.format(G(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a) } }), de("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), de("autoRound,strictUnits", { parser: function (t, e, i, s, r) { return r } }), de("border", { defaultValue: "0px solid #000", parser: function (t, e, i, s, n, a) { return this.parseComplex(t.style, this.format(G(t, "borderTopWidth", r, !1, "0px") + " " + G(t, "borderTopStyle", r, !1, "solid") + " " + G(t, "borderTopColor", r, !1, "#000")), this.format(e), n, a) }, color: !0, formatter: function (t) { var e = t.split(" "); return e[0] + " " + (e[1] || "solid") + " " + (t.match(he) || ["#000"])[0] } }), de("float,cssFloat,styleFloat", { parser: function (t, e, i, s, r) { var n = t.style, a = "cssFloat" in n ? "cssFloat" : "styleFloat"; return new pe(n, a, 0, 0, r, -1, i, !1, 0, n[a], e) } }); var Re = function (t) { var e, i = this.t, s = i.filter || G(this.data, "filter"), r = 0 | this.s + this.c * t; 100 === r && (-1 === s.indexOf("atrix(") && -1 === s.indexOf("radient(") && -1 === s.indexOf("oader(") ? (i.removeAttribute("filter"), e = !G(this.data, "filter")) : (i.filter = s.replace(x, ""), e = !0)), e || (this.xn1 && (i.filter = s = s || "alpha(opacity=" + r + ")"), -1 === s.indexOf("opacity") ? 0 === r && this.xn1 || (i.filter = s + " alpha(opacity=" + r + ")") : i.filter = s.replace(T, "opacity=" + r)) }; de("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, i, s, n, a) { var o = parseFloat(G(t, "opacity", r, !1, "1")), h = t.style, l = "autoAlpha" === i; return e = parseFloat(e), l && 1 === o && "hidden" === G(t, "visibility", r) && 0 !== e && (o = 0), U ? n = new pe(h, "opacity", o, e - o, n) : (n = new pe(h, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = l ? 1 : 0, h.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = Re), l && (n = new pe(h, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", s._overwriteProps.push(n.n), s._overwriteProps.push(i)), n } }); var Ae = function (t, e) { e && (t.removeProperty ? t.removeProperty(e.replace(P, "-$1").toLowerCase()) : t.removeAttribute(e)) }, Ce = function (t) { if (this.t._gsClassPT = this, 1 === t || 0 === t) { this.t.className = 0 === t ? this.b : this.e; for (var e = this.data, i = this.t.style; e;)e.v ? i[e.p] = e.v : Ae(i, e.p), e = e._next; 1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.className !== this.e && (this.t.className = this.e) }; de("className", { parser: function (t, e, s, n, a, o, h) { var l, _, u, p, f, c = t.className, m = t.style.cssText; if (a = n._classNamePT = new pe(t, s, 0, 0, a, 2), a.setRatio = Ce, a.pr = -11, i = !0, a.b = c, _ = W(t, r), u = t._gsClassPT) { for (p = {}, f = u.data; f;)p[f.p] = 1, f = f._next; u.setRatio(1) } return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : c.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), n._tween._duration && (t.className = a.e, l = H(t, _, W(t), h, p), t.className = c, a.data = l.firstMPT, t.style.cssText = m, a = a.xfirst = n.parse(t, l.difs, a, o)), a } }); var Oe = function (t) { if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration) { var e, i, s, r, n = this.t.style, a = o.transform.parse; if ("all" === this.e) n.cssText = "", r = !0; else for (e = this.e.split(","), s = e.length; --s > -1;)i = e[s], o[i] && (o[i].parse === a ? r = !0 : i = "transformOrigin" === i ? we : o[i].p), Ae(n, i); r && (Ae(n, ye), this.t._gsTransform && delete this.t._gsTransform) } }; for (de("clearProps", { parser: function (t, e, s, r, n) { return n = new pe(t, s, 0, 0, n, 2), n.setRatio = Oe, n.e = e, n.pr = -10, n.data = r._tween, i = !0, n } }), h = "bezier,throwProps,physicsProps,physics2D".split(","), ce = h.length; ce--;)ge(h[ce]); h = a.prototype, h._firstPT = null, h._onInitTween = function (t, e, o) { if (!t.nodeType) return !1; this._target = t, this._tween = o, this._vars = e, l = e.autoRound, i = !1, s = e.suffixMap || a.suffixMap, r = Z(t, ""), n = this._overwriteProps; var h, p, c, m, d, g, v, y, T, x = t.style; if (_ && "" === x.zIndex && (h = G(t, "zIndex", r), ("auto" === h || "" === h) && (x.zIndex = 0)), "string" == typeof e && (m = x.cssText, h = W(t, r), x.cssText = m + ";" + e, h = H(t, h, W(t)).difs, !U && w.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, x.cssText = m), this._firstPT = p = this.parse(t, e, null), this._transformType) { for (T = 3 === this._transformType, ye ? u && (_ = !0, "" === x.zIndex && (v = G(t, "zIndex", r), ("auto" === v || "" === v) && (x.zIndex = 0)), f && (x.WebkitBackfaceVisibility = this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : x.zoom = 1, c = p; c && c._next;)c = c._next; y = new pe(t, "transform", 0, 0, null, 2), this._linkCSSP(y, null, c), y.setRatio = T && xe ? ke : ye ? Se : Pe, y.data = this._transform || be(t, r, !0), n.pop() } if (i) { for (; p;) { for (g = p._next, c = m; c && c.pr > p.pr;)c = c._next; (p._prev = c ? c._prev : d) ? p._prev._next = p : m = p, (p._next = c) ? c._prev = p : d = p, p = g } this._firstPT = m } return !0 }, h.parse = function (t, e, i, n) { var a, h, _, u, p, f, c, m, d, g, v = t.style; for (a in e) f = e[a], h = o[a], h ? i = h.parse(t, f, a, this, i, n, e) : (p = G(t, a, r) + "", d = "string" == typeof f, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || d && b.test(f) ? (d || (f = oe(f), f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), i = fe(v, a, p, f, !0, "transparent", i, 0, n)) : !d || -1 === f.indexOf(" ") && -1 === f.indexOf(",") ? (_ = parseFloat(p), c = _ || 0 === _ ? p.substr((_ + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (_ = te(t, a, r), c = "px") : "left" === a || "top" === a ? (_ = Q(t, a, r), c = "px") : (_ = "opacity" !== a ? 0 : 1, c = "")), g = d && "=" === f.charAt(1), g ? (u = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), u *= parseFloat(f), m = f.replace(y, "")) : (u = parseFloat(f), m = d ? f.substr((u + "").length) || "" : ""), "" === m && (m = s[a] || c), f = u || 0 === u ? (g ? u + _ : u) + m : e[a], c !== m && "" !== m && (u || 0 === u) && (_ || 0 === _) && (_ = $(t, a, _, c), "%" === m ? (_ /= $(t, a, 100, "%") / 100, _ > 100 && (_ = 100), e.strictUnits !== !0 && (p = _ + "%")) : "em" === m ? _ /= $(t, a, 1, "em") : (u = $(t, a, u, m), m = "px"), g && (u || 0 === u) && (f = u + _ + m)), g && (u += _), !_ && 0 !== _ || !u && 0 !== u ? void 0 !== v[a] && (f || "NaN" != f + "" && null != f) ? (i = new pe(v, a, u || _ || 0, 0, i, -1, a, !1, 0, p, f), i.xs0 = "none" !== f || "display" !== a && -1 === a.indexOf("Style") ? f : p) : j("invalid " + a + " tween value: " + e[a]) : (i = new pe(v, a, _, u - _, i, 0, a, l !== !1 && ("px" === m || "zIndex" === a), 0, p, f), i.xs0 = m)) : i = fe(v, a, p, f, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n); return i }, h.setRatio = function (t) { var e, i, s, r = this._firstPT, n = 1e-6; if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; r;) { if (e = r.c * t + r.s, r.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : n > e && e > -n && (e = 0), r.type) if (1 === r.type) if (s = r.l, 2 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2; else if (3 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else { for (i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++)i += r["xn" + s] + r["xs" + (s + 1)]; r.t[r.p] = i } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t); else r.t[r.p] = e + r.xs0; r = r._next } else for (; r;)2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next; else for (; r;)2 !== r.type ? r.t[r.p] = r.e : r.setRatio(t), r = r._next }, h._enableTransforms = function (t) { this._transformType = t || 3 === this._transformType ? 3 : 2, this._transform = this._transform || be(this._target, r, !0) }, h._linkCSSP = function (t, e, i, s) { return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, s = !0), i ? i._next = t : s || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t }, h._kill = function (e) { var i, s, r, n = e; if (e.autoAlpha || e.alpha) { n = {}; for (s in e) n[s] = e[s]; n.opacity = 1, n.autoAlpha && (n.visibility = 1) } return e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), t.prototype._kill.call(this, n) }; var De = function (t, e, i) { var s, r, n, a; if (t.slice) for (r = t.length; --r > -1;)De(t[r], e, i); else for (s = t.childNodes, r = s.length; --r > -1;)n = s[r], a = n.type, n.style && (e.push(W(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || De(n, e, i) }; return a.cascadeTo = function (t, i, s) { var r, n, a, o = e.to(t, i, s), h = [o], l = [], _ = [], u = [], p = e._internals.reservedProps; for (t = o._targets || o.target, De(t, l, u), o.render(i, !0), De(t, _), o.render(0, !0), o._enabled(!0), r = u.length; --r > -1;)if (n = H(u[r], l[r], _[r]), n.firstMPT) { n = n.difs; for (a in s) p[a] && (n[a] = s[a]); h.push(e.to(u[r], i, n)) } return h }, t.activate([a]), a }, !0), function () {
    var t = window._gsDefine.plugin({ propName: "roundProps", priority: -1, API: 2, init: function (t, e, i) { return this._tween = i, !0 } }), e = t.prototype; e._onInitAllProps = function () { for (var t, e, i, s = this._tween, r = s.vars.roundProps instanceof Array ? s.vars.roundProps : s.vars.roundProps.split(","), n = r.length, a = {}, o = s._propLookup.roundProps; --n > -1;)a[r[n]] = 1; for (n = r.length; --n > -1;)for (t = r[n], e = s._firstPT; e;)i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : s._firstPT === e && (s._firstPT = i), e._next = e._prev = null, s._propLookup[t] = o), e = i; return !1 }, e._add = function (t, e, i, s) {
      this._addTween(t, e, i, i + s, e, !0), this._overwriteProps.push(e)
    }
  }(), window._gsDefine.plugin({ propName: "attr", API: 2, init: function (t, e) { var i; if ("function" != typeof t.setAttribute) return !1; this._target = t, this._proxy = {}; for (i in e) this._addTween(this._proxy, i, parseFloat(t.getAttribute(i)), e[i], i) && this._overwriteProps.push(i); return !0 }, set: function (t) { this._super.setRatio.call(this, t); for (var e, i = this._overwriteProps, s = i.length; --s > -1;)e = i[s], this._target.setAttribute(e, this._proxy[e] + "") } }), window._gsDefine.plugin({ propName: "directionalRotation", API: 2, init: function (t, e) { "object" != typeof e && (e = { rotation: e }), this.finals = {}; var i, s, r, n, a, o, h = e.useRadians === !0 ? 2 * Math.PI : 360, l = 1e-6; for (i in e) "useRadians" !== i && (o = (e[i] + "").split("_"), s = o[0], r = parseFloat("function" != typeof t[i] ? t[i] : t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), n = this.finals[i] = "string" == typeof s && "=" === s.charAt(1) ? r + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0, a = n - r, o.length && (s = o.join("_"), -1 !== s.indexOf("short") && (a %= h, a !== a % (h / 2) && (a = 0 > a ? a + h : a - h)), -1 !== s.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * h) % h - (0 | a / h) * h : -1 !== s.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * h) % h - (0 | a / h) * h)), (a > l || -l > a) && (this._addTween(t, i, r, r + a, i), this._overwriteProps.push(i))); return !0 }, set: function (t) { var e; if (1 !== t) this._super.setRatio.call(this, t); else for (e = this._firstPT; e;)e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next } })._autoCSS = !0, window._gsDefine("easing.Back", ["easing.Ease"], function (t) { var e, i, s, r = window.GreenSockGlobals || window, n = r.com.greensock, a = 2 * Math.PI, o = Math.PI / 2, h = n._class, l = function (e, i) { var s = h("easing." + e, function () { }, !0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, s }, _ = t.register || function () { }, u = function (t, e, i, s) { var r = h("easing." + t, { easeOut: new e, easeIn: new i, easeInOut: new s }, !0); return _(r, t), r }, p = function (t, e, i) { this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t) }, f = function (e, i) { var s = h("easing." + e, function (t) { this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1 }, !0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, r.config = function (t) { return new s(t) }, s }, c = u("Back", f("BackOut", function (t) { return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1 }), f("BackIn", function (t) { return t * t * ((this._p1 + 1) * t - this._p1) }), f("BackInOut", function (t) { return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2) })), m = h("easing.SlowMo", function (t, e, i) { e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0 }, !0), d = m.prototype = new t; return d.constructor = m, d.getRatio = function (t) { var e = t + (.5 - t) * this._p; return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e }, m.ease = new m(.7, .7), d.config = m.config = function (t, e, i) { return new m(t, e, i) }, e = h("easing.SteppedEase", function (t) { t = t || 1, this._p1 = 1 / t, this._p2 = t + 1 }, !0), d = e.prototype = new t, d.constructor = e, d.getRatio = function (t) { return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1 }, d.config = e.config = function (t) { return new e(t) }, i = h("easing.RoughEase", function (e) { e = e || {}; for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), f = u, c = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --f > -1;)i = c ? Math.random() : 1 / u * f, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), c ? s += Math.random() * r - .5 * r : f % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = { x: i, y: s }; for (l.sort(function (t, e) { return t.x - e.x }), o = new p(1, 1, null), f = u; --f > -1;)a = l[f], o = new p(a.x, a.y, o); this._prev = new p(0, 0, 0 !== o.t ? o : o.next) }, !0), d = i.prototype = new t, d.constructor = i, d.getRatio = function (t) { var e = this._prev; if (t > e.t) { for (; e.next && t >= e.t;)e = e.next; e = e.prev } else for (; e.prev && e.t >= t;)e = e.prev; return this._prev = e, e.v + (t - e.t) / e.gap * e.c }, d.config = function (t) { return new i(t) }, i.ease = new i, u("Bounce", l("BounceOut", function (t) { return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }), l("BounceIn", function (t) { return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375) }), l("BounceInOut", function (t) { var e = .5 > t; return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5 })), u("Circ", l("CircOut", function (t) { return Math.sqrt(1 - (t -= 1) * t) }), l("CircIn", function (t) { return -(Math.sqrt(1 - t * t) - 1) }), l("CircInOut", function (t) { return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) })), s = function (e, i, s) { var r = h("easing." + e, function (t, e) { this._p1 = t || 1, this._p2 = e || s, this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0) }, !0), n = r.prototype = new t; return n.constructor = r, n.getRatio = i, n.config = function (t, e) { return new r(t, e) }, r }, u("Elastic", s("ElasticOut", function (t) { return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * a / this._p2) + 1 }, .3), s("ElasticIn", function (t) { return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2)) }, .3), s("ElasticInOut", function (t) { return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) + 1 }, .45)), u("Expo", l("ExpoOut", function (t) { return 1 - Math.pow(2, -10 * t) }), l("ExpoIn", function (t) { return Math.pow(2, 10 * (t - 1)) - .001 }), l("ExpoInOut", function (t) { return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1))) })), u("Sine", l("SineOut", function (t) { return Math.sin(t * o) }), l("SineIn", function (t) { return -Math.cos(t * o) + 1 }), l("SineInOut", function (t) { return -.5 * (Math.cos(Math.PI * t) - 1) })), h("easing.EaseLookup", { find: function (e) { return t.map[e] } }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), c }, !0)
}), function (t) { "use strict"; var e, i, s, r, n, a = t.GreenSockGlobals || t, o = function (t) { var e, i = t.split("."), s = a; for (e = 0; i.length > e; e++)s[i[e]] = s = s[i[e]] || {}; return s }, h = o("com.greensock"), l = [].slice, _ = function () { }, u = {}, p = function (e, i, s, r) { this.sc = u[e] ? u[e].sc : [], u[e] = this, this.gsClass = null, this.func = s; var n = []; this.check = function (h) { for (var l, _, f, c, m = i.length, d = m; --m > -1;)(l = u[i[m]] || new p(i[m], [])).gsClass ? (n[m] = l.gsClass, d--) : h && l.sc.push(this); if (0 === d && s) for (_ = ("com.greensock." + e).split("."), f = _.pop(), c = o(_.join("."))[f] = this.gsClass = s.apply(s, n), r && (a[f] = c, "function" == typeof define && define.amd ? define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + e.split(".").join("/"), [], function () { return c }) : "undefined" != typeof module && module.exports && (module.exports = c)), m = 0; this.sc.length > m; m++)this.sc[m].check() }, this.check(!0) }, f = t._gsDefine = function (t, e, i, s) { return new p(t, e, i, s) }, c = h._class = function (t, e, i) { return e = e || function () { }, f(t, [], function () { return e }, i), e }; f.globals = a; var m = [0, 0, 1, 1], d = [], g = c("easing.Ease", function (t, e, i, s) { this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? m.concat(e) : m }, !0), v = g.map = {}, y = g.register = function (t, e, i, s) { for (var r, n, a, o, l = e.split(","), _ = l.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --_ > -1;)for (n = l[_], r = s ? c("easing." + n, null, !0) : h.easing[n] || {}, a = u.length; --a > -1;)o = u[a], v[n + "." + o] = v[o + n] = r[o] = t.getRatio ? t : t[o] || new t }; for (s = g.prototype, s._calcEnd = !1, s.getRatio = function (t) { if (this._func) return this._params[0] = t, this._func.apply(null, this._params); var e = this._type, i = this._power, s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t); return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2 }, e = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], i = e.length; --i > -1;)s = e[i] + ",Power" + i, y(new g(null, null, 1, i), s, "easeOut", !0), y(new g(null, null, 2, i), s, "easeIn" + (0 === i ? ",easeNone" : "")), y(new g(null, null, 3, i), s, "easeInOut"); v.linear = h.easing.Linear.easeIn, v.swing = h.easing.Quad.easeInOut; var T = c("events.EventDispatcher", function (t) { this._listeners = {}, this._eventTarget = t || this }); s = T.prototype, s.addEventListener = function (t, e, i, s, a) { a = a || 0; var o, h, l = this._listeners[t], _ = 0; for (null == l && (this._listeners[t] = l = []), h = l.length; --h > -1;)o = l[h], o.c === e && o.s === i ? l.splice(h, 1) : 0 === _ && a > o.pr && (_ = h + 1); l.splice(_, 0, { c: e, s: i, up: s, pr: a }), this !== r || n || r.wake() }, s.removeEventListener = function (t, e) { var i, s = this._listeners[t]; if (s) for (i = s.length; --i > -1;)if (s[i].c === e) return s.splice(i, 1), void 0 }, s.dispatchEvent = function (t) { var e, i, s, r = this._listeners[t]; if (r) for (e = r.length, i = this._eventTarget; --e > -1;)s = r[e], s.up ? s.c.call(s.s || i, { type: t, target: i }) : s.c.call(s.s || i) }; var w = t.requestAnimationFrame, x = t.cancelAnimationFrame, b = Date.now || function () { return (new Date).getTime() }, P = b(); for (e = ["ms", "moz", "webkit", "o"], i = e.length; --i > -1 && !w;)w = t[e[i] + "RequestAnimationFrame"], x = t[e[i] + "CancelAnimationFrame"] || t[e[i] + "CancelRequestAnimationFrame"]; c("Ticker", function (t, e) { var i, s, a, o, h, l = this, u = b(), p = e !== !1 && w, f = function (t) { P = b(), l.time = (P - u) / 1e3; var e, r = l.time - h; (!i || r > 0 || t === !0) && (l.frame++, h += r + (r >= o ? .004 : o - r), e = !0), t !== !0 && (a = s(f)), e && l.dispatchEvent("tick") }; T.call(l), l.time = l.frame = 0, l.tick = function () { f(!0) }, l.sleep = function () { null != a && (p && x ? x(a) : clearTimeout(a), s = _, a = null, l === r && (n = !1)) }, l.wake = function () { null !== a && l.sleep(), s = 0 === i ? _ : p && w ? w : function (t) { return setTimeout(t, 0 | 1e3 * (h - l.time) + 1) }, l === r && (n = !0), f(2) }, l.fps = function (t) { return arguments.length ? (i = t, o = 1 / (i || 60), h = this.time + o, l.wake(), void 0) : i }, l.useRAF = function (t) { return arguments.length ? (l.sleep(), p = t, l.fps(i), void 0) : p }, l.fps(t), setTimeout(function () { p && (!a || 5 > l.frame) && l.useRAF(!1) }, 1500) }), s = h.Ticker.prototype = new h.events.EventDispatcher, s.constructor = h.Ticker; var k = c("core.Animation", function (t, e) { if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, X) { n || r.wake(); var i = this.vars.useFrames ? L : X; i.add(this, i._time), this.vars.paused && this.paused(!0) } }); r = k.ticker = new h.Ticker, s = k.prototype, s._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1; var S = function () { b() - P > 2e3 && r.wake(), setTimeout(S, 2e3) }; S(), s.play = function (t, e) { return arguments.length && this.seek(t, e), this.reversed(!1).paused(!1) }, s.pause = function (t, e) { return arguments.length && this.seek(t, e), this.paused(!0) }, s.resume = function (t, e) { return arguments.length && this.seek(t, e), this.paused(!1) }, s.seek = function (t, e) { return this.totalTime(Number(t), e !== !1) }, s.restart = function (t, e) { return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0) }, s.reverse = function (t, e) { return arguments.length && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, s.render = function () { }, s.invalidate = function () { return this }, s._enabled = function (t, e) { return n || r.wake(), this._gc = !t, this._active = t && !this._paused && this._totalTime > 0 && this._totalTime < this._totalDuration, e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1 }, s._kill = function () { return this._enabled(!1, !1) }, s.kill = function (t, e) { return this._kill(t, e), this }, s._uncache = function (t) { for (var e = t ? this : this.timeline; e;)e._dirty = !0, e = e.timeline; return this }, s._swapSelfInParams = function (t) { for (var e = t.length, i = t.concat(); --e > -1;)"{self}" === t[e] && (i[e] = this); return i }, s.eventCallback = function (t, e, i, s) { if ("on" === (t || "").substr(0, 2)) { var r = this.vars; if (1 === arguments.length) return r[t]; null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = i instanceof Array && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e) } return this }, s.delay = function (t) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay }, s.duration = function (t) { return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration) }, s.totalDuration = function (t) { return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration }, s.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time }, s.totalTime = function (t, e, i) { if (n || r.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var s = this._totalDuration, a = this._timeline; if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : a._time) - (this._reversed ? s - t : t) / this._timeScale, a._dirty || this._uncache(!1), a._timeline) for (; a._timeline;)a._timeline._time !== (a._startTime + a._totalTime) / a._timeScale && a.totalTime(a._totalTime, !0), a = a._timeline } this._gc && this._enabled(!0, !1), this._totalTime !== t && this.render(t, e, !1) } return this }, s.startTime = function (t) { return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime }, s.timeScale = function (t) { if (!arguments.length) return this._timeScale; if (t = t || 1e-6, this._timeline && this._timeline.smoothChildTiming) { var e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(); this._startTime = i - (i - this._startTime) * this._timeScale / t } return this._timeScale = t, this._uncache(!1) }, s.reversed = function (t) { return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._totalTime, !0)), this) : this._reversed }, s.paused = function (t) { if (!arguments.length) return this._paused; if (t != this._paused && this._timeline) { n || t || r.wake(); var e = this._timeline, i = e.rawTime(), s = i - this._pauseTime; !t && e.smoothChildTiming && (this._startTime += s, this._uncache(!1)), this._pauseTime = t ? i : null, this._paused = t, this._active = !t && this._totalTime > 0 && this._totalTime < this._totalDuration, t || 0 === s || 0 === this._duration || this.render(e.smoothChildTiming ? this._totalTime : (i - this._startTime) / this._timeScale, !0, !0) } return this._gc && !t && this._enabled(!0, !1), this }; var R = c("core.SimpleTimeline", function (t) { k.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0 }); s = R.prototype = new k, s.constructor = R, s.kill()._gc = !1, s._first = s._last = null, s._sortChildren = !1, s.add = s.insert = function (t, e) { var i, s; if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren) for (s = t._startTime; i && i._startTime > s;)i = i._prev; return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._timeline && this._uncache(!0), this }, s._remove = function (t, e) { return t.timeline === this && (e || t._enabled(!1, !0), t.timeline = null, t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), this._timeline && this._uncache(!0)), this }, s.render = function (t, e, i) { var s, r = this._first; for (this._totalTime = this._time = this._rawPrevTime = t; r;)s = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = s }, s.rawTime = function () { return n || r.wake(), this._totalTime }; var A = c("TweenLite", function (e, i, s) { if (k.call(this, i, s), this.render = A.prototype.render, null == e) throw "Cannot tween a null target."; this.target = e = "string" != typeof e ? e : A.selector(e) || e; var r, n, a, o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType), h = this.vars.overwrite; if (this._overwrite = h = null == h ? N[A.defaultOverwrite] : "number" == typeof h ? h >> 0 : N[h], (o || e instanceof Array) && "number" != typeof e[0]) for (this._targets = a = l.call(e, 0), this._propLookup = [], this._siblings = [], r = 0; a.length > r; r++)n = a[r], n ? "string" != typeof n ? n.length && n !== t && n[0] && (n[0] === t || n[0].nodeType && n[0].style && !n.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(l.call(n, 0))) : (this._siblings[r] = z(n, this, !1), 1 === h && this._siblings[r].length > 1 && U(n, this, null, 1, this._siblings[r])) : (n = a[r--] = A.selector(n), "string" == typeof n && a.splice(r + 1, 1)) : a.splice(r--, 1); else this._propLookup = {}, this._siblings = z(e, this, !1), 1 === h && this._siblings.length > 1 && U(e, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && this.render(-this._delay, !1, !0) }, !0), C = function (e) { return e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType) }, O = function (t, e) { var i, s = {}; for (i in t) E[i] || i in e && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!M[i] || M[i] && M[i]._autoCSS) || (s[i] = t[i], delete t[i]); t.css = s }; s = A.prototype = new k, s.constructor = A, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = !1, A.version = "1.10.3", A.defaultEase = s._ease = new g(null, null, 1, 1), A.defaultOverwrite = "auto", A.ticker = r, A.autoSleep = !0, A.selector = t.$ || t.jQuery || function (e) { return t.$ ? (A.selector = t.$, t.$(e)) : t.document ? t.document.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e }; var D = A._internals = {}, M = A._plugins = {}, I = A._tweenLookup = {}, F = 0, E = D.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1 }, N = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 }, L = k._rootFramesTimeline = new R, X = k._rootTimeline = new R; X._startTime = r.time, L._startTime = r.frame, X._active = L._active = !0, k._updateRoot = function () { if (X.render((r.time - X._startTime) * X._timeScale, !1, !1), L.render((r.frame - L._startTime) * L._timeScale, !1, !1), !(r.frame % 120)) { var t, e, i; for (i in I) { for (e = I[i].tweens, t = e.length; --t > -1;)e[t]._gc && e.splice(t, 1); 0 === e.length && delete I[i] } if (i = X._first, (!i || i._paused) && A.autoSleep && !L._first && 1 === r._listeners.tick.length) { for (; i && i._paused;)i = i._next; i || r.sleep() } } }, r.addEventListener("tick", k._updateRoot); var z = function (t, e, i) { var s, r, n = t._gsTweenID; if (I[n || (t._gsTweenID = n = "t" + F++)] || (I[n] = { target: t, tweens: [] }), e && (s = I[n].tweens, s[r = s.length] = e, i)) for (; --r > -1;)s[r] === e && s.splice(r, 1); return I[n].tweens }, U = function (t, e, i, s, r) { var n, a, o, h; if (1 === s || s >= 4) { for (h = r.length, n = 0; h > n; n++)if ((o = r[n]) !== e) o._gc || o._enabled(!1, !1) && (a = !0); else if (5 === s) break; return a } var l, _ = e._startTime + 1e-10, u = [], p = 0, f = 0 === e._duration; for (n = r.length; --n > -1;)(o = r[n]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (l = l || Y(e, 0, f), 0 === Y(o, l, f) && (u[p++] = o)) : _ >= o._startTime && o._startTime + o.totalDuration() / o._timeScale + 1e-10 > _ && ((f || !o._initted) && 2e-10 >= _ - o._startTime || (u[p++] = o))); for (n = p; --n > -1;)o = u[n], 2 === s && o._kill(i, t) && (a = !0), (2 !== s || !o._firstPT && o._initted) && o._enabled(!1, !1) && (a = !0); return a }, Y = function (t, e, i) { for (var s = t._timeline, r = s._timeScale, n = t._startTime, a = 1e-10; s._timeline;) { if (n += s._startTime, r *= s._timeScale, s._paused) return -100; s = s._timeline } return n /= r, n > e ? n - e : i && n === e || !t._initted && 2 * a > n - e ? a : (n += t.totalDuration() / t._timeScale / r) > e + a ? 0 : n - e - a }; s._init = function () { var t, e, i, s, r = this.vars, n = this._overwrittenProps, a = this._duration, o = r.immediateRender, h = r.ease; if (r.startAt) { if (this._startAt && this._startAt.render(-1, !0), r.startAt.overwrite = 0, r.startAt.immediateRender = !0, this._startAt = A.to(this.target, 0, r.startAt), o) if (this._time > 0) this._startAt = null; else if (0 !== a) return } else if (r.runBackwards && r.immediateRender && 0 !== a) if (this._startAt) this._startAt.render(-1, !0), this._startAt = null; else if (0 === this._time) { i = {}; for (s in r) E[s] && "autoCSS" !== s || (i[s] = r[s]); return i.overwrite = 0, this._startAt = A.to(this.target, 0, i), void 0 } if (this._ease = h ? h instanceof g ? r.easeParams instanceof Array ? h.config.apply(h, r.easeParams) : h : "function" == typeof h ? new g(h, r.easeParams) : v[h] || A.defaultEase : A.defaultEase, this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (t = this._targets.length; --t > -1;)this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], n ? n[t] : null) && (e = !0); else e = this._initProps(this.target, this._propLookup, this._siblings, n); if (e && A._onPluginEvent("_onInitAllProps", this), n && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), r.runBackwards) for (i = this._firstPT; i;)i.s += i.c, i.c = -i.c, i = i._next; this._onUpdate = r.onUpdate, this._initted = !0 }, s._initProps = function (e, i, s, r) { var n, a, o, h, l, _; if (null == e) return !1; this.vars.css || e.style && e !== t && e.nodeType && M.css && this.vars.autoCSS !== !1 && O(this.vars, e); for (n in this.vars) { if (_ = this.vars[n], E[n]) _ instanceof Array && -1 !== _.join("").indexOf("{self}") && (this.vars[n] = _ = this._swapSelfInParams(_, this)); else if (M[n] && (h = new M[n])._onInitTween(e, this.vars[n], this)) { for (this._firstPT = l = { _next: this._firstPT, t: h, p: "setRatio", s: 0, c: 1, f: !0, n: n, pg: !0, pr: h._priority }, a = h._overwriteProps.length; --a > -1;)i[h._overwriteProps[a]] = this._firstPT; (h._priority || h._onInitAllProps) && (o = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0) } else this._firstPT = i[n] = l = { _next: this._firstPT, t: e, p: n, f: "function" == typeof e[n], n: n, pg: !1, pr: 0 }, l.s = l.f ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), l.c = "string" == typeof _ && "=" === _.charAt(1) ? parseInt(_.charAt(0) + "1", 10) * Number(_.substr(2)) : Number(_) - l.s || 0; l && l._next && (l._next._prev = l) } return r && this._kill(r, e) ? this._initProps(e, i, s, r) : this._overwrite > 1 && this._firstPT && s.length > 1 && U(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, r)) : o }, s.render = function (t, e, i) { var s, r, n, a = this._time; if (t >= this._duration) this._totalTime = this._time = this._duration, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, r = "onComplete"), 0 === this._duration && ((0 === t || 0 > this._rawPrevTime) && this._rawPrevTime !== t && (i = !0, this._rawPrevTime > 0 && (r = "onReverseComplete", e && (t = -1))), this._rawPrevTime = t); else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === this._duration && this._rawPrevTime > 0) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === this._duration && (this._rawPrevTime >= 0 && (i = !0), this._rawPrevTime = t)) : this._initted || (i = !0); else if (this._totalTime = this._time = t, this._easeType) { var o = t / this._duration, h = this._easeType, l = this._easePower; (1 === h || 3 === h && o >= .5) && (o = 1 - o), 3 === h && (o *= 2), 1 === l ? o *= o : 2 === l ? o *= o * o : 3 === l ? o *= o * o * o : 4 === l && (o *= o * o * o * o), this.ratio = 1 === h ? 1 - o : 2 === h ? o : .5 > t / this._duration ? o / 2 : 1 - o / 2 } else this.ratio = this._ease.getRatio(t / this._duration); if (this._time !== a || i) { if (!this._initted) { if (this._init(), !this._initted) return; this._time && !s ? this.ratio = this._ease.getRatio(this._time / this._duration) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === this._duration) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || d))), n = this._firstPT; n;)n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next; this._onUpdate && (0 > t && this._startAt && this._startAt.render(t, e, i), e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || d)), r && (this._gc || (0 > t && this._startAt && !this._onUpdate && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || d))) } }, s._kill = function (t, e) { if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._enabled(!1, !1); e = "string" != typeof e ? e || this._targets || this.target : A.selector(e) || e; var i, s, r, n, a, o, h, l; if ((e instanceof Array || C(e)) && "number" != typeof e[0]) for (i = e.length; --i > -1;)this._kill(t, e[i]) && (o = !0); else { if (this._targets) { for (i = this._targets.length; --i > -1;)if (e === this._targets[i]) { a = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all"; break } } else { if (e !== this.target) return !1; a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all" } if (a) { h = t || a, l = t !== s && "all" !== s && t !== a && (null == t || t._tempKill !== !0); for (r in h) (n = a[r]) && (n.pg && n.t._kill(h) && (o = !0), n.pg && 0 !== n.t._overwriteProps.length || (n._prev ? n._prev._next = n._next : n === this._firstPT && (this._firstPT = n._next), n._next && (n._next._prev = n._prev), n._next = n._prev = null), delete a[r]), l && (s[r] = 1); !this._firstPT && this._initted && this._enabled(!1, !1) } } return o }, s.invalidate = function () { return this._notifyPluginsOfEnabled && A._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = !1, this._propLookup = this._targets ? {} : [], this }, s._enabled = function (t, e) { if (n || r.wake(), t && this._gc) { var i, s = this._targets; if (s) for (i = s.length; --i > -1;)this._siblings[i] = z(s[i], this, !0); else this._siblings = z(this.target, this, !0) } return k.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? A._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1 }, A.to = function (t, e, i) { return new A(t, e, i) }, A.from = function (t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new A(t, e, i) }, A.fromTo = function (t, e, i, s) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new A(t, e, s) }, A.delayedCall = function (t, e, i, s, r) { return new A(e, 0, { delay: t, onComplete: e, onCompleteParams: i, onCompleteScope: s, onReverseComplete: e, onReverseCompleteParams: i, onReverseCompleteScope: s, immediateRender: !1, useFrames: r, overwrite: 0 }) }, A.set = function (t, e) { return new A(t, 0, e) }, A.killTweensOf = A.killDelayedCallsTo = function (t, e) { for (var i = A.getTweensOf(t), s = i.length; --s > -1;)i[s]._kill(e, t) }, A.getTweensOf = function (t) { if (null == t) return []; t = "string" != typeof t ? t : A.selector(t) || t; var e, i, s, r; if ((t instanceof Array || C(t)) && "number" != typeof t[0]) { for (e = t.length, i = []; --e > -1;)i = i.concat(A.getTweensOf(t[e])); for (e = i.length; --e > -1;)for (r = i[e], s = e; --s > -1;)r === i[s] && i.splice(e, 1) } else for (i = z(t).concat(), e = i.length; --e > -1;)i[e]._gc && i.splice(e, 1); return i }; var j = c("plugins.TweenPlugin", function (t, e) { this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = j.prototype }, !0); if (s = j.prototype, j.version = "1.10.1", j.API = 2, s._firstPT = null, s._addTween = function (t, e, i, s, r, n) { var a, o; return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - i : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = { _next: this._firstPT, t: t, p: e, s: i, c: a, f: "function" == typeof t[e], n: r || e, r: n }, o._next && (o._next._prev = o), o) : void 0 }, s.setRatio = function (t) { for (var e, i = this._firstPT, s = 1e-6; i;)e = i.c * t + i.s, i.r ? e = 0 | e + (e > 0 ? .5 : -.5) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next }, s._kill = function (t) { var e, i = this._overwriteProps, s = this._firstPT; if (null != t[this._propName]) this._overwriteProps = []; else for (e = i.length; --e > -1;)null != t[i[e]] && i.splice(e, 1); for (; s;)null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next; return !1 }, s._roundProps = function (t, e) { for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next }, A._onPluginEvent = function (t, e) { var i, s, r, n, a, o = e._firstPT; if ("_onInitAllProps" === t) { for (; o;) { for (a = o._next, s = r; s && s.pr > o.pr;)s = s._next; (o._prev = s ? s._prev : n) ? o._prev._next = o : r = o, (o._next = s) ? s._prev = o : n = o, o = a } o = e._firstPT = r } for (; o;)o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next; return i }, j.activate = function (t) { for (var e = t.length; --e > -1;)t[e].API === j.API && (M[(new t[e])._propName] = t[e]); return !0 }, f.plugin = function (t) { if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition."; var e, i = t.propName, s = t.priority || 0, r = t.overwriteProps, n = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" }, a = c("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () { j.call(this, i, s), this._overwriteProps = r || [] }, t.global === !0), o = a.prototype = new j(i); o.constructor = a, a.API = t.API; for (e in n) "function" == typeof t[e] && (o[n[e]] = t[e]); return a.version = t.version, j.activate([a]), a }, e = t._gsQueue) { for (i = 0; e.length > i; i++)e[i](); for (s in u) u[s].func || t.console.log("GSAP encountered missing dependency: com.greensock." + s) } n = !1 }(window);
define("tweenMax", ["tweenlite"], function () { });

var ADM = window.ADM || {};

define('interactivemap/interactivemap', [
  'jquery',
  'settings',
  'UTILS',
  'googlemap/admMap',
  'utils/urlparser',
  'interactivemap/direction',
  'interactivemap/filters',
  'interactivemap/links',

  'tweenMax',
  'underscore'


], function ($, Settings, Utils, ADMMap, UrlParser, Direction, Filters, InteractivemapMenuLinks) {

  window.$ = $;
  var InteractiveMap = {
    map: null,
    panelUpdate: null,
    airportLatLng: Settings.map.airportLatLng,
    defaultPrintDirection: "https://maps.google.com/maps?q=A%C3%A9roport+international+Pierre-Elliott-Trudeau+de+Montr%C3%A9al,+Dorval,+QC,+Canada&hl=en&ie=UTF8&sll=38.410558,-95.712891&sspn=67.234306,135.263672&oq=A%C3%A9roport+international+Pierre-Elliott-Trudeau&t=m&z=17&iwloc=A&pw=1",
    iconsClassName: {
      up: "icon-arrow-up",
      right: "icon-arrow-right",
      left: "icon-arrow-left",
      down: "icon-arrow-down"
    },
    debugMode: false,
    init: function (context, eventEmitterDelegated) {

      //====================================
      // INIT GLOBAL VARS
      //====================================
      var eventEmitter = this.option.emitter || eventEmitterDelegated,
        $container = InteractiveMap.container = $(context);

      //Fix Google Map Visibility
      $("html").addClass("interactivemap");

      //Global Containers
      InteractiveMap.sections = {
        sectionMap: $(".sct-map", $container),
        sectionInteractive: $(".sct-interactive", $container)
      };

      if (InteractiveMap.sections.sectionMap && InteractiveMap.sections.sectionInteractive) {

        //Global Panels
        InteractiveMap.panels = {
          direction: $(".pnl-direction", InteractiveMap.sections.sectionInteractive),
          filters: $(".pnl-filters", InteractiveMap.sections.sectionInteractive)
        };

        //Get the ADM JSON
        InteractiveMap.getMapOptions(eventEmitter);

        //Set Footer Tools Events
        InteractiveMap.bindFooterTools($container, eventEmitter);

        //Set ALL Buttons Events
        InteractiveMap.bindToggle($container, eventEmitter);
      }
    },
    links: function (context) {
      InteractivemapMenuLinks.init(context);
    },
    bindFooterTools: function ($container, eventEmitter) {

      // ====================================================================================
      // Footer - Open the Share link panel
      // ====================================================================================
      var $footerTools = InteractiveMap.footerTools = $(".ft-tools", $container),
        $pnlShareLink = $(".share-link", $footerTools),
        $inputShareLink = $("input", $pnlShareLink),
        $btnCloseLink = $(".close-link", $footerTools),
        $btnPrint = $(".tools .print-button", $footerTools),
        $btnSharelink = $(".tools .sharelink-button", $footerTools),
        $panelsDirection = InteractiveMap.panels.direction;

      // ============================
      // Set the Share Link Visibility
      // ============================
      $footerTools.on('setShareVisible.INTERACTIVEMAP', function (e, params) {
        if (InteractiveMap.debugMode) console.log("setShareVisible.INTERACTIVEMAP", params);
        if (params) {
          $btnSharelink.show();
        } else {
          $btnSharelink.hide();
          $pnlShareLink.slideUp("easeOutExpo", function () {
            $inputShareLink.focus();
            $btnSharelink.removeClass("ui-open");
          });
        }
      });

      // ============================
      // Set the Share Link url in the input (textbox)
      // ============================
      $panelsDirection.on('setShareLink.INTERACTIVEMAP', function (e, params) {
        if (params) {
          $inputShareLink.val(params);
        }
      });

      // ============================
      // Set the Print Link button Visibility
      // ============================
      $footerTools.on('setPrintVisible.INTERACTIVEMAP', function (e, params) {
        if (InteractiveMap.debugMode) console.log("setPrintVisible.INTERACTIVEMAP", params);
        if (params) {
          $btnPrint.show();
          //console.log("test show");
        } else {
          $btnPrint.hide();
          //console.log("test hide");
        }
      });

      // ============================
      // Set the Print Link button
      //  Params :
      //      direction : Google url to print the direction [string]
      //      windowPrint : use window.print to print the map [boolean]
      // ============================
      $panelsDirection.on('setPrintLink.INTERACTIVEMAP', function (e, params) {
        if (params) {
          //Print Google Direction Map
          $btnPrint.attr("href", params.direction);
        }
      });

      // ============================
      // Print the Interactive Map Page
      // ============================
      //Initialize
      $panelsDirection.trigger("setPrintLink.INTERACTIVEMAP", [{ direction: InteractiveMap.defaultPrintDirection, windowPrint: false }]);

      // ============================
      // Close Link icon Button : Close the panel
      // ============================
      $btnCloseLink.bind("click", function (e) {
        e.preventDefault();
        $btnSharelink.trigger("click");
      });

      // ============================
      // Share Link icon Button : Open or close the panel
      // ============================
      $btnSharelink.bind("click", function (e) {
        e.preventDefault();

        var $this = $(this),
          effects = {
            easing: "easeOutExpo",
            duration: 400
          }

        if ($this.hasClass("ui-open")) {
          $pnlShareLink.slideUp(effects.easing, function () {
            $inputShareLink.focusout();
            $this.removeClass("ui-open");
          });
        } else {
          $pnlShareLink.slideDown(effects.easing, function () {
            $inputShareLink.focus();
            $this.addClass("ui-open");
          });
        }
      });
    },
    bindToggle: function ($container, eventEmitter) {

      //====================================
      // Control Panel - Open/Close
      //====================================
      var $toolbar = $(".toolbar", $container),
        $toolbarButtons = $(".btn-action", $toolbar),

        //Main btn to toggle (itineraire/localisateur)
        $btnMainItineraire = $(".btn-main-itineraire", $toolbar),
        $btnMainLocalisateur = $(".btn-main-localisateur", $toolbar),

        //Main Panel (interactive : Itinéraire/Filtres, map: Google Map)
        $panelMapContainer = InteractiveMap.sections.sectionMap,
        $panelInteractiveContainer = InteractiveMap.sections.sectionInteractive;

      // ============================
      // Panel Update : Open/Close the current panel (Direction/Filters)
      // Call by the Main Btn ($btnMainItineraire, $btnMainLocalisateur)
      // ============================
      var panelUpdate = InteractiveMap.panelUpdate = function (container, target) {


        if (target) {

          //Get the current platform
          var platform = Utils.getPlatform(),

            //Get the current desire panel name
            panelName = target.data("panel"),

            //Get the current click section
            interactivemapFilter = target.data("interactivemap-filter");

          //prevent double click event
          if (!target.hasClass("interactivemap-selected")) {

            //Remove all selected class
            $toolbarButtons.removeClass("interactivemap-selected");

            //Set the current selected element
            target.addClass("interactivemap-selected");

            //Close both panel
            InteractiveMap.panels.direction.hide();
            InteractiveMap.panels.filters.hide();

            //Open the target panel
            $("." + panelName, $container).fadeIn();

            //Show the Mobile Button
            if (platform == "mobile") {
              setMobileButtons(target);
            }

            /*
             *  Direction (itineraire)
             */
            if (interactivemapFilter == "itineraire") {
              //console.log("dataLayer", 'event', 'map_itinerary', 'itinerary_lang', Utils.getLang());
              dataLayer.push({
                'event': 'map_itinerary',
                'itinerary_lang': Utils.getLang()
              });

              InteractiveMap.footerTools.trigger('setShareVisible.INTERACTIVEMAP', [true]);
              InteractiveMap.footerTools.trigger('setPrintVisible.INTERACTIVEMAP', [true]);

              if (platform == "mobile") {
                InteractiveMap.footerTools.trigger('setPrintVisible.INTERACTIVEMAP', [false]);
              }

              InteractiveMap.panels.direction.trigger("setPrintLink.INTERACTIVEMAP", [{ direction: InteractiveMap.defaultPrintDirection, windowPrint: false }]);

              //Reset the direction (clear map and result)
              var reset = function () {
                InteractiveMap.panels.filters.trigger('removeFilters.INTERACTIVEMAP');

                //Optimization : In Mobile device, we executes the "directionsDisplay" function only when we click on the map button.
                if (platform != "mobile") {
                  //Directions Google Map Display
                  InteractiveMap.panels.direction.trigger('directionsDisplay.INTERACTIVEMAP');
                }
              };
            }
            /*
             *  Filtres (localisateur)
             */
            else if (interactivemapFilter == "localisateur") {
              //console.log("dataLayer", 'event', 'map_locator', 'itinerary_lang', Utils.getLang());
              dataLayer.push({
                'event': 'map_locator',
                'itinerary_lang': Utils.getLang()
              });

              InteractiveMap.footerTools.trigger('setShareVisible.INTERACTIVEMAP', [false]);
              InteractiveMap.footerTools.trigger('setPrintVisible.INTERACTIVEMAP', [true]);

              var printLink = $("#interactivemap").attr("data-print-map-url");
              InteractiveMap.panels.direction.trigger("setPrintLink.INTERACTIVEMAP", [{ direction: printLink, windowPrint: true }]);

              //Reset the direction (clear map and result) and reactive the filters markers if it's available
              var reset = function () {
                InteractiveMap.panels.direction.trigger('removeDirection.INTERACTIVEMAP');
                InteractiveMap.panels.filters.trigger('resetFilters.INTERACTIVEMAP');

                //Optimization : In Mobile device, we executes the "directionsDisplay" function only when we click on the map button.
                if (platform != "mobile") {
                  //Make sure markers are visible on the map with the new resize
                  InteractiveMap.panels.filters.trigger('checkBounds.INTERACTIVEMAP');
                }
              };
            }

            //Call reset function when the map is load or wait for google map to load
            if (ADM.googleMapScriptLoadState === 2) {
              reset();
            } else {
              eventEmitter.addListener('googleMapScriptLoaded', function () {
                reset();
              });
            }
          }
        }
      };

      // ============================
      // Link icon Button Click :
      // Open or close the interactive main panel and refresh the Google Map
      // ============================
      var $panelToggle = $(".panel-toggle", $container);

      //Reset to initiale parameters to the Panel Toggle button
      function resetPanelToggle() {
        $panelToggle.css("left", "0");
        $(".arrow", $panelToggle).removeClass(InteractiveMap.iconsClassName.left).addClass(InteractiveMap.iconsClassName.right);
        $panelToggle.removeClass("ui-open");
      };

      //Panel is animated width TweenMax (open/close)
      $panelToggle.bind("click", function (e) {
        e.preventDefault();

        var panelContainerWidth = $panelInteractiveContainer.width(),
          $this = $(this),
          thisWidth = $this.width(),
          $icon = $(".arrow", $this),
          getCenterPoint = "";

        var effects = {
          easing: "Expo.easeOut",
          duration: 0.4
        }

        if ($this.hasClass("ui-open")) {

          //Panel Interactive
          TweenMax.to(
            $panelInteractiveContainer,
            effects.duration, {
            css: { "left": "0" },
            ease: effects.easing,
            onStart: function () {
              $icon.removeClass(InteractiveMap.iconsClassName.left).addClass(InteractiveMap.iconsClassName.right);
              $this.removeClass("ui-open");
              //Get current center value
              getCenterPoint = InteractiveMap.map.getCenter();
            },
            onComplete: function () {
              //Show back the button
              TweenMax.to(
                $this,
                effects.duration, {
                css: { "left": "0" },
                ease: effects.easing
              });
              //Resize the map
              google.maps.event.trigger(InteractiveMap.map, 'resize');
              //Center the map with de current center value
              //airportLatLng = new google.maps.LatLng(getCenterPoint.d, getCenterPoint.e);
              InteractiveMap.map.setCenter(getCenterPoint);
            }
          });

          $panelInteractiveContainer.animate(
            effects.duration, {
            "left": 0,
            easing: effects.easing
          });

          //Panel Map
          TweenMax.to(
            $panelMapContainer,
            effects.duration, {
            css: { "marginLeft": panelContainerWidth },
            ease: effects.easing
          });

        } else {

          //Panel Interactive
          TweenMax.to(
            $panelInteractiveContainer,
            effects.duration, {
            css: { "left": "-" + panelContainerWidth },
            ease: effects.easing,
            onStart: function () {
              $this.css("left", "-" + Math.round(panelContainerWidth + thisWidth) + "px")
                .addClass("ui-open");
              $icon.removeClass(InteractiveMap.iconsClassName.right).addClass(InteractiveMap.iconsClassName.left);
              //Get current center value

              getCenterPoint = InteractiveMap.map.getCenter();
            },
            onComplete: function () {
              //Show back the button
              TweenMax.to(
                $this,
                effects.duration, {
                css: { "left": "-" + panelContainerWidth },
                ease: effects.easing
              });
              //Resize the map
              google.maps.event.trigger(InteractiveMap.map, 'resize');
              //Center the map with de current center value
              //airportLatLng = new google.maps.LatLng(getCenterPoint.d, getCenterPoint.e);

              InteractiveMap.map.setCenter(getCenterPoint);
            }
          });

          //Panel Map
          TweenMax.to(
            $panelMapContainer,
            effects.duration, {
            css: { "marginLeft": "0" },
            ease: effects.easing
          });
        }
      });

      // ============================
      // Set ToolBar Mobile Button Events
      // ============================

      //Mobile Buttons
      var $btnFilters = $(".btn-filters", $toolbar),
        $btnMap = $(".btn-map", $toolbar),
        $btnResults = $(".btn-results", $toolbar),
        $btnItineraire = $(".btn-itineraire", $toolbar),

        //All Buttons
        $btns = [$btnItineraire,
          $btnFilters,
          $btnResults,
          $btnMap
        ],

        //Panel to control (show/hide)
        $pnlNiveau = $(".pnl-niveau", InteractiveMap.panels.filters),
        $pnlAllZones = $(".pnl-zones", InteractiveMap.panels.filters),
        $pnlFilters = $(".container-filters", InteractiveMap.panels.filters),
        $pnlFiltersResults = $(".filters-results", InteractiveMap.panels.filters),

        //Panel to control the title [Filtres/Résultats] (show/hide)
        $pnlFiltersTitle = $(".pnl-filters-title", InteractiveMap.panels.filters),
        $pnlFiltersResultsTitle = $(".pnl-filters-results-title", InteractiveMap.panels.filters),

        //Element to control the Height
        $bodyInteractiveMap = $("body.interactive-map");

      //Fix the map height : set height to 100% when we click on the map button in mobile
      function setBodyHeight(bool) {
        if (bool) {
          $bodyInteractiveMap.css("height", "100%");
        } else {
          $bodyInteractiveMap.css("height", "");
        }
      };

      function showMap() {
        $panelMapContainer.show();
        $panelInteractiveContainer.hide();

        //To show the map...
        setBodyHeight(true);

        //Trigger Resize method to update the map container height
        $(window).trigger('resize');

        //Only when we are in the Filters section
        if ($btnMainLocalisateur.hasClass("selected")) {

          //Make sure markers are visible on the map with the new resize
          InteractiveMap.panels.filters.trigger('checkBounds.INTERACTIVEMAP');

          setTimeout(function () {
            //On mobile device, we center the infowindow if it's available on map
            //without this exeption, the infowindow will be in the corner...
            InteractiveMap.panels.filters.trigger('setInfoWindow.INTERACTIVEMAP');
          }, 200);

        } else if ($btnMainItineraire.hasClass("selected")) {

          //Directions Google Map Display
          InteractiveMap.panels.direction.trigger('directionsDisplay.INTERACTIVEMAP')
        }
      };

      function showInteractiveControl() {
        $panelMapContainer.hide();
        $panelInteractiveContainer.show();

        setBodyHeight(false);
      };

      /*
       * Show the good button on mobile device
       */
      function setMobileButtons(target) {

        if (target.hasClass("btn-main-localisateur")) {
          $btnFilters.trigger("click");

        } else if (target.hasClass("btn-main-itineraire")) {
          $btnItineraire.trigger("click");
        }
      };

      /*
       * Hide all button before active specific button and set the current click element
       * elt : current click btn
       * elts : array of visible btns
       */
      function updateMobileButtons(elt, elts) {

        //Hide all Button
        $.each($btns, function (key, data) {
          data.addClass("neutral avoid-clicks").removeClass("visible");
        });

        //Show Specific Button
        if (elts && elts.length > 0) {
          $.each(elts, function (key, data) {
            data.addClass("visible").removeClass("avoid-clicks");
          });
        }

        //Current Selected item
        if (elt) {
          $(elt).removeClass("neutral");
        }
      };

      $btnItineraire.bind("click", function (e) {
        e.preventDefault();

        updateMobileButtons(this, [$btnMap]);

        $pnlNiveau.show();
        $pnlAllZones.show();
        $pnlFilters.show();
        $pnlFiltersResults.hide();

        $pnlFiltersTitle.show();
        $pnlFiltersResultsTitle.hide();

        showInteractiveControl();
      });

      $btnFilters.bind("click", function (e) {
        e.preventDefault();

        updateMobileButtons(this, [$btnMap, $btnResults]);

        $pnlNiveau.show();
        $pnlAllZones.show();
        $pnlFilters.show();
        $pnlFiltersResults.hide();

        $pnlFiltersTitle.show();
        $pnlFiltersResultsTitle.hide();

        showInteractiveControl();
      });

      $btnResults.bind("click", function (e) {
        e.preventDefault();

        updateMobileButtons(this, [$btnFilters, $btnMap]);

        $pnlNiveau.hide();
        $pnlAllZones.hide();
        $pnlFilters.hide();
        $pnlFiltersResults.show().focus();

        $pnlFiltersTitle.hide();
        $pnlFiltersResultsTitle.show();

        showInteractiveControl();
      });

      $btnMap.bind("click", function (e) {
        e.preventDefault();

        //To know which panel is selected to show the good elements
        if ($btnMainItineraire.hasClass("selected")) {
          updateMobileButtons(this, [$btnItineraire]);

        } else if ($btnMainLocalisateur.hasClass("selected")) {
          updateMobileButtons(this, [$btnFilters, $btnResults]);
        }

        $pnlNiveau.show();
        $pnlAllZones.show();
        $pnlFilters.show();
        $pnlFiltersResults.hide();

        $pnlFiltersTitle.show();
        $pnlFiltersResultsTitle.hide();

        showMap();
      });

      // ============================
      // Trigger Responsive State
      // ============================
      function setDesktop() {
        //console.log('--- setDesktop');
        if (InteractiveMap.debugMode) console.warn("setDesktop");

        //Hide Toolbar Button Link (use for mobile only)
        updateMobileButtons();

        $pnlNiveau.show();
        $pnlAllZones.show();
        $pnlFilters.show();
        $pnlFiltersResults.show();

        $pnlFiltersTitle.hide();
        $pnlFiltersResultsTitle.hide();

        $panelMapContainer.css("margin-left", "").show();
        $panelInteractiveContainer.css("left", "0").show();

        resetPanelToggle();

        //Show the Print link button
        InteractiveMap.footerTools.trigger('setPrintVisible.INTERACTIVEMAP', [true]);
      };

      function setMobile() {
        //console.log('--- setMobile');
        if (InteractiveMap.debugMode) console.warn("setMobile");

        //To know which panel is selected to show the good elements
        if ($btnMainItineraire.hasClass("selected")) {
          $btnItineraire.trigger("click");

        } else if ($btnMainLocalisateur.hasClass("selected")) {
          $btnFilters.trigger("click");
        }

        //Reset the interactive main panel if it's close
        $panelMapContainer.css("margin-left", "0");
        $panelInteractiveContainer.css("left", "0");

        //Hide the Print link button
        InteractiveMap.footerTools.trigger('setPrintVisible.INTERACTIVEMAP', [false]);

        //Modernizr exeption for the Windows Phone (modernizr puts the class "no-touch" but, in fact, the Windows Phone is "touch")
        //This class is used to desactivate Interactive Map in orientation landscape.
        var isWindowsPhone = navigator.userAgent.match(/IEMobile/);
        if (isWindowsPhone) $("html").addClass("windowphone-touch");
      };

      // ============================
      // Listen Trigger Event
      // ============================

      /*
       * PlaformChanged : when the plaform changed.
       * It's to determine the Responsive State (Desktop/Mobile)
       */
      eventEmitter.addListener('plaformChanged', function (platform) {
        if (platform != "mobile") {
          setDesktop();
        } else if (platform == "mobile") {
          //Dont activated mobile in the IE8, IE7, IE6
          if (!Utils.isIE8OrLower()) {
            setMobile();
          }
        }
      });

      /*
       * Panel Update Method : to update the 2 main panel (InteractiveMap.panel.x)
       * Call by the Main Btn ($btnMainItineraire, $btnMainLocalisateur)
       */
      eventEmitter.addListener("interactivemap-panelupdate", panelUpdate);

      // ============================
      // Globals Event
      // ============================

      // Show the map (trigger by the results links in the filters.js)
      InteractiveMap.panels.filters.on('showMap.INTERACTIVEMAP', function (e, params) {
        $btnMap.trigger("click");
      });

      // Show the map (trigger by the init in the direction.js)
      InteractiveMap.panels.direction.on('showMap.INTERACTIVEMAP', function (e, params) {
        $btnMap.trigger("click");
      });

      // Localisateur (Filters) Main panel Btn
      InteractiveMap.panels.filters.on('triggerMainFilters.INTERACTIVEMAP', function (e, params) {
        $btnMainLocalisateur.trigger("click");
      });

      // Itinéraire (Direction) Main panel Btn
      InteractiveMap.panels.direction.on('triggerMainDirection.INTERACTIVEMAP', function (e, params) {
        $btnMainItineraire.trigger("click");
      });

      // ============================
      // Bind an event to window.resize, when the device is turned.
      // ============================
      $(window).on("resize", _.throttle(function (e) {
        // To update the map container height
        var getViewportHeight = $(window).height(),
          setHeight = Math.round(getViewportHeight - 100),
          $gmapContainerCss = $(".admMapContainer", $container);

        if (platform == "mobile") {
          $gmapContainerCss.css("height", setHeight);
          $panelMapContainer.css("height", setHeight);
        } else {
          $gmapContainerCss.css("height", "");
          $panelMapContainer.css("height", "");
        }

        if (typeof google !== "undefined" && InteractiveMap.map !== null) {
          //Resize the map to fit the map container
          google.maps.event.trigger(InteractiveMap.map, 'resize');
        }

      }, 500));

    },
    getMapOptions: function (eventEmitter) {
      //console.log('getMapOptions', eventEmitter);

      //Get the Url Map Options and Markers
      var url;
      if (typeof window.QUnit !== 'undefined' || Settings.interactivemap.mockData) {
        url = Settings.webServicePath.interactivemapMock;
      } else {
        url = Settings.webServicePath.interactivemap;
      }

      $.ajax({
        type: 'GET',
        url: url,
        dataType: "json",
        timeout: 10000,
        success: function (data) {
          //console.log('   ajax success', data);

          if (InteractiveMap.debugMode) console.warn("ajax filters options loaded");

          InteractiveMap.loadMap(data, eventEmitter);

          if (typeof window.QUnit !== 'undefined') {
            test("AJAX Test :", function () {
              console.log("AJAX Test '" + url + "': Success");
              ok(true, "Success");
            });
          }
        },
        error: function (jqXHR, textStatus, errorThrown) {
          if (InteractiveMap.debugMode) {
            console.warn("ajax filters options not loaded");
            console.log("error jqXHR = ", jqXHR);
            console.log("error textStatus = ", textStatus);
            console.log("error errorThrown = ", errorThrown);
          }
          if (typeof window.QUnit !== 'undefined') {
            test("AJAX Test :", function () {
              console.log("AJAX Test '" + url + "': Fail");
              ok(false, "Fail");
            });
          }
        }
      });
    },
    loadMap: function (options, eventEmitter) {
      //console.log('loadMap', options, eventEmitter);
      //options = data JSON

      /* Map instance */
      (function () {

        var $mapContainer = InteractiveMap.sections.sectionMap;

        // ============================
        // Validate if parameter is available - Prevent error
        // ============================
        function isParamValid(elt) {
          var status = false;
          if (elt !== undefined && elt.length > 0) {
            status = true;
          }
          return status
        };

        // ============================
        // Default Filters options value
        // ============================

        //Prevent error when we load the overlay in desktop platform
        if (typeof (platform) == 'undefined') {
          var platform = Utils.getPlatform();
        }
        // Default startup Zoom
        var zoom = (platform === "mobile") ? 16 : 16,

          //Current Platform
          device = $('body').data('device'),
          isDesktop = (device === 'desktop') ? true : false;

        /*
         * Filters Params - send to the Filters Init method
         *  filtersId : Get Filters Id
         *  panel : Get Panel to open (filters/direction)
         *  level : Set Level (departure, arrival, all)
         *  zones : Set Zones (public,domestic,international,transborder,all)
         *  zoom : set zoom level [integer]
         *  directionStart : direction start name [string]
         *  directionEnd : direction end name [string]
         *  directionCenterPoint : latitude And longitude point [lat,lng]
         *  directionCenterZoom : set center zoom level [integer]
         */
        setupLoadOptions = {
          filtersId: "",
          panel: "direction",
          level: "departure",
          zones: "all",
          zoom: zoom,
          directionStart: "",
          directionEnd: "",
          directionCenterPoint: "",
          directionCenterZoom: "",
          mobileDirectToMap: false
        },
          overrightSetupLoadOptions = {};

        // ============================
        // Get Parameters (urlParser) - Active specific fonctionalities
        // ============================

        //Get all params to set the Filters options value and toggle panel
        var url, params, paramsFiltersId, paramPanel, paramLevel, paramZones, paramDstart, mobileDirectToMap;

        if (platform == "mobile") {
          //return params of window.location
          params = UrlParser.init();

        } else {

          //Get the Links Params (return ajax call)
          url = InteractiveMap.container.data("interactivemap-params");

          // ============================
          // TO DELETE : TEST ONLY
          /*
          var url;
          //Filters
          if(Settings.interactivemap.mockData){
              //url = "//www.admtl.com/?panel=filters&level=arrival&zones=public&filterid=toilettes,stationnementaerogare";
              url = "//www.admtl.com/?panel=filters&level=arrival&zones=public&filterid=restaurants,bar";
          }else{
              url = "//www.admtl.com/?panel=filters&level=arrival&zones=public&filterid=113,146,153";
          }
          //Direction
          //url = "//www.admtl.com/?panel=direction&dstart=Candiac,%20QC,%20Canada";
          */
          // ============================

          //Condition to test the page directly as mobile device...
          if (typeof (url) == 'undefined') {
            //return params of window.location
            params = UrlParser.init();
          } else {
            //return params of the specific url string
            params = UrlParser.init(url);
          }
        }

        if (params.length > 0) {

          // Set Filters Id
          paramFiltersId = params['filterid'];
          if (isParamValid(paramFiltersId)) {
            paramFiltersId.replace("#", "");
            overrightSetupLoadOptions.filtersId = paramFiltersId;
          }

          // Set Panel to open
          paramtrackingevent = params['trackingevent'];
          if (isParamValid(paramtrackingevent)) {
            //fix tracking event bug with dataLayer
            setTimeout(function () {
              //console.log("dataLayer", 'event',  paramtrackingevent+ '_'+Utils.getLang() );
              dataLayer.push({ 'event': paramtrackingevent + '_' + Utils.getLang() });
            }, 200);


          }

          paramPanel = params['panel'];
          if (isParamValid(paramPanel)) { overrightSetupLoadOptions.panel = paramPanel; }


          // Set Level
          paramLevel = params['level'];
          if (isParamValid(paramLevel)) { overrightSetupLoadOptions.level = paramLevel; }

          // Zones
          paramZones = params['zones'];
          if (isParamValid(paramZones)) { overrightSetupLoadOptions.zones = paramZones; }

          // Direction Start
          paramDstart = params['dstart'];
          if (isParamValid(paramDstart)) { overrightSetupLoadOptions.directionStart = paramDstart; }

          // Direction End
          paramDend = params['dend'];
          if (isParamValid(paramDend)) { overrightSetupLoadOptions.directionEnd = paramDend; }

          // Direction - Center point
          paramDcenterpoint = params['dcenter'];
          if (isParamValid(paramDcenterpoint)) { overrightSetupLoadOptions.directionCenterPoint = paramDcenterpoint; }

          // Direction - Center point
          paramDczoom = params['dczoom'];
          if (isParamValid(paramDczoom)) { overrightSetupLoadOptions.directionCenterZoom = paramDczoom; }

          // Direction - Center point

          mobileDirectToMap = false;
          if (params['mobiledirecttomap'] === 'true' || params['mobiledirecttomap'] === '1') {
            mobileDirectToMap = true;
          }
          overrightSetupLoadOptions.mobileDirectToMap = mobileDirectToMap;
          options.mobileDirectToMap = mobileDirectToMap;
        }

        $.extend(setupLoadOptions, overrightSetupLoadOptions);

        //Trigger the good main section panel to show
        if (setupLoadOptions.panel == "filters") {
          InteractiveMap.panels.filters.trigger('triggerMainFilters.INTERACTIVEMAP');
        }
        else if (setupLoadOptions.panel == "direction") {
          InteractiveMap.panels.direction.trigger('triggerMainDirection.INTERACTIVEMAP');
        }

        if (InteractiveMap.debugMode) {
          console.log("Google Map - panel = ", setupLoadOptions.panel);
          console.log("Google Map - level = ", setupLoadOptions.level);
          console.log("Google Map - zones = ", setupLoadOptions.zones);
          console.log("Google Map - filters Id = ", setupLoadOptions.filtersId);
        }

        $(".preloader").removeClass("visible").addClass("hidden");

        // ============================
        // ADM Map Object
        // ============================
        var mapObject = ADMMap.getInstance($mapContainer, {
          //defaultOpts
          level: setupLoadOptions.level,
          zones: setupLoadOptions.zones,
          parkings: true,
          gates: (isDesktop) ? true : false,
          //defaultGoogleMapOpts
          gMapOpts: {
            zoom: setupLoadOptions.zoom,
            minZoom: 2
          },
          onReady: function (i) {
            //console.log('ADMMap.instance.onReady');
            var map = InteractiveMap.map = i.map;

            //Remove the preloader when the map is ready
            $(".preloader").removeClass("visible").addClass("hidden");

            //Load Direction
            Direction.init(InteractiveMap.panels.direction, mapObject, options, setupLoadOptions);

            //Load Filters
            Filters.init(InteractiveMap.panels.filters, mapObject, options, setupLoadOptions);

            //Set Controls layer (Traffic/Transit)
            InteractiveMap.setControlsLayer(map);

            //Set Geolocation
            InteractiveMap.geoLocalisation(map, $mapContainer);

            // Listen for the dragend event
            google.maps.event.addListener(map, 'dragend', function () {

              /*
               * Limit map to North America Boundaries
               */

              // Bounds for North America
              var strictBounds = new google.maps.LatLngBounds(
                new google.maps.LatLng(28.70, -127.50),
                new google.maps.LatLng(48.85, -55.90)
              );

              if (strictBounds.contains(map.getCenter())) return;

              // We're out of bounds - Move the map back to the airport
              map.setCenter(InteractiveMap.airportLatLng);
              map.setZoom(setupLoadOptions.zoom);
            });

          }//onReady
        });//mapObject
      })();//Map instance




    },
    setControlsLayer: function (map) {

      // ============================
      // Set Controls layer (Traffic/Transit)
      // ============================
      var $filterLayers = $(".filter-layers"),
        $layers = $(".layers", $filterLayers),
        $trafficLayers = $("input#traffic-layers", $filterLayers),
        $transitLayer = $("input#transit-layers", $filterLayers),
        $btnLayers = $(".btn-layers", $filterLayers),
        trafficLayer = new google.maps.TrafficLayer(),
        transitLayer = new google.maps.TransitLayer();

      //Set the Traffic layer
      $trafficLayers.bind("click", function (e) {
        if ($(this).is(':checked')) {
          trafficLayer.setMap(map);
        } else {
          trafficLayer.setMap(null);
        }
      });

      //Set the Transit layer
      $transitLayer.bind("click", function (e) {
        if ($(this).is(':checked')) {
          transitLayer.setMap(map);
        } else {
          transitLayer.setMap(null);
        }
      });

      //Set the Open/Close layer panel
      $btnLayers.bind("click", function (e) {
        e.preventDefault();

        var $this = $(this),
          $icon = $(".icon", $btnLayers);
        effects = {
          easing: "easeOutExpo",
          duration: 500
        };

        if ($this.hasClass("ui-open")) {
          $layers.slideUp(effects.duration, effects.easing, function () {
            $btnLayers.removeClass("ui-open").removeClass("selected");
            $icon.removeClass(InteractiveMap.iconsClassName.up).addClass(InteractiveMap.iconsClassName.down);
          });
        } else {
          $layers.slideDown(effects.duration, effects.easing, function () {
            $btnLayers.addClass("ui-open").addClass("selected");
            $icon.removeClass(InteractiveMap.iconsClassName.down).addClass(InteractiveMap.iconsClassName.up);
          });
        }
      });
    },
    geoLocalisation: function (map, $mapContainer) {

      // ============================
      // Geolocation
      // ============================

      //Get the marker and center position map to the current position
      var geoMarker,
        airMarker;

      //Get and return the marker and center position map to the current position
      function getMarker(position, icon) {
        return Filters.setGeoLocMarker(map, position, icon);
      }

      //Add marker and center the map to the current position
      function addMarker(m) {
        // Center the marker point
        map.setCenter(m.center);

        //Add marker
        m.marker.setMap(map);
      }

      //Remove marker on map
      function removeMarker(m) {
        m.marker.setMap(null);
      }

      //Get and set the Geolocalisation
      function initGeolocalisation() {

        // Html structure - Mobile Only
        var geolocationHtml = $('<div class="geolocation is-mobile-only"><a class="geo"><span class="icon icon-geolocalisation"></span></a><a class="air"><span class="icon icon-logo"></span></a></div>');

        // Append Html fragment
        $mapContainer.append(geolocationHtml);

        // Get links in fragment and attach event
        var $links = $('.geolocation', $mapContainer),
          $geoLink = $('.geo', $links),
          $airLink = $('.air', $links);

        // Public method to get current position
        function getGeoPosition() {
          navigator.geolocation.getCurrentPosition(onGeolocationSuccess, onGeolocationError, { maximumAge: 15000, timeout: 25000 });
        };

        /*
         * Geolocation Success Callback
         */
        function onGeolocationSuccess(position) {

          var thePosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
          };

          /*
           * Set the geolocation marker and position
           */

          //Get the marker and center position map to the current position
          geoMarker = getMarker(thePosition, "filter_home");

          //Add Marker on map
          addMarker(geoMarker);

          //Toggle the geolocation and airport button
          $geoLink.hide();
          $airLink.css("display", "block");
        };

        /*
         * Geolocation Error Callback
         */
        function onGeolocationError(error) {

          var errorText = "";

          switch (error.code) {
            case error.PERMISSION_DENIED:
              if (InteractiveMap.debugMode) console.log("User denied the request for Geolocation.");
              errorText = "User denied the request for Geolocation.";
              break;
            case error.POSITION_UNAVAILABLE:
              if (InteractiveMap.debugMode) console.log("Location information is unavailable.");
              errorText = "Location information is unavailable.";
              break;
            case error.TIMEOUT:
              if (InteractiveMap.debugMode) console.log("The request to get user location timed out.");
              errorText = "The request to get user location timed out.";
              break;
            default:
              if (InteractiveMap.debugMode) console.log("An unknown error occurred.");
              errorText = "An unknown error occurred.";
              break;
          }
        };

        /*
         * Set the current user position
         */
        $geoLink.bind("click", function (e) {
          //Set Geolocation
          getGeoPosition();

          //Remove previous airport Marker
          removeMarker(airMarker);
        });

        /*
         * Set the airport marker and position
         */

        //Get the marker and center position map to the current position
        airMarker = getMarker(InteractiveMap.airportLatLng, "filter_logo");

        $airLink.bind("click", function (e) {
          //Add Marker on map
          addMarker(airMarker);

          //Remove previous geolocation Marker
          removeMarker(geoMarker);

          //Toggle the geolocation and airport button
          $airLink.hide();
          $geoLink.css("display", "block");
        });
      };

      // Test if Geolocation is available
      var isAvailable = function () {
        return navigator.geolocation;
      },
        isGeolocationAvailable = isAvailable();

      // Init Geolocation
      if (isGeolocationAvailable) {
        initGeolocalisation();
      }
    }
  };

  // ============================
  // Public Object
  // ============================
  return InteractiveMap;
});

var ADM = window.ADM || {};

define('utils/ajaxMarkup', [
  'jquery',

  'enhance'
], function ($) {



  var AjaxMarkup = {
    init: function (context) {

      $(context).each(function (i, elt) {
        var $elt = $(elt);
        var url = $elt.attr("data-markup-url");

        $.get(url, function (data) {
          $elt.html(data);
          $elt.enhance();
        });

      });

    }
  };

  return AjaxMarkup;
});
/**
* RequireJS plugin for optional module loading.
*/
define('requirePlugins/optional', [], function () {
  /** Default value to return when a module failed to load. */
  var DEFAULT = null;

  function load(moduleName, parentRequire, onload) {
    parentRequire([moduleName], onload, function (err) {
      var failedModule = err.requireModules && err.requireModules[0];
      console.warn("Could not load optional module: " + failedModule);
      requirejs.undef(failedModule);

      define(failedModule, [], function () { return DEFAULT; });
      parentRequire([failedModule], onload);
    });
  }

  return {
    load: load,
  };

});



define('forms/newsFormSel', [
  'jquery',
  'UTILS'
], function ($, Utils) {
  var NewsFormSel = {
    init: function (context) {
      var _t = this;

      require([
        'optional!https://trk.publitrac.com/js/processform.js',
        "optional!https://trk.publitrac.com/js/nobots.js",
        "optional!https://app.publitrac.com/Publipage/PubliPage.Forms.WebForms-min.js"

      ], function (processForm, noBot, publipageWebform) {
        if (processForm !== null && noBot !== null && publipageWebform !== null) {
          $(context).each(function (index, el) {
            new NewsFormSelInstance(el);
          });
        } else {
          librariesLoadingErrorHandler(context);
        }
      });
    }
  };

  function librariesLoadingErrorHandler(context) {
    $(context).find('.emailing-form-unavailable').show();
    $(context).find('.emailing-form-fields').hide();
  }


  function NewsFormSelInstance(el) {
    var $el = $(el),
      formId = $el.attr("id"),
      $submit = $el.find("[type='submit']"),
      $email = $el.find(".nlEmailField"),
      $recaptcha = $el.find(".nlRecaptchaField"),
      lang = Utils.getLang();

    var recaptchaValidated = false;

    $submit.on('click', function (evt) {
      evt.preventDefault();

      var isEmailValidated = Nl.validateField($email[0], lang + "_CA");

      if (!recaptchaValidated) {

        $.ajax({
          method: "POST",
          url: "/" + lang + "/captcha/validation",
          async: false,
          data: { "g-recaptcha-response": $('.g-recaptcha-response').val() }
        })
          .done(function (data) {
            var count = data.length;
            $recaptcha.removeClass("nlError");
            ($recaptcha).children(".nlFormMsg").html("");

            if (data.result) {
              recaptchaValidated = true;

            } else {
              $recaptcha.addClass("nlError");
              $.each(data, function (i, error) {
                if (i > 0 && i < count) ($recaptcha).children(".nlFormMsg").append('<br>');
                ($recaptcha).children(".nlFormMsg").append(error);
              });
            }
          });
      }

      if (isEmailValidated && recaptchaValidated) {
        submitToPublitrac($el, $email.val(), formId, lang);
      }

    });
  }

  function submitToPublitrac($el, emailValue, formId, lang) {
    var $subscriber = $el.closest(".emailing-form-subcriber"),
      $confirmation = $subscriber.next(".emailing-form-confirmation");


    PubliPage.Forms.WebForms.config.apiKey = '72c8d07a-68e8-11e8-945f-22000bcdecea';
    PubliPage.Forms.WebForms.config.formId = formId;

    PubliPage.Forms.WebForms.config.fields.Email = emailValue;
    PubliPage.Forms.WebForms.config.fields.FirstName = "";
    PubliPage.Forms.WebForms.config.fields.LastName = "";
    PubliPage.Forms.WebForms.config.fields.Language = lang;


    PubliPage.Forms.WebForms.onPostedForm.callback = function (data) {
      $subscriber.addClass('is-inactive');
      $confirmation.addClass('is-active');

      if (console != undefined) {
        console.log('On Posted Form: ' + data);
      }
    };
    PubliPage.Forms.WebForms.onError.callback = function (error) {
      if (console != undefined) {
        console.log('Error: ' + error);
      }
    };

    PubliPage.Forms.WebForms.post();
  }


  return NewsFormSel;
});
define('GA4/GA4', [
], function () {


  return {
    init: function () {
      // OVERVIEW 5 BUBBLE
      let links = document.getElementsByClassName("overview-link");
      for (let i = 0; i < links.length; i++) {
        links[i].addEventListener("click", function (event) {
          window.dataLayer.push({
            "label": "MORE " + event.target.parentNode.previousElementSibling.innerText,
            "event": "internal_cta",
            "url": event.target.href,
            "current_page": "YMX Overview",
          });
        });
      }
      // MENU DU HAUT
      links = document.querySelectorAll('.main-nav-primary a');
      for (let i = 0; i < links.length; i++) {
        links[i].addEventListener("click", function (event) {
          window.dataLayer.push({
            'event': 'navigation',
            'label': event.target.firstChild.nextSibling.innerText,
            'current_page': document.getElementsByTagName("title")[0].innerText,
          });
        });
      }
      // MENU DE GAUCHE
      links = document.getElementsByClassName("side-menu-link");
      for (let i = 0; i < links.length; i++) {
        links[i].addEventListener("click", function () {
          window.dataLayer.push({
            'event': 'on_page_navigation',
            'label': links[i].firstChild ?
              (
                links[i].firstChild.nextSibling ?
                  links[i].firstChild.nextSibling.innerText :
                  'event triggered on invalid element'
              ) :
              'event triggered on invalid element',
            'current_page': document.getElementsByTagName("title")[0].innerText,
          });
        });
      }
      // SOCIAL
      const $toolsLinks = document.querySelectorAll('.sharing-tools a');
      for (let i = 0; i < $toolsLinks.length; i++) {
        $toolsLinks[i].addEventListener("click", function () {
          window.dataLayer.push({
            'event': 'external_cta',
            'label': $toolsLinks[i].firstChild ? $toolsLinks[i].firstChild.innerText : 'event triggered on invalid element',
            'current_page': document.getElementsByTagName("title")[0].innerText,
          })
        });
      }
      links = document.querySelectorAll('.linkedin');
      for (let i = 0; i < links.length; i++) {
        links[i].addEventListener("click", function () {
          window.dataLayer.push({
            'event': 'external_cta',
            'label': "linked in",
            'current_page': document.getElementsByTagName("title")[0].innerText,
          });
        });
      }
    }
  };
});

define('YMX/noFog', [
], function () {

  return {
    //usage : copy <div class="enhance" data-enhance="removeFog"></div> in the wysiwyg of the page you wanna disable fog for
    init: function () {
      const elems = document.querySelectorAll(".region-bg");
      for (let i = 0; i < elems.length; i++) {
        elems[i].classList.add("no-fog");
      }
    }
  };
});

// Generated by CoffeeScript 1.6.2
/*
jQuery Waypoints - v2.0.3
Copyright (c) 2011-2013 Caleb Troughton
Dual licensed under the MIT license and GPL license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/


(function () {
  var __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define('waypoints', ['jquery'], function ($) {
        return factory($, root);
      });
    } else {
      return factory(root.jQuery, root);
    }
  })(this, function ($, window) {
    var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods, resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps;

    $w = $(window);
    isTouch = __indexOf.call(window, 'ontouchstart') >= 0;
    allWaypoints = {
      horizontal: {},
      vertical: {}
    };
    contextCounter = 1;
    contexts = {};
    contextKey = 'waypoints-context-id';
    resizeEvent = 'resize.waypoints';
    scrollEvent = 'scroll.waypoints';
    waypointCounter = 1;
    waypointKey = 'waypoints-waypoint-ids';
    wp = 'waypoint';
    wps = 'waypoints';
    Context = (function () {
      function Context($element) {
        var _this = this;

        this.$element = $element;
        this.element = $element[0];
        this.didResize = false;
        this.didScroll = false;
        this.id = 'context' + contextCounter++;
        this.oldScroll = {
          x: $element.scrollLeft(),
          y: $element.scrollTop()
        };
        this.waypoints = {
          horizontal: {},
          vertical: {}
        };
        $element.data(contextKey, this.id);
        contexts[this.id] = this;
        $element.bind(scrollEvent, function () {
          var scrollHandler;

          if (!(_this.didScroll || isTouch)) {
            _this.didScroll = true;
            scrollHandler = function () {
              _this.doScroll();
              return _this.didScroll = false;
            };
            return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle);
          }
        });
        $element.bind(resizeEvent, function () {
          var resizeHandler;

          if (!_this.didResize) {
            _this.didResize = true;
            resizeHandler = function () {
              $[wps]('refresh');
              return _this.didResize = false;
            };
            return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle);
          }
        });
      }

      Context.prototype.doScroll = function () {
        var axes,
          _this = this;

        axes = {
          horizontal: {
            newScroll: this.$element.scrollLeft(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left'
          },
          vertical: {
            newScroll: this.$element.scrollTop(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up'
          }
        };
        if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
          $[wps]('refresh');
        }
        $.each(axes, function (aKey, axis) {
          var direction, isForward, triggered;

          triggered = [];
          isForward = axis.newScroll > axis.oldScroll;
          direction = isForward ? axis.forward : axis.backward;
          $.each(_this.waypoints[aKey], function (wKey, waypoint) {
            var _ref, _ref1;

            if ((axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll)) {
              return triggered.push(waypoint);
            } else if ((axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll)) {
              return triggered.push(waypoint);
            }
          });
          triggered.sort(function (a, b) {
            return a.offset - b.offset;
          });
          if (!isForward) {
            triggered.reverse();
          }
          return $.each(triggered, function (i, waypoint) {
            if (waypoint.options.continuous || i === triggered.length - 1) {
              return waypoint.trigger([direction]);
            }
          });
        });
        return this.oldScroll = {
          x: axes.horizontal.newScroll,
          y: axes.vertical.newScroll
        };
      };

      Context.prototype.refresh = function () {
        var axes, cOffset, isWin,
          _this = this;

        isWin = $.isWindow(this.element);
        cOffset = this.$element.offset();
        this.doScroll();
        axes = {
          horizontal: {
            contextOffset: isWin ? 0 : cOffset.left,
            contextScroll: isWin ? 0 : this.oldScroll.x,
            contextDimension: this.$element.width(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left',
            offsetProp: 'left'
          },
          vertical: {
            contextOffset: isWin ? 0 : cOffset.top,
            contextScroll: isWin ? 0 : this.oldScroll.y,
            contextDimension: isWin ? $[wps]('viewportHeight') : this.$element.height(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up',
            offsetProp: 'top'
          }
        };
        return $.each(axes, function (aKey, axis) {
          return $.each(_this.waypoints[aKey], function (i, waypoint) {
            var adjustment, elementOffset, oldOffset, _ref, _ref1;

            adjustment = waypoint.options.offset;
            oldOffset = waypoint.offset;
            elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp];
            if ($.isFunction(adjustment)) {
              adjustment = adjustment.apply(waypoint.element);
            } else if (typeof adjustment === 'string') {
              adjustment = parseFloat(adjustment);
              if (waypoint.options.offset.indexOf('%') > -1) {
                adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
              }
            }
            waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment;
            if ((waypoint.options.onlyOnScroll && (oldOffset != null)) || !waypoint.enabled) {
              return;
            }
            if (oldOffset !== null && (oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset)) {
              return waypoint.trigger([axis.backward]);
            } else if (oldOffset !== null && (oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset)) {
              return waypoint.trigger([axis.forward]);
            } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
              return waypoint.trigger([axis.forward]);
            }
          });
        });
      };

      Context.prototype.checkEmpty = function () {
        if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
          this.$element.unbind([resizeEvent, scrollEvent].join(' '));
          return delete contexts[this.id];
        }
      };

      return Context;

    })();
    Waypoint = (function () {
      function Waypoint($element, context, options) {
        var idList, _ref;

        options = $.extend({}, $.fn[wp].defaults, options);
        if (options.offset === 'bottom-in-view') {
          options.offset = function () {
            var contextHeight;

            contextHeight = $[wps]('viewportHeight');
            if (!$.isWindow(context.element)) {
              contextHeight = context.$element.height();
            }
            return contextHeight - $(this).outerHeight();
          };
        }
        this.$element = $element;
        this.element = $element[0];
        this.axis = options.horizontal ? 'horizontal' : 'vertical';
        this.callback = options.handler;
        this.context = context;
        this.enabled = options.enabled;
        this.id = 'waypoints' + waypointCounter++;
        this.offset = null;
        this.options = options;
        context.waypoints[this.axis][this.id] = this;
        allWaypoints[this.axis][this.id] = this;
        idList = (_ref = $element.data(waypointKey)) != null ? _ref : [];
        idList.push(this.id);
        $element.data(waypointKey, idList);
      }

      Waypoint.prototype.trigger = function (args) {
        if (!this.enabled) {
          return;
        }
        if (this.callback != null) {
          this.callback.apply(this.element, args);
        }
        if (this.options.triggerOnce) {
          return this.destroy();
        }
      };

      Waypoint.prototype.disable = function () {
        return this.enabled = false;
      };

      Waypoint.prototype.enable = function () {
        this.context.refresh();
        return this.enabled = true;
      };

      Waypoint.prototype.destroy = function () {
        delete allWaypoints[this.axis][this.id];
        delete this.context.waypoints[this.axis][this.id];
        return this.context.checkEmpty();
      };

      Waypoint.getWaypointsByElement = function (element) {
        var all, ids;

        ids = $(element).data(waypointKey);
        if (!ids) {
          return [];
        }
        all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical);
        return $.map(ids, function (id) {
          return all[id];
        });
      };

      return Waypoint;

    })();
    methods = {
      init: function (f, options) {
        var _ref;

        if (options == null) {
          options = {};
        }
        if ((_ref = options.handler) == null) {
          options.handler = f;
        }
        this.each(function () {
          var $this, context, contextElement, _ref1;

          $this = $(this);
          contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context;
          if (!$.isWindow(contextElement)) {
            contextElement = $this.closest(contextElement);
          }
          contextElement = $(contextElement);
          context = contexts[contextElement.data(contextKey)];
          if (!context) {
            context = new Context(contextElement);
          }
          return new Waypoint($this, context, options);
        });
        $[wps]('refresh');
        return this;
      },
      disable: function () {
        return methods._invoke(this, 'disable');
      },
      enable: function () {
        return methods._invoke(this, 'enable');
      },
      destroy: function () {
        return methods._invoke(this, 'destroy');
      },
      prev: function (axis, selector) {
        return methods._traverse.call(this, axis, selector, function (stack, index, waypoints) {
          if (index > 0) {
            return stack.push(waypoints[index - 1]);
          }
        });
      },
      next: function (axis, selector) {
        return methods._traverse.call(this, axis, selector, function (stack, index, waypoints) {
          if (index < waypoints.length - 1) {
            return stack.push(waypoints[index + 1]);
          }
        });
      },
      _traverse: function (axis, selector, push) {
        var stack, waypoints;

        if (axis == null) {
          axis = 'vertical';
        }
        if (selector == null) {
          selector = window;
        }
        waypoints = jQMethods.aggregate(selector);
        stack = [];
        this.each(function () {
          var index;

          index = $.inArray(this, waypoints[axis]);
          return push(stack, index, waypoints[axis]);
        });
        return this.pushStack(stack);
      },
      _invoke: function ($elements, method) {
        $elements.each(function () {
          var waypoints;

          waypoints = Waypoint.getWaypointsByElement(this);
          return $.each(waypoints, function (i, waypoint) {
            waypoint[method]();
            return true;
          });
        });
        return this;
      }
    };
    $.fn[wp] = function () {
      var args, method;

      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (methods[method]) {
        return methods[method].apply(this, args);
      } else if ($.isFunction(method)) {
        return methods.init.apply(this, arguments);
      } else if ($.isPlainObject(method)) {
        return methods.init.apply(this, [null, method]);
      } else if (!method) {
        return $.error("jQuery Waypoints needs a callback function or handler option.");
      } else {
        return $.error("The " + method + " method does not exist in jQuery Waypoints.");
      }
    };
    $.fn[wp].defaults = {
      context: window,
      continuous: true,
      enabled: true,
      horizontal: false,
      offset: 0,
      triggerOnce: false
    };
    jQMethods = {
      refresh: function () {
        return $.each(contexts, function (i, context) {
          return context.refresh();
        });
      },
      viewportHeight: function () {
        var _ref;

        return (_ref = window.innerHeight) != null ? _ref : $w.height();
      },
      aggregate: function (contextSelector) {
        var collection, waypoints, _ref;

        collection = allWaypoints;
        if (contextSelector) {
          collection = (_ref = contexts[$(contextSelector).data(contextKey)]) != null ? _ref.waypoints : void 0;
        }
        if (!collection) {
          return [];
        }
        waypoints = {
          horizontal: [],
          vertical: []
        };
        $.each(waypoints, function (axis, arr) {
          $.each(collection[axis], function (key, waypoint) {
            return arr.push(waypoint);
          });
          arr.sort(function (a, b) {
            return a.offset - b.offset;
          });
          waypoints[axis] = $.map(arr, function (waypoint) {
            return waypoint.element;
          });
          return waypoints[axis] = $.unique(waypoints[axis]);
        });
        return waypoints;
      },
      above: function (contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'vertical', function (context, waypoint) {
          return waypoint.offset <= context.oldScroll.y;
        });
      },
      below: function (contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'vertical', function (context, waypoint) {
          return waypoint.offset > context.oldScroll.y;
        });
      },
      left: function (contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'horizontal', function (context, waypoint) {
          return waypoint.offset <= context.oldScroll.x;
        });
      },
      right: function (contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'horizontal', function (context, waypoint) {
          return waypoint.offset > context.oldScroll.x;
        });
      },
      enable: function () {
        return jQMethods._invoke('enable');
      },
      disable: function () {
        return jQMethods._invoke('disable');
      },
      destroy: function () {
        return jQMethods._invoke('destroy');
      },
      extendFn: function (methodName, f) {
        return methods[methodName] = f;
      },
      _invoke: function (method) {
        var waypoints;

        waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal);
        return $.each(waypoints, function (key, waypoint) {
          waypoint[method]();
          return true;
        });
      },
      _filter: function (selector, axis, test) {
        var context, waypoints;

        context = contexts[$(selector).data(contextKey)];
        if (!context) {
          return [];
        }
        waypoints = [];
        $.each(context.waypoints[axis], function (i, waypoint) {
          if (test(context, waypoint)) {
            return waypoints.push(waypoint);
          }
        });
        waypoints.sort(function (a, b) {
          return a.offset - b.offset;
        });
        return $.map(waypoints, function (waypoint) {
          return waypoint.element;
        });
      }
    };
    $[wps] = function () {
      var args, method;

      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (jQMethods[method]) {
        return jQMethods[method].apply(null, args);
      } else {
        return jQMethods.aggregate.call(null, method);
      }
    };
    $[wps].settings = {
      resizeThrottle: 100,
      scrollThrottle: 30
    };
    return $w.load(function () {
      return $[wps]('refresh');
    });
  });

}).call(this);

/*!
* Modified by fhoule
* 
* jQuery Smart Banner
* Copyright (c) 2012 Arnold Daniels <arnold@jasny.net>
* Based on 'jQuery Smart Web App Banner' by Kurt Zenisek @ kzeni.com
*/
!function ($) {
  var SmartBanner = function (options) {
    //console.log('SmartBanner()', options);

    this.origHtmlMargin = parseFloat($('html').css('margin-top')) // Get the original margin-top of the HTML element so we can take that into account
    this.options = $.extend({}, $.smartbanner.defaults, options)

    var standalone = navigator.standalone // Check if it's already a standalone web app or running within a webui view of an app (not mobile safari)
      , UA = navigator.userAgent

    // Detect banner type (iOS or Android)
    if (this.options.force) {
      this.type = this.options.force
    } else if (UA.match(/iPhone|iPod/i) != null || (UA.match(/iPad/) && this.options.iOSUniversalApp)) {
      this.type = 'ios' // Check webview and native smart banner support (iOS 6+)
    } else if (UA.match(/\bSilk\/(.*\bMobile Safari\b)?/) || UA.match(/\bKF\w/) || UA.match('Kindle Fire')) {
      this.type = 'kindle'
    } else if (UA.match(/Android/i) != null) {
      this.type = 'android'
    } else if (UA.match(/Windows NT 6.2/i) != null && UA.match(/Touch/i) !== null) {
      this.type = 'windows'
    } else if (navigator.userAgent.match(/Windows Phone/i) != null) {
      this.type = 'windows-phone'
    }

    // Don't show banner if device isn't iOS or Android, website is loaded in app or user dismissed banner
    if (!this.type || standalone || this.getCookie('sb-closed') || this.getCookie('sb-installed')) {
      return
    }

    //Added to support only specific mobile devices (Mathieu)
    if (!this.type.match(this.options.supportedPlatforms)) {
      return
    }

    // Calculate scale
    this.scale = this.options.scale == 'auto' ? $(window).width() / window.screen.width : this.options.scale
    if (this.scale < 1) this.scale = 1

    // Get info from meta data
    var meta = $(this.type == 'android' ? 'meta[name="sb-google-play-app"]' :
      this.type == 'ios' ? 'meta[name="sb-apple-appstore-app"]' :
        this.type == 'windows-phone' ? 'meta[name="sb-msApplication-ID"]' :
          this.type == 'kindle' ? 'meta[name="kindle-fire-app"]' : 'meta[name="sb-msApplication-ID"]');
    if (meta.length == 0) return

    // For Windows Store apps, get the PackageFamilyName for protocol launch
    if (this.type == 'windows') {
      this.pfn = $('meta[name="msApplication-PackageFamilyName"]').attr('content');
      this.appId = meta.attr('content')[1]
    } else {
      this.appId = /app-id=([^\s,]+)/.exec(meta.attr('content'))[1]
    }

    this.title = this.options.title ? this.options.title : meta.data('title') || $('title').text().replace(/\s*[|\-·].*$/, '')
    this.author = this.options.author ? this.options.author : meta.data('author') || ($('meta[name="author"]').length ? $('meta[name="author"]').attr('content') : window.location.hostname)
    this.iconUrl = meta.data('icon-url');
    this.price = meta.data('price');

    // Create banner
    this.create()
    this.show()
    this.listen()

    //console.log('end');



    /* Update YULi url in footer */
    /*
    var ftLinker=(this.options.url ? this.options.url : (this.type == 'windows-phone' ? 'http://windowsphone.com/s?appId=' : (this.type == 'windows' ? 'ms-windows-store:PDP?PFN=' + this.pfn : (this.type == 'android' ? 'market://details?id=' : (this.type == 'kindle' ? 'amzn://apps/android?asin=' : 'https://itunes.apple.com/' + this.options.appStoreLanguage + '/app/id')))) + this.appId);
    if(this.type=='android') {
        ftLinker = 'https://play.google.com/store/apps/details?id=' + this.appId

        if(this.options.GooglePlayParams){
            ftLinker = ftLinker + '&referrer=' + this.options.GooglePlayParams
        }
    } else if(this.type=='windows-phone') {
        ftLinker = 'http://windowsphone.com/s?appId=' + this.appId
    } else {
        ftLinker = 'https://itunes.apple.com/app/apple-store/id' + this.appId;
        if(this.options.iTunesPT){
            ftLinker = ftLinker + '?pt=' + this.options.iTunesPT +'&ct=' + this.options.iTunesPTParams + '&mt=8';
        }
    }
    $(".footer-left-content .app-yuli a").attr("href", ftLinker);
    */
    //Removed for now because we point to the page made by the client
    /* //Update YULi url in footer */
  }

  SmartBanner.prototype = {

    constructor: SmartBanner

    , create: function () {
      //console.log('create()');

      var iconURL
        , link = (this.options.url ? this.options.url : (this.type == 'windows-phone' ? 'http://windowsphone.com/s?appId=' : (this.type == 'windows' ? 'ms-windows-store:PDP?PFN=' + this.pfn : (this.type == 'android' ? 'market://details?id=' : (this.type == 'kindle' ? 'amzn://apps/android?asin=' : 'https://itunes.apple.com/' + this.options.appStoreLanguage + '/app/id')))) + this.appId)
        , price = this.price || this.options.price
        , inStore = price ? price + ' - ' + (this.type == 'android' ? this.options.inGooglePlay : this.type == 'kindle' ? this.options.inAmazonAppStore : this.type == 'ios' ? this.options.inAppStore : this.options.inWindowsStore) : ''
        , gloss = this.options.iconGloss === null ? (this.type == 'ios') : this.options.iconGloss
      if (this.options.url)
        link = this.options.url
      else {
        if (this.type == 'android') {
          link = 'https://play.google.com/store/apps/details?id=' + this.appId
          if (this.options.GooglePlayParams)
            link = link + '&referrer=' + this.options.GooglePlayParams
        } else if (this.type == 'windows-phone') {
          link = 'http://windowsphone.com/s?appId=' + this.appId
        }
        else {
          link = 'https://itunes.apple.com/app/apple-store/id' + this.appId;
          if (this.options.iTunesPT)
            link = link + '?pt=' + this.options.iTunesPT + '&ct=' + this.options.iTunesPTParams + '&mt=8';
        }
      }

      //fhoule Removed author
      //var banner = '<div id="smartbanner" class="'+this.type+'"><div class="sb-container"><span class="sb-icon"></span><div class="sb-info"><strong>'+this.title+'</strong><span>'+this.author+'</span><span>'+inStore+'</span></div><a href="'+link+'" class="sb-button"><span>'+this.options.button+'</span></a></div></div>';
      var banner = '<div id="smartbanner" class="' + this.type + '"><div class="sb-container"><span class="sb-icon"></span><div class="sb-info"><strong>' + this.title + '</strong><span>' + inStore + '</span></div><a href="' + link + '" class="sb-button"><span>' + this.options.button + '</span></a></div></div>';
      (this.options.layer) ? $(this.options.appendToSelector).append(banner) : $(this.options.appendToSelector).prepend(banner);

      if (this.options.icon) {
        iconURL = this.options.icon
      } else if (this.iconUrl) {
        iconURL = this.iconUrl;
      } else if ($('link[rel="apple-touch-icon-precomposed"]').length > 0) {
        iconURL = $('link[rel="apple-touch-icon-precomposed"]').attr('href')
        if (this.options.iconGloss === null) gloss = false
      } else if ($('link[rel="apple-touch-icon"]').length > 0) {
        iconURL = $('link[rel="apple-touch-icon"]').attr('href')
      } else if ($('meta[name="msApplication-TileImage"]').length > 0) {
        iconURL = $('meta[name="msApplication-TileImage"]').attr('content')
      } else if ($('meta[name="msapplication-TileImage"]').length > 0) { /* redundant because ms docs show two case usages */
        iconURL = $('meta[name="msapplication-TileImage"]').attr('content')
      }

      if (iconURL) {
        $('#smartbanner .sb-icon').css('background-image', 'url(' + iconURL + ')')
        if (gloss) $('#smartbanner .sb-icon').addClass('gloss')
      } else {
        $('#smartbanner').addClass('no-icon')
      }

      this.bannerHeight = $('#smartbanner').outerHeight() + 2

      if (this.scale > 1) {
        $('#smartbanner')
          .css('top', parseFloat($('#smartbanner').css('top')) * this.scale)
          .css('height', parseFloat($('#smartbanner').css('height')) * this.scale)
          .hide()
        $('#smartbanner .sb-container')
          .css('-webkit-transform', 'scale(' + this.scale + ')')
          .css('-msie-transform', 'scale(' + this.scale + ')')
          .css('-moz-transform', 'scale(' + this.scale + ')')
          .css('width', $(window).width() / this.scale)
      }
      $('#smartbanner').css('position', (this.options.layer) ? 'fixed' : 'static');
      $('body').addClass('smartbanner-applied');

    }

    , listen: function () {
      $('#smartbanner .sb-close').on('click', $.proxy(this.close, this))
      $('#smartbanner .sb-button').on('click', $.proxy(this.install, this))
    }

    , show: function (callback) {
      //console.log('show()');

      var banner = $('#smartbanner');
      banner.stop();

      if (this.options.layer) {
        banner.animate({ top: 0, display: 'block' }, this.options.speedIn).addClass('shown').show();
        $('html').animate({ marginTop: this.origHtmlMargin + (this.bannerHeight * this.scale) }, this.options.speedIn, 'swing', callback);
      } else {
        if ($.support.transition) {
          banner.animate({ top: 0 }, this.options.speedIn).addClass('shown');
          var transitionCallback = function () {
            $('html').removeClass('sb-animation');
            if (callback) {
              callback();
            }
          };
          if (this.options.margin) {
            $('html').addClass('sb-animation').one($.support.transition.end, transitionCallback).emulateTransitionEnd(this.options.speedIn).css('margin-top', this.origHtmlMargin + (this.bannerHeight * this.scale));
          } else {
            $('html').addClass('sb-animation').one($.support.transition.end, transitionCallback).emulateTransitionEnd(this.options.speedIn);
          }
        } else {
          banner.slideDown(this.options.speedIn).addClass('shown');
        }
      }

      /* Quick fix for alerts on display */
      $(".region-warnings").addClass("appBannerApplied");
      $("header .nav").addClass("appBannerApplied");

    }

    , hide: function (callback) {
      var banner = $('#smartbanner');
      banner.stop();

      if (this.options.layer) {
        banner.animate({ top: -1 * this.bannerHeight * this.scale, display: 'block' }, this.options.speedIn).removeClass('shown');
        $('html').animate({ marginTop: this.origHtmlMargin }, this.options.speedIn, 'swing', callback);
      } else {
        if ($.support.transition) {
          banner.css('top', -1 * this.bannerHeight * this.scale).removeClass('shown');
          var transitionCallback = function () {
            $('html').removeClass('sb-animation');
            if (callback) {
              callback();
            }
          };
          if (this.options.margin) {
            $('html').addClass('sb-animation').one($.support.transition.end, transitionCallback).emulateTransitionEnd(this.options.speedOut).css('margin-top', this.origHtmlMargin);
          } else {
            $('html').addClass('sb-animation').one($.support.transition.end, transitionCallback).emulateTransitionEnd(this.options.speedOut);
          }
        } else {
          banner.slideUp(this.options.speedOut).removeClass('shown');
        }
      }
    }

    , close: function (e) {
      e.preventDefault()
      this.hide()
      this.setCookie('sb-closed', 'true', this.options.daysHidden);
    }

    , install: function (e) {

      if (this.options.hideOnInstall) {
        this.hide()
      }
      if (typeof ga !== 'undefined') {
        ga('send', 'event', 'button', 'click', 'SmartBanner Install', 1);
      }
      if (this.options.conversionId && this.options.conversionLabel) {
        this.trackConv(this.options.conversionId, this.options.conversionLabel);
      }
      this.setCookie('sb-installed', 'true', this.options.daysReminder)
    }

    , trackConv: function (google_conversion_id, google_conversion_label) {
      var image = new Image(1, 1);
      image.src = "//www.googleadservices.com/pagead/conversion/" + google_conversion_id + "/?label=" + google_conversion_label + "&script=0";
    }

    , setCookie: function (name, value, exdays) {
      var exdate = new Date()
      exdate.setDate(exdate.getDate() + exdays)
      value = encodeURI(value) + ((exdays == null) ? '' : '; expires=' + exdate.toUTCString())
      document.cookie = name + '=' + value + '; path=/;'
    }

    , getCookie: function (name) {
      var i, x, y, ARRcookies = document.cookie.split(";")
      for (i = 0; i < ARRcookies.length; i++) {
        x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="))
        y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1)
        x = x.replace(/^\s+|\s+$/g, "")
        if (x == name) {
          return decodeURI(y)
        }
      }
      return null
    }

    // Demo only
    , switchType: function () {
      var that = this

      this.hide(function () {
        that.type = that.type == 'android' ? 'ios' : 'android'
        var meta = $(that.type == 'android' ? 'meta[name="google-play-app"]' : 'meta[name="apple-appstore-app"]').attr('content')
        that.appId = /app-id=([^\s,]+)/.exec(meta)[1]

        $('#smartbanner').detach()
        that.create()
        that.show()
      })
    }
  }

  $.smartbanner = function (option) {
    //console.log('smartbanner()');

    var $window = $(window)
      , data = $window.data('smartbanner')
      , options = typeof option == 'object' && option
    if (!data) $window.data('smartbanner', (data = new SmartBanner(options)))
    if (typeof option == 'string') data[option]()
  }

  // override these globally if you like (they are all optional)
  $.smartbanner.defaults = {
    title: null, // What the title of the app should be in the banner (defaults to <title>)
    author: null, // What the author of the app should be in the banner (defaults to <meta name="author"> or hostname)
    price: 'FREE', // Price of the app
    appStoreLanguage: 'us', // Language code for App Store
    inAppStore: 'On the App Store', // Text of price for iOS
    inGooglePlay: 'In Google Play', // Text of price for Android
    inAmazonAppStore: 'In the Amazon Appstore',
    inWindowsStore: 'In the Windows Store', //Text of price for Windows
    GooglePlayParams: null, // Aditional parameters for the market
    icon: null, // The URL of the icon (defaults to <meta name="apple-touch-icon">)
    iconGloss: null, // Force gloss effect for iOS even for precomposed
    button: 'VIEW', // Text for the install button
    url: null, // The URL for the button. Keep null if you want the button to link to the app store.
    scale: 'auto', // Scale based on viewport size (set to 1 to disable)
    speedIn: 300, // Show animation speed of the banner
    speedOut: 400, // Close animation speed of the banner
    daysHidden: 15, // Duration to hide the banner after being closed (0 = always show banner)
    daysReminder: 90, // Duration to hide the banner after "VIEW" is clicked *separate from when the close button is clicked* (0 = always show banner)
    force: null, // Choose 'ios', 'android' or 'windows'. Don't do a browser check, just always show this banner
    hideOnInstall: true, // Hide the banner after "VIEW" is clicked.
    layer: false, // Display as overlay layer or slide down the page
    iOSUniversalApp: true, // If the iOS App is a universal app for both iPad and iPhone, display Smart Banner to iPad users, too.
    appendToSelector: 'body', //Append the banner to a specific selector
    supportedPlatforms: 'ios' //
  }

  $.smartbanner.Constructor = SmartBanner;


  // ============================================================
  // Bootstrap transition
  // Copyright 2011-2014 Twitter, Inc.
  // Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)

  function transitionEnd() {
    var el = document.createElement('smartbanner')

    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  if ($.support.transition !== undefined)
    return  // Prevent conflict with Twitter Bootstrap

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false, $el = this
    $(this).one($.support.transition.end, function () {
      called = true
    })
    var callback = function () {
      if (!called) $($el).trigger($.support.transition.end)
    }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()
  })
  // ============================================================

}(window.jQuery);

define("smartbanner", ["jquery"], (function (global) {
  return function () {
    var ret, fn;
    return ret || global.jQuery.fn.smartbanner;
  };
}(this)));

define('taxicontest', ['jquery'], function ($) {
  $(document).ready(function () {
    $('#edit-taxicontest-type-van, ' +
      '#edit-taxicontest-type-green, ' +
      '#edit-taxicontest-type-accessible'
    ).on('click', function () {
      updatePrices();
    });
    updatePrices();
  });

  function updatePrices() {
    var vanPrice = 0,
      greenPrice = 0,
      accessiblePrice = 0,
      vanCheckbox = $('#edit-taxicontest-type-van'),
      greenCheckbox = $('#edit-taxicontest-type-green'),
      accessibleCheckbox = $('#edit-taxicontest-type-accessible');

    if (vanCheckbox.is(':checked')) {
      vanPrice = parseFloat($('#taxicontest-price-van').val());
    }
    if (greenCheckbox.is(':checked')) {
      greenPrice = parseFloat($('#taxicontest-price-green').val());
    }
    if (accessibleCheckbox.is(':checked')) {
      accessiblePrice = parseFloat($('#taxicontest-price-accessible').val());
    }

    var totalPrice = greenPrice + vanPrice + accessiblePrice,
      greenPrice = getPrice(greenPrice),
      vanPrice = getPrice(vanPrice),
      accessiblePrice = getPrice(accessiblePrice),
      taxes = getTaxes(totalPrice);

    //Add taxes to total
    taxes['tps'] = taxes['tps'].toFixed(2);
    taxes['tvq'] = taxes['tvq'].toFixed(2);
    totalPrice = parseFloat(totalPrice) + parseFloat(taxes['tps']) + parseFloat(taxes['tvq']);

    taxes['tps'] = getPrice(taxes['tps']);
    taxes['tvq'] = getPrice(taxes['tvq']);

    totalPrice = getPrice(totalPrice);

    //update subtotals
    $('#taxicontest-type-van-total-price .dollars').text(vanPrice['integer']);
    $('#taxicontest-type-van-total-price .decimals').text('.' + ('0' + vanPrice['decimals']).slice(-2));
    $('#taxicontest-type-green-total-price .dollars').text(greenPrice['integer']);
    $('#taxicontest-type-green-total-price .decimals').text('.' + ('0' + greenPrice['decimals']).slice(-2));
    $('#taxicontest-type-accessible-total-price .dollars').text(accessiblePrice['integer']);
    $('#taxicontest-type-accessible-total-price .decimals').text('.' + ('0' + accessiblePrice['decimals']).slice(-2));
    //update taxes
    $('#taxicontest-total-tps .dollars').text(taxes['tps']['integer']);
    $('#taxicontest-total-tps .decimals').text('.' + ('0' + taxes['tps']['decimals']).slice(-2));
    $('#taxicontest-total-tvq .dollars').text(taxes['tvq']['integer']);
    $('#taxicontest-total-tvq .decimals').text('.' + ('0' + taxes['tvq']['decimals']).slice(-2));
    //update total
    $('#taxicontest-total-price .dollars').text(totalPrice['integer']);
    $('#taxicontest-total-price .decimals').text('.' + ('0' + totalPrice['decimals']).slice(-2));
  }

  function getPrice(priceAsFloat) {
    var price = {},
      total = Math.round(parseFloat(priceAsFloat) * 100) / 100;

    price['integer'] = parseInt(total);
    price['decimals'] = Math.round(total * 100) % 100;

    return price;
  }

  function getTaxes(subTotal) {
    var taxes = {},
      tps = $('#taxicontest-tps').val(),
      tvq = $('#taxicontest-tvq').val();

    subTotal = parseFloat(subTotal);

    taxes['tps'] = parseFloat(subTotal * (tps / 100));
    taxes['tvq'] = parseFloat(subTotal * (tvq / 100));

    return taxes;
  }
});
define('onlinebilling', ['jquery'], function ($) {
  var updateTotalTimeout;
  $(document).ready(function () {
    bindUpdateTotal();

    $('.onlinebilling-invoice-wrapper').on('change', function () {
      updateTotal();
    });

    updateTotal();

    var $errors = $('.error', 'form.online-billing');
    var $input = $('textarea, input[type="text"], input[type="radio"]');

    $input.bind('change', function () {
      if ($(this).is('textarea#g-recaptcha-response')) {
        var rel = $('.captcha-field'),
          $msgcaptcha = $('.msg', rel);
        rel.removeClass('error');
        $msgcaptcha.css('display', 'none');
      } else {
        var $msg = $(this).prev('.msg'),
          $c = $(this).parents('.error');
        $c.removeClass('error');
        $msg.css('display', 'none');
      }
    });

    //Focus on first error
    if ($errors.length) {
      $t = $('input', $errors[0]);
      if ($t.length) {
        $t[0].focus();
      }
    }
  });


  $(document).ajaxSuccess(function (event, xhr, settings) {
    var lang = $('html').attr('lang');
    var url = '/' + lang + '/system/ajax';

    bindUpdateTotal();
    if (settings.url == url) {
      updateTotal();
    }
  });

  function bindUpdateTotal() {
    $('.invoice-total').each(function (index) {
      $(this).off('keyup').on('keyup', function () {
        clearTimeout(updateTotalTimeout);
        updateTotalTimeout = setTimeout(updateTotal(), 500);
      })
    });
  }

  function updateTotal() {
    var total = 0;

    $('.invoice-total').each(function (index) {
      $this = $(this);

      //Proper number?
      if (/^[\d]+[.,]?[\d]*$/.test($this.val()) || $this.val() == '') {
        var subTotal = ($this.val() !== '') ? parseFloat($this.val().replace(',', '.')) : 0;
        total += subTotal;
        if (subTotal >= 0 && subTotal <= 15000) {
          $this.removeClass('error');
        } else {
          $this.addClass('error');
        }
      } else {
        $this.addClass('error');
      }

    });

    total = total.toFixed(2);
    var totalInt = parseInt(total),
      totalDecimals = Math.round(total * 100) % 100;

    $('#onlinebilling-total-price .dollars').text(totalInt);
    $('#onlinebilling-total-price .decimals').text('.' + ('0' + totalDecimals).slice(-2));
  }
});
define('a11y/external-links', [
  'jquery',
], function ($) {

  function getSvg() {
    return [
      '<svg width="100%" height="100%" viewBox="30 64 2016 1952" xmlns="http://www.w3.org/2000/svg" version="1.1">',
      '<g transform="rotate(-90)" transform-origin="50% 50%">',
      '<path d="M1344 704h-640v640h192v192h-384v-1024h1024v384h-192v-192zM1088 1536l156 -156l-388 -388l136 -136l388 388l156 -156v448h-448z" ',
      'fill="currentColor" stroke-width="3" />',
      '</g>',
      '</svg>'
    ].join('');
  }

  function getTranslatedLabel() {
    return $('#a11y-dictionnary').attr('data-external-page-label');
  }

  function generateHiddenLabel(label) {
    return $('<span class="external-icon" role="img" aria-label="' + label + '">' + getSvg() + '</span>');
  }

  $(document).ready(function () {
    $('a.external').each(function () {
      var label = getTranslatedLabel();
      var $mention = generateHiddenLabel(label);
      var $link = $(this);

      $link.append($mention);
    })
  })

});
define('a11y/iframe-renaming', [], function () {
  function setupIframe(iframe) {
    var haveA11yTitle = iframe.getAttribute('title') !== null;
    if (haveA11yTitle) {
      return; // All good
    }

    var isInvisible = parseInt(iframe.width) === 0 || parseInt(iframe.height) === 0;
    if (isInvisible) {
      iframe.setAttribute('aria-hidden', true);
    }
  }

  function init() {
    checkCurrentsIframe();
    const observer = watchForNewIframe();

    // Stop watching the DOM for iframe after some time
    setTimeout(() => {
      observer.disconnect();
    }, 4000);
  }


  function checkCurrentsIframe() {
    const iframeNodeList = document.querySelectorAll('body > iframe')
    if (iframeNodeList) {
      iframeNodeList.forEach(function (iframe) {
        setupIframe(iframe)
      });
    }
  }

  function watchForNewIframe() {
    const observer = new MutationObserver(function (mutations_list) {
      mutations_list.forEach(function (mutation) {
        mutation.addedNodes.forEach(function (added_node) {
          if (added_node && added_node.tagName && added_node.tagName.toLowerCase() === 'iframe') {
            setupIframe(added_node);
          }
        });
      });
    });

    observer.observe(document.body, { subtree: false, childList: true });

    return observer;
  }

  init();

});


// Author : Etienne Dion <dionetienne@gmail.com> October 2013,
//          Julie Cardinal <julie.cardinal@nurun.com>,
//          Frédéric Ginioux <frederic.ginioux@nurun.com>

/* Namespace Project Global Scope */

var ADM = window.ADM || {};

ADM.Forms = {};
ADM.eventEmitter = null;
ADM.googleMapCallback = null;
ADM.googleMapScriptLoadState = 0;
//dataLayer = typeof dataLayer !="undefined" ? dataLayer : []; // analytics

// Drupal Ajax forms handeling
var Drupal = Drupal || {};
if (Drupal.hasOwnProperty('ajax')) {
  Drupal.ajax.prototype.beforeSubmit = function (form_values, element, options) {
    var timeout = 0
      , repeat = 0
      , limit = 20
      , delay = 10;

    var quit = function () {
      window.clearTimeout(timeout);
      timeout = null;
      return timeout;
    };

    var check = function () {
      var $elt = jQuery('.ajax-progress', element);
      if ($elt.length || limit == repeat) {
        quit();
        if ($elt.length) {
          element.trigger('ajax-progress-started', [$elt]);
        }
      } else {
        repeat++;
        window.setTimeout(function () {
          check();
        }, delay);
      }
    };

    timeout = window.setTimeout(function () {
      check();
    }, delay);
  };
}



require.config({
  waitSeconds: 0,
  paths: {
    jquery: 'jquery-global',
    enhance: 'libs/enhance/src/enhance',
    eventEmitter: 'libs/eventEmitter/EventEmitter',
    async: 'libs/async/lib/async',
    debounce: 'libs/debounce/jquery.ba-throttle-debounce',
    gsap: 'libs/gsap/src/minified/jquery.gsap.min',
    tweenlite: 'libs/gsap/src/minified/TweenLite.min',
    easepack: 'libs/gsap/src/minified/easing/EasePack.min',
    cssPlugin: 'libs/gsap/src/minified/plugins/CSSPlugin.min',
    enquire: 'libs/enquire/dist/enquire',
    royalSlider: 'libs/jquery.royalslider.min',
    touchCarousel: 'libs/jquery.touchcarousel-1.2',
    tweenMax: 'libs/gsap/src/minified/TweenMax.min',
    timelineMax: 'libs/gsap/src/minified/TimelineMax.min',
    autocomplete: 'libs/jquery-ui-1.10.3.custom',
    mobiscroll: 'libs/mobiscroll.custom-2.9.3.modified.min',
    moment: 'libs/momentjs.modified',
    livestamp: 'libs/livestamp.modified',
    customSelect: 'libs/jquery.customselect',
    chosen: 'libs/chosen.jquery',
    jsrender: 'libs/jsrender/jsviews',
    dataTable: 'libs/jquery.dataTables.modified',
    dataTableWithUtils: 'utils/datatables',
    urldecoder: 'libs/jquery.urldecoder.modified',
    momentWithi18n: 'i18n/moment',
    canvasLoader: 'libs/heartcode-canvasloader-min/index',
    placeholder: 'libs/jquery-placeholder/jquery.placeholder',
    waypoints: 'libs/waypoints/waypoints',
    foundation: 'libs/foundation.modified',
    interchange: 'libs/foundation.interchange.modified',
    magnificPopup: 'libs/jquery.magnific-popup',
    footable: 'libs/footable/js/footable.modified',
    footable_sort: 'libs/footable/js/footable.sort.modified',
    mask: 'libs/jquery-mask-plugin/dist/jquery.mask.min',
    owlcarousel: 'libs/owlcarousel/owl-carousel/owl.carousel',
    dropkick: 'libs/jquery.dropkick-1.0.0.modified',
    raphael: 'libs/raphael',
    tweenMaxRaphael: 'libs/gsap/src/minified/plugins/RaphaelPlugin.min',
    select2: 'libs/select2.min',
    urls: 'urls/urls',
    underscore: 'libs/underscore',
    dotdotdot: 'libs/jQuery.dotdotdot/src/js/jquery.dotdotdot.min',
    imagesloaded: 'libs/qtip2/imagesloaded.min',
    qtip2: 'libs/qtip2/jquery.qtip2.min',
    guid0: 'libs/guid0',
    lazyload: 'libs/jquery.lazyload',
    smartbanner: 'libs/jquery.smartbanner/jquery.smartbanner',
    newsFormSel: 'forms/newsFormSel',
    taxicontest: 'forms/taxicontest',
    onlinebilling: 'forms/onlinebilling',
    intersectionObserver: 'libs/intersection-observer/intersection-observer',
    tabbable: 'libs/tabbable',
    focusTrap: 'libs/focusTrap',

    /***************************************** WARNING ******************************************/
    //
    //  THIS SCRIPT BELOW, WE DEFINED IT LIKE DEPENDENCIES BECAUSE WE USE THE SAME SCRIPT
    //  IN DARKSITE, IF WE WANT TO REUSE THE SAME SCRIPT, WE HAVE DEFINE DEPENDENCIES LIKE THAT
    //  AND NOT WITH THE PATH DIRECTLY IN THE MODULE.
    //
    UTILS: 'utils/utils',
    UTILS_TIME: 'utils/time',
    UTILS_DATE: 'utils/date',
    UTILS_UPDATER: 'utils/updater',
    UTILS_PRELOADER: 'utils/preloader',
    i18n_general: 'i18n/general',
    i18n_datatables: 'i18n/datatables',
    dataprovider: 'data/dataprovider',
    datalayer_flight: 'data/flights',
    buttonGroup: 'uiTools/boutonsGroup',
    equalize: 'uiTools/equalize',
    automaticUpdate: 'widgets/automaticUpdate',
    datetime: 'widgets/datetime',
    genericResponsiveTable: 'uiTools/genericResponsiveTable',
    responsiveTable: 'uiTools/responsiveTable',
    stickyElement: 'widgets/stickyElement',
    sharingTools: 'widgets/sharingTools',
    jScrollPaneWheel: 'libs/jscrollpane/jquery.mousewheel',
    jScrollPane: 'libs/jscrollpane/jquery.jscrollpane.min',
    ImagePrint: 'widgets/imagePrint'
  },
  shim: {
    'enhance': {
      deps: ['jquery']
    },
    'lazyload': {
      deps: ['jquery'],
      exports: 'jQuery.fn.lazyload'
    },
    'gsap': {
      deps: ['jquery', 'cssPlugin', 'easepack', 'tweenlite']
    },
    'timelineMax': {
      deps: ['easepack', 'tweenlite']
    },
    'debounce': {
      deps: ['jquery'],
      exports: 'jQuery.fn.throttle'
    },
    'autocomplete': {
      deps: ['jquery']
    },
    'mobiscroll': {
      deps: ['jquery'],
      exports: 'jQuery.fn.mobiscroll'
    },
    'dataTable': {
      deps: ['jquery'],
      exports: 'jQuery.dataTable'
    },
    'dataTableWithUtils': {
      deps: ['jquery', 'dataTable']
    },
    'urldecoder': {
      deps: ['jquery'],
      exports: 'jQuery.url'
    },
    'tweenMax': {
      deps: ['tweenlite']
    },
    'customSelect': {
      deps: ['jquery']
    },
    'chosen': {
      deps: ['jquery']
    },
    'momentWithi18n': {
      deps: ['moment']
    },
    'livestamp': {
      deps: ['momentWithi18n'],
      exports: 'jQuery.fn.livestamp'
    },
    'eventEmitter': {
      exports: 'eventEmitter'
    },
    'waypoints': {
      deps: ['jquery']
    },
    'foundation': {
      deps: ['jquery']
    },
    'interchange': {
      deps: ['jquery', 'foundation']
    },
    magnificPopup: {
      deps: ['jquery']
    },
    footable: {
      deps: ['jquery'],
      exports: 'jQuery.fn.footable'
    },
    footable_sort: {
      deps: ['jquery', 'footable']
    },
    'owlcarousel': {
      deps: ['jquery'],
      exports: 'jQuery.fn.owlCarousel'
    },
    'dropkick': {
      deps: ['jquery'],
      exports: 'jQuery.fn.dropkick'
    },
    'tweenMaxRaphael': {
      deps: ['tweenMax']
    },
    'chromelog': {
      deps: ['jquery'],
      exports: 'jQuery.fn.log'
    },
    'select2': {
      deps: ['jquery'],
      exports: 'jQuery.fn.select2'
    },
    'underscore': {
      deps: ['jquery']
    },
    'dotdotdot': {
      deps: ['jquery'],
      exports: 'jQuery.fn.dotdotdot'
    },
    'mask': {
      deps: ['jquery'],
      exports: 'jQuery.fn.mask'
    },
    'smartbanner': {
      deps: ['jquery'],
      exports: 'jQuery.fn.smartbanner'
    },
    'taxicontest': {
      deps: ['jquery']
    },
    'onlinebilling': {
      deps: ['jquery']
    },
    'GA4': {
      deps: []
    }
  },
  map: {
    '*': {
      'optional': 'requirePlugins/optional'
    }
  }
});

// Use for Unit Testing
if (typeof window.QUnit !== 'undefined') {
  QUnit.start();
  test("Page Load :", function () {
    ok(true, "Page has loaded Successfully!");
  });
}
require([
  'jquery',
  'settings',
  'eventEmitter',
  'mediaQueries/mediaQueries',
  'UTILS',
  'nav/nav',
  'warnings/forcedNews',
  'uiTools/tools',
  'widgets/widgets',
  'interactivemap/interactivemap',
  'uiTools/modals',
  'utils/ajaxMarkup',
  'forms/newsFormSel',
  'GA4/GA4',
  'YMX/noFog',

  'enhance',
  'waypoints',
  'smartbanner',
  'taxicontest',
  'onlinebilling',
  'a11y/external-links',
  'a11y/iframe-renaming',
  'a11y/footnote',
], function ($, Settings, EventEmitter, MediaQueries, Utils, Nav, ForcedNews, uiTools, Widgets, InteractiveMap, Modals, AjaxMarkup, NewsFormSel, GA4, noFog) {

  function t(en, fr) {
    return lg === 'en' ? en : fr;
  }

  var
    emitter = new EventEmitter(),
    lg = $('html').attr('lang');

  ADM.eventEmitter = emitter;

  // Compatibility test
  if (!Utils.compatibilityTest()) {

    var $wrapper = $(Settings.compatibility.modal.settings.items.src);
    var $elems = $('[data-src]', $wrapper);
    $elems.each(function (i, item) {
      var $this = $(item);
      $this.attr('src', $this.attr('data-src')).removeAttr('data-src');
    });

    Modals.call($(Settings.compatibility.modal.settings.items.src), Settings.compatibility.modal.settings);

  } else {

    MediaQueries.init(emitter);
    //ADM namespace Event Emitter util in integration solution

    $.enhance(AjaxMarkup.init, { id: "ajaxMarkup", title: "Load ajax some markup to prevent caching issues" });
    $.enhance(Nav.init, { id: "stickyNav", title: "Navigation logic" });
    $.enhance(ForcedNews.init, { id: "forcedNews", title: "Forced news" });

    //not for ie8
    $.enhance(Widgets.stickyElement, { id: "stickyElement", title: "Sticky HTML element" });
    $.enhance(uiTools.responsiveTable, { id: "responsiveTable", title: "Rend responsive les tables" });
    $.enhance(uiTools.genericReponsiveTable, { id: "genericResponsiveTable", title: "" });
    $.enhance(Widgets.sharingTools, { id: "sharingTools", title: "Sharing tools" });

    $.enhance(uiTools.customSelect, { id: "customSelect", title: "Custom Skinned Select" });

    $.enhance(uiTools.faq, { id: "faq", title: "" });
    $.enhance(uiTools.filters, { id: "filters", title: "" });

    $.enhance(uiTools.pagination, { id: "pagination", title: "" });

    $.enhance(uiTools.mailto, { id: "mailto", title: "" });

    $.enhance(uiTools.retinaImages, { id: "retinaImages", title: "Manage Retina Background Image" });

    $.enhance(uiTools.tooltips, { id: "infoTooltip", title: "Tooltips information" });

    $.enhance(uiTools.placeholder, { id: "placeholder", title: "Placeholder polyfill" });

    $.enhance(uiTools.modals, { id: "magnificPopup", title: "Manage Popup and Modal" });

    $.enhance(uiTools.equalize, { id: "equalize", title: "Rend les éléments de la même dimension" });
    $.enhance(uiTools.newsItem, { id: "newsItem", title: "" });
    $.enhance(uiTools.formHelpers, { id: "formHelpers", title: "formHelpers / datepicker / time picker / phone formatter" });

    $.enhance(uiTools.toggle, { id: "toggle", title: "toggle elements" });

    $.enhance(Widgets.commentsForm, { id: "commentsForm", title: "Comments Form.", emitter: emitter });

    $.enhance(Widgets.globalSearchWidget, { id: "globalSearchWidget", title: "Search Icon aside of language" });

    $.enhance(Widgets.buttonsGroup, { id: "buttonsgroup", title: "Filters Group" });

    $.enhance(Widgets.bannersCarousel, { id: "bannersCarousel", title: "Banners List Carousel" });
    $.enhance(Widgets.ajaxFormDrupalized, { id: "ajaxFormDrupalized", title: "Drupal Forms Js Bindind" });

    $.enhance(Widgets.services, { id: "services", title: "Services teaser widget" });

    $.enhance(Widgets.iabads, { id: "iabads", title: "Handle IAB Ads in a page" });
    $.enhance(Widgets.mfp, { id: "mfp", title: "Handle Magnific Popup overlay" });

    $.enhance(InteractiveMap.init, { id: "interactivemap", title: "Interactive Map", emitter: emitter });
    $.enhance(InteractiveMap.links, { id: "interactivemaplinks", title: "Interactive Map Links", emitter: emitter });

    //could be page specific
    $.enhance(Widgets.stationnement, { id: "stationnement", title: "Stationnement" });
    $.enhance(Widgets.stationnementMap, { id: "stationnement-map", title: "Handle stationnement map" });
    $.enhance(Widgets.accessForm, { id: "accessForm", title: "Access Form widget" });
    $.enhance(Widgets.formGuidePerso, { id: "formGuidePerso", title: "Formulaire guide personnalisé" });
    $.enhance(Widgets.delaysBoard, { id: "delayboard", title: "delaysBoard on homepage and delay page" });
    $.enhance(Widgets.automaticUpdate, { id: "automaticUpdate", title: "automaticUpdate delaysBoard" });

    $.enhance(Widgets.searchFlightAutocomplete, { id: "searchFlightAutocomplete", title: "searchFlightAutocomplete Widget" });
    $.enhance(Widgets.convertHomeNews, { id: "convertHomeNews", title: "change btn all news links on mobile" });

    $.enhance(Widgets.imagePrint, { id: "imagePrint", title: "imagePrint Widget" });

    $.enhance(NewsFormSel.init, { id: "newsFormSel", title: "Newsletter form auto language selector" });

    // Parking occupancy template
    $.enhance(Widgets.parkingOccupancy, { id: "parkingOccupancy", title: "Parking occupancy" });
    $.enhance(Widgets.taxiWaitingTime, { id: "taxiWaitingTime", title: "Taxis waiting time" });
    $.enhance(Widgets.addStylesOnIntersection, { id: "addStylesOnIntersection", title: "Add styles when element is visible in window (IntersectionObserver)" });

    $.enhance(Widgets.globalHeightLayout, { id: "globalHeightLayout", title: "Set height of the elements" });

    // enhance GA4
    $.enhance(GA4.init, { id: "internalCTA", title: "Set internalCTA for GA4" });

    //enhance remove fog
    $.enhance(noFog.init, { id: "removeFog", title: "remove fog on header" });

    // Drupal need to acces to reenhance function for preview wysiwyg - Drupal work only with jquery functions
    jQuery.fn.extend({
      reenhance: function (elementSelector) {
        $(elementSelector).enhance();
        return;
      }
    });
    var initiated = 0;

    if (dependanciesToBeLoaded.length === 0) {
      $(document).ready(function () {
        console.log("enhance on load");
        initiated = 1;
        $(document).enhance();

        MediaQueries.init(emitter);
      });
    } else {
      ADM.eventEmitter.addListener('dependancyLoaded', function () {

        $(document).ready(function () {

          if (dependanciesToBeLoaded.length === 0) {
            setTimeout(function () {

              if (!initiated) {
                console.log("enhance on dependancy loaded");
                initiated = 1;
                $(document).enhance();
                MediaQueries.init(emitter);
              }

            }, 50);
          }

        });
      });
    }

    $(document).ready(function () {
      //Analytics
      //newsletter
      $(".newsletter-active").find('input[type="submit"]').click(function () {
        dataLayer.push({
          'event': 'newsletter_' + Utils.getLang()
        });
      });

      //Ecommerce block on homepage
      $(".ecommerce-block-list").find('.ecommerce-block-item a').click(function (e) {
        e.preventDefault();
        var ecommerce_block_title = $(this).find('.ecommerce-block-item__title').text();
        dataLayer.push({
          'event': 'eventGA',
          'categoryGA': 'Tuiles',
          'actionGA': 'Clic',
          'labelGA': ecommerce_block_title
        });
        if (this.href) {
          var target = this.href;
          setTimeout(function () {
            window.location = target;
          }, 500);
        }
      });

      //Quick access block on homepage - bottom
      $(".block-quick-access__list").find('.block-quick-access__list-item a').click(function (e) {
        e.preventDefault();
        var quickaccess_block_title = $(this).find('.title').text();
        dataLayer.push({
          'event': 'eventGA',
          'categoryGA': 'Tuiles Acces Rapide',
          'actionGA': 'Clic',
          'labelGA': quickaccess_block_title
        });
        if (this.href) {
          var target = this.href;
          setTimeout(function () {
            window.location = target;
          }, 500);
        }
      });

      // Parking page compare
      $(".parkinglist-cell-trigger a").click(function (e) {
        e.preventDefault();
        var title = $(this).text();
        dataLayer.push({
          'event': 'eventGA',
          'categoryGA': 'Stationnement',
          'actionGA': 'Clic',
          'labelGA': title
        });
        if (this.href) {
          var target = this.href;
          setTimeout(function () {
            window.location = target;
          }, 500);
        }
      });

      // Parking page accessibility links
      $(".parking-accessibilitylist a").click(function (e) {
        e.preventDefault();
        var title = $(this).find('.link-withicon-text').text();
        dataLayer.push({
          'event': 'eventGA',
          'categoryGA': 'Stationnement',
          'actionGA': 'Clic',
          'labelGA': title
        });
        if (this.href) {
          var target = this.href;
          setTimeout(function () {
            window.location = target;
          }, 500);
        }
      });

      // Parking page direction link
      $(".tableaux-stationnement .tableaux-stationnement-map a").click(function (e) {
        e.preventDefault();
        var title = $(this).find('.tableaux-stationnement-map-label').text();
        var stationnement = $(this).parents('.tableaux-stationnement-location').parent().prev('.tableaux-stationnement-type-row').find('.stationnement-type-item').text();
        dataLayer.push({
          'event': 'eventGA',
          'categoryGA': 'Stationnement',
          'actionGA': 'Clic',
          'labelGA': stationnement.trim() + ' - ' + title
        });
        if (this.href) {
          var target = this.href;
          setTimeout(function () {
            window.location = target;
          }, 500);
        }
      });

      //parking page reserve now button
      $(".tableaux-stationnement .tableaux-stationnement-promoslist a").click(function (e) {
        e.preventDefault();
        var title = $(this).text();
        var stationnement = $(this).parents('.tableaux-stationnement-type-row').find('.stationnement-type-item').text();
        dataLayer.push({
          'event': 'eventGA',
          'categoryGA': 'Stationnement',
          'actionGA': 'Clic',
          'labelGA': stationnement.trim() + ' - ' + title
        });
        if (this.href) {
          var target = this.href;
          setTimeout(function () {
            window.location = target;
          }, 500);
        }
      });


      //fhoule Stupid ugly ugly hack allowing to be sure that the nav is visible on mobile.
      //This fix was specifically for Android 4.1, 4.2 and 4.3 (tested on a Samsung S3)
      //TODO : Fix this fix, as it breaks mobile for iPhones
      /*
      if(Utils.getPlatform() === "mobile"){

          $('header .nav').css({
              left: 0,
              top: 0,
              width: '100%',
              height: '100%',
              position: 'fixed',
              'zoom': 1
          });
      }
      */
    });

    // Fix a bug with input (when were change orientation while typing)
    $(window).bind('orientationchange', function () {
      setTimeout(function () {

        var scrollTop = $(window).scrollTop();
        if (scrollTop > 300) {
          $(document).scrollTop(0);
        }

        $('body').css('-webkit-transform', 'scale3d(1,1,1)');
        setTimeout(function () {
          $('body').css('-webkit-transform', 'none');
          $('input').blur();
        }, 50);
      }, 200);
    });

    // Rental car iframe: resize iframe
    var $iframe = $('iframe.iframe-rentalcar');

    if ($iframe.length > 0) {

      $(window).resize(function () {

        if ($(window).width() <= 753) {
          $('iframe.iframe-rentalcar').height(375);
        } else {
          $('iframe.iframe-rentalcar').height(300);
        }
      }).resize();
    }

    // ADMMNT-283: Car rental communication between crossdomain iframe and website to track with Google Analytics
    (function (window) {

      addEvent(window, 'message', function (message) {
        var dataLayer = window.dataLayer || (window.dataLayer = []); // Safely instantiate dataLayer locally

        // The message.data value is arbitrary and can be customized
        if (message.data === 'rentalCarsFormSubmission' && message.origin === 'IFRAME_PROTOCOL_HOSTNAME_AND_PORT') { // Check this is a whitelisted message & origin
          dataLayer.push({
            // The key 'event' is required for GTM; the value is arbitrary and can be customized
            'event': 'rentalCarsFormSubmission' // Notify GTM via pushing this event
          });
        }

      });

      // Cross-browser event listener
      function addEvent(el, evt, fn) {
        if (el.addEventListener) {
          el.addEventListener(evt, fn);
        } else if (el.attachEvent) {
          el.attachEvent('on' + evt, function (evt) {
            fn.call(el, evt);
          });
        } else if (typeof el['on' + evt] === 'undefined' || el['on' + evt] === null) {
          el['on' + evt] = function (evt) {
            fn.call(el, evt);
          };
        }
      }
    })(window);
  }
});

define("main", function () { });

